// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Account is the Schema for the Accounts API. Provides a settings of an API Gateway Account.
 *
 * @schema Account
 */
export class Account extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Account"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'Account',
  }

  /**
   * Renders a Kubernetes manifest for "Account".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccountProps): any {
    return {
      ...Account.GVK,
      ...toJson_AccountProps(props),
    };
  }

  /**
   * Defines a "Account" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccountProps) {
    super(scope, id, {
      ...Account.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Account.GVK,
      ...toJson_AccountProps(resolved),
    };
  }
}

/**
 * Account is the Schema for the Accounts API. Provides a settings of an API Gateway Account.
 *
 * @schema Account
 */
export interface AccountProps {
  /**
   * @schema Account#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccountSpec defines the desired state of Account
   *
   * @schema Account#spec
   */
  readonly spec: AccountSpec;

}

/**
 * Converts an object of type 'AccountProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountProps(obj: AccountProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccountSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccountSpec defines the desired state of Account
 *
 * @schema AccountSpec
 */
export interface AccountSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccountSpecDeletionPolicy;

  /**
   * @schema AccountSpec#forProvider
   */
  readonly forProvider: AccountSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountSpec#managementPolicy
   */
  readonly managementPolicy?: AccountSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccountSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccountSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AccountSpec#providerRef
   */
  readonly providerRef?: AccountSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccountSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccountSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccountSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccountSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccountSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpec(obj: AccountSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccountSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AccountSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AccountSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AccountSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccountSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountSpecDeletionPolicy
 */
export enum AccountSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccountSpecForProvider
 */
export interface AccountSpecForProvider {
  /**
   * ARN of an IAM role for CloudWatch (to allow logging & monitoring). See more in AWS Docs. Logging & monitoring can be enabled/disabled and otherwise tuned on the API Gateway Stage level.
   *
   * @schema AccountSpecForProvider#cloudwatchRoleArn
   */
  readonly cloudwatchRoleArn?: string;

  /**
   * Reference to a Role in iam to populate cloudwatchRoleArn.
   *
   * @schema AccountSpecForProvider#cloudwatchRoleArnRef
   */
  readonly cloudwatchRoleArnRef?: AccountSpecForProviderCloudwatchRoleArnRef;

  /**
   * Selector for a Role in iam to populate cloudwatchRoleArn.
   *
   * @schema AccountSpecForProvider#cloudwatchRoleArnSelector
   */
  readonly cloudwatchRoleArnSelector?: AccountSpecForProviderCloudwatchRoleArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccountSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AccountSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecForProvider(obj: AccountSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchRoleArn': obj.cloudwatchRoleArn,
    'cloudwatchRoleArnRef': toJson_AccountSpecForProviderCloudwatchRoleArnRef(obj.cloudwatchRoleArnRef),
    'cloudwatchRoleArnSelector': toJson_AccountSpecForProviderCloudwatchRoleArnSelector(obj.cloudwatchRoleArnSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountSpecManagementPolicy
 */
export enum AccountSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccountSpecProviderConfigRef
 */
export interface AccountSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecProviderConfigRef#policy
   */
  readonly policy?: AccountSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderConfigRef(obj: AccountSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AccountSpecProviderRef
 */
export interface AccountSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecProviderRef#policy
   */
  readonly policy?: AccountSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderRef(obj: AccountSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccountSpecPublishConnectionDetailsTo
 */
export interface AccountSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccountSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccountSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccountSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsTo(obj: AccountSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccountSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccountSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccountSpecWriteConnectionSecretToRef
 */
export interface AccountSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccountSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccountSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccountSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecWriteConnectionSecretToRef(obj: AccountSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate cloudwatchRoleArn.
 *
 * @schema AccountSpecForProviderCloudwatchRoleArnRef
 */
export interface AccountSpecForProviderCloudwatchRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecForProviderCloudwatchRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecForProviderCloudwatchRoleArnRef#policy
   */
  readonly policy?: AccountSpecForProviderCloudwatchRoleArnRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecForProviderCloudwatchRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecForProviderCloudwatchRoleArnRef(obj: AccountSpecForProviderCloudwatchRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecForProviderCloudwatchRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate cloudwatchRoleArn.
 *
 * @schema AccountSpecForProviderCloudwatchRoleArnSelector
 */
export interface AccountSpecForProviderCloudwatchRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccountSpecForProviderCloudwatchRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccountSpecForProviderCloudwatchRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccountSpecForProviderCloudwatchRoleArnSelector#policy
   */
  readonly policy?: AccountSpecForProviderCloudwatchRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'AccountSpecForProviderCloudwatchRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecForProviderCloudwatchRoleArnSelector(obj: AccountSpecForProviderCloudwatchRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccountSpecForProviderCloudwatchRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountSpecProviderConfigRefPolicy
 */
export interface AccountSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderConfigRefPolicy(obj: AccountSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountSpecProviderRefPolicy
 */
export interface AccountSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AccountSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AccountSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecProviderRefPolicy(obj: AccountSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRef
 */
export interface AccountSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccountSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToConfigRef(obj: AccountSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccountSpecPublishConnectionDetailsToMetadata
 */
export interface AccountSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccountSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToMetadata(obj: AccountSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountSpecForProviderCloudwatchRoleArnRefPolicy
 */
export interface AccountSpecForProviderCloudwatchRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecForProviderCloudwatchRoleArnRefPolicy#resolution
   */
  readonly resolution?: AccountSpecForProviderCloudwatchRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecForProviderCloudwatchRoleArnRefPolicy#resolve
   */
  readonly resolve?: AccountSpecForProviderCloudwatchRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecForProviderCloudwatchRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecForProviderCloudwatchRoleArnRefPolicy(obj: AccountSpecForProviderCloudwatchRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccountSpecForProviderCloudwatchRoleArnSelectorPolicy
 */
export interface AccountSpecForProviderCloudwatchRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecForProviderCloudwatchRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: AccountSpecForProviderCloudwatchRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecForProviderCloudwatchRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: AccountSpecForProviderCloudwatchRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecForProviderCloudwatchRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecForProviderCloudwatchRoleArnSelectorPolicy(obj: AccountSpecForProviderCloudwatchRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecProviderConfigRefPolicyResolution
 */
export enum AccountSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecProviderConfigRefPolicyResolve
 */
export enum AccountSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecProviderRefPolicyResolution
 */
export enum AccountSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecProviderRefPolicyResolve
 */
export enum AccountSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccountSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccountSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecForProviderCloudwatchRoleArnRefPolicyResolution
 */
export enum AccountSpecForProviderCloudwatchRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecForProviderCloudwatchRoleArnRefPolicyResolve
 */
export enum AccountSpecForProviderCloudwatchRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecForProviderCloudwatchRoleArnSelectorPolicyResolution
 */
export enum AccountSpecForProviderCloudwatchRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecForProviderCloudwatchRoleArnSelectorPolicyResolve
 */
export enum AccountSpecForProviderCloudwatchRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccountSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccountSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * APIKey is the Schema for the APIKeys API. Provides an API Gateway API Key.
 *
 * @schema APIKey
 */
export class ApiKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'APIKey',
  }

  /**
   * Renders a Kubernetes manifest for "APIKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiKeyProps): any {
    return {
      ...ApiKey.GVK,
      ...toJson_ApiKeyProps(props),
    };
  }

  /**
   * Defines a "APIKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiKeyProps) {
    super(scope, id, {
      ...ApiKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiKey.GVK,
      ...toJson_ApiKeyProps(resolved),
    };
  }
}

/**
 * APIKey is the Schema for the APIKeys API. Provides an API Gateway API Key.
 *
 * @schema APIKey
 */
export interface ApiKeyProps {
  /**
   * @schema APIKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * APIKeySpec defines the desired state of APIKey
   *
   * @schema APIKey#spec
   */
  readonly spec: ApiKeySpec;

}

/**
 * Converts an object of type 'ApiKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeyProps(obj: ApiKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIKeySpec defines the desired state of APIKey
 *
 * @schema ApiKeySpec
 */
export interface ApiKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApiKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: ApiKeySpecDeletionPolicy;

  /**
   * @schema ApiKeySpec#forProvider
   */
  readonly forProvider: ApiKeySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApiKeySpec#managementPolicy
   */
  readonly managementPolicy?: ApiKeySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApiKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: ApiKeySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ApiKeySpec#providerRef
   */
  readonly providerRef?: ApiKeySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApiKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApiKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApiKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApiKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApiKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpec(obj: ApiKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApiKeySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ApiKeySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ApiKeySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ApiKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApiKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApiKeySpecDeletionPolicy
 */
export enum ApiKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApiKeySpecForProvider
 */
export interface ApiKeySpecForProvider {
  /**
   * API key description.
   *
   * @schema ApiKeySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether the API key can be used by callers. Defaults to true.
   *
   * @default true.
   * @schema ApiKeySpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Name of the API key.
   *
   * @schema ApiKeySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApiKeySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApiKeySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Value of the API key. If specified, the value must be an alphanumeric string between 20 and 128 characters. If not specified, it will be automatically generated by AWS on creation.
   *
   * @schema ApiKeySpecForProvider#valueSecretRef
   */
  readonly valueSecretRef?: ApiKeySpecForProviderValueSecretRef;

}

/**
 * Converts an object of type 'ApiKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecForProvider(obj: ApiKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'enabled': obj.enabled,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'valueSecretRef': toJson_ApiKeySpecForProviderValueSecretRef(obj.valueSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApiKeySpecManagementPolicy
 */
export enum ApiKeySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApiKeySpecProviderConfigRef
 */
export interface ApiKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiKeySpecProviderConfigRef#policy
   */
  readonly policy?: ApiKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecProviderConfigRef(obj: ApiKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ApiKeySpecProviderRef
 */
export interface ApiKeySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiKeySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiKeySpecProviderRef#policy
   */
  readonly policy?: ApiKeySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ApiKeySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecProviderRef(obj: ApiKeySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiKeySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApiKeySpecPublishConnectionDetailsTo
 */
export interface ApiKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApiKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApiKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApiKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApiKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApiKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsTo(obj: ApiKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApiKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApiKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApiKeySpecWriteConnectionSecretToRef
 */
export interface ApiKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApiKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApiKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApiKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecWriteConnectionSecretToRef(obj: ApiKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Value of the API key. If specified, the value must be an alphanumeric string between 20 and 128 characters. If not specified, it will be automatically generated by AWS on creation.
 *
 * @schema ApiKeySpecForProviderValueSecretRef
 */
export interface ApiKeySpecForProviderValueSecretRef {
  /**
   * The key to select.
   *
   * @schema ApiKeySpecForProviderValueSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ApiKeySpecForProviderValueSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApiKeySpecForProviderValueSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApiKeySpecForProviderValueSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecForProviderValueSecretRef(obj: ApiKeySpecForProviderValueSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiKeySpecProviderConfigRefPolicy
 */
export interface ApiKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApiKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApiKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecProviderConfigRefPolicy(obj: ApiKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiKeySpecProviderRefPolicy
 */
export interface ApiKeySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiKeySpecProviderRefPolicy#resolution
   */
  readonly resolution?: ApiKeySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiKeySpecProviderRefPolicy#resolve
   */
  readonly resolve?: ApiKeySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiKeySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecProviderRefPolicy(obj: ApiKeySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRef
 */
export interface ApiKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApiKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsToConfigRef(obj: ApiKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToMetadata
 */
export interface ApiKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsToMetadata(obj: ApiKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiKeySpecProviderConfigRefPolicyResolution
 */
export enum ApiKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiKeySpecProviderConfigRefPolicyResolve
 */
export enum ApiKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiKeySpecProviderRefPolicyResolution
 */
export enum ApiKeySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiKeySpecProviderRefPolicyResolve
 */
export enum ApiKeySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApiKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: ApiKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Authorizer is the Schema for the Authorizers API. Provides an API Gateway Authorizer.
 *
 * @schema Authorizer
 */
export class Authorizer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Authorizer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'Authorizer',
  }

  /**
   * Renders a Kubernetes manifest for "Authorizer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AuthorizerProps): any {
    return {
      ...Authorizer.GVK,
      ...toJson_AuthorizerProps(props),
    };
  }

  /**
   * Defines a "Authorizer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AuthorizerProps) {
    super(scope, id, {
      ...Authorizer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Authorizer.GVK,
      ...toJson_AuthorizerProps(resolved),
    };
  }
}

/**
 * Authorizer is the Schema for the Authorizers API. Provides an API Gateway Authorizer.
 *
 * @schema Authorizer
 */
export interface AuthorizerProps {
  /**
   * @schema Authorizer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AuthorizerSpec defines the desired state of Authorizer
   *
   * @schema Authorizer#spec
   */
  readonly spec: AuthorizerSpec;

}

/**
 * Converts an object of type 'AuthorizerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerProps(obj: AuthorizerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AuthorizerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthorizerSpec defines the desired state of Authorizer
 *
 * @schema AuthorizerSpec
 */
export interface AuthorizerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AuthorizerSpec#deletionPolicy
   */
  readonly deletionPolicy?: AuthorizerSpecDeletionPolicy;

  /**
   * @schema AuthorizerSpec#forProvider
   */
  readonly forProvider: AuthorizerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AuthorizerSpec#managementPolicy
   */
  readonly managementPolicy?: AuthorizerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AuthorizerSpec#providerConfigRef
   */
  readonly providerConfigRef?: AuthorizerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AuthorizerSpec#providerRef
   */
  readonly providerRef?: AuthorizerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AuthorizerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AuthorizerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AuthorizerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AuthorizerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AuthorizerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpec(obj: AuthorizerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AuthorizerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AuthorizerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AuthorizerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AuthorizerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AuthorizerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AuthorizerSpecDeletionPolicy
 */
export enum AuthorizerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AuthorizerSpecForProvider
 */
export interface AuthorizerSpecForProvider {
  /**
   * Credentials required for the authorizer. To specify an IAM Role for API Gateway to assume, use the IAM Role ARN.
   *
   * @schema AuthorizerSpecForProvider#authorizerCredentials
   */
  readonly authorizerCredentials?: string;

  /**
   * Reference to a Role in iam to populate authorizerCredentials.
   *
   * @schema AuthorizerSpecForProvider#authorizerCredentialsRef
   */
  readonly authorizerCredentialsRef?: AuthorizerSpecForProviderAuthorizerCredentialsRef;

  /**
   * Selector for a Role in iam to populate authorizerCredentials.
   *
   * @schema AuthorizerSpecForProvider#authorizerCredentialsSelector
   */
  readonly authorizerCredentialsSelector?: AuthorizerSpecForProviderAuthorizerCredentialsSelector;

  /**
   * TTL of cached authorizer results in seconds. Defaults to 300.
   *
   * @default 300.
   * @schema AuthorizerSpecForProvider#authorizerResultTtlInSeconds
   */
  readonly authorizerResultTtlInSeconds?: number;

  /**
   * Authorizer's Uniform Resource Identifier (URI). This must be a well-formed Lambda function URI in the form of arn:aws:apigateway:{region}:lambda:path/{service_api}, e.g., arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:012345678912:function:my-function/invocations
   *
   * @schema AuthorizerSpecForProvider#authorizerUri
   */
  readonly authorizerUri?: string;

  /**
   * Reference to a Function in lambda to populate authorizerUri.
   *
   * @schema AuthorizerSpecForProvider#authorizerUriRef
   */
  readonly authorizerUriRef?: AuthorizerSpecForProviderAuthorizerUriRef;

  /**
   * Selector for a Function in lambda to populate authorizerUri.
   *
   * @schema AuthorizerSpecForProvider#authorizerUriSelector
   */
  readonly authorizerUriSelector?: AuthorizerSpecForProviderAuthorizerUriSelector;

  /**
   * Source of the identity in an incoming request. Defaults to method.request.header.Authorization. For REQUEST type, this may be a comma-separated list of values, including headers, query string parameters and stage variables - e.g., "method.request.header.SomeHeaderName,method.request.querystring.SomeQueryStringName,stageVariables.SomeStageVariableName"
   *
   * @default method.request.header.Authorization. For REQUEST type, this may be a comma-separated list of values, including headers, query string parameters and stage variables - e.g., "method.request.header.SomeHeaderName,method.request.querystring.SomeQueryStringName,stageVariables.SomeStageVariableName"
   * @schema AuthorizerSpecForProvider#identitySource
   */
  readonly identitySource?: string;

  /**
   * Validation expression for the incoming identity. For TOKEN type, this value should be a regular expression. The incoming token from the client is matched against this expression, and will proceed if the token matches. If the token doesn't match, the client receives a 401 Unauthorized response.
   *
   * @schema AuthorizerSpecForProvider#identityValidationExpression
   */
  readonly identityValidationExpression?: string;

  /**
   * Name of the authorizer
   *
   * @schema AuthorizerSpecForProvider#name
   */
  readonly name?: string;

  /**
   * List of the Amazon Cognito user pool ARNs. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}.
   *
   * @schema AuthorizerSpecForProvider#providerArns
   */
  readonly providerArns?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AuthorizerSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the associated REST API
   *
   * @schema AuthorizerSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema AuthorizerSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: AuthorizerSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema AuthorizerSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: AuthorizerSpecForProviderRestApiIdSelector;

  /**
   * Type of the authorizer. Possible values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, or COGNITO_USER_POOLS for using an Amazon Cognito user pool. Defaults to TOKEN.
   *
   * @default TOKEN.
   * @schema AuthorizerSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AuthorizerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProvider(obj: AuthorizerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizerCredentials': obj.authorizerCredentials,
    'authorizerCredentialsRef': toJson_AuthorizerSpecForProviderAuthorizerCredentialsRef(obj.authorizerCredentialsRef),
    'authorizerCredentialsSelector': toJson_AuthorizerSpecForProviderAuthorizerCredentialsSelector(obj.authorizerCredentialsSelector),
    'authorizerResultTtlInSeconds': obj.authorizerResultTtlInSeconds,
    'authorizerUri': obj.authorizerUri,
    'authorizerUriRef': toJson_AuthorizerSpecForProviderAuthorizerUriRef(obj.authorizerUriRef),
    'authorizerUriSelector': toJson_AuthorizerSpecForProviderAuthorizerUriSelector(obj.authorizerUriSelector),
    'identitySource': obj.identitySource,
    'identityValidationExpression': obj.identityValidationExpression,
    'name': obj.name,
    'providerArns': obj.providerArns?.map(y => y),
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_AuthorizerSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_AuthorizerSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AuthorizerSpecManagementPolicy
 */
export enum AuthorizerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AuthorizerSpecProviderConfigRef
 */
export interface AuthorizerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecProviderConfigRef#policy
   */
  readonly policy?: AuthorizerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderConfigRef(obj: AuthorizerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AuthorizerSpecProviderRef
 */
export interface AuthorizerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecProviderRef#policy
   */
  readonly policy?: AuthorizerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderRef(obj: AuthorizerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsTo
 */
export interface AuthorizerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AuthorizerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AuthorizerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsTo(obj: AuthorizerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AuthorizerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AuthorizerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AuthorizerSpecWriteConnectionSecretToRef
 */
export interface AuthorizerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AuthorizerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AuthorizerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AuthorizerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecWriteConnectionSecretToRef(obj: AuthorizerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate authorizerCredentials.
 *
 * @schema AuthorizerSpecForProviderAuthorizerCredentialsRef
 */
export interface AuthorizerSpecForProviderAuthorizerCredentialsRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecForProviderAuthorizerCredentialsRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecForProviderAuthorizerCredentialsRef#policy
   */
  readonly policy?: AuthorizerSpecForProviderAuthorizerCredentialsRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerCredentialsRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerCredentialsRef(obj: AuthorizerSpecForProviderAuthorizerCredentialsRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecForProviderAuthorizerCredentialsRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate authorizerCredentials.
 *
 * @schema AuthorizerSpecForProviderAuthorizerCredentialsSelector
 */
export interface AuthorizerSpecForProviderAuthorizerCredentialsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AuthorizerSpecForProviderAuthorizerCredentialsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AuthorizerSpecForProviderAuthorizerCredentialsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AuthorizerSpecForProviderAuthorizerCredentialsSelector#policy
   */
  readonly policy?: AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerCredentialsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerCredentialsSelector(obj: AuthorizerSpecForProviderAuthorizerCredentialsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate authorizerUri.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriRef
 */
export interface AuthorizerSpecForProviderAuthorizerUriRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriRef#policy
   */
  readonly policy?: AuthorizerSpecForProviderAuthorizerUriRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerUriRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerUriRef(obj: AuthorizerSpecForProviderAuthorizerUriRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecForProviderAuthorizerUriRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate authorizerUri.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriSelector
 */
export interface AuthorizerSpecForProviderAuthorizerUriSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriSelector#policy
   */
  readonly policy?: AuthorizerSpecForProviderAuthorizerUriSelectorPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerUriSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerUriSelector(obj: AuthorizerSpecForProviderAuthorizerUriSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AuthorizerSpecForProviderAuthorizerUriSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema AuthorizerSpecForProviderRestApiIdRef
 */
export interface AuthorizerSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: AuthorizerSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderRestApiIdRef(obj: AuthorizerSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema AuthorizerSpecForProviderRestApiIdSelector
 */
export interface AuthorizerSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AuthorizerSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AuthorizerSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AuthorizerSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: AuthorizerSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderRestApiIdSelector(obj: AuthorizerSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AuthorizerSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicy
 */
export interface AuthorizerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderConfigRefPolicy(obj: AuthorizerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecProviderRefPolicy
 */
export interface AuthorizerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecProviderRefPolicy(obj: AuthorizerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef
 */
export interface AuthorizerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToConfigRef(obj: AuthorizerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToMetadata
 */
export interface AuthorizerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToMetadata(obj: AuthorizerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecForProviderAuthorizerCredentialsRefPolicy
 */
export interface AuthorizerSpecForProviderAuthorizerCredentialsRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderAuthorizerCredentialsRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderAuthorizerCredentialsRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderAuthorizerCredentialsRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderAuthorizerCredentialsRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerCredentialsRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerCredentialsRefPolicy(obj: AuthorizerSpecForProviderAuthorizerCredentialsRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicy
 */
export interface AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicy(obj: AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriRefPolicy
 */
export interface AuthorizerSpecForProviderAuthorizerUriRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderAuthorizerUriRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderAuthorizerUriRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerUriRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerUriRefPolicy(obj: AuthorizerSpecForProviderAuthorizerUriRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriSelectorPolicy
 */
export interface AuthorizerSpecForProviderAuthorizerUriSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriSelectorPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderAuthorizerUriSelectorPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderAuthorizerUriSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderAuthorizerUriSelectorPolicy(obj: AuthorizerSpecForProviderAuthorizerUriSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecForProviderRestApiIdRefPolicy
 */
export interface AuthorizerSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderRestApiIdRefPolicy(obj: AuthorizerSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AuthorizerSpecForProviderRestApiIdSelectorPolicy
 */
export interface AuthorizerSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecForProviderRestApiIdSelectorPolicy(obj: AuthorizerSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicyResolution
 */
export enum AuthorizerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecProviderConfigRefPolicyResolve
 */
export enum AuthorizerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecProviderRefPolicyResolution
 */
export enum AuthorizerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecProviderRefPolicyResolve
 */
export enum AuthorizerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy(obj: AuthorizerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderAuthorizerCredentialsRefPolicyResolution
 */
export enum AuthorizerSpecForProviderAuthorizerCredentialsRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderAuthorizerCredentialsRefPolicyResolve
 */
export enum AuthorizerSpecForProviderAuthorizerCredentialsRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicyResolution
 */
export enum AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicyResolve
 */
export enum AuthorizerSpecForProviderAuthorizerCredentialsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriRefPolicyResolution
 */
export enum AuthorizerSpecForProviderAuthorizerUriRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriRefPolicyResolve
 */
export enum AuthorizerSpecForProviderAuthorizerUriRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolution
 */
export enum AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolve
 */
export enum AuthorizerSpecForProviderAuthorizerUriSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderRestApiIdRefPolicyResolution
 */
export enum AuthorizerSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderRestApiIdRefPolicyResolve
 */
export enum AuthorizerSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum AuthorizerSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum AuthorizerSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AuthorizerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BasePathMapping is the Schema for the BasePathMappings API. Connects a custom domain with a deployed API
 *
 * @schema BasePathMapping
 */
export class BasePathMapping extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BasePathMapping"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'BasePathMapping',
  }

  /**
   * Renders a Kubernetes manifest for "BasePathMapping".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BasePathMappingProps): any {
    return {
      ...BasePathMapping.GVK,
      ...toJson_BasePathMappingProps(props),
    };
  }

  /**
   * Defines a "BasePathMapping" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BasePathMappingProps) {
    super(scope, id, {
      ...BasePathMapping.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BasePathMapping.GVK,
      ...toJson_BasePathMappingProps(resolved),
    };
  }
}

/**
 * BasePathMapping is the Schema for the BasePathMappings API. Connects a custom domain with a deployed API
 *
 * @schema BasePathMapping
 */
export interface BasePathMappingProps {
  /**
   * @schema BasePathMapping#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BasePathMappingSpec defines the desired state of BasePathMapping
   *
   * @schema BasePathMapping#spec
   */
  readonly spec: BasePathMappingSpec;

}

/**
 * Converts an object of type 'BasePathMappingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingProps(obj: BasePathMappingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BasePathMappingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasePathMappingSpec defines the desired state of BasePathMapping
 *
 * @schema BasePathMappingSpec
 */
export interface BasePathMappingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BasePathMappingSpec#deletionPolicy
   */
  readonly deletionPolicy?: BasePathMappingSpecDeletionPolicy;

  /**
   * @schema BasePathMappingSpec#forProvider
   */
  readonly forProvider: BasePathMappingSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BasePathMappingSpec#managementPolicy
   */
  readonly managementPolicy?: BasePathMappingSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BasePathMappingSpec#providerConfigRef
   */
  readonly providerConfigRef?: BasePathMappingSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BasePathMappingSpec#providerRef
   */
  readonly providerRef?: BasePathMappingSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BasePathMappingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BasePathMappingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BasePathMappingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BasePathMappingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BasePathMappingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpec(obj: BasePathMappingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BasePathMappingSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_BasePathMappingSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BasePathMappingSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BasePathMappingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BasePathMappingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BasePathMappingSpecDeletionPolicy
 */
export enum BasePathMappingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BasePathMappingSpecForProvider
 */
export interface BasePathMappingSpecForProvider {
  /**
   * ID of the API to connect.
   *
   * @schema BasePathMappingSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate apiId.
   *
   * @schema BasePathMappingSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: BasePathMappingSpecForProviderApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate apiId.
   *
   * @schema BasePathMappingSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: BasePathMappingSpecForProviderApiIdSelector;

  /**
   * Path segment that must be prepended to the path when accessing the API via this mapping. If omitted, the API is exposed at the root of the given domain.
   *
   * @schema BasePathMappingSpecForProvider#basePath
   */
  readonly basePath?: string;

  /**
   * Already-registered domain name to connect the API to.
   *
   * @schema BasePathMappingSpecForProvider#domainName
   */
  readonly domainName?: string;

  /**
   * Reference to a DomainName in apigateway to populate domainName.
   *
   * @schema BasePathMappingSpecForProvider#domainNameRef
   */
  readonly domainNameRef?: BasePathMappingSpecForProviderDomainNameRef;

  /**
   * Selector for a DomainName in apigateway to populate domainName.
   *
   * @schema BasePathMappingSpecForProvider#domainNameSelector
   */
  readonly domainNameSelector?: BasePathMappingSpecForProviderDomainNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BasePathMappingSpecForProvider#region
   */
  readonly region: string;

  /**
   * Name of a specific deployment stage to expose at the given path. If omitted, callers may select any stage by including its name as a path element after the base path.
   *
   * @schema BasePathMappingSpecForProvider#stageName
   */
  readonly stageName?: string;

  /**
   * Reference to a Stage in apigateway to populate stageName.
   *
   * @schema BasePathMappingSpecForProvider#stageNameRef
   */
  readonly stageNameRef?: BasePathMappingSpecForProviderStageNameRef;

  /**
   * Selector for a Stage in apigateway to populate stageName.
   *
   * @schema BasePathMappingSpecForProvider#stageNameSelector
   */
  readonly stageNameSelector?: BasePathMappingSpecForProviderStageNameSelector;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProvider(obj: BasePathMappingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_BasePathMappingSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_BasePathMappingSpecForProviderApiIdSelector(obj.apiIdSelector),
    'basePath': obj.basePath,
    'domainName': obj.domainName,
    'domainNameRef': toJson_BasePathMappingSpecForProviderDomainNameRef(obj.domainNameRef),
    'domainNameSelector': toJson_BasePathMappingSpecForProviderDomainNameSelector(obj.domainNameSelector),
    'region': obj.region,
    'stageName': obj.stageName,
    'stageNameRef': toJson_BasePathMappingSpecForProviderStageNameRef(obj.stageNameRef),
    'stageNameSelector': toJson_BasePathMappingSpecForProviderStageNameSelector(obj.stageNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BasePathMappingSpecManagementPolicy
 */
export enum BasePathMappingSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BasePathMappingSpecProviderConfigRef
 */
export interface BasePathMappingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BasePathMappingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BasePathMappingSpecProviderConfigRef#policy
   */
  readonly policy?: BasePathMappingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecProviderConfigRef(obj: BasePathMappingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BasePathMappingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BasePathMappingSpecProviderRef
 */
export interface BasePathMappingSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BasePathMappingSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BasePathMappingSpecProviderRef#policy
   */
  readonly policy?: BasePathMappingSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecProviderRef(obj: BasePathMappingSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BasePathMappingSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsTo
 */
export interface BasePathMappingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BasePathMappingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BasePathMappingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BasePathMappingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecPublishConnectionDetailsTo(obj: BasePathMappingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BasePathMappingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BasePathMappingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BasePathMappingSpecWriteConnectionSecretToRef
 */
export interface BasePathMappingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BasePathMappingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BasePathMappingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BasePathMappingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecWriteConnectionSecretToRef(obj: BasePathMappingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate apiId.
 *
 * @schema BasePathMappingSpecForProviderApiIdRef
 */
export interface BasePathMappingSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BasePathMappingSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BasePathMappingSpecForProviderApiIdRef#policy
   */
  readonly policy?: BasePathMappingSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderApiIdRef(obj: BasePathMappingSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BasePathMappingSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate apiId.
 *
 * @schema BasePathMappingSpecForProviderApiIdSelector
 */
export interface BasePathMappingSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BasePathMappingSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BasePathMappingSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BasePathMappingSpecForProviderApiIdSelector#policy
   */
  readonly policy?: BasePathMappingSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderApiIdSelector(obj: BasePathMappingSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BasePathMappingSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DomainName in apigateway to populate domainName.
 *
 * @schema BasePathMappingSpecForProviderDomainNameRef
 */
export interface BasePathMappingSpecForProviderDomainNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema BasePathMappingSpecForProviderDomainNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BasePathMappingSpecForProviderDomainNameRef#policy
   */
  readonly policy?: BasePathMappingSpecForProviderDomainNameRefPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderDomainNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderDomainNameRef(obj: BasePathMappingSpecForProviderDomainNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BasePathMappingSpecForProviderDomainNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DomainName in apigateway to populate domainName.
 *
 * @schema BasePathMappingSpecForProviderDomainNameSelector
 */
export interface BasePathMappingSpecForProviderDomainNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BasePathMappingSpecForProviderDomainNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BasePathMappingSpecForProviderDomainNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BasePathMappingSpecForProviderDomainNameSelector#policy
   */
  readonly policy?: BasePathMappingSpecForProviderDomainNameSelectorPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderDomainNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderDomainNameSelector(obj: BasePathMappingSpecForProviderDomainNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BasePathMappingSpecForProviderDomainNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stage in apigateway to populate stageName.
 *
 * @schema BasePathMappingSpecForProviderStageNameRef
 */
export interface BasePathMappingSpecForProviderStageNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema BasePathMappingSpecForProviderStageNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BasePathMappingSpecForProviderStageNameRef#policy
   */
  readonly policy?: BasePathMappingSpecForProviderStageNameRefPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderStageNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderStageNameRef(obj: BasePathMappingSpecForProviderStageNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BasePathMappingSpecForProviderStageNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stage in apigateway to populate stageName.
 *
 * @schema BasePathMappingSpecForProviderStageNameSelector
 */
export interface BasePathMappingSpecForProviderStageNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BasePathMappingSpecForProviderStageNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BasePathMappingSpecForProviderStageNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BasePathMappingSpecForProviderStageNameSelector#policy
   */
  readonly policy?: BasePathMappingSpecForProviderStageNameSelectorPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderStageNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderStageNameSelector(obj: BasePathMappingSpecForProviderStageNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BasePathMappingSpecForProviderStageNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BasePathMappingSpecProviderConfigRefPolicy
 */
export interface BasePathMappingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecProviderConfigRefPolicy(obj: BasePathMappingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BasePathMappingSpecProviderRefPolicy
 */
export interface BasePathMappingSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecProviderRefPolicy(obj: BasePathMappingSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRef
 */
export interface BasePathMappingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BasePathMappingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecPublishConnectionDetailsToConfigRef(obj: BasePathMappingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsToMetadata
 */
export interface BasePathMappingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BasePathMappingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecPublishConnectionDetailsToMetadata(obj: BasePathMappingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BasePathMappingSpecForProviderApiIdRefPolicy
 */
export interface BasePathMappingSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderApiIdRefPolicy(obj: BasePathMappingSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BasePathMappingSpecForProviderApiIdSelectorPolicy
 */
export interface BasePathMappingSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderApiIdSelectorPolicy(obj: BasePathMappingSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BasePathMappingSpecForProviderDomainNameRefPolicy
 */
export interface BasePathMappingSpecForProviderDomainNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecForProviderDomainNameRefPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecForProviderDomainNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecForProviderDomainNameRefPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecForProviderDomainNameRefPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderDomainNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderDomainNameRefPolicy(obj: BasePathMappingSpecForProviderDomainNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BasePathMappingSpecForProviderDomainNameSelectorPolicy
 */
export interface BasePathMappingSpecForProviderDomainNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecForProviderDomainNameSelectorPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecForProviderDomainNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecForProviderDomainNameSelectorPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecForProviderDomainNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderDomainNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderDomainNameSelectorPolicy(obj: BasePathMappingSpecForProviderDomainNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BasePathMappingSpecForProviderStageNameRefPolicy
 */
export interface BasePathMappingSpecForProviderStageNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecForProviderStageNameRefPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecForProviderStageNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecForProviderStageNameRefPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecForProviderStageNameRefPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderStageNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderStageNameRefPolicy(obj: BasePathMappingSpecForProviderStageNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BasePathMappingSpecForProviderStageNameSelectorPolicy
 */
export interface BasePathMappingSpecForProviderStageNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecForProviderStageNameSelectorPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecForProviderStageNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecForProviderStageNameSelectorPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecForProviderStageNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecForProviderStageNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecForProviderStageNameSelectorPolicy(obj: BasePathMappingSpecForProviderStageNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecProviderConfigRefPolicyResolution
 */
export enum BasePathMappingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecProviderConfigRefPolicyResolve
 */
export enum BasePathMappingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecProviderRefPolicyResolution
 */
export enum BasePathMappingSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecProviderRefPolicyResolve
 */
export enum BasePathMappingSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy(obj: BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecForProviderApiIdRefPolicyResolution
 */
export enum BasePathMappingSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecForProviderApiIdRefPolicyResolve
 */
export enum BasePathMappingSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecForProviderApiIdSelectorPolicyResolution
 */
export enum BasePathMappingSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecForProviderApiIdSelectorPolicyResolve
 */
export enum BasePathMappingSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecForProviderDomainNameRefPolicyResolution
 */
export enum BasePathMappingSpecForProviderDomainNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecForProviderDomainNameRefPolicyResolve
 */
export enum BasePathMappingSpecForProviderDomainNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecForProviderDomainNameSelectorPolicyResolution
 */
export enum BasePathMappingSpecForProviderDomainNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecForProviderDomainNameSelectorPolicyResolve
 */
export enum BasePathMappingSpecForProviderDomainNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecForProviderStageNameRefPolicyResolution
 */
export enum BasePathMappingSpecForProviderStageNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecForProviderStageNameRefPolicyResolve
 */
export enum BasePathMappingSpecForProviderStageNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecForProviderStageNameSelectorPolicyResolution
 */
export enum BasePathMappingSpecForProviderStageNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecForProviderStageNameSelectorPolicyResolve
 */
export enum BasePathMappingSpecForProviderStageNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BasePathMappingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClientCertificate is the Schema for the ClientCertificates API. Provides an API Gateway Client Certificate.
 *
 * @schema ClientCertificate
 */
export class ClientCertificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClientCertificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'ClientCertificate',
  }

  /**
   * Renders a Kubernetes manifest for "ClientCertificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClientCertificateProps): any {
    return {
      ...ClientCertificate.GVK,
      ...toJson_ClientCertificateProps(props),
    };
  }

  /**
   * Defines a "ClientCertificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClientCertificateProps) {
    super(scope, id, {
      ...ClientCertificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClientCertificate.GVK,
      ...toJson_ClientCertificateProps(resolved),
    };
  }
}

/**
 * ClientCertificate is the Schema for the ClientCertificates API. Provides an API Gateway Client Certificate.
 *
 * @schema ClientCertificate
 */
export interface ClientCertificateProps {
  /**
   * @schema ClientCertificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClientCertificateSpec defines the desired state of ClientCertificate
   *
   * @schema ClientCertificate#spec
   */
  readonly spec: ClientCertificateSpec;

}

/**
 * Converts an object of type 'ClientCertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateProps(obj: ClientCertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClientCertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientCertificateSpec defines the desired state of ClientCertificate
 *
 * @schema ClientCertificateSpec
 */
export interface ClientCertificateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClientCertificateSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClientCertificateSpecDeletionPolicy;

  /**
   * @schema ClientCertificateSpec#forProvider
   */
  readonly forProvider: ClientCertificateSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClientCertificateSpec#managementPolicy
   */
  readonly managementPolicy?: ClientCertificateSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClientCertificateSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClientCertificateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClientCertificateSpec#providerRef
   */
  readonly providerRef?: ClientCertificateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClientCertificateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClientCertificateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClientCertificateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClientCertificateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClientCertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateSpec(obj: ClientCertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClientCertificateSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ClientCertificateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClientCertificateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClientCertificateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClientCertificateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClientCertificateSpecDeletionPolicy
 */
export enum ClientCertificateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClientCertificateSpecForProvider
 */
export interface ClientCertificateSpecForProvider {
  /**
   * Description of the client certificate.
   *
   * @schema ClientCertificateSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClientCertificateSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClientCertificateSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClientCertificateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateSpecForProvider(obj: ClientCertificateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClientCertificateSpecManagementPolicy
 */
export enum ClientCertificateSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClientCertificateSpecProviderConfigRef
 */
export interface ClientCertificateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientCertificateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientCertificateSpecProviderConfigRef#policy
   */
  readonly policy?: ClientCertificateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClientCertificateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateSpecProviderConfigRef(obj: ClientCertificateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientCertificateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClientCertificateSpecProviderRef
 */
export interface ClientCertificateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientCertificateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientCertificateSpecProviderRef#policy
   */
  readonly policy?: ClientCertificateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClientCertificateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateSpecProviderRef(obj: ClientCertificateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientCertificateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClientCertificateSpecPublishConnectionDetailsTo
 */
export interface ClientCertificateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClientCertificateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClientCertificateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClientCertificateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClientCertificateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClientCertificateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClientCertificateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateSpecPublishConnectionDetailsTo(obj: ClientCertificateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClientCertificateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClientCertificateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClientCertificateSpecWriteConnectionSecretToRef
 */
export interface ClientCertificateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClientCertificateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClientCertificateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClientCertificateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateSpecWriteConnectionSecretToRef(obj: ClientCertificateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClientCertificateSpecProviderConfigRefPolicy
 */
export interface ClientCertificateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClientCertificateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClientCertificateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClientCertificateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClientCertificateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientCertificateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateSpecProviderConfigRefPolicy(obj: ClientCertificateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClientCertificateSpecProviderRefPolicy
 */
export interface ClientCertificateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClientCertificateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClientCertificateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClientCertificateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClientCertificateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientCertificateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateSpecProviderRefPolicy(obj: ClientCertificateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClientCertificateSpecPublishConnectionDetailsToConfigRef
 */
export interface ClientCertificateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClientCertificateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClientCertificateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClientCertificateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateSpecPublishConnectionDetailsToConfigRef(obj: ClientCertificateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClientCertificateSpecPublishConnectionDetailsToMetadata
 */
export interface ClientCertificateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClientCertificateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClientCertificateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClientCertificateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClientCertificateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateSpecPublishConnectionDetailsToMetadata(obj: ClientCertificateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClientCertificateSpecProviderConfigRefPolicyResolution
 */
export enum ClientCertificateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClientCertificateSpecProviderConfigRefPolicyResolve
 */
export enum ClientCertificateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClientCertificateSpecProviderRefPolicyResolution
 */
export enum ClientCertificateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClientCertificateSpecProviderRefPolicyResolve
 */
export enum ClientCertificateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClientCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Deployment is the Schema for the Deployments API. Manages an API Gateway REST Deployment.
 *
 * @schema Deployment
 */
export class Deployment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Deployment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'Deployment',
  }

  /**
   * Renders a Kubernetes manifest for "Deployment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeploymentProps): any {
    return {
      ...Deployment.GVK,
      ...toJson_DeploymentProps(props),
    };
  }

  /**
   * Defines a "Deployment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeploymentProps) {
    super(scope, id, {
      ...Deployment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Deployment.GVK,
      ...toJson_DeploymentProps(resolved),
    };
  }
}

/**
 * Deployment is the Schema for the Deployments API. Manages an API Gateway REST Deployment.
 *
 * @schema Deployment
 */
export interface DeploymentProps {
  /**
   * @schema Deployment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeploymentSpec defines the desired state of Deployment
   *
   * @schema Deployment#spec
   */
  readonly spec: DeploymentSpec;

}

/**
 * Converts an object of type 'DeploymentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentProps(obj: DeploymentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeploymentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentSpec defines the desired state of Deployment
 *
 * @schema DeploymentSpec
 */
export interface DeploymentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeploymentSpecDeletionPolicy;

  /**
   * @schema DeploymentSpec#forProvider
   */
  readonly forProvider: DeploymentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentSpec#managementPolicy
   */
  readonly managementPolicy?: DeploymentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeploymentSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeploymentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DeploymentSpec#providerRef
   */
  readonly providerRef?: DeploymentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeploymentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeploymentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeploymentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeploymentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeploymentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpec(obj: DeploymentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeploymentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DeploymentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DeploymentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DeploymentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeploymentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentSpecDeletionPolicy
 */
export enum DeploymentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeploymentSpecForProvider
 */
export interface DeploymentSpecForProvider {
  /**
   * Description of the deployment
   *
   * @schema DeploymentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DeploymentSpecForProvider#region
   */
  readonly region: string;

  /**
   * REST API identifier.
   *
   * @schema DeploymentSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema DeploymentSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: DeploymentSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema DeploymentSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: DeploymentSpecForProviderRestApiIdSelector;

  /**
   * Description to set on the stage managed by the stage_name argument.
   *
   * @schema DeploymentSpecForProvider#stageDescription
   */
  readonly stageDescription?: string;

  /**
   * Name of the stage to create with this deployment. If the specified stage already exists, it will be updated to point to the new deployment. We recommend using the aws_api_gateway_stage resource instead to manage stages.
   *
   * @schema DeploymentSpecForProvider#stageName
   */
  readonly stageName?: string;

  /**
   * argument or explicit resource references using the resource . The triggers argument should be preferred over depends_on, since depends_on can only capture dependency ordering and will not cause the resource to recreate (redeploy the REST API) with upstream configuration changes.
   *
   * @schema DeploymentSpecForProvider#triggers
   */
  readonly triggers?: { [key: string]: string };

  /**
   * Map to set on the stage managed by the stage_name argument.
   *
   * @schema DeploymentSpecForProvider#variables
   */
  readonly variables?: { [key: string]: string };

}

/**
 * Converts an object of type 'DeploymentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProvider(obj: DeploymentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_DeploymentSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_DeploymentSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'stageDescription': obj.stageDescription,
    'stageName': obj.stageName,
    'triggers': ((obj.triggers) === undefined) ? undefined : (Object.entries(obj.triggers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'variables': ((obj.variables) === undefined) ? undefined : (Object.entries(obj.variables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentSpecManagementPolicy
 */
export enum DeploymentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeploymentSpecProviderConfigRef
 */
export interface DeploymentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecProviderConfigRef#policy
   */
  readonly policy?: DeploymentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderConfigRef(obj: DeploymentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DeploymentSpecProviderRef
 */
export interface DeploymentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecProviderRef#policy
   */
  readonly policy?: DeploymentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderRef(obj: DeploymentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeploymentSpecPublishConnectionDetailsTo
 */
export interface DeploymentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeploymentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeploymentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeploymentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsTo(obj: DeploymentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeploymentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeploymentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeploymentSpecWriteConnectionSecretToRef
 */
export interface DeploymentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeploymentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeploymentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeploymentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecWriteConnectionSecretToRef(obj: DeploymentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema DeploymentSpecForProviderRestApiIdRef
 */
export interface DeploymentSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: DeploymentSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderRestApiIdRef(obj: DeploymentSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema DeploymentSpecForProviderRestApiIdSelector
 */
export interface DeploymentSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: DeploymentSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderRestApiIdSelector(obj: DeploymentSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecProviderConfigRefPolicy
 */
export interface DeploymentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderConfigRefPolicy(obj: DeploymentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecProviderRefPolicy
 */
export interface DeploymentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecProviderRefPolicy(obj: DeploymentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRef
 */
export interface DeploymentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToConfigRef(obj: DeploymentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToMetadata
 */
export interface DeploymentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToMetadata(obj: DeploymentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecForProviderRestApiIdRefPolicy
 */
export interface DeploymentSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderRestApiIdRefPolicy(obj: DeploymentSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentSpecForProviderRestApiIdSelectorPolicy
 */
export interface DeploymentSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecForProviderRestApiIdSelectorPolicy(obj: DeploymentSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecProviderConfigRefPolicyResolution
 */
export enum DeploymentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecProviderConfigRefPolicyResolve
 */
export enum DeploymentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecProviderRefPolicyResolution
 */
export enum DeploymentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecProviderRefPolicyResolve
 */
export enum DeploymentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeploymentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeploymentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderRestApiIdRefPolicyResolution
 */
export enum DeploymentSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderRestApiIdRefPolicyResolve
 */
export enum DeploymentSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum DeploymentSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum DeploymentSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeploymentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DocumentationPart is the Schema for the DocumentationParts API. Provides a settings of an API Gateway Documentation Part.
 *
 * @schema DocumentationPart
 */
export class DocumentationPart extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DocumentationPart"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'DocumentationPart',
  }

  /**
   * Renders a Kubernetes manifest for "DocumentationPart".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DocumentationPartProps): any {
    return {
      ...DocumentationPart.GVK,
      ...toJson_DocumentationPartProps(props),
    };
  }

  /**
   * Defines a "DocumentationPart" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DocumentationPartProps) {
    super(scope, id, {
      ...DocumentationPart.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DocumentationPart.GVK,
      ...toJson_DocumentationPartProps(resolved),
    };
  }
}

/**
 * DocumentationPart is the Schema for the DocumentationParts API. Provides a settings of an API Gateway Documentation Part.
 *
 * @schema DocumentationPart
 */
export interface DocumentationPartProps {
  /**
   * @schema DocumentationPart#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DocumentationPartSpec defines the desired state of DocumentationPart
   *
   * @schema DocumentationPart#spec
   */
  readonly spec: DocumentationPartSpec;

}

/**
 * Converts an object of type 'DocumentationPartProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartProps(obj: DocumentationPartProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DocumentationPartSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DocumentationPartSpec defines the desired state of DocumentationPart
 *
 * @schema DocumentationPartSpec
 */
export interface DocumentationPartSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DocumentationPartSpec#deletionPolicy
   */
  readonly deletionPolicy?: DocumentationPartSpecDeletionPolicy;

  /**
   * @schema DocumentationPartSpec#forProvider
   */
  readonly forProvider: DocumentationPartSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DocumentationPartSpec#managementPolicy
   */
  readonly managementPolicy?: DocumentationPartSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DocumentationPartSpec#providerConfigRef
   */
  readonly providerConfigRef?: DocumentationPartSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DocumentationPartSpec#providerRef
   */
  readonly providerRef?: DocumentationPartSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DocumentationPartSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DocumentationPartSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DocumentationPartSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DocumentationPartSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DocumentationPartSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpec(obj: DocumentationPartSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DocumentationPartSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DocumentationPartSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DocumentationPartSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DocumentationPartSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DocumentationPartSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DocumentationPartSpecDeletionPolicy
 */
export enum DocumentationPartSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DocumentationPartSpecForProvider
 */
export interface DocumentationPartSpecForProvider {
  /**
   * Location of the targeted API entity of the to-be-created documentation part. See below.
   *
   * @schema DocumentationPartSpecForProvider#location
   */
  readonly location?: DocumentationPartSpecForProviderLocation[];

  /**
   * Content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ "description": "The API does ..." }". Only Swagger-compliant key-value pairs can be exported and, hence, published.
   *
   * @schema DocumentationPartSpecForProvider#properties
   */
  readonly properties?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DocumentationPartSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the associated Rest API
   *
   * @schema DocumentationPartSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema DocumentationPartSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: DocumentationPartSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema DocumentationPartSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: DocumentationPartSpecForProviderRestApiIdSelector;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProvider(obj: DocumentationPartSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'location': obj.location?.map(y => toJson_DocumentationPartSpecForProviderLocation(y)),
    'properties': obj.properties,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_DocumentationPartSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_DocumentationPartSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DocumentationPartSpecManagementPolicy
 */
export enum DocumentationPartSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DocumentationPartSpecProviderConfigRef
 */
export interface DocumentationPartSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationPartSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationPartSpecProviderConfigRef#policy
   */
  readonly policy?: DocumentationPartSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DocumentationPartSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecProviderConfigRef(obj: DocumentationPartSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationPartSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DocumentationPartSpecProviderRef
 */
export interface DocumentationPartSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationPartSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationPartSpecProviderRef#policy
   */
  readonly policy?: DocumentationPartSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DocumentationPartSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecProviderRef(obj: DocumentationPartSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationPartSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsTo
 */
export interface DocumentationPartSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DocumentationPartSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DocumentationPartSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DocumentationPartSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecPublishConnectionDetailsTo(obj: DocumentationPartSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DocumentationPartSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DocumentationPartSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DocumentationPartSpecWriteConnectionSecretToRef
 */
export interface DocumentationPartSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DocumentationPartSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DocumentationPartSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DocumentationPartSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecWriteConnectionSecretToRef(obj: DocumentationPartSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DocumentationPartSpecForProviderLocation
 */
export interface DocumentationPartSpecForProviderLocation {
  /**
   * HTTP verb of a method. The default value is * for any method.
   *
   * @schema DocumentationPartSpecForProviderLocation#method
   */
  readonly method?: string;

  /**
   * Name of the targeted API entity.
   *
   * @schema DocumentationPartSpecForProviderLocation#name
   */
  readonly name?: string;

  /**
   * URL path of the target. The default value is / for the root resource.
   *
   * @schema DocumentationPartSpecForProviderLocation#path
   */
  readonly path?: string;

  /**
   * HTTP status code of a response. The default value is * for any status code.
   *
   * @schema DocumentationPartSpecForProviderLocation#statusCode
   */
  readonly statusCode?: string;

  /**
   * Type of API entity to which the documentation content appliesE.g., API, METHOD or REQUEST_BODY
   *
   * @schema DocumentationPartSpecForProviderLocation#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProviderLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProviderLocation(obj: DocumentationPartSpecForProviderLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'name': obj.name,
    'path': obj.path,
    'statusCode': obj.statusCode,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdRef
 */
export interface DocumentationPartSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: DocumentationPartSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProviderRestApiIdRef(obj: DocumentationPartSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationPartSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdSelector
 */
export interface DocumentationPartSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: DocumentationPartSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProviderRestApiIdSelector(obj: DocumentationPartSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DocumentationPartSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentationPartSpecProviderConfigRefPolicy
 */
export interface DocumentationPartSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationPartSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DocumentationPartSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationPartSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DocumentationPartSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationPartSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecProviderConfigRefPolicy(obj: DocumentationPartSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentationPartSpecProviderRefPolicy
 */
export interface DocumentationPartSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationPartSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DocumentationPartSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationPartSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DocumentationPartSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationPartSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecProviderRefPolicy(obj: DocumentationPartSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRef
 */
export interface DocumentationPartSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DocumentationPartSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecPublishConnectionDetailsToConfigRef(obj: DocumentationPartSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsToMetadata
 */
export interface DocumentationPartSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DocumentationPartSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecPublishConnectionDetailsToMetadata(obj: DocumentationPartSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdRefPolicy
 */
export interface DocumentationPartSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: DocumentationPartSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: DocumentationPartSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProviderRestApiIdRefPolicy(obj: DocumentationPartSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdSelectorPolicy
 */
export interface DocumentationPartSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationPartSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationPartSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecForProviderRestApiIdSelectorPolicy(obj: DocumentationPartSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationPartSpecProviderConfigRefPolicyResolution
 */
export enum DocumentationPartSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationPartSpecProviderConfigRefPolicyResolve
 */
export enum DocumentationPartSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationPartSpecProviderRefPolicyResolution
 */
export enum DocumentationPartSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationPartSpecProviderRefPolicyResolve
 */
export enum DocumentationPartSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy(obj: DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdRefPolicyResolution
 */
export enum DocumentationPartSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdRefPolicyResolve
 */
export enum DocumentationPartSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum DocumentationPartSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DocumentationPartSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DocumentationVersion is the Schema for the DocumentationVersions API. Provides a resource to manage an API Gateway Documentation Version.
 *
 * @schema DocumentationVersion
 */
export class DocumentationVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DocumentationVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'DocumentationVersion',
  }

  /**
   * Renders a Kubernetes manifest for "DocumentationVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DocumentationVersionProps): any {
    return {
      ...DocumentationVersion.GVK,
      ...toJson_DocumentationVersionProps(props),
    };
  }

  /**
   * Defines a "DocumentationVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DocumentationVersionProps) {
    super(scope, id, {
      ...DocumentationVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DocumentationVersion.GVK,
      ...toJson_DocumentationVersionProps(resolved),
    };
  }
}

/**
 * DocumentationVersion is the Schema for the DocumentationVersions API. Provides a resource to manage an API Gateway Documentation Version.
 *
 * @schema DocumentationVersion
 */
export interface DocumentationVersionProps {
  /**
   * @schema DocumentationVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DocumentationVersionSpec defines the desired state of DocumentationVersion
   *
   * @schema DocumentationVersion#spec
   */
  readonly spec: DocumentationVersionSpec;

}

/**
 * Converts an object of type 'DocumentationVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionProps(obj: DocumentationVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DocumentationVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DocumentationVersionSpec defines the desired state of DocumentationVersion
 *
 * @schema DocumentationVersionSpec
 */
export interface DocumentationVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DocumentationVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: DocumentationVersionSpecDeletionPolicy;

  /**
   * @schema DocumentationVersionSpec#forProvider
   */
  readonly forProvider: DocumentationVersionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DocumentationVersionSpec#managementPolicy
   */
  readonly managementPolicy?: DocumentationVersionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DocumentationVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: DocumentationVersionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DocumentationVersionSpec#providerRef
   */
  readonly providerRef?: DocumentationVersionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DocumentationVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DocumentationVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DocumentationVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DocumentationVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DocumentationVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpec(obj: DocumentationVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DocumentationVersionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DocumentationVersionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DocumentationVersionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DocumentationVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DocumentationVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DocumentationVersionSpecDeletionPolicy
 */
export enum DocumentationVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DocumentationVersionSpecForProvider
 */
export interface DocumentationVersionSpecForProvider {
  /**
   * Description of the API documentation version.
   *
   * @schema DocumentationVersionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DocumentationVersionSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the associated Rest API
   *
   * @schema DocumentationVersionSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema DocumentationVersionSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: DocumentationVersionSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema DocumentationVersionSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: DocumentationVersionSpecForProviderRestApiIdSelector;

  /**
   * Version identifier of the API documentation snapshot.
   *
   * @schema DocumentationVersionSpecForProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'DocumentationVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecForProvider(obj: DocumentationVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_DocumentationVersionSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_DocumentationVersionSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DocumentationVersionSpecManagementPolicy
 */
export enum DocumentationVersionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DocumentationVersionSpecProviderConfigRef
 */
export interface DocumentationVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationVersionSpecProviderConfigRef#policy
   */
  readonly policy?: DocumentationVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DocumentationVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecProviderConfigRef(obj: DocumentationVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DocumentationVersionSpecProviderRef
 */
export interface DocumentationVersionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationVersionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationVersionSpecProviderRef#policy
   */
  readonly policy?: DocumentationVersionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DocumentationVersionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecProviderRef(obj: DocumentationVersionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationVersionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsTo
 */
export interface DocumentationVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DocumentationVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DocumentationVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DocumentationVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecPublishConnectionDetailsTo(obj: DocumentationVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DocumentationVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DocumentationVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DocumentationVersionSpecWriteConnectionSecretToRef
 */
export interface DocumentationVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DocumentationVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DocumentationVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DocumentationVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecWriteConnectionSecretToRef(obj: DocumentationVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdRef
 */
export interface DocumentationVersionSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: DocumentationVersionSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'DocumentationVersionSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecForProviderRestApiIdRef(obj: DocumentationVersionSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationVersionSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdSelector
 */
export interface DocumentationVersionSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: DocumentationVersionSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'DocumentationVersionSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecForProviderRestApiIdSelector(obj: DocumentationVersionSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DocumentationVersionSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentationVersionSpecProviderConfigRefPolicy
 */
export interface DocumentationVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DocumentationVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DocumentationVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecProviderConfigRefPolicy(obj: DocumentationVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentationVersionSpecProviderRefPolicy
 */
export interface DocumentationVersionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationVersionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DocumentationVersionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationVersionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DocumentationVersionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationVersionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecProviderRefPolicy(obj: DocumentationVersionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface DocumentationVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DocumentationVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecPublishConnectionDetailsToConfigRef(obj: DocumentationVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsToMetadata
 */
export interface DocumentationVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DocumentationVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecPublishConnectionDetailsToMetadata(obj: DocumentationVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdRefPolicy
 */
export interface DocumentationVersionSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: DocumentationVersionSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: DocumentationVersionSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationVersionSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecForProviderRestApiIdRefPolicy(obj: DocumentationVersionSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdSelectorPolicy
 */
export interface DocumentationVersionSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationVersionSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationVersionSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecForProviderRestApiIdSelectorPolicy(obj: DocumentationVersionSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationVersionSpecProviderConfigRefPolicyResolution
 */
export enum DocumentationVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationVersionSpecProviderConfigRefPolicyResolve
 */
export enum DocumentationVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationVersionSpecProviderRefPolicyResolution
 */
export enum DocumentationVersionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationVersionSpecProviderRefPolicyResolve
 */
export enum DocumentationVersionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdRefPolicyResolution
 */
export enum DocumentationVersionSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdRefPolicyResolve
 */
export enum DocumentationVersionSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum DocumentationVersionSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DocumentationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DomainName is the Schema for the DomainNames API. Registers a custom domain name for use with AWS API Gateway.
 *
 * @schema DomainName
 */
export class DomainName extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DomainName"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'DomainName',
  }

  /**
   * Renders a Kubernetes manifest for "DomainName".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainNameProps): any {
    return {
      ...DomainName.GVK,
      ...toJson_DomainNameProps(props),
    };
  }

  /**
   * Defines a "DomainName" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainNameProps) {
    super(scope, id, {
      ...DomainName.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DomainName.GVK,
      ...toJson_DomainNameProps(resolved),
    };
  }
}

/**
 * DomainName is the Schema for the DomainNames API. Registers a custom domain name for use with AWS API Gateway.
 *
 * @schema DomainName
 */
export interface DomainNameProps {
  /**
   * @schema DomainName#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainNameSpec defines the desired state of DomainName
   *
   * @schema DomainName#spec
   */
  readonly spec: DomainNameSpec;

}

/**
 * Converts an object of type 'DomainNameProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameProps(obj: DomainNameProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainNameSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainNameSpec defines the desired state of DomainName
 *
 * @schema DomainNameSpec
 */
export interface DomainNameSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainNameSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainNameSpecDeletionPolicy;

  /**
   * @schema DomainNameSpec#forProvider
   */
  readonly forProvider: DomainNameSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainNameSpec#managementPolicy
   */
  readonly managementPolicy?: DomainNameSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainNameSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainNameSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DomainNameSpec#providerRef
   */
  readonly providerRef?: DomainNameSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainNameSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainNameSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainNameSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainNameSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainNameSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpec(obj: DomainNameSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainNameSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DomainNameSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DomainNameSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DomainNameSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainNameSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainNameSpecDeletionPolicy
 */
export enum DomainNameSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainNameSpecForProvider
 */
export interface DomainNameSpecForProvider {
  /**
   * ARN for an AWS-managed certificate. AWS Certificate Manager is the only supported source. Used when an edge-optimized domain name is desired. Conflicts with certificate_name, certificate_body, certificate_chain, certificate_private_key, regional_certificate_arn, and regional_certificate_name.
   *
   * @schema DomainNameSpecForProvider#certificateArn
   */
  readonly certificateArn?: string;

  /**
   * Reference to a CertificateValidation in acm to populate certificateArn.
   *
   * @schema DomainNameSpecForProvider#certificateArnRef
   */
  readonly certificateArnRef?: DomainNameSpecForProviderCertificateArnRef;

  /**
   * Selector for a CertificateValidation in acm to populate certificateArn.
   *
   * @schema DomainNameSpecForProvider#certificateArnSelector
   */
  readonly certificateArnSelector?: DomainNameSpecForProviderCertificateArnSelector;

  /**
   * Certificate issued for the domain name being registered, in PEM format. Only valid for EDGE endpoint configuration type. Conflicts with certificate_arn, regional_certificate_arn, and regional_certificate_name.
   *
   * @schema DomainNameSpecForProvider#certificateBody
   */
  readonly certificateBody?: string;

  /**
   * Certificate for the CA that issued the certificate, along with any intermediate CA certificates required to create an unbroken chain to a certificate trusted by the intended API clients. Only valid for EDGE endpoint configuration type. Conflicts with certificate_arn, regional_certificate_arn, and regional_certificate_name.
   *
   * @schema DomainNameSpecForProvider#certificateChain
   */
  readonly certificateChain?: string;

  /**
   * Unique name to use when registering this certificate as an IAM server certificate. Conflicts with certificate_arn, regional_certificate_arn, and regional_certificate_name. Required if certificate_arn is not set.
   *
   * @schema DomainNameSpecForProvider#certificateName
   */
  readonly certificateName?: string;

  /**
   * Private key associated with the domain certificate given in certificate_body. Only valid for EDGE endpoint configuration type. Conflicts with certificate_arn, regional_certificate_arn, and regional_certificate_name.
   *
   * @schema DomainNameSpecForProvider#certificatePrivateKeySecretRef
   */
  readonly certificatePrivateKeySecretRef?: DomainNameSpecForProviderCertificatePrivateKeySecretRef;

  /**
   * Fully-qualified domain name to register.
   *
   * @schema DomainNameSpecForProvider#domainName
   */
  readonly domainName?: string;

  /**
   * Configuration block defining API endpoint information including type. See below.
   *
   * @schema DomainNameSpecForProvider#endpointConfiguration
   */
  readonly endpointConfiguration?: DomainNameSpecForProviderEndpointConfiguration[];

  /**
   * Mutual TLS authentication configuration for the domain name. See below.
   *
   * @schema DomainNameSpecForProvider#mutualTlsAuthentication
   */
  readonly mutualTlsAuthentication?: DomainNameSpecForProviderMutualTlsAuthentication[];

  /**
   * ARN of the AWS-issued certificate used to validate custom domain ownership (when certificate_arn is issued via an ACM Private CA or mutual_tls_authentication is configured with an ACM-imported certificate.)
   *
   * @schema DomainNameSpecForProvider#ownershipVerificationCertificateArn
   */
  readonly ownershipVerificationCertificateArn?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DomainNameSpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN for an AWS-managed certificate. AWS Certificate Manager is the only supported source. Used when a regional domain name is desired. Conflicts with certificate_arn, certificate_name, certificate_body, certificate_chain, and certificate_private_key.
   *
   * @schema DomainNameSpecForProvider#regionalCertificateArn
   */
  readonly regionalCertificateArn?: string;

  /**
   * Reference to a CertificateValidation in acm to populate regionalCertificateArn.
   *
   * @schema DomainNameSpecForProvider#regionalCertificateArnRef
   */
  readonly regionalCertificateArnRef?: DomainNameSpecForProviderRegionalCertificateArnRef;

  /**
   * Selector for a CertificateValidation in acm to populate regionalCertificateArn.
   *
   * @schema DomainNameSpecForProvider#regionalCertificateArnSelector
   */
  readonly regionalCertificateArnSelector?: DomainNameSpecForProviderRegionalCertificateArnSelector;

  /**
   * User-friendly name of the certificate that will be used by regional endpoint for this domain name. Conflicts with certificate_arn, certificate_name, certificate_body, certificate_chain, and certificate_private_key.
   *
   * @schema DomainNameSpecForProvider#regionalCertificateName
   */
  readonly regionalCertificateName?: string;

  /**
   * Transport Layer Security (TLS) version + cipher suite for this DomainName. Valid values are TLS_1_0 and TLS_1_2. Must be configured to perform drift detection.
   *
   * @schema DomainNameSpecForProvider#securityPolicy
   */
  readonly securityPolicy?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DomainNameSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DomainNameSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProvider(obj: DomainNameSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateArn': obj.certificateArn,
    'certificateArnRef': toJson_DomainNameSpecForProviderCertificateArnRef(obj.certificateArnRef),
    'certificateArnSelector': toJson_DomainNameSpecForProviderCertificateArnSelector(obj.certificateArnSelector),
    'certificateBody': obj.certificateBody,
    'certificateChain': obj.certificateChain,
    'certificateName': obj.certificateName,
    'certificatePrivateKeySecretRef': toJson_DomainNameSpecForProviderCertificatePrivateKeySecretRef(obj.certificatePrivateKeySecretRef),
    'domainName': obj.domainName,
    'endpointConfiguration': obj.endpointConfiguration?.map(y => toJson_DomainNameSpecForProviderEndpointConfiguration(y)),
    'mutualTlsAuthentication': obj.mutualTlsAuthentication?.map(y => toJson_DomainNameSpecForProviderMutualTlsAuthentication(y)),
    'ownershipVerificationCertificateArn': obj.ownershipVerificationCertificateArn,
    'region': obj.region,
    'regionalCertificateArn': obj.regionalCertificateArn,
    'regionalCertificateArnRef': toJson_DomainNameSpecForProviderRegionalCertificateArnRef(obj.regionalCertificateArnRef),
    'regionalCertificateArnSelector': toJson_DomainNameSpecForProviderRegionalCertificateArnSelector(obj.regionalCertificateArnSelector),
    'regionalCertificateName': obj.regionalCertificateName,
    'securityPolicy': obj.securityPolicy,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainNameSpecManagementPolicy
 */
export enum DomainNameSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainNameSpecProviderConfigRef
 */
export interface DomainNameSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecProviderConfigRef#policy
   */
  readonly policy?: DomainNameSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderConfigRef(obj: DomainNameSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DomainNameSpecProviderRef
 */
export interface DomainNameSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecProviderRef#policy
   */
  readonly policy?: DomainNameSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderRef(obj: DomainNameSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainNameSpecPublishConnectionDetailsTo
 */
export interface DomainNameSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainNameSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainNameSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainNameSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsTo(obj: DomainNameSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainNameSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainNameSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainNameSpecWriteConnectionSecretToRef
 */
export interface DomainNameSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainNameSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainNameSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainNameSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecWriteConnectionSecretToRef(obj: DomainNameSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateValidation in acm to populate certificateArn.
 *
 * @schema DomainNameSpecForProviderCertificateArnRef
 */
export interface DomainNameSpecForProviderCertificateArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecForProviderCertificateArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecForProviderCertificateArnRef#policy
   */
  readonly policy?: DomainNameSpecForProviderCertificateArnRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderCertificateArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderCertificateArnRef(obj: DomainNameSpecForProviderCertificateArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecForProviderCertificateArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateValidation in acm to populate certificateArn.
 *
 * @schema DomainNameSpecForProviderCertificateArnSelector
 */
export interface DomainNameSpecForProviderCertificateArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainNameSpecForProviderCertificateArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainNameSpecForProviderCertificateArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainNameSpecForProviderCertificateArnSelector#policy
   */
  readonly policy?: DomainNameSpecForProviderCertificateArnSelectorPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderCertificateArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderCertificateArnSelector(obj: DomainNameSpecForProviderCertificateArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainNameSpecForProviderCertificateArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Private key associated with the domain certificate given in certificate_body. Only valid for EDGE endpoint configuration type. Conflicts with certificate_arn, regional_certificate_arn, and regional_certificate_name.
 *
 * @schema DomainNameSpecForProviderCertificatePrivateKeySecretRef
 */
export interface DomainNameSpecForProviderCertificatePrivateKeySecretRef {
  /**
   * The key to select.
   *
   * @schema DomainNameSpecForProviderCertificatePrivateKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DomainNameSpecForProviderCertificatePrivateKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainNameSpecForProviderCertificatePrivateKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderCertificatePrivateKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderCertificatePrivateKeySecretRef(obj: DomainNameSpecForProviderCertificatePrivateKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainNameSpecForProviderEndpointConfiguration
 */
export interface DomainNameSpecForProviderEndpointConfiguration {
  /**
   * List of endpoint types. This resource currently only supports managing a single value. Valid values: EDGE or REGIONAL. If unspecified, defaults to EDGE. Must be declared as REGIONAL in non-Commercial partitions. Refer to the documentation for more information on the difference between edge-optimized and regional APIs.
   *
   * @schema DomainNameSpecForProviderEndpointConfiguration#types
   */
  readonly types: string[];

}

/**
 * Converts an object of type 'DomainNameSpecForProviderEndpointConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderEndpointConfiguration(obj: DomainNameSpecForProviderEndpointConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'types': obj.types?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainNameSpecForProviderMutualTlsAuthentication
 */
export interface DomainNameSpecForProviderMutualTlsAuthentication {
  /**
   * Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version.
   *
   * @schema DomainNameSpecForProviderMutualTlsAuthentication#truststoreUri
   */
  readonly truststoreUri: string;

  /**
   * Version of the S3 object that contains the truststore. To specify a version, you must have versioning enabled for the S3 bucket.
   *
   * @schema DomainNameSpecForProviderMutualTlsAuthentication#truststoreVersion
   */
  readonly truststoreVersion?: string;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderMutualTlsAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderMutualTlsAuthentication(obj: DomainNameSpecForProviderMutualTlsAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'truststoreUri': obj.truststoreUri,
    'truststoreVersion': obj.truststoreVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateValidation in acm to populate regionalCertificateArn.
 *
 * @schema DomainNameSpecForProviderRegionalCertificateArnRef
 */
export interface DomainNameSpecForProviderRegionalCertificateArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecForProviderRegionalCertificateArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecForProviderRegionalCertificateArnRef#policy
   */
  readonly policy?: DomainNameSpecForProviderRegionalCertificateArnRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderRegionalCertificateArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderRegionalCertificateArnRef(obj: DomainNameSpecForProviderRegionalCertificateArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecForProviderRegionalCertificateArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateValidation in acm to populate regionalCertificateArn.
 *
 * @schema DomainNameSpecForProviderRegionalCertificateArnSelector
 */
export interface DomainNameSpecForProviderRegionalCertificateArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainNameSpecForProviderRegionalCertificateArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainNameSpecForProviderRegionalCertificateArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainNameSpecForProviderRegionalCertificateArnSelector#policy
   */
  readonly policy?: DomainNameSpecForProviderRegionalCertificateArnSelectorPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderRegionalCertificateArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderRegionalCertificateArnSelector(obj: DomainNameSpecForProviderRegionalCertificateArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainNameSpecForProviderRegionalCertificateArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecProviderConfigRefPolicy
 */
export interface DomainNameSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderConfigRefPolicy(obj: DomainNameSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecProviderRefPolicy
 */
export interface DomainNameSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecProviderRefPolicy(obj: DomainNameSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainNameSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToConfigRef(obj: DomainNameSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainNameSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToMetadata
 */
export interface DomainNameSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToMetadata(obj: DomainNameSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecForProviderCertificateArnRefPolicy
 */
export interface DomainNameSpecForProviderCertificateArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecForProviderCertificateArnRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecForProviderCertificateArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecForProviderCertificateArnRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecForProviderCertificateArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderCertificateArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderCertificateArnRefPolicy(obj: DomainNameSpecForProviderCertificateArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainNameSpecForProviderCertificateArnSelectorPolicy
 */
export interface DomainNameSpecForProviderCertificateArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecForProviderCertificateArnSelectorPolicy#resolution
   */
  readonly resolution?: DomainNameSpecForProviderCertificateArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecForProviderCertificateArnSelectorPolicy#resolve
   */
  readonly resolve?: DomainNameSpecForProviderCertificateArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderCertificateArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderCertificateArnSelectorPolicy(obj: DomainNameSpecForProviderCertificateArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecForProviderRegionalCertificateArnRefPolicy
 */
export interface DomainNameSpecForProviderRegionalCertificateArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecForProviderRegionalCertificateArnRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecForProviderRegionalCertificateArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecForProviderRegionalCertificateArnRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecForProviderRegionalCertificateArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderRegionalCertificateArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderRegionalCertificateArnRefPolicy(obj: DomainNameSpecForProviderRegionalCertificateArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainNameSpecForProviderRegionalCertificateArnSelectorPolicy
 */
export interface DomainNameSpecForProviderRegionalCertificateArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecForProviderRegionalCertificateArnSelectorPolicy#resolution
   */
  readonly resolution?: DomainNameSpecForProviderRegionalCertificateArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecForProviderRegionalCertificateArnSelectorPolicy#resolve
   */
  readonly resolve?: DomainNameSpecForProviderRegionalCertificateArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecForProviderRegionalCertificateArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecForProviderRegionalCertificateArnSelectorPolicy(obj: DomainNameSpecForProviderRegionalCertificateArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecProviderConfigRefPolicyResolution
 */
export enum DomainNameSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecProviderConfigRefPolicyResolve
 */
export enum DomainNameSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecProviderRefPolicyResolution
 */
export enum DomainNameSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecProviderRefPolicyResolve
 */
export enum DomainNameSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainNameSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainNameSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainNameSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainNameSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecForProviderCertificateArnRefPolicyResolution
 */
export enum DomainNameSpecForProviderCertificateArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecForProviderCertificateArnRefPolicyResolve
 */
export enum DomainNameSpecForProviderCertificateArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecForProviderCertificateArnSelectorPolicyResolution
 */
export enum DomainNameSpecForProviderCertificateArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecForProviderCertificateArnSelectorPolicyResolve
 */
export enum DomainNameSpecForProviderCertificateArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecForProviderRegionalCertificateArnRefPolicyResolution
 */
export enum DomainNameSpecForProviderRegionalCertificateArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecForProviderRegionalCertificateArnRefPolicyResolve
 */
export enum DomainNameSpecForProviderRegionalCertificateArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecForProviderRegionalCertificateArnSelectorPolicyResolution
 */
export enum DomainNameSpecForProviderRegionalCertificateArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecForProviderRegionalCertificateArnSelectorPolicyResolve
 */
export enum DomainNameSpecForProviderRegionalCertificateArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainNameSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GatewayResponse is the Schema for the GatewayResponses API. Provides an API Gateway Gateway Response for a REST API Gateway.
 *
 * @schema GatewayResponse
 */
export class GatewayResponse extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GatewayResponse"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'GatewayResponse',
  }

  /**
   * Renders a Kubernetes manifest for "GatewayResponse".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GatewayResponseProps): any {
    return {
      ...GatewayResponse.GVK,
      ...toJson_GatewayResponseProps(props),
    };
  }

  /**
   * Defines a "GatewayResponse" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GatewayResponseProps) {
    super(scope, id, {
      ...GatewayResponse.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GatewayResponse.GVK,
      ...toJson_GatewayResponseProps(resolved),
    };
  }
}

/**
 * GatewayResponse is the Schema for the GatewayResponses API. Provides an API Gateway Gateway Response for a REST API Gateway.
 *
 * @schema GatewayResponse
 */
export interface GatewayResponseProps {
  /**
   * @schema GatewayResponse#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GatewayResponseSpec defines the desired state of GatewayResponse
   *
   * @schema GatewayResponse#spec
   */
  readonly spec: GatewayResponseSpec;

}

/**
 * Converts an object of type 'GatewayResponseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseProps(obj: GatewayResponseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GatewayResponseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayResponseSpec defines the desired state of GatewayResponse
 *
 * @schema GatewayResponseSpec
 */
export interface GatewayResponseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GatewayResponseSpec#deletionPolicy
   */
  readonly deletionPolicy?: GatewayResponseSpecDeletionPolicy;

  /**
   * @schema GatewayResponseSpec#forProvider
   */
  readonly forProvider: GatewayResponseSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GatewayResponseSpec#managementPolicy
   */
  readonly managementPolicy?: GatewayResponseSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GatewayResponseSpec#providerConfigRef
   */
  readonly providerConfigRef?: GatewayResponseSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema GatewayResponseSpec#providerRef
   */
  readonly providerRef?: GatewayResponseSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GatewayResponseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GatewayResponseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GatewayResponseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GatewayResponseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GatewayResponseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpec(obj: GatewayResponseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GatewayResponseSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_GatewayResponseSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_GatewayResponseSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_GatewayResponseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GatewayResponseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GatewayResponseSpecDeletionPolicy
 */
export enum GatewayResponseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GatewayResponseSpecForProvider
 */
export interface GatewayResponseSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GatewayResponseSpecForProvider#region
   */
  readonly region: string;

  /**
   * Map of parameters (paths, query strings and headers) of the Gateway Response.
   *
   * @schema GatewayResponseSpecForProvider#responseParameters
   */
  readonly responseParameters?: { [key: string]: string };

  /**
   * Map of templates used to transform the response body.
   *
   * @schema GatewayResponseSpecForProvider#responseTemplates
   */
  readonly responseTemplates?: { [key: string]: string };

  /**
   * Response type of the associated GatewayResponse.
   *
   * @schema GatewayResponseSpecForProvider#responseType
   */
  readonly responseType?: string;

  /**
   * String identifier of the associated REST API.
   *
   * @schema GatewayResponseSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema GatewayResponseSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: GatewayResponseSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema GatewayResponseSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: GatewayResponseSpecForProviderRestApiIdSelector;

  /**
   * HTTP status code of the Gateway Response.
   *
   * @schema GatewayResponseSpecForProvider#statusCode
   */
  readonly statusCode?: string;

}

/**
 * Converts an object of type 'GatewayResponseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecForProvider(obj: GatewayResponseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'responseParameters': ((obj.responseParameters) === undefined) ? undefined : (Object.entries(obj.responseParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseTemplates': ((obj.responseTemplates) === undefined) ? undefined : (Object.entries(obj.responseTemplates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseType': obj.responseType,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_GatewayResponseSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_GatewayResponseSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GatewayResponseSpecManagementPolicy
 */
export enum GatewayResponseSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GatewayResponseSpecProviderConfigRef
 */
export interface GatewayResponseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayResponseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayResponseSpecProviderConfigRef#policy
   */
  readonly policy?: GatewayResponseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewayResponseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecProviderConfigRef(obj: GatewayResponseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayResponseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema GatewayResponseSpecProviderRef
 */
export interface GatewayResponseSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayResponseSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayResponseSpecProviderRef#policy
   */
  readonly policy?: GatewayResponseSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'GatewayResponseSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecProviderRef(obj: GatewayResponseSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayResponseSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsTo
 */
export interface GatewayResponseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GatewayResponseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GatewayResponseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GatewayResponseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecPublishConnectionDetailsTo(obj: GatewayResponseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GatewayResponseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GatewayResponseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GatewayResponseSpecWriteConnectionSecretToRef
 */
export interface GatewayResponseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GatewayResponseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GatewayResponseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GatewayResponseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecWriteConnectionSecretToRef(obj: GatewayResponseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdRef
 */
export interface GatewayResponseSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: GatewayResponseSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'GatewayResponseSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecForProviderRestApiIdRef(obj: GatewayResponseSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayResponseSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdSelector
 */
export interface GatewayResponseSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: GatewayResponseSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'GatewayResponseSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecForProviderRestApiIdSelector(obj: GatewayResponseSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GatewayResponseSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayResponseSpecProviderConfigRefPolicy
 */
export interface GatewayResponseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayResponseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GatewayResponseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayResponseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GatewayResponseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayResponseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecProviderConfigRefPolicy(obj: GatewayResponseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayResponseSpecProviderRefPolicy
 */
export interface GatewayResponseSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayResponseSpecProviderRefPolicy#resolution
   */
  readonly resolution?: GatewayResponseSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayResponseSpecProviderRefPolicy#resolve
   */
  readonly resolve?: GatewayResponseSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayResponseSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecProviderRefPolicy(obj: GatewayResponseSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRef
 */
export interface GatewayResponseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GatewayResponseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecPublishConnectionDetailsToConfigRef(obj: GatewayResponseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsToMetadata
 */
export interface GatewayResponseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GatewayResponseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecPublishConnectionDetailsToMetadata(obj: GatewayResponseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdRefPolicy
 */
export interface GatewayResponseSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: GatewayResponseSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: GatewayResponseSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayResponseSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecForProviderRestApiIdRefPolicy(obj: GatewayResponseSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdSelectorPolicy
 */
export interface GatewayResponseSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayResponseSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GatewayResponseSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecForProviderRestApiIdSelectorPolicy(obj: GatewayResponseSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayResponseSpecProviderConfigRefPolicyResolution
 */
export enum GatewayResponseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayResponseSpecProviderConfigRefPolicyResolve
 */
export enum GatewayResponseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayResponseSpecProviderRefPolicyResolution
 */
export enum GatewayResponseSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayResponseSpecProviderRefPolicyResolve
 */
export enum GatewayResponseSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj: GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdRefPolicyResolution
 */
export enum GatewayResponseSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdRefPolicyResolve
 */
export enum GatewayResponseSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum GatewayResponseSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GatewayResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Integration is the Schema for the Integrations API. Provides an HTTP Method Integration for an API Gateway Integration.
 *
 * @schema Integration
 */
export class Integration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Integration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'Integration',
  }

  /**
   * Renders a Kubernetes manifest for "Integration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IntegrationProps): any {
    return {
      ...Integration.GVK,
      ...toJson_IntegrationProps(props),
    };
  }

  /**
   * Defines a "Integration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IntegrationProps) {
    super(scope, id, {
      ...Integration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Integration.GVK,
      ...toJson_IntegrationProps(resolved),
    };
  }
}

/**
 * Integration is the Schema for the Integrations API. Provides an HTTP Method Integration for an API Gateway Integration.
 *
 * @schema Integration
 */
export interface IntegrationProps {
  /**
   * @schema Integration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IntegrationSpec defines the desired state of Integration
   *
   * @schema Integration#spec
   */
  readonly spec: IntegrationSpec;

}

/**
 * Converts an object of type 'IntegrationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationProps(obj: IntegrationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntegrationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntegrationSpec defines the desired state of Integration
 *
 * @schema IntegrationSpec
 */
export interface IntegrationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationSpec#deletionPolicy
   */
  readonly deletionPolicy?: IntegrationSpecDeletionPolicy;

  /**
   * @schema IntegrationSpec#forProvider
   */
  readonly forProvider: IntegrationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationSpec#managementPolicy
   */
  readonly managementPolicy?: IntegrationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IntegrationSpec#providerConfigRef
   */
  readonly providerConfigRef?: IntegrationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IntegrationSpec#providerRef
   */
  readonly providerRef?: IntegrationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IntegrationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IntegrationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IntegrationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IntegrationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IntegrationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpec(obj: IntegrationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IntegrationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_IntegrationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IntegrationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IntegrationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IntegrationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationSpecDeletionPolicy
 */
export enum IntegrationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IntegrationSpecForProvider
 */
export interface IntegrationSpecForProvider {
  /**
   * List of cache key parameters for the integration.
   *
   * @schema IntegrationSpecForProvider#cacheKeyParameters
   */
  readonly cacheKeyParameters?: string[];

  /**
   * Integration's cache namespace.
   *
   * @schema IntegrationSpecForProvider#cacheNamespace
   */
  readonly cacheNamespace?: string;

  /**
   * ID of the VpcLink used for the integration. Required if connection_type is VPC_LINK
   *
   * @schema IntegrationSpecForProvider#connectionId
   */
  readonly connectionId?: string;

  /**
   * Reference to a VPCLink in apigateway to populate connectionId.
   *
   * @schema IntegrationSpecForProvider#connectionIdRef
   */
  readonly connectionIdRef?: IntegrationSpecForProviderConnectionIdRef;

  /**
   * Selector for a VPCLink in apigateway to populate connectionId.
   *
   * @schema IntegrationSpecForProvider#connectionIdSelector
   */
  readonly connectionIdSelector?: IntegrationSpecForProviderConnectionIdSelector;

  /**
   * Integration input's connectionType. Valid values are INTERNET (default for connections through the public routable internet), and VPC_LINK (for private connections between API Gateway and a network load balancer in a VPC).
   *
   * @schema IntegrationSpecForProvider#connectionType
   */
  readonly connectionType?: string;

  /**
   * How to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT. If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehaviors is configured to support payload pass-through.
   *
   * @schema IntegrationSpecForProvider#contentHandling
   */
  readonly contentHandling?: string;

  /**
   * Credentials required for the integration. For AWS integrations, 2 options are available. To specify an IAM Role for Amazon API Gateway to assume, use the role's ARN. To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*.
   *
   * @schema IntegrationSpecForProvider#credentials
   */
  readonly credentials?: string;

  /**
   * HTTP method (GET, POST, PUT, DELETE, HEAD, OPTION, ANY) when calling the associated resource.
   *
   * @schema IntegrationSpecForProvider#httpMethod
   */
  readonly httpMethod?: string;

  /**
   * Reference to a Method in apigateway to populate httpMethod.
   *
   * @schema IntegrationSpecForProvider#httpMethodRef
   */
  readonly httpMethodRef?: IntegrationSpecForProviderHttpMethodRef;

  /**
   * Selector for a Method in apigateway to populate httpMethod.
   *
   * @schema IntegrationSpecForProvider#httpMethodSelector
   */
  readonly httpMethodSelector?: IntegrationSpecForProviderHttpMethodSelector;

  /**
   * Integration HTTP method (GET, POST, PUT, DELETE, HEAD, OPTIONs, ANY, PATCH) specifying how API Gateway will interact with the back end. Required if type is AWS, AWS_PROXY, HTTP or HTTP_PROXY. Not all methods are compatible with all AWS integrations. e.g., Lambda function can only be invoked via POST.
   *
   * @schema IntegrationSpecForProvider#integrationHttpMethod
   */
  readonly integrationHttpMethod?: string;

  /**
   * Integration passthrough behavior (WHEN_NO_MATCH, WHEN_NO_TEMPLATES, NEVER).  Required if request_templates is used.
   *
   * @schema IntegrationSpecForProvider#passthroughBehavior
   */
  readonly passthroughBehavior?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IntegrationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Map of request query string parameters and headers that should be passed to the backend responder. For example: request_parameters = { "integration.request.header.X-Some-Other-Header" = "method.request.header.X-Some-Header" }
   *
   * @schema IntegrationSpecForProvider#requestParameters
   */
  readonly requestParameters?: { [key: string]: string };

  /**
   * Map of the integration's request templates.
   *
   * @schema IntegrationSpecForProvider#requestTemplates
   */
  readonly requestTemplates?: { [key: string]: string };

  /**
   * API resource ID.
   *
   * @schema IntegrationSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a Resource in apigateway to populate resourceId.
   *
   * @schema IntegrationSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: IntegrationSpecForProviderResourceIdRef;

  /**
   * Selector for a Resource in apigateway to populate resourceId.
   *
   * @schema IntegrationSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: IntegrationSpecForProviderResourceIdSelector;

  /**
   * ID of the associated REST API.
   *
   * @schema IntegrationSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema IntegrationSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: IntegrationSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema IntegrationSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: IntegrationSpecForProviderRestApiIdSelector;

  /**
   * Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds.
   *
   * @schema IntegrationSpecForProvider#timeoutMilliseconds
   */
  readonly timeoutMilliseconds?: number;

  /**
   * TLS configuration. See below.
   *
   * @schema IntegrationSpecForProvider#tlsConfig
   */
  readonly tlsConfig?: IntegrationSpecForProviderTlsConfig[];

  /**
   * Integration input's type. Valid values are HTTP (for HTTP backends), MOCK (not calling any real backend), AWS (for AWS services), AWS_PROXY (for Lambda proxy integration) and HTTP_PROXY (for HTTP proxy integration). An HTTP or HTTP_PROXY integration with a connection_type of VPC_LINK is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
   *
   * @schema IntegrationSpecForProvider#type
   */
  readonly type?: string;

  /**
   * Input's URI. Required if type is AWS, AWS_PROXY, HTTP or HTTP_PROXY. For HTTP integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification . For AWS integrations, the URI should be of the form arn:aws:apigateway:{region}:{subdomain.service|service}:{path|action}/{service_api}. region, subdomain and service are used to determine the right endpoint. e.g., arn:aws:apigateway:eu-west-1:lambda:path/2015-03-31/functions/arn:aws:lambda:eu-west-1:012345678901:function:my-func/invocations. For private integrations, the URI parameter is not used for routing requests to your endpoint, but is used for setting the Host header and for certificate validation.
   *
   * @schema IntegrationSpecForProvider#uri
   */
  readonly uri?: string;

  /**
   * Reference to a Function in lambda to populate uri.
   *
   * @schema IntegrationSpecForProvider#uriRef
   */
  readonly uriRef?: IntegrationSpecForProviderUriRef;

  /**
   * Selector for a Function in lambda to populate uri.
   *
   * @schema IntegrationSpecForProvider#uriSelector
   */
  readonly uriSelector?: IntegrationSpecForProviderUriSelector;

}

/**
 * Converts an object of type 'IntegrationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProvider(obj: IntegrationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cacheKeyParameters': obj.cacheKeyParameters?.map(y => y),
    'cacheNamespace': obj.cacheNamespace,
    'connectionId': obj.connectionId,
    'connectionIdRef': toJson_IntegrationSpecForProviderConnectionIdRef(obj.connectionIdRef),
    'connectionIdSelector': toJson_IntegrationSpecForProviderConnectionIdSelector(obj.connectionIdSelector),
    'connectionType': obj.connectionType,
    'contentHandling': obj.contentHandling,
    'credentials': obj.credentials,
    'httpMethod': obj.httpMethod,
    'httpMethodRef': toJson_IntegrationSpecForProviderHttpMethodRef(obj.httpMethodRef),
    'httpMethodSelector': toJson_IntegrationSpecForProviderHttpMethodSelector(obj.httpMethodSelector),
    'integrationHttpMethod': obj.integrationHttpMethod,
    'passthroughBehavior': obj.passthroughBehavior,
    'region': obj.region,
    'requestParameters': ((obj.requestParameters) === undefined) ? undefined : (Object.entries(obj.requestParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requestTemplates': ((obj.requestTemplates) === undefined) ? undefined : (Object.entries(obj.requestTemplates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_IntegrationSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_IntegrationSpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_IntegrationSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_IntegrationSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'timeoutMilliseconds': obj.timeoutMilliseconds,
    'tlsConfig': obj.tlsConfig?.map(y => toJson_IntegrationSpecForProviderTlsConfig(y)),
    'type': obj.type,
    'uri': obj.uri,
    'uriRef': toJson_IntegrationSpecForProviderUriRef(obj.uriRef),
    'uriSelector': toJson_IntegrationSpecForProviderUriSelector(obj.uriSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationSpecManagementPolicy
 */
export enum IntegrationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IntegrationSpecProviderConfigRef
 */
export interface IntegrationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecProviderConfigRef#policy
   */
  readonly policy?: IntegrationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderConfigRef(obj: IntegrationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IntegrationSpecProviderRef
 */
export interface IntegrationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecProviderRef#policy
   */
  readonly policy?: IntegrationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderRef(obj: IntegrationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IntegrationSpecPublishConnectionDetailsTo
 */
export interface IntegrationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IntegrationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IntegrationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IntegrationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsTo(obj: IntegrationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IntegrationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IntegrationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IntegrationSpecWriteConnectionSecretToRef
 */
export interface IntegrationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IntegrationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IntegrationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IntegrationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecWriteConnectionSecretToRef(obj: IntegrationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPCLink in apigateway to populate connectionId.
 *
 * @schema IntegrationSpecForProviderConnectionIdRef
 */
export interface IntegrationSpecForProviderConnectionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderConnectionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderConnectionIdRef#policy
   */
  readonly policy?: IntegrationSpecForProviderConnectionIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderConnectionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderConnectionIdRef(obj: IntegrationSpecForProviderConnectionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderConnectionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPCLink in apigateway to populate connectionId.
 *
 * @schema IntegrationSpecForProviderConnectionIdSelector
 */
export interface IntegrationSpecForProviderConnectionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderConnectionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderConnectionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderConnectionIdSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderConnectionIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderConnectionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderConnectionIdSelector(obj: IntegrationSpecForProviderConnectionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderConnectionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Method in apigateway to populate httpMethod.
 *
 * @schema IntegrationSpecForProviderHttpMethodRef
 */
export interface IntegrationSpecForProviderHttpMethodRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderHttpMethodRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderHttpMethodRef#policy
   */
  readonly policy?: IntegrationSpecForProviderHttpMethodRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderHttpMethodRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderHttpMethodRef(obj: IntegrationSpecForProviderHttpMethodRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderHttpMethodRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Method in apigateway to populate httpMethod.
 *
 * @schema IntegrationSpecForProviderHttpMethodSelector
 */
export interface IntegrationSpecForProviderHttpMethodSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderHttpMethodSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderHttpMethodSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderHttpMethodSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderHttpMethodSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderHttpMethodSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderHttpMethodSelector(obj: IntegrationSpecForProviderHttpMethodSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderHttpMethodSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Resource in apigateway to populate resourceId.
 *
 * @schema IntegrationSpecForProviderResourceIdRef
 */
export interface IntegrationSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderResourceIdRef#policy
   */
  readonly policy?: IntegrationSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderResourceIdRef(obj: IntegrationSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Resource in apigateway to populate resourceId.
 *
 * @schema IntegrationSpecForProviderResourceIdSelector
 */
export interface IntegrationSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderResourceIdSelector(obj: IntegrationSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema IntegrationSpecForProviderRestApiIdRef
 */
export interface IntegrationSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: IntegrationSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderRestApiIdRef(obj: IntegrationSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema IntegrationSpecForProviderRestApiIdSelector
 */
export interface IntegrationSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderRestApiIdSelector(obj: IntegrationSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IntegrationSpecForProviderTlsConfig
 */
export interface IntegrationSpecForProviderTlsConfig {
  /**
   * Whether or not API Gateway skips verification that the certificate for an integration endpoint is issued by a supported certificate authority. This isn’t recommended, but it enables you to use certificates that are signed by private certificate authorities, or certificates that are self-signed. If enabled, API Gateway still performs basic certificate validation, which includes checking the certificate's expiration date, hostname, and presence of a root certificate authority. Supported only for HTTP and HTTP_PROXY integrations.
   *
   * @schema IntegrationSpecForProviderTlsConfig#insecureSkipVerification
   */
  readonly insecureSkipVerification?: boolean;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderTlsConfig(obj: IntegrationSpecForProviderTlsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'insecureSkipVerification': obj.insecureSkipVerification,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate uri.
 *
 * @schema IntegrationSpecForProviderUriRef
 */
export interface IntegrationSpecForProviderUriRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecForProviderUriRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecForProviderUriRef#policy
   */
  readonly policy?: IntegrationSpecForProviderUriRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderUriRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderUriRef(obj: IntegrationSpecForProviderUriRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecForProviderUriRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate uri.
 *
 * @schema IntegrationSpecForProviderUriSelector
 */
export interface IntegrationSpecForProviderUriSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationSpecForProviderUriSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationSpecForProviderUriSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationSpecForProviderUriSelector#policy
   */
  readonly policy?: IntegrationSpecForProviderUriSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderUriSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderUriSelector(obj: IntegrationSpecForProviderUriSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationSpecForProviderUriSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecProviderConfigRefPolicy
 */
export interface IntegrationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderConfigRefPolicy(obj: IntegrationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecProviderRefPolicy
 */
export interface IntegrationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecProviderRefPolicy(obj: IntegrationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRef
 */
export interface IntegrationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToConfigRef(obj: IntegrationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToMetadata
 */
export interface IntegrationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToMetadata(obj: IntegrationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderConnectionIdRefPolicy
 */
export interface IntegrationSpecForProviderConnectionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderConnectionIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderConnectionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderConnectionIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderConnectionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderConnectionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderConnectionIdRefPolicy(obj: IntegrationSpecForProviderConnectionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderConnectionIdSelectorPolicy
 */
export interface IntegrationSpecForProviderConnectionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderConnectionIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderConnectionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderConnectionIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderConnectionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderConnectionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderConnectionIdSelectorPolicy(obj: IntegrationSpecForProviderConnectionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderHttpMethodRefPolicy
 */
export interface IntegrationSpecForProviderHttpMethodRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderHttpMethodRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderHttpMethodRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderHttpMethodRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderHttpMethodRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderHttpMethodRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderHttpMethodRefPolicy(obj: IntegrationSpecForProviderHttpMethodRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderHttpMethodSelectorPolicy
 */
export interface IntegrationSpecForProviderHttpMethodSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderHttpMethodSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderHttpMethodSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderHttpMethodSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderHttpMethodSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderHttpMethodSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderHttpMethodSelectorPolicy(obj: IntegrationSpecForProviderHttpMethodSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderResourceIdRefPolicy
 */
export interface IntegrationSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderResourceIdRefPolicy(obj: IntegrationSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderResourceIdSelectorPolicy
 */
export interface IntegrationSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderResourceIdSelectorPolicy(obj: IntegrationSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderRestApiIdRefPolicy
 */
export interface IntegrationSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderRestApiIdRefPolicy(obj: IntegrationSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderRestApiIdSelectorPolicy
 */
export interface IntegrationSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderRestApiIdSelectorPolicy(obj: IntegrationSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecForProviderUriRefPolicy
 */
export interface IntegrationSpecForProviderUriRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderUriRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderUriRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderUriRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderUriRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderUriRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderUriRefPolicy(obj: IntegrationSpecForProviderUriRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationSpecForProviderUriSelectorPolicy
 */
export interface IntegrationSpecForProviderUriSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecForProviderUriSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationSpecForProviderUriSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecForProviderUriSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationSpecForProviderUriSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecForProviderUriSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecForProviderUriSelectorPolicy(obj: IntegrationSpecForProviderUriSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecProviderConfigRefPolicyResolution
 */
export enum IntegrationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecProviderConfigRefPolicyResolve
 */
export enum IntegrationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecProviderRefPolicyResolution
 */
export enum IntegrationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecProviderRefPolicyResolve
 */
export enum IntegrationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IntegrationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationSpecPublishConnectionDetailsToConfigRefPolicy(obj: IntegrationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderConnectionIdRefPolicyResolution
 */
export enum IntegrationSpecForProviderConnectionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderConnectionIdRefPolicyResolve
 */
export enum IntegrationSpecForProviderConnectionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderConnectionIdSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderConnectionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderConnectionIdSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderConnectionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderHttpMethodRefPolicyResolution
 */
export enum IntegrationSpecForProviderHttpMethodRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderHttpMethodRefPolicyResolve
 */
export enum IntegrationSpecForProviderHttpMethodRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderHttpMethodSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderHttpMethodSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderHttpMethodSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderHttpMethodSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderResourceIdRefPolicyResolution
 */
export enum IntegrationSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderResourceIdRefPolicyResolve
 */
export enum IntegrationSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderRestApiIdRefPolicyResolution
 */
export enum IntegrationSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderRestApiIdRefPolicyResolve
 */
export enum IntegrationSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderUriRefPolicyResolution
 */
export enum IntegrationSpecForProviderUriRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderUriRefPolicyResolve
 */
export enum IntegrationSpecForProviderUriRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecForProviderUriSelectorPolicyResolution
 */
export enum IntegrationSpecForProviderUriSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecForProviderUriSelectorPolicyResolve
 */
export enum IntegrationSpecForProviderUriSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IntegrationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * IntegrationResponse is the Schema for the IntegrationResponses API. Provides an HTTP Method Integration Response for an API Gateway Resource.
 *
 * @schema IntegrationResponse
 */
export class IntegrationResponse extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IntegrationResponse"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'IntegrationResponse',
  }

  /**
   * Renders a Kubernetes manifest for "IntegrationResponse".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IntegrationResponseProps): any {
    return {
      ...IntegrationResponse.GVK,
      ...toJson_IntegrationResponseProps(props),
    };
  }

  /**
   * Defines a "IntegrationResponse" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IntegrationResponseProps) {
    super(scope, id, {
      ...IntegrationResponse.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IntegrationResponse.GVK,
      ...toJson_IntegrationResponseProps(resolved),
    };
  }
}

/**
 * IntegrationResponse is the Schema for the IntegrationResponses API. Provides an HTTP Method Integration Response for an API Gateway Resource.
 *
 * @schema IntegrationResponse
 */
export interface IntegrationResponseProps {
  /**
   * @schema IntegrationResponse#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IntegrationResponseSpec defines the desired state of IntegrationResponse
   *
   * @schema IntegrationResponse#spec
   */
  readonly spec: IntegrationResponseSpec;

}

/**
 * Converts an object of type 'IntegrationResponseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseProps(obj: IntegrationResponseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IntegrationResponseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IntegrationResponseSpec defines the desired state of IntegrationResponse
 *
 * @schema IntegrationResponseSpec
 */
export interface IntegrationResponseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationResponseSpec#deletionPolicy
   */
  readonly deletionPolicy?: IntegrationResponseSpecDeletionPolicy;

  /**
   * @schema IntegrationResponseSpec#forProvider
   */
  readonly forProvider: IntegrationResponseSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema IntegrationResponseSpec#managementPolicy
   */
  readonly managementPolicy?: IntegrationResponseSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IntegrationResponseSpec#providerConfigRef
   */
  readonly providerConfigRef?: IntegrationResponseSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IntegrationResponseSpec#providerRef
   */
  readonly providerRef?: IntegrationResponseSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IntegrationResponseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IntegrationResponseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IntegrationResponseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IntegrationResponseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IntegrationResponseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpec(obj: IntegrationResponseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IntegrationResponseSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_IntegrationResponseSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IntegrationResponseSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IntegrationResponseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IntegrationResponseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationResponseSpecDeletionPolicy
 */
export enum IntegrationResponseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IntegrationResponseSpecForProvider
 */
export interface IntegrationResponseSpecForProvider {
  /**
   * How to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT. If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
   *
   * @schema IntegrationResponseSpecForProvider#contentHandling
   */
  readonly contentHandling?: string;

  /**
   * HTTP method (GET, POST, PUT, DELETE, HEAD, OPTIONS, ANY).
   *
   * @schema IntegrationResponseSpecForProvider#httpMethod
   */
  readonly httpMethod?: string;

  /**
   * Reference to a Method in apigateway to populate httpMethod.
   *
   * @schema IntegrationResponseSpecForProvider#httpMethodRef
   */
  readonly httpMethodRef?: IntegrationResponseSpecForProviderHttpMethodRef;

  /**
   * Selector for a Method in apigateway to populate httpMethod.
   *
   * @schema IntegrationResponseSpecForProvider#httpMethodSelector
   */
  readonly httpMethodSelector?: IntegrationResponseSpecForProviderHttpMethodSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IntegrationResponseSpecForProvider#region
   */
  readonly region: string;

  /**
   * API resource ID.
   *
   * @schema IntegrationResponseSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a Resource in apigateway to populate resourceId.
   *
   * @schema IntegrationResponseSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: IntegrationResponseSpecForProviderResourceIdRef;

  /**
   * Selector for a Resource in apigateway to populate resourceId.
   *
   * @schema IntegrationResponseSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: IntegrationResponseSpecForProviderResourceIdSelector;

  /**
   * Map of response parameters that can be read from the backend response. For example: response_parameters = { "method.response.header.X-Some-Header" = "integration.response.header.X-Some-Other-Header" }.
   *
   * @schema IntegrationResponseSpecForProvider#responseParameters
   */
  readonly responseParameters?: { [key: string]: string };

  /**
   * Map of templates used to transform the integration response body.
   *
   * @schema IntegrationResponseSpecForProvider#responseTemplates
   */
  readonly responseTemplates?: { [key: string]: string };

  /**
   * ID of the associated REST API.
   *
   * @schema IntegrationResponseSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema IntegrationResponseSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: IntegrationResponseSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema IntegrationResponseSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: IntegrationResponseSpecForProviderRestApiIdSelector;

  /**
   * Regular expression pattern used to choose an integration response based on the response from the backend. Omit configuring this to make the integration the default one. If the backend is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS backends, the HTTP status code is matched.
   *
   * @schema IntegrationResponseSpecForProvider#selectionPattern
   */
  readonly selectionPattern?: string;

  /**
   * HTTP status code.
   *
   * @schema IntegrationResponseSpecForProvider#statusCode
   */
  readonly statusCode?: string;

  /**
   * Reference to a MethodResponse in apigateway to populate statusCode.
   *
   * @schema IntegrationResponseSpecForProvider#statusCodeRef
   */
  readonly statusCodeRef?: IntegrationResponseSpecForProviderStatusCodeRef;

  /**
   * Selector for a MethodResponse in apigateway to populate statusCode.
   *
   * @schema IntegrationResponseSpecForProvider#statusCodeSelector
   */
  readonly statusCodeSelector?: IntegrationResponseSpecForProviderStatusCodeSelector;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProvider(obj: IntegrationResponseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentHandling': obj.contentHandling,
    'httpMethod': obj.httpMethod,
    'httpMethodRef': toJson_IntegrationResponseSpecForProviderHttpMethodRef(obj.httpMethodRef),
    'httpMethodSelector': toJson_IntegrationResponseSpecForProviderHttpMethodSelector(obj.httpMethodSelector),
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_IntegrationResponseSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_IntegrationResponseSpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'responseParameters': ((obj.responseParameters) === undefined) ? undefined : (Object.entries(obj.responseParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseTemplates': ((obj.responseTemplates) === undefined) ? undefined : (Object.entries(obj.responseTemplates).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_IntegrationResponseSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_IntegrationResponseSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'selectionPattern': obj.selectionPattern,
    'statusCode': obj.statusCode,
    'statusCodeRef': toJson_IntegrationResponseSpecForProviderStatusCodeRef(obj.statusCodeRef),
    'statusCodeSelector': toJson_IntegrationResponseSpecForProviderStatusCodeSelector(obj.statusCodeSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema IntegrationResponseSpecManagementPolicy
 */
export enum IntegrationResponseSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IntegrationResponseSpecProviderConfigRef
 */
export interface IntegrationResponseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecProviderConfigRef#policy
   */
  readonly policy?: IntegrationResponseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderConfigRef(obj: IntegrationResponseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IntegrationResponseSpecProviderRef
 */
export interface IntegrationResponseSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecProviderRef#policy
   */
  readonly policy?: IntegrationResponseSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderRef(obj: IntegrationResponseSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsTo
 */
export interface IntegrationResponseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IntegrationResponseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IntegrationResponseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsTo(obj: IntegrationResponseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IntegrationResponseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IntegrationResponseSpecWriteConnectionSecretToRef
 */
export interface IntegrationResponseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IntegrationResponseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IntegrationResponseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecWriteConnectionSecretToRef(obj: IntegrationResponseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Method in apigateway to populate httpMethod.
 *
 * @schema IntegrationResponseSpecForProviderHttpMethodRef
 */
export interface IntegrationResponseSpecForProviderHttpMethodRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecForProviderHttpMethodRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecForProviderHttpMethodRef#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderHttpMethodRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderHttpMethodRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderHttpMethodRef(obj: IntegrationResponseSpecForProviderHttpMethodRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecForProviderHttpMethodRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Method in apigateway to populate httpMethod.
 *
 * @schema IntegrationResponseSpecForProviderHttpMethodSelector
 */
export interface IntegrationResponseSpecForProviderHttpMethodSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationResponseSpecForProviderHttpMethodSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationResponseSpecForProviderHttpMethodSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationResponseSpecForProviderHttpMethodSelector#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderHttpMethodSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderHttpMethodSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderHttpMethodSelector(obj: IntegrationResponseSpecForProviderHttpMethodSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationResponseSpecForProviderHttpMethodSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Resource in apigateway to populate resourceId.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdRef
 */
export interface IntegrationResponseSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdRef#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderResourceIdRef(obj: IntegrationResponseSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Resource in apigateway to populate resourceId.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdSelector
 */
export interface IntegrationResponseSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderResourceIdSelector(obj: IntegrationResponseSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationResponseSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdRef
 */
export interface IntegrationResponseSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderRestApiIdRef(obj: IntegrationResponseSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdSelector
 */
export interface IntegrationResponseSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderRestApiIdSelector(obj: IntegrationResponseSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationResponseSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a MethodResponse in apigateway to populate statusCode.
 *
 * @schema IntegrationResponseSpecForProviderStatusCodeRef
 */
export interface IntegrationResponseSpecForProviderStatusCodeRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecForProviderStatusCodeRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecForProviderStatusCodeRef#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderStatusCodeRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderStatusCodeRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderStatusCodeRef(obj: IntegrationResponseSpecForProviderStatusCodeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecForProviderStatusCodeRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a MethodResponse in apigateway to populate statusCode.
 *
 * @schema IntegrationResponseSpecForProviderStatusCodeSelector
 */
export interface IntegrationResponseSpecForProviderStatusCodeSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IntegrationResponseSpecForProviderStatusCodeSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IntegrationResponseSpecForProviderStatusCodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IntegrationResponseSpecForProviderStatusCodeSelector#policy
   */
  readonly policy?: IntegrationResponseSpecForProviderStatusCodeSelectorPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderStatusCodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderStatusCodeSelector(obj: IntegrationResponseSpecForProviderStatusCodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IntegrationResponseSpecForProviderStatusCodeSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicy
 */
export interface IntegrationResponseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderConfigRefPolicy(obj: IntegrationResponseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecProviderRefPolicy
 */
export interface IntegrationResponseSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecProviderRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecProviderRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecProviderRefPolicy(obj: IntegrationResponseSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRef(obj: IntegrationResponseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToMetadata(obj: IntegrationResponseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecForProviderHttpMethodRefPolicy
 */
export interface IntegrationResponseSpecForProviderHttpMethodRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderHttpMethodRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderHttpMethodRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderHttpMethodRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderHttpMethodRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderHttpMethodRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderHttpMethodRefPolicy(obj: IntegrationResponseSpecForProviderHttpMethodRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationResponseSpecForProviderHttpMethodSelectorPolicy
 */
export interface IntegrationResponseSpecForProviderHttpMethodSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderHttpMethodSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderHttpMethodSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderHttpMethodSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderHttpMethodSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderHttpMethodSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderHttpMethodSelectorPolicy(obj: IntegrationResponseSpecForProviderHttpMethodSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdRefPolicy
 */
export interface IntegrationResponseSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderResourceIdRefPolicy(obj: IntegrationResponseSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdSelectorPolicy
 */
export interface IntegrationResponseSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderResourceIdSelectorPolicy(obj: IntegrationResponseSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdRefPolicy
 */
export interface IntegrationResponseSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderRestApiIdRefPolicy(obj: IntegrationResponseSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdSelectorPolicy
 */
export interface IntegrationResponseSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderRestApiIdSelectorPolicy(obj: IntegrationResponseSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecForProviderStatusCodeRefPolicy
 */
export interface IntegrationResponseSpecForProviderStatusCodeRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderStatusCodeRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderStatusCodeRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderStatusCodeRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderStatusCodeRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderStatusCodeRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderStatusCodeRefPolicy(obj: IntegrationResponseSpecForProviderStatusCodeRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IntegrationResponseSpecForProviderStatusCodeSelectorPolicy
 */
export interface IntegrationResponseSpecForProviderStatusCodeSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecForProviderStatusCodeSelectorPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecForProviderStatusCodeSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecForProviderStatusCodeSelectorPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecForProviderStatusCodeSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecForProviderStatusCodeSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecForProviderStatusCodeSelectorPolicy(obj: IntegrationResponseSpecForProviderStatusCodeSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicyResolution
 */
export enum IntegrationResponseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecProviderConfigRefPolicyResolve
 */
export enum IntegrationResponseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecProviderRefPolicyResolution
 */
export enum IntegrationResponseSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecProviderRefPolicyResolve
 */
export enum IntegrationResponseSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj: IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderHttpMethodRefPolicyResolution
 */
export enum IntegrationResponseSpecForProviderHttpMethodRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderHttpMethodRefPolicyResolve
 */
export enum IntegrationResponseSpecForProviderHttpMethodRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderHttpMethodSelectorPolicyResolution
 */
export enum IntegrationResponseSpecForProviderHttpMethodSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderHttpMethodSelectorPolicyResolve
 */
export enum IntegrationResponseSpecForProviderHttpMethodSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdRefPolicyResolution
 */
export enum IntegrationResponseSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdRefPolicyResolve
 */
export enum IntegrationResponseSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum IntegrationResponseSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdRefPolicyResolution
 */
export enum IntegrationResponseSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdRefPolicyResolve
 */
export enum IntegrationResponseSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum IntegrationResponseSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderStatusCodeRefPolicyResolution
 */
export enum IntegrationResponseSpecForProviderStatusCodeRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderStatusCodeRefPolicyResolve
 */
export enum IntegrationResponseSpecForProviderStatusCodeRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecForProviderStatusCodeSelectorPolicyResolution
 */
export enum IntegrationResponseSpecForProviderStatusCodeSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecForProviderStatusCodeSelectorPolicyResolve
 */
export enum IntegrationResponseSpecForProviderStatusCodeSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IntegrationResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Method is the Schema for the Methods API. Provides a HTTP Method for an API Gateway Resource.
 *
 * @schema Method
 */
export class Method extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Method"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'Method',
  }

  /**
   * Renders a Kubernetes manifest for "Method".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MethodProps): any {
    return {
      ...Method.GVK,
      ...toJson_MethodProps(props),
    };
  }

  /**
   * Defines a "Method" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MethodProps) {
    super(scope, id, {
      ...Method.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Method.GVK,
      ...toJson_MethodProps(resolved),
    };
  }
}

/**
 * Method is the Schema for the Methods API. Provides a HTTP Method for an API Gateway Resource.
 *
 * @schema Method
 */
export interface MethodProps {
  /**
   * @schema Method#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MethodSpec defines the desired state of Method
   *
   * @schema Method#spec
   */
  readonly spec: MethodSpec;

}

/**
 * Converts an object of type 'MethodProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodProps(obj: MethodProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MethodSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MethodSpec defines the desired state of Method
 *
 * @schema MethodSpec
 */
export interface MethodSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MethodSpec#deletionPolicy
   */
  readonly deletionPolicy?: MethodSpecDeletionPolicy;

  /**
   * @schema MethodSpec#forProvider
   */
  readonly forProvider: MethodSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MethodSpec#managementPolicy
   */
  readonly managementPolicy?: MethodSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MethodSpec#providerConfigRef
   */
  readonly providerConfigRef?: MethodSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MethodSpec#providerRef
   */
  readonly providerRef?: MethodSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MethodSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MethodSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MethodSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MethodSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MethodSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpec(obj: MethodSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MethodSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MethodSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MethodSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MethodSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MethodSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MethodSpecDeletionPolicy
 */
export enum MethodSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MethodSpecForProvider
 */
export interface MethodSpecForProvider {
  /**
   * Specify if the method requires an API key
   *
   * @schema MethodSpecForProvider#apiKeyRequired
   */
  readonly apiKeyRequired?: boolean;

  /**
   * Type of authorization used for the method (NONE, CUSTOM, AWS_IAM, COGNITO_USER_POOLS)
   *
   * @schema MethodSpecForProvider#authorization
   */
  readonly authorization?: string;

  /**
   * Authorization scopes used when the authorization is COGNITO_USER_POOLS
   *
   * @schema MethodSpecForProvider#authorizationScopes
   */
  readonly authorizationScopes?: string[];

  /**
   * Authorizer id to be used when the authorization is CUSTOM or COGNITO_USER_POOLS
   *
   * @schema MethodSpecForProvider#authorizerId
   */
  readonly authorizerId?: string;

  /**
   * Reference to a Authorizer in apigateway to populate authorizerId.
   *
   * @schema MethodSpecForProvider#authorizerIdRef
   */
  readonly authorizerIdRef?: MethodSpecForProviderAuthorizerIdRef;

  /**
   * Selector for a Authorizer in apigateway to populate authorizerId.
   *
   * @schema MethodSpecForProvider#authorizerIdSelector
   */
  readonly authorizerIdSelector?: MethodSpecForProviderAuthorizerIdSelector;

  /**
   * HTTP Method (GET, POST, PUT, DELETE, HEAD, OPTIONS, ANY)
   *
   * @schema MethodSpecForProvider#httpMethod
   */
  readonly httpMethod?: string;

  /**
   * Function name that will be given to the method when generating an SDK through API Gateway. If omitted, API Gateway will generate a function name based on the resource path and HTTP verb.
   *
   * @schema MethodSpecForProvider#operationName
   */
  readonly operationName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MethodSpecForProvider#region
   */
  readonly region: string;

  /**
   * Map of the API models used for the request's content type where key is the content type (e.g., application/json) and value is either Error, Empty (built-in models) or aws_api_gateway_model's name.
   *
   * @schema MethodSpecForProvider#requestModels
   */
  readonly requestModels?: { [key: string]: string };

  /**
   * Map of request parameters (from the path, query string and headers) that should be passed to the integration. The boolean value indicates whether the parameter is required (true) or optional (false). For example: request_parameters = {"method.request.header.X-Some-Header" = true "method.request.querystring.some-query-param" = true} would define that the header X-Some-Header and the query string some-query-param must be provided in the request.
   *
   * @schema MethodSpecForProvider#requestParameters
   */
  readonly requestParameters?: { [key: string]: boolean };

  /**
   * ID of a aws_api_gateway_request_validator
   *
   * @schema MethodSpecForProvider#requestValidatorId
   */
  readonly requestValidatorId?: string;

  /**
   * API resource ID
   *
   * @schema MethodSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a Resource in apigateway to populate resourceId.
   *
   * @schema MethodSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: MethodSpecForProviderResourceIdRef;

  /**
   * Selector for a Resource in apigateway to populate resourceId.
   *
   * @schema MethodSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: MethodSpecForProviderResourceIdSelector;

  /**
   * ID of the associated REST API
   *
   * @schema MethodSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema MethodSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: MethodSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema MethodSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: MethodSpecForProviderRestApiIdSelector;

}

/**
 * Converts an object of type 'MethodSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProvider(obj: MethodSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeyRequired': obj.apiKeyRequired,
    'authorization': obj.authorization,
    'authorizationScopes': obj.authorizationScopes?.map(y => y),
    'authorizerId': obj.authorizerId,
    'authorizerIdRef': toJson_MethodSpecForProviderAuthorizerIdRef(obj.authorizerIdRef),
    'authorizerIdSelector': toJson_MethodSpecForProviderAuthorizerIdSelector(obj.authorizerIdSelector),
    'httpMethod': obj.httpMethod,
    'operationName': obj.operationName,
    'region': obj.region,
    'requestModels': ((obj.requestModels) === undefined) ? undefined : (Object.entries(obj.requestModels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requestParameters': ((obj.requestParameters) === undefined) ? undefined : (Object.entries(obj.requestParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'requestValidatorId': obj.requestValidatorId,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_MethodSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_MethodSpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_MethodSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_MethodSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MethodSpecManagementPolicy
 */
export enum MethodSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MethodSpecProviderConfigRef
 */
export interface MethodSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecProviderConfigRef#policy
   */
  readonly policy?: MethodSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecProviderConfigRef(obj: MethodSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MethodSpecProviderRef
 */
export interface MethodSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecProviderRef#policy
   */
  readonly policy?: MethodSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecProviderRef(obj: MethodSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MethodSpecPublishConnectionDetailsTo
 */
export interface MethodSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MethodSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MethodSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MethodSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MethodSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MethodSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MethodSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecPublishConnectionDetailsTo(obj: MethodSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MethodSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MethodSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MethodSpecWriteConnectionSecretToRef
 */
export interface MethodSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MethodSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MethodSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MethodSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecWriteConnectionSecretToRef(obj: MethodSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Authorizer in apigateway to populate authorizerId.
 *
 * @schema MethodSpecForProviderAuthorizerIdRef
 */
export interface MethodSpecForProviderAuthorizerIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecForProviderAuthorizerIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecForProviderAuthorizerIdRef#policy
   */
  readonly policy?: MethodSpecForProviderAuthorizerIdRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderAuthorizerIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderAuthorizerIdRef(obj: MethodSpecForProviderAuthorizerIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecForProviderAuthorizerIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Authorizer in apigateway to populate authorizerId.
 *
 * @schema MethodSpecForProviderAuthorizerIdSelector
 */
export interface MethodSpecForProviderAuthorizerIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodSpecForProviderAuthorizerIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodSpecForProviderAuthorizerIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodSpecForProviderAuthorizerIdSelector#policy
   */
  readonly policy?: MethodSpecForProviderAuthorizerIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderAuthorizerIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderAuthorizerIdSelector(obj: MethodSpecForProviderAuthorizerIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodSpecForProviderAuthorizerIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Resource in apigateway to populate resourceId.
 *
 * @schema MethodSpecForProviderResourceIdRef
 */
export interface MethodSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecForProviderResourceIdRef#policy
   */
  readonly policy?: MethodSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderResourceIdRef(obj: MethodSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Resource in apigateway to populate resourceId.
 *
 * @schema MethodSpecForProviderResourceIdSelector
 */
export interface MethodSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: MethodSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderResourceIdSelector(obj: MethodSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema MethodSpecForProviderRestApiIdRef
 */
export interface MethodSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: MethodSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRestApiIdRef(obj: MethodSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema MethodSpecForProviderRestApiIdSelector
 */
export interface MethodSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: MethodSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRestApiIdSelector(obj: MethodSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSpecProviderConfigRefPolicy
 */
export interface MethodSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MethodSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MethodSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecProviderConfigRefPolicy(obj: MethodSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSpecProviderRefPolicy
 */
export interface MethodSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MethodSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MethodSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecProviderRefPolicy(obj: MethodSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MethodSpecPublishConnectionDetailsToConfigRef
 */
export interface MethodSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MethodSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MethodSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecPublishConnectionDetailsToConfigRef(obj: MethodSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MethodSpecPublishConnectionDetailsToMetadata
 */
export interface MethodSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MethodSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MethodSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MethodSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MethodSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecPublishConnectionDetailsToMetadata(obj: MethodSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSpecForProviderAuthorizerIdRefPolicy
 */
export interface MethodSpecForProviderAuthorizerIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderAuthorizerIdRefPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderAuthorizerIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderAuthorizerIdRefPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderAuthorizerIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderAuthorizerIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderAuthorizerIdRefPolicy(obj: MethodSpecForProviderAuthorizerIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodSpecForProviderAuthorizerIdSelectorPolicy
 */
export interface MethodSpecForProviderAuthorizerIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderAuthorizerIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderAuthorizerIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderAuthorizerIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderAuthorizerIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderAuthorizerIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderAuthorizerIdSelectorPolicy(obj: MethodSpecForProviderAuthorizerIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSpecForProviderResourceIdRefPolicy
 */
export interface MethodSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderResourceIdRefPolicy(obj: MethodSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodSpecForProviderResourceIdSelectorPolicy
 */
export interface MethodSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderResourceIdSelectorPolicy(obj: MethodSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSpecForProviderRestApiIdRefPolicy
 */
export interface MethodSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRestApiIdRefPolicy(obj: MethodSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodSpecForProviderRestApiIdSelectorPolicy
 */
export interface MethodSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecForProviderRestApiIdSelectorPolicy(obj: MethodSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecProviderConfigRefPolicyResolution
 */
export enum MethodSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecProviderConfigRefPolicyResolve
 */
export enum MethodSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecProviderRefPolicyResolution
 */
export enum MethodSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecProviderRefPolicyResolve
 */
export enum MethodSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MethodSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MethodSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MethodSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MethodSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSpecPublishConnectionDetailsToConfigRefPolicy(obj: MethodSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderAuthorizerIdRefPolicyResolution
 */
export enum MethodSpecForProviderAuthorizerIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderAuthorizerIdRefPolicyResolve
 */
export enum MethodSpecForProviderAuthorizerIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderAuthorizerIdSelectorPolicyResolution
 */
export enum MethodSpecForProviderAuthorizerIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderAuthorizerIdSelectorPolicyResolve
 */
export enum MethodSpecForProviderAuthorizerIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderResourceIdRefPolicyResolution
 */
export enum MethodSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderResourceIdRefPolicyResolve
 */
export enum MethodSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum MethodSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum MethodSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderRestApiIdRefPolicyResolution
 */
export enum MethodSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderRestApiIdRefPolicyResolve
 */
export enum MethodSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum MethodSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum MethodSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MethodSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MethodSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MethodResponse is the Schema for the MethodResponses API. Provides an HTTP Method Response for an API Gateway Resource.
 *
 * @schema MethodResponse
 */
export class MethodResponse extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MethodResponse"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'MethodResponse',
  }

  /**
   * Renders a Kubernetes manifest for "MethodResponse".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MethodResponseProps): any {
    return {
      ...MethodResponse.GVK,
      ...toJson_MethodResponseProps(props),
    };
  }

  /**
   * Defines a "MethodResponse" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MethodResponseProps) {
    super(scope, id, {
      ...MethodResponse.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MethodResponse.GVK,
      ...toJson_MethodResponseProps(resolved),
    };
  }
}

/**
 * MethodResponse is the Schema for the MethodResponses API. Provides an HTTP Method Response for an API Gateway Resource.
 *
 * @schema MethodResponse
 */
export interface MethodResponseProps {
  /**
   * @schema MethodResponse#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MethodResponseSpec defines the desired state of MethodResponse
   *
   * @schema MethodResponse#spec
   */
  readonly spec: MethodResponseSpec;

}

/**
 * Converts an object of type 'MethodResponseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseProps(obj: MethodResponseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MethodResponseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MethodResponseSpec defines the desired state of MethodResponse
 *
 * @schema MethodResponseSpec
 */
export interface MethodResponseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MethodResponseSpec#deletionPolicy
   */
  readonly deletionPolicy?: MethodResponseSpecDeletionPolicy;

  /**
   * @schema MethodResponseSpec#forProvider
   */
  readonly forProvider: MethodResponseSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MethodResponseSpec#managementPolicy
   */
  readonly managementPolicy?: MethodResponseSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MethodResponseSpec#providerConfigRef
   */
  readonly providerConfigRef?: MethodResponseSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MethodResponseSpec#providerRef
   */
  readonly providerRef?: MethodResponseSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MethodResponseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MethodResponseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MethodResponseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MethodResponseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MethodResponseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpec(obj: MethodResponseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MethodResponseSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MethodResponseSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MethodResponseSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MethodResponseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MethodResponseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MethodResponseSpecDeletionPolicy
 */
export enum MethodResponseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MethodResponseSpecForProvider
 */
export interface MethodResponseSpecForProvider {
  /**
   * HTTP Method (GET, POST, PUT, DELETE, HEAD, OPTIONS, ANY)
   *
   * @schema MethodResponseSpecForProvider#httpMethod
   */
  readonly httpMethod?: string;

  /**
   * Reference to a Method in apigateway to populate httpMethod.
   *
   * @schema MethodResponseSpecForProvider#httpMethodRef
   */
  readonly httpMethodRef?: MethodResponseSpecForProviderHttpMethodRef;

  /**
   * Selector for a Method in apigateway to populate httpMethod.
   *
   * @schema MethodResponseSpecForProvider#httpMethodSelector
   */
  readonly httpMethodSelector?: MethodResponseSpecForProviderHttpMethodSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MethodResponseSpecForProvider#region
   */
  readonly region: string;

  /**
   * API resource ID
   *
   * @schema MethodResponseSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a Resource in apigateway to populate resourceId.
   *
   * @schema MethodResponseSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: MethodResponseSpecForProviderResourceIdRef;

  /**
   * Selector for a Resource in apigateway to populate resourceId.
   *
   * @schema MethodResponseSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: MethodResponseSpecForProviderResourceIdSelector;

  /**
   * Map of the API models used for the response's content type
   *
   * @schema MethodResponseSpecForProvider#responseModels
   */
  readonly responseModels?: { [key: string]: string };

  /**
   * Map of response parameters that can be sent to the caller. For example: response_parameters = { "method.response.header.X-Some-Header" = true } would define that the header X-Some-Header can be provided on the response.
   *
   * @schema MethodResponseSpecForProvider#responseParameters
   */
  readonly responseParameters?: { [key: string]: boolean };

  /**
   * ID of the associated REST API
   *
   * @schema MethodResponseSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema MethodResponseSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: MethodResponseSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema MethodResponseSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: MethodResponseSpecForProviderRestApiIdSelector;

  /**
   * HTTP status code
   *
   * @schema MethodResponseSpecForProvider#statusCode
   */
  readonly statusCode?: string;

}

/**
 * Converts an object of type 'MethodResponseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProvider(obj: MethodResponseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpMethod': obj.httpMethod,
    'httpMethodRef': toJson_MethodResponseSpecForProviderHttpMethodRef(obj.httpMethodRef),
    'httpMethodSelector': toJson_MethodResponseSpecForProviderHttpMethodSelector(obj.httpMethodSelector),
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_MethodResponseSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_MethodResponseSpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'responseModels': ((obj.responseModels) === undefined) ? undefined : (Object.entries(obj.responseModels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'responseParameters': ((obj.responseParameters) === undefined) ? undefined : (Object.entries(obj.responseParameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_MethodResponseSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_MethodResponseSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MethodResponseSpecManagementPolicy
 */
export enum MethodResponseSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MethodResponseSpecProviderConfigRef
 */
export interface MethodResponseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodResponseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodResponseSpecProviderConfigRef#policy
   */
  readonly policy?: MethodResponseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecProviderConfigRef(obj: MethodResponseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodResponseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MethodResponseSpecProviderRef
 */
export interface MethodResponseSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodResponseSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodResponseSpecProviderRef#policy
   */
  readonly policy?: MethodResponseSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecProviderRef(obj: MethodResponseSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodResponseSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsTo
 */
export interface MethodResponseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MethodResponseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MethodResponseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MethodResponseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecPublishConnectionDetailsTo(obj: MethodResponseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MethodResponseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MethodResponseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MethodResponseSpecWriteConnectionSecretToRef
 */
export interface MethodResponseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MethodResponseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MethodResponseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MethodResponseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecWriteConnectionSecretToRef(obj: MethodResponseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Method in apigateway to populate httpMethod.
 *
 * @schema MethodResponseSpecForProviderHttpMethodRef
 */
export interface MethodResponseSpecForProviderHttpMethodRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodResponseSpecForProviderHttpMethodRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodResponseSpecForProviderHttpMethodRef#policy
   */
  readonly policy?: MethodResponseSpecForProviderHttpMethodRefPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderHttpMethodRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderHttpMethodRef(obj: MethodResponseSpecForProviderHttpMethodRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodResponseSpecForProviderHttpMethodRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Method in apigateway to populate httpMethod.
 *
 * @schema MethodResponseSpecForProviderHttpMethodSelector
 */
export interface MethodResponseSpecForProviderHttpMethodSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodResponseSpecForProviderHttpMethodSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodResponseSpecForProviderHttpMethodSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodResponseSpecForProviderHttpMethodSelector#policy
   */
  readonly policy?: MethodResponseSpecForProviderHttpMethodSelectorPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderHttpMethodSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderHttpMethodSelector(obj: MethodResponseSpecForProviderHttpMethodSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodResponseSpecForProviderHttpMethodSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Resource in apigateway to populate resourceId.
 *
 * @schema MethodResponseSpecForProviderResourceIdRef
 */
export interface MethodResponseSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodResponseSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodResponseSpecForProviderResourceIdRef#policy
   */
  readonly policy?: MethodResponseSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderResourceIdRef(obj: MethodResponseSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodResponseSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Resource in apigateway to populate resourceId.
 *
 * @schema MethodResponseSpecForProviderResourceIdSelector
 */
export interface MethodResponseSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodResponseSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodResponseSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodResponseSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: MethodResponseSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderResourceIdSelector(obj: MethodResponseSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodResponseSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema MethodResponseSpecForProviderRestApiIdRef
 */
export interface MethodResponseSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodResponseSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodResponseSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: MethodResponseSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderRestApiIdRef(obj: MethodResponseSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodResponseSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema MethodResponseSpecForProviderRestApiIdSelector
 */
export interface MethodResponseSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodResponseSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodResponseSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodResponseSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: MethodResponseSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderRestApiIdSelector(obj: MethodResponseSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodResponseSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodResponseSpecProviderConfigRefPolicy
 */
export interface MethodResponseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecProviderConfigRefPolicy(obj: MethodResponseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodResponseSpecProviderRefPolicy
 */
export interface MethodResponseSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecProviderRefPolicy(obj: MethodResponseSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsToConfigRef
 */
export interface MethodResponseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MethodResponseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecPublishConnectionDetailsToConfigRef(obj: MethodResponseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsToMetadata
 */
export interface MethodResponseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MethodResponseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecPublishConnectionDetailsToMetadata(obj: MethodResponseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodResponseSpecForProviderHttpMethodRefPolicy
 */
export interface MethodResponseSpecForProviderHttpMethodRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecForProviderHttpMethodRefPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecForProviderHttpMethodRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecForProviderHttpMethodRefPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecForProviderHttpMethodRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderHttpMethodRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderHttpMethodRefPolicy(obj: MethodResponseSpecForProviderHttpMethodRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodResponseSpecForProviderHttpMethodSelectorPolicy
 */
export interface MethodResponseSpecForProviderHttpMethodSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecForProviderHttpMethodSelectorPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecForProviderHttpMethodSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecForProviderHttpMethodSelectorPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecForProviderHttpMethodSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderHttpMethodSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderHttpMethodSelectorPolicy(obj: MethodResponseSpecForProviderHttpMethodSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodResponseSpecForProviderResourceIdRefPolicy
 */
export interface MethodResponseSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderResourceIdRefPolicy(obj: MethodResponseSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodResponseSpecForProviderResourceIdSelectorPolicy
 */
export interface MethodResponseSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderResourceIdSelectorPolicy(obj: MethodResponseSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodResponseSpecForProviderRestApiIdRefPolicy
 */
export interface MethodResponseSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderRestApiIdRefPolicy(obj: MethodResponseSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodResponseSpecForProviderRestApiIdSelectorPolicy
 */
export interface MethodResponseSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecForProviderRestApiIdSelectorPolicy(obj: MethodResponseSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecProviderConfigRefPolicyResolution
 */
export enum MethodResponseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecProviderConfigRefPolicyResolve
 */
export enum MethodResponseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecProviderRefPolicyResolution
 */
export enum MethodResponseSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecProviderRefPolicyResolve
 */
export enum MethodResponseSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy(obj: MethodResponseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecForProviderHttpMethodRefPolicyResolution
 */
export enum MethodResponseSpecForProviderHttpMethodRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecForProviderHttpMethodRefPolicyResolve
 */
export enum MethodResponseSpecForProviderHttpMethodRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecForProviderHttpMethodSelectorPolicyResolution
 */
export enum MethodResponseSpecForProviderHttpMethodSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecForProviderHttpMethodSelectorPolicyResolve
 */
export enum MethodResponseSpecForProviderHttpMethodSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecForProviderResourceIdRefPolicyResolution
 */
export enum MethodResponseSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecForProviderResourceIdRefPolicyResolve
 */
export enum MethodResponseSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum MethodResponseSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum MethodResponseSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecForProviderRestApiIdRefPolicyResolution
 */
export enum MethodResponseSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecForProviderRestApiIdRefPolicyResolve
 */
export enum MethodResponseSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum MethodResponseSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum MethodResponseSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MethodResponseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MethodSettings is the Schema for the MethodSettingss API. Manages API Gateway Stage Method Settings
 *
 * @schema MethodSettings
 */
export class MethodSettings extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MethodSettings"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'MethodSettings',
  }

  /**
   * Renders a Kubernetes manifest for "MethodSettings".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MethodSettingsProps): any {
    return {
      ...MethodSettings.GVK,
      ...toJson_MethodSettingsProps(props),
    };
  }

  /**
   * Defines a "MethodSettings" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MethodSettingsProps) {
    super(scope, id, {
      ...MethodSettings.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MethodSettings.GVK,
      ...toJson_MethodSettingsProps(resolved),
    };
  }
}

/**
 * MethodSettings is the Schema for the MethodSettingss API. Manages API Gateway Stage Method Settings
 *
 * @schema MethodSettings
 */
export interface MethodSettingsProps {
  /**
   * @schema MethodSettings#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MethodSettingsSpec defines the desired state of MethodSettings
   *
   * @schema MethodSettings#spec
   */
  readonly spec: MethodSettingsSpec;

}

/**
 * Converts an object of type 'MethodSettingsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsProps(obj: MethodSettingsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MethodSettingsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MethodSettingsSpec defines the desired state of MethodSettings
 *
 * @schema MethodSettingsSpec
 */
export interface MethodSettingsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MethodSettingsSpec#deletionPolicy
   */
  readonly deletionPolicy?: MethodSettingsSpecDeletionPolicy;

  /**
   * @schema MethodSettingsSpec#forProvider
   */
  readonly forProvider: MethodSettingsSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MethodSettingsSpec#managementPolicy
   */
  readonly managementPolicy?: MethodSettingsSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MethodSettingsSpec#providerConfigRef
   */
  readonly providerConfigRef?: MethodSettingsSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MethodSettingsSpec#providerRef
   */
  readonly providerRef?: MethodSettingsSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MethodSettingsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MethodSettingsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MethodSettingsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MethodSettingsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MethodSettingsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpec(obj: MethodSettingsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MethodSettingsSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MethodSettingsSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MethodSettingsSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MethodSettingsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MethodSettingsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MethodSettingsSpecDeletionPolicy
 */
export enum MethodSettingsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MethodSettingsSpecForProvider
 */
export interface MethodSettingsSpecForProvider {
  /**
   * Method path defined as {resource_path}/{http_method} for an individual method override, or _/* for overriding all methods in the stage. Ensure to trim any leading forward slashes in the path (e.g., trimprefix(aws_api_gateway_resource.example.path, "/")).
   *
   * @schema MethodSettingsSpecForProvider#methodPath
   */
  readonly methodPath?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MethodSettingsSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the REST API
   *
   * @schema MethodSettingsSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema MethodSettingsSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: MethodSettingsSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema MethodSettingsSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: MethodSettingsSpecForProviderRestApiIdSelector;

  /**
   * Settings block, see below.
   *
   * @schema MethodSettingsSpecForProvider#settings
   */
  readonly settings?: MethodSettingsSpecForProviderSettings[];

  /**
   * Name of the stage
   *
   * @schema MethodSettingsSpecForProvider#stageName
   */
  readonly stageName?: string;

  /**
   * Reference to a Stage in apigateway to populate stageName.
   *
   * @schema MethodSettingsSpecForProvider#stageNameRef
   */
  readonly stageNameRef?: MethodSettingsSpecForProviderStageNameRef;

  /**
   * Selector for a Stage in apigateway to populate stageName.
   *
   * @schema MethodSettingsSpecForProvider#stageNameSelector
   */
  readonly stageNameSelector?: MethodSettingsSpecForProviderStageNameSelector;

}

/**
 * Converts an object of type 'MethodSettingsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecForProvider(obj: MethodSettingsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'methodPath': obj.methodPath,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_MethodSettingsSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_MethodSettingsSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'settings': obj.settings?.map(y => toJson_MethodSettingsSpecForProviderSettings(y)),
    'stageName': obj.stageName,
    'stageNameRef': toJson_MethodSettingsSpecForProviderStageNameRef(obj.stageNameRef),
    'stageNameSelector': toJson_MethodSettingsSpecForProviderStageNameSelector(obj.stageNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MethodSettingsSpecManagementPolicy
 */
export enum MethodSettingsSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MethodSettingsSpecProviderConfigRef
 */
export interface MethodSettingsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSettingsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSettingsSpecProviderConfigRef#policy
   */
  readonly policy?: MethodSettingsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MethodSettingsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecProviderConfigRef(obj: MethodSettingsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSettingsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MethodSettingsSpecProviderRef
 */
export interface MethodSettingsSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSettingsSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSettingsSpecProviderRef#policy
   */
  readonly policy?: MethodSettingsSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MethodSettingsSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecProviderRef(obj: MethodSettingsSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSettingsSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MethodSettingsSpecPublishConnectionDetailsTo
 */
export interface MethodSettingsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MethodSettingsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MethodSettingsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MethodSettingsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MethodSettingsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MethodSettingsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MethodSettingsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecPublishConnectionDetailsTo(obj: MethodSettingsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MethodSettingsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MethodSettingsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MethodSettingsSpecWriteConnectionSecretToRef
 */
export interface MethodSettingsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MethodSettingsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MethodSettingsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MethodSettingsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecWriteConnectionSecretToRef(obj: MethodSettingsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema MethodSettingsSpecForProviderRestApiIdRef
 */
export interface MethodSettingsSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSettingsSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSettingsSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: MethodSettingsSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'MethodSettingsSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecForProviderRestApiIdRef(obj: MethodSettingsSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSettingsSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema MethodSettingsSpecForProviderRestApiIdSelector
 */
export interface MethodSettingsSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodSettingsSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodSettingsSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodSettingsSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: MethodSettingsSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'MethodSettingsSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecForProviderRestApiIdSelector(obj: MethodSettingsSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodSettingsSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MethodSettingsSpecForProviderSettings
 */
export interface MethodSettingsSpecForProviderSettings {
  /**
   * Whether the cached responses are encrypted.
   *
   * @schema MethodSettingsSpecForProviderSettings#cacheDataEncrypted
   */
  readonly cacheDataEncrypted?: boolean;

  /**
   * Time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.
   *
   * @schema MethodSettingsSpecForProviderSettings#cacheTtlInSeconds
   */
  readonly cacheTtlInSeconds?: number;

  /**
   * Whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.
   *
   * @schema MethodSettingsSpecForProviderSettings#cachingEnabled
   */
  readonly cachingEnabled?: boolean;

  /**
   * Whether data trace logging is enabled for this method, which effects the log entries pushed to Amazon CloudWatch Logs.
   *
   * @schema MethodSettingsSpecForProviderSettings#dataTraceEnabled
   */
  readonly dataTraceEnabled?: boolean;

  /**
   * Logging level for this method, which effects the log entries pushed to Amazon CloudWatch Logs. The available levels are OFF, ERROR, and INFO.
   *
   * @schema MethodSettingsSpecForProviderSettings#loggingLevel
   */
  readonly loggingLevel?: string;

  /**
   * Whether Amazon CloudWatch metrics are enabled for this method.
   *
   * @schema MethodSettingsSpecForProviderSettings#metricsEnabled
   */
  readonly metricsEnabled?: boolean;

  /**
   * Whether authorization is required for a cache invalidation request.
   *
   * @schema MethodSettingsSpecForProviderSettings#requireAuthorizationForCacheControl
   */
  readonly requireAuthorizationForCacheControl?: boolean;

  /**
   * Throttling burst limit. Default: -1 (throttling disabled).
   *
   * @schema MethodSettingsSpecForProviderSettings#throttlingBurstLimit
   */
  readonly throttlingBurstLimit?: number;

  /**
   * Throttling rate limit. Default: -1 (throttling disabled).
   *
   * @schema MethodSettingsSpecForProviderSettings#throttlingRateLimit
   */
  readonly throttlingRateLimit?: number;

  /**
   * How to handle unauthorized requests for cache invalidation. The available values are FAIL_WITH_403, SUCCEED_WITH_RESPONSE_HEADER, SUCCEED_WITHOUT_RESPONSE_HEADER.
   *
   * @schema MethodSettingsSpecForProviderSettings#unauthorizedCacheControlHeaderStrategy
   */
  readonly unauthorizedCacheControlHeaderStrategy?: string;

}

/**
 * Converts an object of type 'MethodSettingsSpecForProviderSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecForProviderSettings(obj: MethodSettingsSpecForProviderSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cacheDataEncrypted': obj.cacheDataEncrypted,
    'cacheTtlInSeconds': obj.cacheTtlInSeconds,
    'cachingEnabled': obj.cachingEnabled,
    'dataTraceEnabled': obj.dataTraceEnabled,
    'loggingLevel': obj.loggingLevel,
    'metricsEnabled': obj.metricsEnabled,
    'requireAuthorizationForCacheControl': obj.requireAuthorizationForCacheControl,
    'throttlingBurstLimit': obj.throttlingBurstLimit,
    'throttlingRateLimit': obj.throttlingRateLimit,
    'unauthorizedCacheControlHeaderStrategy': obj.unauthorizedCacheControlHeaderStrategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stage in apigateway to populate stageName.
 *
 * @schema MethodSettingsSpecForProviderStageNameRef
 */
export interface MethodSettingsSpecForProviderStageNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSettingsSpecForProviderStageNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSettingsSpecForProviderStageNameRef#policy
   */
  readonly policy?: MethodSettingsSpecForProviderStageNameRefPolicy;

}

/**
 * Converts an object of type 'MethodSettingsSpecForProviderStageNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecForProviderStageNameRef(obj: MethodSettingsSpecForProviderStageNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSettingsSpecForProviderStageNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stage in apigateway to populate stageName.
 *
 * @schema MethodSettingsSpecForProviderStageNameSelector
 */
export interface MethodSettingsSpecForProviderStageNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MethodSettingsSpecForProviderStageNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MethodSettingsSpecForProviderStageNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MethodSettingsSpecForProviderStageNameSelector#policy
   */
  readonly policy?: MethodSettingsSpecForProviderStageNameSelectorPolicy;

}

/**
 * Converts an object of type 'MethodSettingsSpecForProviderStageNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecForProviderStageNameSelector(obj: MethodSettingsSpecForProviderStageNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MethodSettingsSpecForProviderStageNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSettingsSpecProviderConfigRefPolicy
 */
export interface MethodSettingsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSettingsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MethodSettingsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSettingsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MethodSettingsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSettingsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecProviderConfigRefPolicy(obj: MethodSettingsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSettingsSpecProviderRefPolicy
 */
export interface MethodSettingsSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSettingsSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MethodSettingsSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSettingsSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MethodSettingsSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSettingsSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecProviderRefPolicy(obj: MethodSettingsSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MethodSettingsSpecPublishConnectionDetailsToConfigRef
 */
export interface MethodSettingsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MethodSettingsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MethodSettingsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MethodSettingsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecPublishConnectionDetailsToConfigRef(obj: MethodSettingsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MethodSettingsSpecPublishConnectionDetailsToMetadata
 */
export interface MethodSettingsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MethodSettingsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MethodSettingsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MethodSettingsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MethodSettingsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecPublishConnectionDetailsToMetadata(obj: MethodSettingsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSettingsSpecForProviderRestApiIdRefPolicy
 */
export interface MethodSettingsSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSettingsSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: MethodSettingsSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSettingsSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: MethodSettingsSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSettingsSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecForProviderRestApiIdRefPolicy(obj: MethodSettingsSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodSettingsSpecForProviderRestApiIdSelectorPolicy
 */
export interface MethodSettingsSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSettingsSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: MethodSettingsSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSettingsSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: MethodSettingsSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodSettingsSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecForProviderRestApiIdSelectorPolicy(obj: MethodSettingsSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MethodSettingsSpecForProviderStageNameRefPolicy
 */
export interface MethodSettingsSpecForProviderStageNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSettingsSpecForProviderStageNameRefPolicy#resolution
   */
  readonly resolution?: MethodSettingsSpecForProviderStageNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSettingsSpecForProviderStageNameRefPolicy#resolve
   */
  readonly resolve?: MethodSettingsSpecForProviderStageNameRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSettingsSpecForProviderStageNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecForProviderStageNameRefPolicy(obj: MethodSettingsSpecForProviderStageNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MethodSettingsSpecForProviderStageNameSelectorPolicy
 */
export interface MethodSettingsSpecForProviderStageNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSettingsSpecForProviderStageNameSelectorPolicy#resolution
   */
  readonly resolution?: MethodSettingsSpecForProviderStageNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSettingsSpecForProviderStageNameSelectorPolicy#resolve
   */
  readonly resolve?: MethodSettingsSpecForProviderStageNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MethodSettingsSpecForProviderStageNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecForProviderStageNameSelectorPolicy(obj: MethodSettingsSpecForProviderStageNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSettingsSpecProviderConfigRefPolicyResolution
 */
export enum MethodSettingsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSettingsSpecProviderConfigRefPolicyResolve
 */
export enum MethodSettingsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSettingsSpecProviderRefPolicyResolution
 */
export enum MethodSettingsSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSettingsSpecProviderRefPolicyResolve
 */
export enum MethodSettingsSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj: MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSettingsSpecForProviderRestApiIdRefPolicyResolution
 */
export enum MethodSettingsSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSettingsSpecForProviderRestApiIdRefPolicyResolve
 */
export enum MethodSettingsSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSettingsSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum MethodSettingsSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSettingsSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum MethodSettingsSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSettingsSpecForProviderStageNameRefPolicyResolution
 */
export enum MethodSettingsSpecForProviderStageNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSettingsSpecForProviderStageNameRefPolicyResolve
 */
export enum MethodSettingsSpecForProviderStageNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSettingsSpecForProviderStageNameSelectorPolicyResolution
 */
export enum MethodSettingsSpecForProviderStageNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSettingsSpecForProviderStageNameSelectorPolicyResolve
 */
export enum MethodSettingsSpecForProviderStageNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MethodSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Model is the Schema for the Models API. Provides a Model for a REST API Gateway.
 *
 * @schema Model
 */
export class Model extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Model"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'Model',
  }

  /**
   * Renders a Kubernetes manifest for "Model".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ModelProps): any {
    return {
      ...Model.GVK,
      ...toJson_ModelProps(props),
    };
  }

  /**
   * Defines a "Model" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ModelProps) {
    super(scope, id, {
      ...Model.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Model.GVK,
      ...toJson_ModelProps(resolved),
    };
  }
}

/**
 * Model is the Schema for the Models API. Provides a Model for a REST API Gateway.
 *
 * @schema Model
 */
export interface ModelProps {
  /**
   * @schema Model#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ModelSpec defines the desired state of Model
   *
   * @schema Model#spec
   */
  readonly spec: ModelSpec;

}

/**
 * Converts an object of type 'ModelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelProps(obj: ModelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ModelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ModelSpec defines the desired state of Model
 *
 * @schema ModelSpec
 */
export interface ModelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ModelSpec#deletionPolicy
   */
  readonly deletionPolicy?: ModelSpecDeletionPolicy;

  /**
   * @schema ModelSpec#forProvider
   */
  readonly forProvider: ModelSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ModelSpec#managementPolicy
   */
  readonly managementPolicy?: ModelSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ModelSpec#providerConfigRef
   */
  readonly providerConfigRef?: ModelSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ModelSpec#providerRef
   */
  readonly providerRef?: ModelSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ModelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ModelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ModelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ModelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ModelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpec(obj: ModelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ModelSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ModelSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ModelSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ModelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ModelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ModelSpecDeletionPolicy
 */
export enum ModelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ModelSpecForProvider
 */
export interface ModelSpecForProvider {
  /**
   * Content type of the model
   *
   * @schema ModelSpecForProvider#contentType
   */
  readonly contentType?: string;

  /**
   * Description of the model
   *
   * @schema ModelSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Name of the model
   *
   * @schema ModelSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ModelSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the associated REST API
   *
   * @schema ModelSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema ModelSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: ModelSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema ModelSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: ModelSpecForProviderRestApiIdSelector;

  /**
   * Schema of the model in a JSON form
   *
   * @schema ModelSpecForProvider#schema
   */
  readonly schema?: string;

}

/**
 * Converts an object of type 'ModelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProvider(obj: ModelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentType': obj.contentType,
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_ModelSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_ModelSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'schema': obj.schema,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ModelSpecManagementPolicy
 */
export enum ModelSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ModelSpecProviderConfigRef
 */
export interface ModelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecProviderConfigRef#policy
   */
  readonly policy?: ModelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderConfigRef(obj: ModelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ModelSpecProviderRef
 */
export interface ModelSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecProviderRef#policy
   */
  readonly policy?: ModelSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderRef(obj: ModelSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ModelSpecPublishConnectionDetailsTo
 */
export interface ModelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ModelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ModelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ModelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsTo(obj: ModelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ModelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ModelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ModelSpecWriteConnectionSecretToRef
 */
export interface ModelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ModelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ModelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ModelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecWriteConnectionSecretToRef(obj: ModelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema ModelSpecForProviderRestApiIdRef
 */
export interface ModelSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: ModelSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderRestApiIdRef(obj: ModelSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema ModelSpecForProviderRestApiIdSelector
 */
export interface ModelSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ModelSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ModelSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ModelSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: ModelSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'ModelSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderRestApiIdSelector(obj: ModelSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ModelSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecProviderConfigRefPolicy
 */
export interface ModelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ModelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ModelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderConfigRefPolicy(obj: ModelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecProviderRefPolicy
 */
export interface ModelSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ModelSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ModelSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecProviderRefPolicy(obj: ModelSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRef
 */
export interface ModelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ModelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToConfigRef(obj: ModelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ModelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ModelSpecPublishConnectionDetailsToMetadata
 */
export interface ModelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ModelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToMetadata(obj: ModelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ModelSpecForProviderRestApiIdRefPolicy
 */
export interface ModelSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: ModelSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: ModelSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderRestApiIdRefPolicy(obj: ModelSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ModelSpecForProviderRestApiIdSelectorPolicy
 */
export interface ModelSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: ModelSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: ModelSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecForProviderRestApiIdSelectorPolicy(obj: ModelSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecProviderConfigRefPolicyResolution
 */
export enum ModelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecProviderConfigRefPolicyResolve
 */
export enum ModelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecProviderRefPolicyResolution
 */
export enum ModelSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecProviderRefPolicyResolve
 */
export enum ModelSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ModelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ModelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ModelSpecPublishConnectionDetailsToConfigRefPolicy(obj: ModelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecForProviderRestApiIdRefPolicyResolution
 */
export enum ModelSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecForProviderRestApiIdRefPolicyResolve
 */
export enum ModelSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum ModelSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum ModelSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ModelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ModelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RequestValidator is the Schema for the RequestValidators API. Manages an API Gateway Request Validator.
 *
 * @schema RequestValidator
 */
export class RequestValidator extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RequestValidator"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'RequestValidator',
  }

  /**
   * Renders a Kubernetes manifest for "RequestValidator".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RequestValidatorProps): any {
    return {
      ...RequestValidator.GVK,
      ...toJson_RequestValidatorProps(props),
    };
  }

  /**
   * Defines a "RequestValidator" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RequestValidatorProps) {
    super(scope, id, {
      ...RequestValidator.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RequestValidator.GVK,
      ...toJson_RequestValidatorProps(resolved),
    };
  }
}

/**
 * RequestValidator is the Schema for the RequestValidators API. Manages an API Gateway Request Validator.
 *
 * @schema RequestValidator
 */
export interface RequestValidatorProps {
  /**
   * @schema RequestValidator#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RequestValidatorSpec defines the desired state of RequestValidator
   *
   * @schema RequestValidator#spec
   */
  readonly spec: RequestValidatorSpec;

}

/**
 * Converts an object of type 'RequestValidatorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorProps(obj: RequestValidatorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RequestValidatorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestValidatorSpec defines the desired state of RequestValidator
 *
 * @schema RequestValidatorSpec
 */
export interface RequestValidatorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RequestValidatorSpec#deletionPolicy
   */
  readonly deletionPolicy?: RequestValidatorSpecDeletionPolicy;

  /**
   * @schema RequestValidatorSpec#forProvider
   */
  readonly forProvider: RequestValidatorSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RequestValidatorSpec#managementPolicy
   */
  readonly managementPolicy?: RequestValidatorSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RequestValidatorSpec#providerConfigRef
   */
  readonly providerConfigRef?: RequestValidatorSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RequestValidatorSpec#providerRef
   */
  readonly providerRef?: RequestValidatorSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RequestValidatorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RequestValidatorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RequestValidatorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RequestValidatorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RequestValidatorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpec(obj: RequestValidatorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RequestValidatorSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RequestValidatorSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RequestValidatorSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RequestValidatorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RequestValidatorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RequestValidatorSpecDeletionPolicy
 */
export enum RequestValidatorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RequestValidatorSpecForProvider
 */
export interface RequestValidatorSpecForProvider {
  /**
   * Name of the request validator
   *
   * @schema RequestValidatorSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RequestValidatorSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the associated Rest API
   *
   * @schema RequestValidatorSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema RequestValidatorSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: RequestValidatorSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema RequestValidatorSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: RequestValidatorSpecForProviderRestApiIdSelector;

  /**
   * Boolean whether to validate request body. Defaults to false.
   *
   * @default false.
   * @schema RequestValidatorSpecForProvider#validateRequestBody
   */
  readonly validateRequestBody?: boolean;

  /**
   * Boolean whether to validate request parameters. Defaults to false.
   *
   * @default false.
   * @schema RequestValidatorSpecForProvider#validateRequestParameters
   */
  readonly validateRequestParameters?: boolean;

}

/**
 * Converts an object of type 'RequestValidatorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecForProvider(obj: RequestValidatorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_RequestValidatorSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_RequestValidatorSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'validateRequestBody': obj.validateRequestBody,
    'validateRequestParameters': obj.validateRequestParameters,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RequestValidatorSpecManagementPolicy
 */
export enum RequestValidatorSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RequestValidatorSpecProviderConfigRef
 */
export interface RequestValidatorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RequestValidatorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RequestValidatorSpecProviderConfigRef#policy
   */
  readonly policy?: RequestValidatorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RequestValidatorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecProviderConfigRef(obj: RequestValidatorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RequestValidatorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RequestValidatorSpecProviderRef
 */
export interface RequestValidatorSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RequestValidatorSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RequestValidatorSpecProviderRef#policy
   */
  readonly policy?: RequestValidatorSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RequestValidatorSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecProviderRef(obj: RequestValidatorSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RequestValidatorSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsTo
 */
export interface RequestValidatorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RequestValidatorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RequestValidatorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RequestValidatorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecPublishConnectionDetailsTo(obj: RequestValidatorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RequestValidatorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RequestValidatorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RequestValidatorSpecWriteConnectionSecretToRef
 */
export interface RequestValidatorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RequestValidatorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RequestValidatorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RequestValidatorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecWriteConnectionSecretToRef(obj: RequestValidatorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdRef
 */
export interface RequestValidatorSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: RequestValidatorSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'RequestValidatorSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecForProviderRestApiIdRef(obj: RequestValidatorSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RequestValidatorSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdSelector
 */
export interface RequestValidatorSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: RequestValidatorSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'RequestValidatorSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecForProviderRestApiIdSelector(obj: RequestValidatorSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RequestValidatorSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RequestValidatorSpecProviderConfigRefPolicy
 */
export interface RequestValidatorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RequestValidatorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RequestValidatorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RequestValidatorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RequestValidatorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RequestValidatorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecProviderConfigRefPolicy(obj: RequestValidatorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RequestValidatorSpecProviderRefPolicy
 */
export interface RequestValidatorSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RequestValidatorSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RequestValidatorSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RequestValidatorSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RequestValidatorSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RequestValidatorSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecProviderRefPolicy(obj: RequestValidatorSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRef
 */
export interface RequestValidatorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RequestValidatorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecPublishConnectionDetailsToConfigRef(obj: RequestValidatorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsToMetadata
 */
export interface RequestValidatorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RequestValidatorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecPublishConnectionDetailsToMetadata(obj: RequestValidatorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdRefPolicy
 */
export interface RequestValidatorSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: RequestValidatorSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: RequestValidatorSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RequestValidatorSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecForProviderRestApiIdRefPolicy(obj: RequestValidatorSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdSelectorPolicy
 */
export interface RequestValidatorSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RequestValidatorSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RequestValidatorSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecForProviderRestApiIdSelectorPolicy(obj: RequestValidatorSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RequestValidatorSpecProviderConfigRefPolicyResolution
 */
export enum RequestValidatorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RequestValidatorSpecProviderConfigRefPolicyResolve
 */
export enum RequestValidatorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RequestValidatorSpecProviderRefPolicyResolution
 */
export enum RequestValidatorSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RequestValidatorSpecProviderRefPolicyResolve
 */
export enum RequestValidatorSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy(obj: RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdRefPolicyResolution
 */
export enum RequestValidatorSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdRefPolicyResolve
 */
export enum RequestValidatorSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum RequestValidatorSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RequestValidatorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Resource is the Schema for the Resources API. Provides an API Gateway Resource.
 *
 * @schema Resource
 */
export class Resource extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Resource"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'Resource',
  }

  /**
   * Renders a Kubernetes manifest for "Resource".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResourceProps): any {
    return {
      ...Resource.GVK,
      ...toJson_ResourceProps(props),
    };
  }

  /**
   * Defines a "Resource" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResourceProps) {
    super(scope, id, {
      ...Resource.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Resource.GVK,
      ...toJson_ResourceProps(resolved),
    };
  }
}

/**
 * Resource is the Schema for the Resources API. Provides an API Gateway Resource.
 *
 * @schema Resource
 */
export interface ResourceProps {
  /**
   * @schema Resource#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResourceSpec defines the desired state of Resource
   *
   * @schema Resource#spec
   */
  readonly spec: ResourceSpec;

}

/**
 * Converts an object of type 'ResourceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceProps(obj: ResourceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResourceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceSpec defines the desired state of Resource
 *
 * @schema ResourceSpec
 */
export interface ResourceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResourceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResourceSpecDeletionPolicy;

  /**
   * @schema ResourceSpec#forProvider
   */
  readonly forProvider: ResourceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResourceSpec#managementPolicy
   */
  readonly managementPolicy?: ResourceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResourceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResourceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ResourceSpec#providerRef
   */
  readonly providerRef?: ResourceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResourceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResourceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResourceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResourceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpec(obj: ResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResourceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ResourceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ResourceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ResourceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResourceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResourceSpecDeletionPolicy
 */
export enum ResourceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ResourceSpecForProvider
 */
export interface ResourceSpecForProvider {
  /**
   * ID of the parent API resource
   *
   * @schema ResourceSpecForProvider#parentId
   */
  readonly parentId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate parentId.
   *
   * @schema ResourceSpecForProvider#parentIdRef
   */
  readonly parentIdRef?: ResourceSpecForProviderParentIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate parentId.
   *
   * @schema ResourceSpecForProvider#parentIdSelector
   */
  readonly parentIdSelector?: ResourceSpecForProviderParentIdSelector;

  /**
   * Last path segment of this API resource.
   *
   * @schema ResourceSpecForProvider#pathPart
   */
  readonly pathPart?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ResourceSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the associated REST API
   *
   * @schema ResourceSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema ResourceSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: ResourceSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema ResourceSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: ResourceSpecForProviderRestApiIdSelector;

}

/**
 * Converts an object of type 'ResourceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProvider(obj: ResourceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parentId': obj.parentId,
    'parentIdRef': toJson_ResourceSpecForProviderParentIdRef(obj.parentIdRef),
    'parentIdSelector': toJson_ResourceSpecForProviderParentIdSelector(obj.parentIdSelector),
    'pathPart': obj.pathPart,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_ResourceSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_ResourceSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResourceSpecManagementPolicy
 */
export enum ResourceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResourceSpecProviderConfigRef
 */
export interface ResourceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecProviderConfigRef#policy
   */
  readonly policy?: ResourceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderConfigRef(obj: ResourceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ResourceSpecProviderRef
 */
export interface ResourceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecProviderRef#policy
   */
  readonly policy?: ResourceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderRef(obj: ResourceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResourceSpecPublishConnectionDetailsTo
 */
export interface ResourceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResourceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResourceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsTo(obj: ResourceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResourceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResourceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResourceSpecWriteConnectionSecretToRef
 */
export interface ResourceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResourceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResourceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResourceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecWriteConnectionSecretToRef(obj: ResourceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate parentId.
 *
 * @schema ResourceSpecForProviderParentIdRef
 */
export interface ResourceSpecForProviderParentIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecForProviderParentIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecForProviderParentIdRef#policy
   */
  readonly policy?: ResourceSpecForProviderParentIdRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderParentIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderParentIdRef(obj: ResourceSpecForProviderParentIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecForProviderParentIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate parentId.
 *
 * @schema ResourceSpecForProviderParentIdSelector
 */
export interface ResourceSpecForProviderParentIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResourceSpecForProviderParentIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResourceSpecForProviderParentIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResourceSpecForProviderParentIdSelector#policy
   */
  readonly policy?: ResourceSpecForProviderParentIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderParentIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderParentIdSelector(obj: ResourceSpecForProviderParentIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResourceSpecForProviderParentIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema ResourceSpecForProviderRestApiIdRef
 */
export interface ResourceSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: ResourceSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRestApiIdRef(obj: ResourceSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema ResourceSpecForProviderRestApiIdSelector
 */
export interface ResourceSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResourceSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResourceSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResourceSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: ResourceSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRestApiIdSelector(obj: ResourceSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResourceSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecProviderConfigRefPolicy
 */
export interface ResourceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderConfigRefPolicy(obj: ResourceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecProviderRefPolicy
 */
export interface ResourceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderRefPolicy(obj: ResourceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRef
 */
export interface ResourceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResourceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToConfigRef(obj: ResourceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResourceSpecPublishConnectionDetailsToMetadata
 */
export interface ResourceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToMetadata(obj: ResourceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecForProviderParentIdRefPolicy
 */
export interface ResourceSpecForProviderParentIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderParentIdRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderParentIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderParentIdRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderParentIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderParentIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderParentIdRefPolicy(obj: ResourceSpecForProviderParentIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResourceSpecForProviderParentIdSelectorPolicy
 */
export interface ResourceSpecForProviderParentIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderParentIdSelectorPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderParentIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderParentIdSelectorPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderParentIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderParentIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderParentIdSelectorPolicy(obj: ResourceSpecForProviderParentIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecForProviderRestApiIdRefPolicy
 */
export interface ResourceSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRestApiIdRefPolicy(obj: ResourceSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResourceSpecForProviderRestApiIdSelectorPolicy
 */
export interface ResourceSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRestApiIdSelectorPolicy(obj: ResourceSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecProviderConfigRefPolicyResolution
 */
export enum ResourceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecProviderConfigRefPolicyResolve
 */
export enum ResourceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecProviderRefPolicyResolution
 */
export enum ResourceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecProviderRefPolicyResolve
 */
export enum ResourceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResourceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResourceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderParentIdRefPolicyResolution
 */
export enum ResourceSpecForProviderParentIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderParentIdRefPolicyResolve
 */
export enum ResourceSpecForProviderParentIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderParentIdSelectorPolicyResolution
 */
export enum ResourceSpecForProviderParentIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderParentIdSelectorPolicyResolve
 */
export enum ResourceSpecForProviderParentIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderRestApiIdRefPolicyResolution
 */
export enum ResourceSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderRestApiIdRefPolicyResolve
 */
export enum ResourceSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum ResourceSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum ResourceSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RestAPI is the Schema for the RestAPIs API. Manages an API Gateway REST API.
 *
 * @schema RestAPI
 */
export class RestApi extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RestAPI"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'RestAPI',
  }

  /**
   * Renders a Kubernetes manifest for "RestAPI".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RestApiProps): any {
    return {
      ...RestApi.GVK,
      ...toJson_RestApiProps(props),
    };
  }

  /**
   * Defines a "RestAPI" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RestApiProps) {
    super(scope, id, {
      ...RestApi.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RestApi.GVK,
      ...toJson_RestApiProps(resolved),
    };
  }
}

/**
 * RestAPI is the Schema for the RestAPIs API. Manages an API Gateway REST API.
 *
 * @schema RestAPI
 */
export interface RestApiProps {
  /**
   * @schema RestAPI#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RestAPISpec defines the desired state of RestAPI
   *
   * @schema RestAPI#spec
   */
  readonly spec: RestApiSpec;

}

/**
 * Converts an object of type 'RestApiProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiProps(obj: RestApiProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RestApiSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPISpec defines the desired state of RestAPI
 *
 * @schema RestApiSpec
 */
export interface RestApiSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RestApiSpec#deletionPolicy
   */
  readonly deletionPolicy?: RestApiSpecDeletionPolicy;

  /**
   * @schema RestApiSpec#forProvider
   */
  readonly forProvider: RestApiSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RestApiSpec#managementPolicy
   */
  readonly managementPolicy?: RestApiSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RestApiSpec#providerConfigRef
   */
  readonly providerConfigRef?: RestApiSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RestApiSpec#providerRef
   */
  readonly providerRef?: RestApiSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RestApiSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RestApiSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RestApiSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RestApiSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RestApiSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpec(obj: RestApiSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RestApiSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RestApiSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RestApiSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RestApiSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RestApiSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RestApiSpecDeletionPolicy
 */
export enum RestApiSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RestApiSpecForProvider
 */
export interface RestApiSpecForProvider {
  /**
   * Source of the API key for requests. Valid values are HEADER (default) and AUTHORIZER. If importing an OpenAPI specification via the body argument, this corresponds to the x-amazon-apigateway-api-key-source extension. If the argument value is provided and is different than the OpenAPI value, the argument value will override the OpenAPI value.
   *
   * @schema RestApiSpecForProvider#apiKeySource
   */
  readonly apiKeySource?: string;

  /**
   * List of binary media types supported by the REST API. By default, the REST API supports only UTF-8-encoded text payloads. If importing an OpenAPI specification via the body argument, this corresponds to the x-amazon-apigateway-binary-media-types extension. If the argument value is provided and is different than the OpenAPI value, the argument value will override the OpenAPI value.
   *
   * @schema RestApiSpecForProvider#binaryMediaTypes
   */
  readonly binaryMediaTypes?: string[];

  /**
   * OpenAPI specification that defines the set of routes and integrations to create as part of the REST API. This configuration, and any updates to it, will replace all REST API configuration except values overridden in this resource configuration and other resource updates applied after this resource but before any aws_api_gateway_deployment creation. More information about REST API OpenAPI support can be found in the API Gateway Developer Guide.
   *
   * @schema RestApiSpecForProvider#body
   */
  readonly body?: string;

  /**
   * Description of the REST API. If importing an OpenAPI specification via the body argument, this corresponds to the info.description field. If the argument value is provided and is different than the OpenAPI value, the argument value will override the OpenAPI value.
   *
   * @schema RestApiSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint. Defaults to false. If importing an OpenAPI specification via the body argument, this corresponds to the x-amazon-apigateway-endpoint-configuration extension disableExecuteApiEndpoint property. If the argument value is true and is different than the OpenAPI value, the argument value will override the OpenAPI value.
   *
   * @default false. If importing an OpenAPI specification via the body argument, this corresponds to the x-amazon-apigateway-endpoint-configuration extension disableExecuteApiEndpoint property. If the argument value is true and is different than the OpenAPI value, the argument value will override the OpenAPI value.
   * @schema RestApiSpecForProvider#disableExecuteApiEndpoint
   */
  readonly disableExecuteApiEndpoint?: boolean;

  /**
   * Configuration block defining API endpoint configuration including endpoint type. Defined below.
   *
   * @schema RestApiSpecForProvider#endpointConfiguration
   */
  readonly endpointConfiguration?: RestApiSpecForProviderEndpointConfiguration[];

  /**
   * Whether warnings while API Gateway is creating or updating the resource should return an error or not. Defaults to false
   *
   * @default false
   * @schema RestApiSpecForProvider#failOnWarnings
   */
  readonly failOnWarnings?: boolean;

  /**
   * Minimum response size to compress for the REST API. Integer between -1 and 10485760 (10MB). Setting a value greater than -1 will enable compression, -1 disables compression (default). If importing an OpenAPI specification via the body argument, this corresponds to the x-amazon-apigateway-minimum-compression-size extension. If the argument value (except -1) is provided and is different than the OpenAPI value, the argument value will override the OpenAPI value.
   *
   * @schema RestApiSpecForProvider#minimumCompressionSize
   */
  readonly minimumCompressionSize?: number;

  /**
   * Name of the REST API. If importing an OpenAPI specification via the body argument, this corresponds to the info.title field. If the argument value is different than the OpenAPI value, the argument value will override the OpenAPI value.
   *
   * @schema RestApiSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Map of customizations for importing the specification in the body argument. For example, to exclude DocumentationParts from an imported API, set ignore equal to documentation. Additional documentation, including other parameters such as basepath, can be found in the API Gateway Developer Guide.
   *
   * @schema RestApiSpecForProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Mode of the PutRestApi operation when importing an OpenAPI specification via the body argument (create or update operation). Valid values are merge and overwrite. If unspecificed, defaults to overwrite (for backwards compatibility). This corresponds to the x-amazon-apigateway-put-integration-method extension. If the argument value is provided and is different than the OpenAPI value, the argument value will override the OpenAPI value.
   *
   * @schema RestApiSpecForProvider#putRestApiMode
   */
  readonly putRestApiMode?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RestApiSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RestApiSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RestApiSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecForProvider(obj: RestApiSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeySource': obj.apiKeySource,
    'binaryMediaTypes': obj.binaryMediaTypes?.map(y => y),
    'body': obj.body,
    'description': obj.description,
    'disableExecuteApiEndpoint': obj.disableExecuteApiEndpoint,
    'endpointConfiguration': obj.endpointConfiguration?.map(y => toJson_RestApiSpecForProviderEndpointConfiguration(y)),
    'failOnWarnings': obj.failOnWarnings,
    'minimumCompressionSize': obj.minimumCompressionSize,
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'putRestApiMode': obj.putRestApiMode,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RestApiSpecManagementPolicy
 */
export enum RestApiSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RestApiSpecProviderConfigRef
 */
export interface RestApiSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RestApiSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RestApiSpecProviderConfigRef#policy
   */
  readonly policy?: RestApiSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RestApiSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecProviderConfigRef(obj: RestApiSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RestApiSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RestApiSpecProviderRef
 */
export interface RestApiSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RestApiSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RestApiSpecProviderRef#policy
   */
  readonly policy?: RestApiSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RestApiSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecProviderRef(obj: RestApiSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RestApiSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RestApiSpecPublishConnectionDetailsTo
 */
export interface RestApiSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RestApiSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RestApiSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RestApiSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RestApiSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RestApiSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RestApiSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecPublishConnectionDetailsTo(obj: RestApiSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RestApiSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RestApiSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RestApiSpecWriteConnectionSecretToRef
 */
export interface RestApiSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RestApiSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RestApiSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RestApiSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecWriteConnectionSecretToRef(obj: RestApiSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RestApiSpecForProviderEndpointConfiguration
 */
export interface RestApiSpecForProviderEndpointConfiguration {
  /**
   * List of endpoint types. This resource currently only supports managing a single value. Valid values: EDGE, REGIONAL or PRIVATE. If unspecified, defaults to EDGE. If set to PRIVATE recommend to set put_rest_api_mode = merge to not cause the endpoints and associated Route53 records to be deleted. Refer to the documentation for more information on the difference between edge-optimized and regional APIs.
   *
   * @schema RestApiSpecForProviderEndpointConfiguration#types
   */
  readonly types: string[];

  /**
   * Set of VPC Endpoint identifiers. It is only supported for PRIVATE endpoint type. If importing an OpenAPI specification via the body argument, this corresponds to the x-amazon-apigateway-endpoint-configuration extension vpcEndpointIds property. If the argument value is provided and is different than the OpenAPI value, the argument value will override the OpenAPI value.
   *
   * @schema RestApiSpecForProviderEndpointConfiguration#vpcEndpointIds
   */
  readonly vpcEndpointIds?: string[];

}

/**
 * Converts an object of type 'RestApiSpecForProviderEndpointConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecForProviderEndpointConfiguration(obj: RestApiSpecForProviderEndpointConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'types': obj.types?.map(y => y),
    'vpcEndpointIds': obj.vpcEndpointIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RestApiSpecProviderConfigRefPolicy
 */
export interface RestApiSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RestApiSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RestApiSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RestApiSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RestApiSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RestApiSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecProviderConfigRefPolicy(obj: RestApiSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RestApiSpecProviderRefPolicy
 */
export interface RestApiSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RestApiSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RestApiSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RestApiSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RestApiSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RestApiSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecProviderRefPolicy(obj: RestApiSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RestApiSpecPublishConnectionDetailsToConfigRef
 */
export interface RestApiSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RestApiSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RestApiSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RestApiSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RestApiSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecPublishConnectionDetailsToConfigRef(obj: RestApiSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RestApiSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RestApiSpecPublishConnectionDetailsToMetadata
 */
export interface RestApiSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RestApiSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RestApiSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RestApiSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RestApiSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecPublishConnectionDetailsToMetadata(obj: RestApiSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RestApiSpecProviderConfigRefPolicyResolution
 */
export enum RestApiSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RestApiSpecProviderConfigRefPolicyResolve
 */
export enum RestApiSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RestApiSpecProviderRefPolicyResolution
 */
export enum RestApiSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RestApiSpecProviderRefPolicyResolve
 */
export enum RestApiSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RestApiSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RestApiSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RestApiSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RestApiSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RestApiSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiSpecPublishConnectionDetailsToConfigRefPolicy(obj: RestApiSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RestApiSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RestAPIPolicy is the Schema for the RestAPIPolicys API. Provides an API Gateway REST API Policy.
 *
 * @schema RestAPIPolicy
 */
export class RestApiPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RestAPIPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'RestAPIPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "RestAPIPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RestApiPolicyProps): any {
    return {
      ...RestApiPolicy.GVK,
      ...toJson_RestApiPolicyProps(props),
    };
  }

  /**
   * Defines a "RestAPIPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RestApiPolicyProps) {
    super(scope, id, {
      ...RestApiPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RestApiPolicy.GVK,
      ...toJson_RestApiPolicyProps(resolved),
    };
  }
}

/**
 * RestAPIPolicy is the Schema for the RestAPIPolicys API. Provides an API Gateway REST API Policy.
 *
 * @schema RestAPIPolicy
 */
export interface RestApiPolicyProps {
  /**
   * @schema RestAPIPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RestAPIPolicySpec defines the desired state of RestAPIPolicy
   *
   * @schema RestAPIPolicy#spec
   */
  readonly spec: RestApiPolicySpec;

}

/**
 * Converts an object of type 'RestApiPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicyProps(obj: RestApiPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RestApiPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RestAPIPolicySpec defines the desired state of RestAPIPolicy
 *
 * @schema RestApiPolicySpec
 */
export interface RestApiPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RestApiPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: RestApiPolicySpecDeletionPolicy;

  /**
   * @schema RestApiPolicySpec#forProvider
   */
  readonly forProvider: RestApiPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RestApiPolicySpec#managementPolicy
   */
  readonly managementPolicy?: RestApiPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RestApiPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: RestApiPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RestApiPolicySpec#providerRef
   */
  readonly providerRef?: RestApiPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RestApiPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RestApiPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RestApiPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RestApiPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RestApiPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpec(obj: RestApiPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RestApiPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RestApiPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RestApiPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RestApiPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RestApiPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RestApiPolicySpecDeletionPolicy
 */
export enum RestApiPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RestApiPolicySpecForProvider
 */
export interface RestApiPolicySpecForProvider {
  /**
   * JSON formatted policy document that controls access to the API Gateway
   *
   * @schema RestApiPolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RestApiPolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the REST API.
   *
   * @schema RestApiPolicySpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema RestApiPolicySpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: RestApiPolicySpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema RestApiPolicySpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: RestApiPolicySpecForProviderRestApiIdSelector;

}

/**
 * Converts an object of type 'RestApiPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecForProvider(obj: RestApiPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_RestApiPolicySpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_RestApiPolicySpecForProviderRestApiIdSelector(obj.restApiIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RestApiPolicySpecManagementPolicy
 */
export enum RestApiPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RestApiPolicySpecProviderConfigRef
 */
export interface RestApiPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RestApiPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RestApiPolicySpecProviderConfigRef#policy
   */
  readonly policy?: RestApiPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RestApiPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecProviderConfigRef(obj: RestApiPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RestApiPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RestApiPolicySpecProviderRef
 */
export interface RestApiPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RestApiPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RestApiPolicySpecProviderRef#policy
   */
  readonly policy?: RestApiPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RestApiPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecProviderRef(obj: RestApiPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RestApiPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RestApiPolicySpecPublishConnectionDetailsTo
 */
export interface RestApiPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RestApiPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RestApiPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RestApiPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RestApiPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RestApiPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RestApiPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecPublishConnectionDetailsTo(obj: RestApiPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RestApiPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RestApiPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RestApiPolicySpecWriteConnectionSecretToRef
 */
export interface RestApiPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RestApiPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RestApiPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RestApiPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecWriteConnectionSecretToRef(obj: RestApiPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema RestApiPolicySpecForProviderRestApiIdRef
 */
export interface RestApiPolicySpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RestApiPolicySpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RestApiPolicySpecForProviderRestApiIdRef#policy
   */
  readonly policy?: RestApiPolicySpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'RestApiPolicySpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecForProviderRestApiIdRef(obj: RestApiPolicySpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RestApiPolicySpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema RestApiPolicySpecForProviderRestApiIdSelector
 */
export interface RestApiPolicySpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RestApiPolicySpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RestApiPolicySpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RestApiPolicySpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: RestApiPolicySpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'RestApiPolicySpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecForProviderRestApiIdSelector(obj: RestApiPolicySpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RestApiPolicySpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RestApiPolicySpecProviderConfigRefPolicy
 */
export interface RestApiPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RestApiPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RestApiPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RestApiPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RestApiPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RestApiPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecProviderConfigRefPolicy(obj: RestApiPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RestApiPolicySpecProviderRefPolicy
 */
export interface RestApiPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RestApiPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: RestApiPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RestApiPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: RestApiPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RestApiPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecProviderRefPolicy(obj: RestApiPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RestApiPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface RestApiPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RestApiPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RestApiPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RestApiPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecPublishConnectionDetailsToConfigRef(obj: RestApiPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RestApiPolicySpecPublishConnectionDetailsToMetadata
 */
export interface RestApiPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RestApiPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RestApiPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RestApiPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RestApiPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecPublishConnectionDetailsToMetadata(obj: RestApiPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RestApiPolicySpecForProviderRestApiIdRefPolicy
 */
export interface RestApiPolicySpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RestApiPolicySpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: RestApiPolicySpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RestApiPolicySpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: RestApiPolicySpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RestApiPolicySpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecForProviderRestApiIdRefPolicy(obj: RestApiPolicySpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RestApiPolicySpecForProviderRestApiIdSelectorPolicy
 */
export interface RestApiPolicySpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RestApiPolicySpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: RestApiPolicySpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RestApiPolicySpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: RestApiPolicySpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RestApiPolicySpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecForProviderRestApiIdSelectorPolicy(obj: RestApiPolicySpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RestApiPolicySpecProviderConfigRefPolicyResolution
 */
export enum RestApiPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RestApiPolicySpecProviderConfigRefPolicyResolve
 */
export enum RestApiPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RestApiPolicySpecProviderRefPolicyResolution
 */
export enum RestApiPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RestApiPolicySpecProviderRefPolicyResolve
 */
export enum RestApiPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RestApiPolicySpecForProviderRestApiIdRefPolicyResolution
 */
export enum RestApiPolicySpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RestApiPolicySpecForProviderRestApiIdRefPolicyResolve
 */
export enum RestApiPolicySpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RestApiPolicySpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum RestApiPolicySpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RestApiPolicySpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum RestApiPolicySpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RestApiPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Stage is the Schema for the Stages API. Manages an API Gateway Stage.
 *
 * @schema Stage
 */
export class Stage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'Stage',
  }

  /**
   * Renders a Kubernetes manifest for "Stage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StageProps): any {
    return {
      ...Stage.GVK,
      ...toJson_StageProps(props),
    };
  }

  /**
   * Defines a "Stage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StageProps) {
    super(scope, id, {
      ...Stage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stage.GVK,
      ...toJson_StageProps(resolved),
    };
  }
}

/**
 * Stage is the Schema for the Stages API. Manages an API Gateway Stage.
 *
 * @schema Stage
 */
export interface StageProps {
  /**
   * @schema Stage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StageSpec defines the desired state of Stage
   *
   * @schema Stage#spec
   */
  readonly spec: StageSpec;

}

/**
 * Converts an object of type 'StageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageProps(obj: StageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StageSpec defines the desired state of Stage
 *
 * @schema StageSpec
 */
export interface StageSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StageSpec#deletionPolicy
   */
  readonly deletionPolicy?: StageSpecDeletionPolicy;

  /**
   * @schema StageSpec#forProvider
   */
  readonly forProvider: StageSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StageSpec#managementPolicy
   */
  readonly managementPolicy?: StageSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StageSpec#providerConfigRef
   */
  readonly providerConfigRef?: StageSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StageSpec#providerRef
   */
  readonly providerRef?: StageSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StageSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StageSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StageSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StageSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StageSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpec(obj: StageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StageSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_StageSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StageSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StageSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StageSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StageSpecDeletionPolicy
 */
export enum StageSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StageSpecForProvider
 */
export interface StageSpecForProvider {
  /**
   * Enables access logs for the API stage. See Access Log Settings below.
   *
   * @schema StageSpecForProvider#accessLogSettings
   */
  readonly accessLogSettings?: StageSpecForProviderAccessLogSettings[];

  /**
   * Whether a cache cluster is enabled for the stage
   *
   * @schema StageSpecForProvider#cacheClusterEnabled
   */
  readonly cacheClusterEnabled?: boolean;

  /**
   * Size of the cache cluster for the stage, if enabled. Allowed values include 0.5, 1.6, 6.1, 13.5, 28.4, 58.2, 118 and 237.
   *
   * @schema StageSpecForProvider#cacheClusterSize
   */
  readonly cacheClusterSize?: string;

  /**
   * Configuration settings of a canary deployment. See Canary Settings below.
   *
   * @schema StageSpecForProvider#canarySettings
   */
  readonly canarySettings?: StageSpecForProviderCanarySettings[];

  /**
   * Identifier of a client certificate for the stage.
   *
   * @schema StageSpecForProvider#clientCertificateId
   */
  readonly clientCertificateId?: string;

  /**
   * ID of the deployment that the stage points to
   *
   * @schema StageSpecForProvider#deploymentId
   */
  readonly deploymentId?: string;

  /**
   * Reference to a Deployment in apigateway to populate deploymentId.
   *
   * @schema StageSpecForProvider#deploymentIdRef
   */
  readonly deploymentIdRef?: StageSpecForProviderDeploymentIdRef;

  /**
   * Selector for a Deployment in apigateway to populate deploymentId.
   *
   * @schema StageSpecForProvider#deploymentIdSelector
   */
  readonly deploymentIdSelector?: StageSpecForProviderDeploymentIdSelector;

  /**
   * Description of the stage.
   *
   * @schema StageSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Version of the associated API documentation
   *
   * @schema StageSpecForProvider#documentationVersion
   */
  readonly documentationVersion?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StageSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the associated REST API
   *
   * @schema StageSpecForProvider#restApiId
   */
  readonly restApiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate restApiId.
   *
   * @schema StageSpecForProvider#restApiIdRef
   */
  readonly restApiIdRef?: StageSpecForProviderRestApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate restApiId.
   *
   * @schema StageSpecForProvider#restApiIdSelector
   */
  readonly restApiIdSelector?: StageSpecForProviderRestApiIdSelector;

  /**
   * Name of the stage
   *
   * @schema StageSpecForProvider#stageName
   */
  readonly stageName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StageSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Map that defines the stage variables
   *
   * @schema StageSpecForProvider#variables
   */
  readonly variables?: { [key: string]: string };

  /**
   * Whether active tracing with X-ray is enabled. Defaults to false.
   *
   * @default false.
   * @schema StageSpecForProvider#xrayTracingEnabled
   */
  readonly xrayTracingEnabled?: boolean;

}

/**
 * Converts an object of type 'StageSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProvider(obj: StageSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLogSettings': obj.accessLogSettings?.map(y => toJson_StageSpecForProviderAccessLogSettings(y)),
    'cacheClusterEnabled': obj.cacheClusterEnabled,
    'cacheClusterSize': obj.cacheClusterSize,
    'canarySettings': obj.canarySettings?.map(y => toJson_StageSpecForProviderCanarySettings(y)),
    'clientCertificateId': obj.clientCertificateId,
    'deploymentId': obj.deploymentId,
    'deploymentIdRef': toJson_StageSpecForProviderDeploymentIdRef(obj.deploymentIdRef),
    'deploymentIdSelector': toJson_StageSpecForProviderDeploymentIdSelector(obj.deploymentIdSelector),
    'description': obj.description,
    'documentationVersion': obj.documentationVersion,
    'region': obj.region,
    'restApiId': obj.restApiId,
    'restApiIdRef': toJson_StageSpecForProviderRestApiIdRef(obj.restApiIdRef),
    'restApiIdSelector': toJson_StageSpecForProviderRestApiIdSelector(obj.restApiIdSelector),
    'stageName': obj.stageName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'variables': ((obj.variables) === undefined) ? undefined : (Object.entries(obj.variables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'xrayTracingEnabled': obj.xrayTracingEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StageSpecManagementPolicy
 */
export enum StageSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StageSpecProviderConfigRef
 */
export interface StageSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecProviderConfigRef#policy
   */
  readonly policy?: StageSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StageSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderConfigRef(obj: StageSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StageSpecProviderRef
 */
export interface StageSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecProviderRef#policy
   */
  readonly policy?: StageSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StageSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderRef(obj: StageSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StageSpecPublishConnectionDetailsTo
 */
export interface StageSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StageSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StageSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StageSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsTo(obj: StageSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StageSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StageSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StageSpecWriteConnectionSecretToRef
 */
export interface StageSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StageSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StageSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StageSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecWriteConnectionSecretToRef(obj: StageSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StageSpecForProviderAccessLogSettings
 */
export interface StageSpecForProviderAccessLogSettings {
  /**
   * ARN of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with amazon-apigateway-. Automatically removes trailing :* if present.
   *
   * @schema StageSpecForProviderAccessLogSettings#destinationArn
   */
  readonly destinationArn: string;

  /**
   * Formatting and values recorded in the logs. For more information on configuring the log format rules visit the AWS documentation
   *
   * @schema StageSpecForProviderAccessLogSettings#format
   */
  readonly format: string;

}

/**
 * Converts an object of type 'StageSpecForProviderAccessLogSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderAccessLogSettings(obj: StageSpecForProviderAccessLogSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationArn': obj.destinationArn,
    'format': obj.format,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StageSpecForProviderCanarySettings
 */
export interface StageSpecForProviderCanarySettings {
  /**
   * Percent 0.0 - 100.0 of traffic to divert to the canary deployment.
   *
   * @schema StageSpecForProviderCanarySettings#percentTraffic
   */
  readonly percentTraffic?: number;

  /**
   * Map of overridden stage variables (including new variables) for the canary deployment.
   *
   * @schema StageSpecForProviderCanarySettings#stageVariableOverrides
   */
  readonly stageVariableOverrides?: { [key: string]: string };

  /**
   * Whether the canary deployment uses the stage cache. Defaults to false.
   *
   * @default false.
   * @schema StageSpecForProviderCanarySettings#useStageCache
   */
  readonly useStageCache?: boolean;

}

/**
 * Converts an object of type 'StageSpecForProviderCanarySettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderCanarySettings(obj: StageSpecForProviderCanarySettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'percentTraffic': obj.percentTraffic,
    'stageVariableOverrides': ((obj.stageVariableOverrides) === undefined) ? undefined : (Object.entries(obj.stageVariableOverrides).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'useStageCache': obj.useStageCache,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Deployment in apigateway to populate deploymentId.
 *
 * @schema StageSpecForProviderDeploymentIdRef
 */
export interface StageSpecForProviderDeploymentIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecForProviderDeploymentIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecForProviderDeploymentIdRef#policy
   */
  readonly policy?: StageSpecForProviderDeploymentIdRefPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdRef(obj: StageSpecForProviderDeploymentIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecForProviderDeploymentIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Deployment in apigateway to populate deploymentId.
 *
 * @schema StageSpecForProviderDeploymentIdSelector
 */
export interface StageSpecForProviderDeploymentIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StageSpecForProviderDeploymentIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StageSpecForProviderDeploymentIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StageSpecForProviderDeploymentIdSelector#policy
   */
  readonly policy?: StageSpecForProviderDeploymentIdSelectorPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdSelector(obj: StageSpecForProviderDeploymentIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StageSpecForProviderDeploymentIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate restApiId.
 *
 * @schema StageSpecForProviderRestApiIdRef
 */
export interface StageSpecForProviderRestApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecForProviderRestApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecForProviderRestApiIdRef#policy
   */
  readonly policy?: StageSpecForProviderRestApiIdRefPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderRestApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderRestApiIdRef(obj: StageSpecForProviderRestApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecForProviderRestApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate restApiId.
 *
 * @schema StageSpecForProviderRestApiIdSelector
 */
export interface StageSpecForProviderRestApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StageSpecForProviderRestApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StageSpecForProviderRestApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StageSpecForProviderRestApiIdSelector#policy
   */
  readonly policy?: StageSpecForProviderRestApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'StageSpecForProviderRestApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderRestApiIdSelector(obj: StageSpecForProviderRestApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StageSpecForProviderRestApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecProviderConfigRefPolicy
 */
export interface StageSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StageSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StageSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderConfigRefPolicy(obj: StageSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecProviderRefPolicy
 */
export interface StageSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StageSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StageSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecProviderRefPolicy(obj: StageSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRef
 */
export interface StageSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StageSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToConfigRef(obj: StageSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StageSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StageSpecPublishConnectionDetailsToMetadata
 */
export interface StageSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StageSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToMetadata(obj: StageSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecForProviderDeploymentIdRefPolicy
 */
export interface StageSpecForProviderDeploymentIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderDeploymentIdRefPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderDeploymentIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderDeploymentIdRefPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderDeploymentIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdRefPolicy(obj: StageSpecForProviderDeploymentIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StageSpecForProviderDeploymentIdSelectorPolicy
 */
export interface StageSpecForProviderDeploymentIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderDeploymentIdSelectorPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderDeploymentIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderDeploymentIdSelectorPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderDeploymentIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderDeploymentIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderDeploymentIdSelectorPolicy(obj: StageSpecForProviderDeploymentIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StageSpecForProviderRestApiIdRefPolicy
 */
export interface StageSpecForProviderRestApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderRestApiIdRefPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderRestApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderRestApiIdRefPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderRestApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderRestApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderRestApiIdRefPolicy(obj: StageSpecForProviderRestApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StageSpecForProviderRestApiIdSelectorPolicy
 */
export interface StageSpecForProviderRestApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecForProviderRestApiIdSelectorPolicy#resolution
   */
  readonly resolution?: StageSpecForProviderRestApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecForProviderRestApiIdSelectorPolicy#resolve
   */
  readonly resolve?: StageSpecForProviderRestApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecForProviderRestApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecForProviderRestApiIdSelectorPolicy(obj: StageSpecForProviderRestApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecProviderConfigRefPolicyResolution
 */
export enum StageSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecProviderConfigRefPolicyResolve
 */
export enum StageSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecProviderRefPolicyResolution
 */
export enum StageSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecProviderRefPolicyResolve
 */
export enum StageSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StageSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StageSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StageSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StageSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StageSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StageSpecPublishConnectionDetailsToConfigRefPolicy(obj: StageSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderDeploymentIdRefPolicyResolution
 */
export enum StageSpecForProviderDeploymentIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderDeploymentIdRefPolicyResolve
 */
export enum StageSpecForProviderDeploymentIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderDeploymentIdSelectorPolicyResolution
 */
export enum StageSpecForProviderDeploymentIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderDeploymentIdSelectorPolicyResolve
 */
export enum StageSpecForProviderDeploymentIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderRestApiIdRefPolicyResolution
 */
export enum StageSpecForProviderRestApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderRestApiIdRefPolicyResolve
 */
export enum StageSpecForProviderRestApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecForProviderRestApiIdSelectorPolicyResolution
 */
export enum StageSpecForProviderRestApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecForProviderRestApiIdSelectorPolicyResolve
 */
export enum StageSpecForProviderRestApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StageSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StageSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StageSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UsagePlan is the Schema for the UsagePlans API. Provides an API Gateway Usage Plan.
 *
 * @schema UsagePlan
 */
export class UsagePlan extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UsagePlan"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'UsagePlan',
  }

  /**
   * Renders a Kubernetes manifest for "UsagePlan".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UsagePlanProps): any {
    return {
      ...UsagePlan.GVK,
      ...toJson_UsagePlanProps(props),
    };
  }

  /**
   * Defines a "UsagePlan" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UsagePlanProps) {
    super(scope, id, {
      ...UsagePlan.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UsagePlan.GVK,
      ...toJson_UsagePlanProps(resolved),
    };
  }
}

/**
 * UsagePlan is the Schema for the UsagePlans API. Provides an API Gateway Usage Plan.
 *
 * @schema UsagePlan
 */
export interface UsagePlanProps {
  /**
   * @schema UsagePlan#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UsagePlanSpec defines the desired state of UsagePlan
   *
   * @schema UsagePlan#spec
   */
  readonly spec: UsagePlanSpec;

}

/**
 * Converts an object of type 'UsagePlanProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanProps(obj: UsagePlanProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UsagePlanSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UsagePlanSpec defines the desired state of UsagePlan
 *
 * @schema UsagePlanSpec
 */
export interface UsagePlanSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UsagePlanSpec#deletionPolicy
   */
  readonly deletionPolicy?: UsagePlanSpecDeletionPolicy;

  /**
   * @schema UsagePlanSpec#forProvider
   */
  readonly forProvider: UsagePlanSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UsagePlanSpec#managementPolicy
   */
  readonly managementPolicy?: UsagePlanSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UsagePlanSpec#providerConfigRef
   */
  readonly providerConfigRef?: UsagePlanSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UsagePlanSpec#providerRef
   */
  readonly providerRef?: UsagePlanSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UsagePlanSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UsagePlanSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UsagePlanSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UsagePlanSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UsagePlanSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpec(obj: UsagePlanSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UsagePlanSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_UsagePlanSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UsagePlanSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UsagePlanSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UsagePlanSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UsagePlanSpecDeletionPolicy
 */
export enum UsagePlanSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UsagePlanSpecForProvider
 */
export interface UsagePlanSpecForProvider {
  /**
   * Associated API stages of the usage plan.
   *
   * @schema UsagePlanSpecForProvider#apiStages
   */
  readonly apiStages?: UsagePlanSpecForProviderApiStages[];

  /**
   * Description of a usage plan.
   *
   * @schema UsagePlanSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Name of the usage plan.
   *
   * @schema UsagePlanSpecForProvider#name
   */
  readonly name?: string;

  /**
   * AWS Marketplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace.
   *
   * @schema UsagePlanSpecForProvider#productCode
   */
  readonly productCode?: string;

  /**
   * The quota settings of the usage plan.
   *
   * @schema UsagePlanSpecForProvider#quotaSettings
   */
  readonly quotaSettings?: UsagePlanSpecForProviderQuotaSettings[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UsagePlanSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema UsagePlanSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The throttling limits of the usage plan.
   *
   * @schema UsagePlanSpecForProvider#throttleSettings
   */
  readonly throttleSettings?: UsagePlanSpecForProviderThrottleSettings[];

}

/**
 * Converts an object of type 'UsagePlanSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProvider(obj: UsagePlanSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiStages': obj.apiStages?.map(y => toJson_UsagePlanSpecForProviderApiStages(y)),
    'description': obj.description,
    'name': obj.name,
    'productCode': obj.productCode,
    'quotaSettings': obj.quotaSettings?.map(y => toJson_UsagePlanSpecForProviderQuotaSettings(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'throttleSettings': obj.throttleSettings?.map(y => toJson_UsagePlanSpecForProviderThrottleSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UsagePlanSpecManagementPolicy
 */
export enum UsagePlanSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UsagePlanSpecProviderConfigRef
 */
export interface UsagePlanSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanSpecProviderConfigRef#policy
   */
  readonly policy?: UsagePlanSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecProviderConfigRef(obj: UsagePlanSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UsagePlanSpecProviderRef
 */
export interface UsagePlanSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanSpecProviderRef#policy
   */
  readonly policy?: UsagePlanSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecProviderRef(obj: UsagePlanSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsTo
 */
export interface UsagePlanSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UsagePlanSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UsagePlanSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UsagePlanSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecPublishConnectionDetailsTo(obj: UsagePlanSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UsagePlanSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UsagePlanSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UsagePlanSpecWriteConnectionSecretToRef
 */
export interface UsagePlanSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UsagePlanSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UsagePlanSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UsagePlanSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecWriteConnectionSecretToRef(obj: UsagePlanSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UsagePlanSpecForProviderApiStages
 */
export interface UsagePlanSpecForProviderApiStages {
  /**
   * API Id of the associated API stage in a usage plan.
   *
   * @schema UsagePlanSpecForProviderApiStages#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a RestAPI in apigateway to populate apiId.
   *
   * @schema UsagePlanSpecForProviderApiStages#apiIdRef
   */
  readonly apiIdRef?: UsagePlanSpecForProviderApiStagesApiIdRef;

  /**
   * Selector for a RestAPI in apigateway to populate apiId.
   *
   * @schema UsagePlanSpecForProviderApiStages#apiIdSelector
   */
  readonly apiIdSelector?: UsagePlanSpecForProviderApiStagesApiIdSelector;

  /**
   * API stage name of the associated API stage in a usage plan.
   *
   * @schema UsagePlanSpecForProviderApiStages#stage
   */
  readonly stage?: string;

  /**
   * Reference to a Stage in apigateway to populate stage.
   *
   * @schema UsagePlanSpecForProviderApiStages#stageRef
   */
  readonly stageRef?: UsagePlanSpecForProviderApiStagesStageRef;

  /**
   * Selector for a Stage in apigateway to populate stage.
   *
   * @schema UsagePlanSpecForProviderApiStages#stageSelector
   */
  readonly stageSelector?: UsagePlanSpecForProviderApiStagesStageSelector;

  /**
   * The throttling limits of the usage plan.
   *
   * @schema UsagePlanSpecForProviderApiStages#throttle
   */
  readonly throttle?: UsagePlanSpecForProviderApiStagesThrottle[];

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStages(obj: UsagePlanSpecForProviderApiStages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_UsagePlanSpecForProviderApiStagesApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_UsagePlanSpecForProviderApiStagesApiIdSelector(obj.apiIdSelector),
    'stage': obj.stage,
    'stageRef': toJson_UsagePlanSpecForProviderApiStagesStageRef(obj.stageRef),
    'stageSelector': toJson_UsagePlanSpecForProviderApiStagesStageSelector(obj.stageSelector),
    'throttle': obj.throttle?.map(y => toJson_UsagePlanSpecForProviderApiStagesThrottle(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UsagePlanSpecForProviderQuotaSettings
 */
export interface UsagePlanSpecForProviderQuotaSettings {
  /**
   * Maximum number of requests that can be made in a given time period.
   *
   * @schema UsagePlanSpecForProviderQuotaSettings#limit
   */
  readonly limit: number;

  /**
   * Number of requests subtracted from the given limit in the initial time period.
   *
   * @schema UsagePlanSpecForProviderQuotaSettings#offset
   */
  readonly offset?: number;

  /**
   * Time period in which the limit applies. Valid values are "DAY", "WEEK" or "MONTH".
   *
   * @schema UsagePlanSpecForProviderQuotaSettings#period
   */
  readonly period: string;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderQuotaSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderQuotaSettings(obj: UsagePlanSpecForProviderQuotaSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limit': obj.limit,
    'offset': obj.offset,
    'period': obj.period,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UsagePlanSpecForProviderThrottleSettings
 */
export interface UsagePlanSpecForProviderThrottleSettings {
  /**
   * The API request burst limit, the maximum rate limit over a time ranging from one to a few seconds, depending upon whether the underlying token bucket is at its full capacity.
   *
   * @schema UsagePlanSpecForProviderThrottleSettings#burstLimit
   */
  readonly burstLimit?: number;

  /**
   * The API request steady-state rate limit.
   *
   * @schema UsagePlanSpecForProviderThrottleSettings#rateLimit
   */
  readonly rateLimit?: number;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderThrottleSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderThrottleSettings(obj: UsagePlanSpecForProviderThrottleSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'burstLimit': obj.burstLimit,
    'rateLimit': obj.rateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanSpecProviderConfigRefPolicy
 */
export interface UsagePlanSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UsagePlanSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UsagePlanSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecProviderConfigRefPolicy(obj: UsagePlanSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanSpecProviderRefPolicy
 */
export interface UsagePlanSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UsagePlanSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UsagePlanSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecProviderRefPolicy(obj: UsagePlanSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsToConfigRef
 */
export interface UsagePlanSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecPublishConnectionDetailsToConfigRef(obj: UsagePlanSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsToMetadata
 */
export interface UsagePlanSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UsagePlanSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecPublishConnectionDetailsToMetadata(obj: UsagePlanSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RestAPI in apigateway to populate apiId.
 *
 * @schema UsagePlanSpecForProviderApiStagesApiIdRef
 */
export interface UsagePlanSpecForProviderApiStagesApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanSpecForProviderApiStagesApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanSpecForProviderApiStagesApiIdRef#policy
   */
  readonly policy?: UsagePlanSpecForProviderApiStagesApiIdRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesApiIdRef(obj: UsagePlanSpecForProviderApiStagesApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanSpecForProviderApiStagesApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RestAPI in apigateway to populate apiId.
 *
 * @schema UsagePlanSpecForProviderApiStagesApiIdSelector
 */
export interface UsagePlanSpecForProviderApiStagesApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UsagePlanSpecForProviderApiStagesApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UsagePlanSpecForProviderApiStagesApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UsagePlanSpecForProviderApiStagesApiIdSelector#policy
   */
  readonly policy?: UsagePlanSpecForProviderApiStagesApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesApiIdSelector(obj: UsagePlanSpecForProviderApiStagesApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UsagePlanSpecForProviderApiStagesApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stage in apigateway to populate stage.
 *
 * @schema UsagePlanSpecForProviderApiStagesStageRef
 */
export interface UsagePlanSpecForProviderApiStagesStageRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanSpecForProviderApiStagesStageRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanSpecForProviderApiStagesStageRef#policy
   */
  readonly policy?: UsagePlanSpecForProviderApiStagesStageRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesStageRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesStageRef(obj: UsagePlanSpecForProviderApiStagesStageRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanSpecForProviderApiStagesStageRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stage in apigateway to populate stage.
 *
 * @schema UsagePlanSpecForProviderApiStagesStageSelector
 */
export interface UsagePlanSpecForProviderApiStagesStageSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UsagePlanSpecForProviderApiStagesStageSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UsagePlanSpecForProviderApiStagesStageSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UsagePlanSpecForProviderApiStagesStageSelector#policy
   */
  readonly policy?: UsagePlanSpecForProviderApiStagesStageSelectorPolicy;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesStageSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesStageSelector(obj: UsagePlanSpecForProviderApiStagesStageSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UsagePlanSpecForProviderApiStagesStageSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UsagePlanSpecForProviderApiStagesThrottle
 */
export interface UsagePlanSpecForProviderApiStagesThrottle {
  /**
   * The API request burst limit, the maximum rate limit over a time ranging from one to a few seconds, depending upon whether the underlying token bucket is at its full capacity.
   *
   * @schema UsagePlanSpecForProviderApiStagesThrottle#burstLimit
   */
  readonly burstLimit?: number;

  /**
   * Method to apply the throttle settings for. Specfiy the path and method, for example /test/GET.
   *
   * @schema UsagePlanSpecForProviderApiStagesThrottle#path
   */
  readonly path: string;

  /**
   * The API request steady-state rate limit.
   *
   * @schema UsagePlanSpecForProviderApiStagesThrottle#rateLimit
   */
  readonly rateLimit?: number;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesThrottle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesThrottle(obj: UsagePlanSpecForProviderApiStagesThrottle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'burstLimit': obj.burstLimit,
    'path': obj.path,
    'rateLimit': obj.rateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanSpecProviderConfigRefPolicyResolution
 */
export enum UsagePlanSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanSpecProviderConfigRefPolicyResolve
 */
export enum UsagePlanSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanSpecProviderRefPolicyResolution
 */
export enum UsagePlanSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanSpecProviderRefPolicyResolve
 */
export enum UsagePlanSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy(obj: UsagePlanSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanSpecForProviderApiStagesApiIdRefPolicy
 */
export interface UsagePlanSpecForProviderApiStagesApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanSpecForProviderApiStagesApiIdRefPolicy#resolution
   */
  readonly resolution?: UsagePlanSpecForProviderApiStagesApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanSpecForProviderApiStagesApiIdRefPolicy#resolve
   */
  readonly resolve?: UsagePlanSpecForProviderApiStagesApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesApiIdRefPolicy(obj: UsagePlanSpecForProviderApiStagesApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UsagePlanSpecForProviderApiStagesApiIdSelectorPolicy
 */
export interface UsagePlanSpecForProviderApiStagesApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanSpecForProviderApiStagesApiIdSelectorPolicy#resolution
   */
  readonly resolution?: UsagePlanSpecForProviderApiStagesApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanSpecForProviderApiStagesApiIdSelectorPolicy#resolve
   */
  readonly resolve?: UsagePlanSpecForProviderApiStagesApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesApiIdSelectorPolicy(obj: UsagePlanSpecForProviderApiStagesApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanSpecForProviderApiStagesStageRefPolicy
 */
export interface UsagePlanSpecForProviderApiStagesStageRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanSpecForProviderApiStagesStageRefPolicy#resolution
   */
  readonly resolution?: UsagePlanSpecForProviderApiStagesStageRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanSpecForProviderApiStagesStageRefPolicy#resolve
   */
  readonly resolve?: UsagePlanSpecForProviderApiStagesStageRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesStageRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesStageRefPolicy(obj: UsagePlanSpecForProviderApiStagesStageRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UsagePlanSpecForProviderApiStagesStageSelectorPolicy
 */
export interface UsagePlanSpecForProviderApiStagesStageSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanSpecForProviderApiStagesStageSelectorPolicy#resolution
   */
  readonly resolution?: UsagePlanSpecForProviderApiStagesStageSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanSpecForProviderApiStagesStageSelectorPolicy#resolve
   */
  readonly resolve?: UsagePlanSpecForProviderApiStagesStageSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanSpecForProviderApiStagesStageSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanSpecForProviderApiStagesStageSelectorPolicy(obj: UsagePlanSpecForProviderApiStagesStageSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UsagePlanSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanSpecForProviderApiStagesApiIdRefPolicyResolution
 */
export enum UsagePlanSpecForProviderApiStagesApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanSpecForProviderApiStagesApiIdRefPolicyResolve
 */
export enum UsagePlanSpecForProviderApiStagesApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanSpecForProviderApiStagesApiIdSelectorPolicyResolution
 */
export enum UsagePlanSpecForProviderApiStagesApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanSpecForProviderApiStagesApiIdSelectorPolicyResolve
 */
export enum UsagePlanSpecForProviderApiStagesApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanSpecForProviderApiStagesStageRefPolicyResolution
 */
export enum UsagePlanSpecForProviderApiStagesStageRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanSpecForProviderApiStagesStageRefPolicyResolve
 */
export enum UsagePlanSpecForProviderApiStagesStageRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanSpecForProviderApiStagesStageSelectorPolicyResolution
 */
export enum UsagePlanSpecForProviderApiStagesStageSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanSpecForProviderApiStagesStageSelectorPolicyResolve
 */
export enum UsagePlanSpecForProviderApiStagesStageSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UsagePlanKey is the Schema for the UsagePlanKeys API. Provides an API Gateway Usage Plan Key.
 *
 * @schema UsagePlanKey
 */
export class UsagePlanKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UsagePlanKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'UsagePlanKey',
  }

  /**
   * Renders a Kubernetes manifest for "UsagePlanKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UsagePlanKeyProps): any {
    return {
      ...UsagePlanKey.GVK,
      ...toJson_UsagePlanKeyProps(props),
    };
  }

  /**
   * Defines a "UsagePlanKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UsagePlanKeyProps) {
    super(scope, id, {
      ...UsagePlanKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UsagePlanKey.GVK,
      ...toJson_UsagePlanKeyProps(resolved),
    };
  }
}

/**
 * UsagePlanKey is the Schema for the UsagePlanKeys API. Provides an API Gateway Usage Plan Key.
 *
 * @schema UsagePlanKey
 */
export interface UsagePlanKeyProps {
  /**
   * @schema UsagePlanKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UsagePlanKeySpec defines the desired state of UsagePlanKey
   *
   * @schema UsagePlanKey#spec
   */
  readonly spec: UsagePlanKeySpec;

}

/**
 * Converts an object of type 'UsagePlanKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeyProps(obj: UsagePlanKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UsagePlanKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UsagePlanKeySpec defines the desired state of UsagePlanKey
 *
 * @schema UsagePlanKeySpec
 */
export interface UsagePlanKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UsagePlanKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: UsagePlanKeySpecDeletionPolicy;

  /**
   * @schema UsagePlanKeySpec#forProvider
   */
  readonly forProvider: UsagePlanKeySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UsagePlanKeySpec#managementPolicy
   */
  readonly managementPolicy?: UsagePlanKeySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UsagePlanKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: UsagePlanKeySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UsagePlanKeySpec#providerRef
   */
  readonly providerRef?: UsagePlanKeySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UsagePlanKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UsagePlanKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UsagePlanKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UsagePlanKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UsagePlanKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpec(obj: UsagePlanKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UsagePlanKeySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_UsagePlanKeySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UsagePlanKeySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UsagePlanKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UsagePlanKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UsagePlanKeySpecDeletionPolicy
 */
export enum UsagePlanKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UsagePlanKeySpecForProvider
 */
export interface UsagePlanKeySpecForProvider {
  /**
   * Identifier of the API key resource.
   *
   * @schema UsagePlanKeySpecForProvider#keyId
   */
  readonly keyId?: string;

  /**
   * Reference to a APIKey in apigateway to populate keyId.
   *
   * @schema UsagePlanKeySpecForProvider#keyIdRef
   */
  readonly keyIdRef?: UsagePlanKeySpecForProviderKeyIdRef;

  /**
   * Selector for a APIKey in apigateway to populate keyId.
   *
   * @schema UsagePlanKeySpecForProvider#keyIdSelector
   */
  readonly keyIdSelector?: UsagePlanKeySpecForProviderKeyIdSelector;

  /**
   * Type of the API key resource. Currently, the valid key type is API_KEY.
   *
   * @schema UsagePlanKeySpecForProvider#keyType
   */
  readonly keyType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UsagePlanKeySpecForProvider#region
   */
  readonly region: string;

  /**
   * Id of the usage plan resource representing to associate the key to.
   *
   * @schema UsagePlanKeySpecForProvider#usagePlanId
   */
  readonly usagePlanId?: string;

  /**
   * Reference to a UsagePlan in apigateway to populate usagePlanId.
   *
   * @schema UsagePlanKeySpecForProvider#usagePlanIdRef
   */
  readonly usagePlanIdRef?: UsagePlanKeySpecForProviderUsagePlanIdRef;

  /**
   * Selector for a UsagePlan in apigateway to populate usagePlanId.
   *
   * @schema UsagePlanKeySpecForProvider#usagePlanIdSelector
   */
  readonly usagePlanIdSelector?: UsagePlanKeySpecForProviderUsagePlanIdSelector;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProvider(obj: UsagePlanKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
    'keyIdRef': toJson_UsagePlanKeySpecForProviderKeyIdRef(obj.keyIdRef),
    'keyIdSelector': toJson_UsagePlanKeySpecForProviderKeyIdSelector(obj.keyIdSelector),
    'keyType': obj.keyType,
    'region': obj.region,
    'usagePlanId': obj.usagePlanId,
    'usagePlanIdRef': toJson_UsagePlanKeySpecForProviderUsagePlanIdRef(obj.usagePlanIdRef),
    'usagePlanIdSelector': toJson_UsagePlanKeySpecForProviderUsagePlanIdSelector(obj.usagePlanIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UsagePlanKeySpecManagementPolicy
 */
export enum UsagePlanKeySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UsagePlanKeySpecProviderConfigRef
 */
export interface UsagePlanKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanKeySpecProviderConfigRef#policy
   */
  readonly policy?: UsagePlanKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecProviderConfigRef(obj: UsagePlanKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UsagePlanKeySpecProviderRef
 */
export interface UsagePlanKeySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanKeySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanKeySpecProviderRef#policy
   */
  readonly policy?: UsagePlanKeySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanKeySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecProviderRef(obj: UsagePlanKeySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanKeySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsTo
 */
export interface UsagePlanKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UsagePlanKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UsagePlanKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UsagePlanKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecPublishConnectionDetailsTo(obj: UsagePlanKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UsagePlanKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UsagePlanKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UsagePlanKeySpecWriteConnectionSecretToRef
 */
export interface UsagePlanKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UsagePlanKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UsagePlanKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UsagePlanKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecWriteConnectionSecretToRef(obj: UsagePlanKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a APIKey in apigateway to populate keyId.
 *
 * @schema UsagePlanKeySpecForProviderKeyIdRef
 */
export interface UsagePlanKeySpecForProviderKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanKeySpecForProviderKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanKeySpecForProviderKeyIdRef#policy
   */
  readonly policy?: UsagePlanKeySpecForProviderKeyIdRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderKeyIdRef(obj: UsagePlanKeySpecForProviderKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanKeySpecForProviderKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a APIKey in apigateway to populate keyId.
 *
 * @schema UsagePlanKeySpecForProviderKeyIdSelector
 */
export interface UsagePlanKeySpecForProviderKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UsagePlanKeySpecForProviderKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UsagePlanKeySpecForProviderKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UsagePlanKeySpecForProviderKeyIdSelector#policy
   */
  readonly policy?: UsagePlanKeySpecForProviderKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderKeyIdSelector(obj: UsagePlanKeySpecForProviderKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UsagePlanKeySpecForProviderKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UsagePlan in apigateway to populate usagePlanId.
 *
 * @schema UsagePlanKeySpecForProviderUsagePlanIdRef
 */
export interface UsagePlanKeySpecForProviderUsagePlanIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanKeySpecForProviderUsagePlanIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanKeySpecForProviderUsagePlanIdRef#policy
   */
  readonly policy?: UsagePlanKeySpecForProviderUsagePlanIdRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderUsagePlanIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderUsagePlanIdRef(obj: UsagePlanKeySpecForProviderUsagePlanIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanKeySpecForProviderUsagePlanIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UsagePlan in apigateway to populate usagePlanId.
 *
 * @schema UsagePlanKeySpecForProviderUsagePlanIdSelector
 */
export interface UsagePlanKeySpecForProviderUsagePlanIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UsagePlanKeySpecForProviderUsagePlanIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UsagePlanKeySpecForProviderUsagePlanIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UsagePlanKeySpecForProviderUsagePlanIdSelector#policy
   */
  readonly policy?: UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicy;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderUsagePlanIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderUsagePlanIdSelector(obj: UsagePlanKeySpecForProviderUsagePlanIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanKeySpecProviderConfigRefPolicy
 */
export interface UsagePlanKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UsagePlanKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UsagePlanKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecProviderConfigRefPolicy(obj: UsagePlanKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanKeySpecProviderRefPolicy
 */
export interface UsagePlanKeySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanKeySpecProviderRefPolicy#resolution
   */
  readonly resolution?: UsagePlanKeySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanKeySpecProviderRefPolicy#resolve
   */
  readonly resolve?: UsagePlanKeySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanKeySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecProviderRefPolicy(obj: UsagePlanKeySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRef
 */
export interface UsagePlanKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UsagePlanKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecPublishConnectionDetailsToConfigRef(obj: UsagePlanKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsToMetadata
 */
export interface UsagePlanKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UsagePlanKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecPublishConnectionDetailsToMetadata(obj: UsagePlanKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanKeySpecForProviderKeyIdRefPolicy
 */
export interface UsagePlanKeySpecForProviderKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanKeySpecForProviderKeyIdRefPolicy#resolution
   */
  readonly resolution?: UsagePlanKeySpecForProviderKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanKeySpecForProviderKeyIdRefPolicy#resolve
   */
  readonly resolve?: UsagePlanKeySpecForProviderKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderKeyIdRefPolicy(obj: UsagePlanKeySpecForProviderKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UsagePlanKeySpecForProviderKeyIdSelectorPolicy
 */
export interface UsagePlanKeySpecForProviderKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanKeySpecForProviderKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: UsagePlanKeySpecForProviderKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanKeySpecForProviderKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: UsagePlanKeySpecForProviderKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderKeyIdSelectorPolicy(obj: UsagePlanKeySpecForProviderKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsagePlanKeySpecForProviderUsagePlanIdRefPolicy
 */
export interface UsagePlanKeySpecForProviderUsagePlanIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanKeySpecForProviderUsagePlanIdRefPolicy#resolution
   */
  readonly resolution?: UsagePlanKeySpecForProviderUsagePlanIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanKeySpecForProviderUsagePlanIdRefPolicy#resolve
   */
  readonly resolve?: UsagePlanKeySpecForProviderUsagePlanIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderUsagePlanIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderUsagePlanIdRefPolicy(obj: UsagePlanKeySpecForProviderUsagePlanIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicy
 */
export interface UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicy#resolution
   */
  readonly resolution?: UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicy#resolve
   */
  readonly resolve?: UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicy(obj: UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanKeySpecProviderConfigRefPolicyResolution
 */
export enum UsagePlanKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanKeySpecProviderConfigRefPolicyResolve
 */
export enum UsagePlanKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanKeySpecProviderRefPolicyResolution
 */
export enum UsagePlanKeySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanKeySpecProviderRefPolicyResolve
 */
export enum UsagePlanKeySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanKeySpecForProviderKeyIdRefPolicyResolution
 */
export enum UsagePlanKeySpecForProviderKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanKeySpecForProviderKeyIdRefPolicyResolve
 */
export enum UsagePlanKeySpecForProviderKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanKeySpecForProviderKeyIdSelectorPolicyResolution
 */
export enum UsagePlanKeySpecForProviderKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanKeySpecForProviderKeyIdSelectorPolicyResolve
 */
export enum UsagePlanKeySpecForProviderKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanKeySpecForProviderUsagePlanIdRefPolicyResolution
 */
export enum UsagePlanKeySpecForProviderUsagePlanIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanKeySpecForProviderUsagePlanIdRefPolicyResolve
 */
export enum UsagePlanKeySpecForProviderUsagePlanIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicyResolution
 */
export enum UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicyResolve
 */
export enum UsagePlanKeySpecForProviderUsagePlanIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UsagePlanKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCLink is the Schema for the VPCLinks API. Provides an API Gateway VPC Link.
 *
 * @schema VPCLink
 */
export class VpcLink extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCLink"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apigateway.aws.upbound.io/v1beta1',
    kind: 'VPCLink',
  }

  /**
   * Renders a Kubernetes manifest for "VPCLink".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcLinkProps): any {
    return {
      ...VpcLink.GVK,
      ...toJson_VpcLinkProps(props),
    };
  }

  /**
   * Defines a "VPCLink" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcLinkProps) {
    super(scope, id, {
      ...VpcLink.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpcLink.GVK,
      ...toJson_VpcLinkProps(resolved),
    };
  }
}

/**
 * VPCLink is the Schema for the VPCLinks API. Provides an API Gateway VPC Link.
 *
 * @schema VPCLink
 */
export interface VpcLinkProps {
  /**
   * @schema VPCLink#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCLinkSpec defines the desired state of VPCLink
   *
   * @schema VPCLink#spec
   */
  readonly spec: VpcLinkSpec;

}

/**
 * Converts an object of type 'VpcLinkProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkProps(obj: VpcLinkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcLinkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCLinkSpec defines the desired state of VPCLink
 *
 * @schema VpcLinkSpec
 */
export interface VpcLinkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcLinkSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcLinkSpecDeletionPolicy;

  /**
   * @schema VpcLinkSpec#forProvider
   */
  readonly forProvider: VpcLinkSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcLinkSpec#managementPolicy
   */
  readonly managementPolicy?: VpcLinkSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcLinkSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcLinkSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema VpcLinkSpec#providerRef
   */
  readonly providerRef?: VpcLinkSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcLinkSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcLinkSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcLinkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcLinkSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcLinkSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpec(obj: VpcLinkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcLinkSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_VpcLinkSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_VpcLinkSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_VpcLinkSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcLinkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcLinkSpecDeletionPolicy
 */
export enum VpcLinkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VpcLinkSpecForProvider
 */
export interface VpcLinkSpecForProvider {
  /**
   * Description of the VPC link.
   *
   * @schema VpcLinkSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Name used to label and identify the VPC link.
   *
   * @schema VpcLinkSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VpcLinkSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema VpcLinkSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * References to LB in elbv2 to populate targetArns.
   *
   * @schema VpcLinkSpecForProvider#targetArnRefs
   */
  readonly targetArnRefs?: VpcLinkSpecForProviderTargetArnRefs[];

  /**
   * Selector for a list of LB in elbv2 to populate targetArns.
   *
   * @schema VpcLinkSpecForProvider#targetArnSelector
   */
  readonly targetArnSelector?: VpcLinkSpecForProviderTargetArnSelector;

  /**
   * List of network load balancer arns in the VPC targeted by the VPC link. Currently AWS only supports 1 target.
   *
   * @schema VpcLinkSpecForProvider#targetArns
   */
  readonly targetArns?: string[];

}

/**
 * Converts an object of type 'VpcLinkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProvider(obj: VpcLinkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetArnRefs': obj.targetArnRefs?.map(y => toJson_VpcLinkSpecForProviderTargetArnRefs(y)),
    'targetArnSelector': toJson_VpcLinkSpecForProviderTargetArnSelector(obj.targetArnSelector),
    'targetArns': obj.targetArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcLinkSpecManagementPolicy
 */
export enum VpcLinkSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcLinkSpecProviderConfigRef
 */
export interface VpcLinkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecProviderConfigRef#policy
   */
  readonly policy?: VpcLinkSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderConfigRef(obj: VpcLinkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema VpcLinkSpecProviderRef
 */
export interface VpcLinkSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecProviderRef#policy
   */
  readonly policy?: VpcLinkSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderRef(obj: VpcLinkSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsTo
 */
export interface VpcLinkSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcLinkSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcLinkSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsTo(obj: VpcLinkSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcLinkSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcLinkSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcLinkSpecWriteConnectionSecretToRef
 */
export interface VpcLinkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcLinkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcLinkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcLinkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecWriteConnectionSecretToRef(obj: VpcLinkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcLinkSpecForProviderTargetArnRefs
 */
export interface VpcLinkSpecForProviderTargetArnRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecForProviderTargetArnRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecForProviderTargetArnRefs#policy
   */
  readonly policy?: VpcLinkSpecForProviderTargetArnRefsPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderTargetArnRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderTargetArnRefs(obj: VpcLinkSpecForProviderTargetArnRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecForProviderTargetArnRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of LB in elbv2 to populate targetArns.
 *
 * @schema VpcLinkSpecForProviderTargetArnSelector
 */
export interface VpcLinkSpecForProviderTargetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcLinkSpecForProviderTargetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcLinkSpecForProviderTargetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcLinkSpecForProviderTargetArnSelector#policy
   */
  readonly policy?: VpcLinkSpecForProviderTargetArnSelectorPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderTargetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderTargetArnSelector(obj: VpcLinkSpecForProviderTargetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcLinkSpecForProviderTargetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicy
 */
export interface VpcLinkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderConfigRefPolicy(obj: VpcLinkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecProviderRefPolicy
 */
export interface VpcLinkSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecProviderRefPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecProviderRefPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecProviderRefPolicy(obj: VpcLinkSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcLinkSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToConfigRef(obj: VpcLinkSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToMetadata
 */
export interface VpcLinkSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToMetadata(obj: VpcLinkSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecForProviderTargetArnRefsPolicy
 */
export interface VpcLinkSpecForProviderTargetArnRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecForProviderTargetArnRefsPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecForProviderTargetArnRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecForProviderTargetArnRefsPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecForProviderTargetArnRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderTargetArnRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderTargetArnRefsPolicy(obj: VpcLinkSpecForProviderTargetArnRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcLinkSpecForProviderTargetArnSelectorPolicy
 */
export interface VpcLinkSpecForProviderTargetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecForProviderTargetArnSelectorPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecForProviderTargetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecForProviderTargetArnSelectorPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecForProviderTargetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecForProviderTargetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecForProviderTargetArnSelectorPolicy(obj: VpcLinkSpecForProviderTargetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicyResolution
 */
export enum VpcLinkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecProviderConfigRefPolicyResolve
 */
export enum VpcLinkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecProviderRefPolicyResolution
 */
export enum VpcLinkSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecProviderRefPolicyResolve
 */
export enum VpcLinkSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcLinkSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecForProviderTargetArnRefsPolicyResolution
 */
export enum VpcLinkSpecForProviderTargetArnRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecForProviderTargetArnRefsPolicyResolve
 */
export enum VpcLinkSpecForProviderTargetArnRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecForProviderTargetArnSelectorPolicyResolution
 */
export enum VpcLinkSpecForProviderTargetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecForProviderTargetArnSelectorPolicyResolve
 */
export enum VpcLinkSpecForProviderTargetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcLinkSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

