// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Instance is the Schema for the Instances API. A Google Cloud Memcache instance.
 *
 * @schema Instance
 */
export class Instance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Instance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'memcache.gcp.upbound.io/v1beta1',
    kind: 'Instance',
  }

  /**
   * Renders a Kubernetes manifest for "Instance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceProps): any {
    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(props),
    };
  }

  /**
   * Defines a "Instance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceProps) {
    super(scope, id, {
      ...Instance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(resolved),
    };
  }
}

/**
 * Instance is the Schema for the Instances API. A Google Cloud Memcache instance.
 *
 * @schema Instance
 */
export interface InstanceProps {
  /**
   * @schema Instance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceSpec defines the desired state of Instance
   *
   * @schema Instance#spec
   */
  readonly spec: InstanceSpec;

}

/**
 * Converts an object of type 'InstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProps(obj: InstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSpec defines the desired state of Instance
 *
 * @schema InstanceSpec
 */
export interface InstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceSpecDeletionPolicy;

  /**
   * @schema InstanceSpec#forProvider
   */
  readonly forProvider: InstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema InstanceSpec#initProvider
   */
  readonly initProvider?: InstanceSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InstanceSpec#managementPolicies
   */
  readonly managementPolicies?: InstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpec(obj: InstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceSpecForProvider(obj.forProvider),
    'initProvider': toJson_InstanceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecDeletionPolicy
 */
export enum InstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceSpecForProvider
 */
export interface InstanceSpecForProvider {
  /**
   * The full name of the GCE network to connect the instance to.  If not provided, 'default' will be used.
   *
   * @schema InstanceSpecForProvider#authorizedNetwork
   */
  readonly authorizedNetwork?: string;

  /**
   * Reference to a Connection in servicenetworking to populate authorizedNetwork.
   *
   * @schema InstanceSpecForProvider#authorizedNetworkRef
   */
  readonly authorizedNetworkRef?: InstanceSpecForProviderAuthorizedNetworkRef;

  /**
   * Selector for a Connection in servicenetworking to populate authorizedNetwork.
   *
   * @schema InstanceSpecForProvider#authorizedNetworkSelector
   */
  readonly authorizedNetworkSelector?: InstanceSpecForProviderAuthorizedNetworkSelector;

  /**
   * A user-visible name for the instance.
   *
   * @schema InstanceSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Resource labels to represent user-provided metadata.
   *
   * @schema InstanceSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Maintenance policy for an instance. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#maintenancePolicy
   */
  readonly maintenancePolicy?: InstanceSpecForProviderMaintenancePolicy[];

  /**
   * User-specified parameters for this memcache instance. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#memcacheParameters
   */
  readonly memcacheParameters?: InstanceSpecForProviderMemcacheParameters[];

  /**
   * The major version of Memcached software. If not provided, latest supported version will be used. Currently the latest supported major version is MEMCACHE_1_5. The minor version will be automatically determined by our system based on the latest supported minor version. Default value is MEMCACHE_1_5. Possible values are: MEMCACHE_1_5.
   *
   * @schema InstanceSpecForProvider#memcacheVersion
   */
  readonly memcacheVersion?: string;

  /**
   * The resource name of the instance.
   *
   * @schema InstanceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Configuration for memcache nodes. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#nodeConfig
   */
  readonly nodeConfig?: InstanceSpecForProviderNodeConfig[];

  /**
   * Number of nodes in the memcache instance.
   *
   * @schema InstanceSpecForProvider#nodeCount
   */
  readonly nodeCount?: number;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema InstanceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region of the Memcache instance. If it is not provided, the provider region is used.
   *
   * @schema InstanceSpecForProvider#region
   */
  readonly region?: string;

  /**
   * Zones where memcache nodes should be provisioned.  If not provided, all zones will be used.
   *
   * @schema InstanceSpecForProvider#zones
   */
  readonly zones?: string[];

}

/**
 * Converts an object of type 'InstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProvider(obj: InstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedNetwork': obj.authorizedNetwork,
    'authorizedNetworkRef': toJson_InstanceSpecForProviderAuthorizedNetworkRef(obj.authorizedNetworkRef),
    'authorizedNetworkSelector': toJson_InstanceSpecForProviderAuthorizedNetworkSelector(obj.authorizedNetworkSelector),
    'displayName': obj.displayName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'maintenancePolicy': obj.maintenancePolicy?.map(y => toJson_InstanceSpecForProviderMaintenancePolicy(y)),
    'memcacheParameters': obj.memcacheParameters?.map(y => toJson_InstanceSpecForProviderMemcacheParameters(y)),
    'memcacheVersion': obj.memcacheVersion,
    'name': obj.name,
    'nodeConfig': obj.nodeConfig?.map(y => toJson_InstanceSpecForProviderNodeConfig(y)),
    'nodeCount': obj.nodeCount,
    'project': obj.project,
    'region': obj.region,
    'zones': obj.zones?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema InstanceSpecInitProvider
 */
export interface InstanceSpecInitProvider {
  /**
   * A user-visible name for the instance.
   *
   * @schema InstanceSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Resource labels to represent user-provided metadata.
   *
   * @schema InstanceSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Maintenance policy for an instance. Structure is documented below.
   *
   * @schema InstanceSpecInitProvider#maintenancePolicy
   */
  readonly maintenancePolicy?: InstanceSpecInitProviderMaintenancePolicy[];

  /**
   * User-specified parameters for this memcache instance. Structure is documented below.
   *
   * @schema InstanceSpecInitProvider#memcacheParameters
   */
  readonly memcacheParameters?: InstanceSpecInitProviderMemcacheParameters[];

  /**
   * The major version of Memcached software. If not provided, latest supported version will be used. Currently the latest supported major version is MEMCACHE_1_5. The minor version will be automatically determined by our system based on the latest supported minor version. Default value is MEMCACHE_1_5. Possible values are: MEMCACHE_1_5.
   *
   * @schema InstanceSpecInitProvider#memcacheVersion
   */
  readonly memcacheVersion?: string;

  /**
   * The resource name of the instance.
   *
   * @schema InstanceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Configuration for memcache nodes. Structure is documented below.
   *
   * @schema InstanceSpecInitProvider#nodeConfig
   */
  readonly nodeConfig?: InstanceSpecInitProviderNodeConfig[];

  /**
   * Number of nodes in the memcache instance.
   *
   * @schema InstanceSpecInitProvider#nodeCount
   */
  readonly nodeCount?: number;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema InstanceSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The region of the Memcache instance. If it is not provided, the provider region is used.
   *
   * @schema InstanceSpecInitProvider#region
   */
  readonly region?: string;

  /**
   * Zones where memcache nodes should be provisioned.  If not provided, all zones will be used.
   *
   * @schema InstanceSpecInitProvider#zones
   */
  readonly zones?: string[];

}

/**
 * Converts an object of type 'InstanceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProvider(obj: InstanceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'maintenancePolicy': obj.maintenancePolicy?.map(y => toJson_InstanceSpecInitProviderMaintenancePolicy(y)),
    'memcacheParameters': obj.memcacheParameters?.map(y => toJson_InstanceSpecInitProviderMemcacheParameters(y)),
    'memcacheVersion': obj.memcacheVersion,
    'name': obj.name,
    'nodeConfig': obj.nodeConfig?.map(y => toJson_InstanceSpecInitProviderNodeConfig(y)),
    'nodeCount': obj.nodeCount,
    'project': obj.project,
    'region': obj.region,
    'zones': obj.zones?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InstanceSpecManagementPolicies
 */
export enum InstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceSpecProviderConfigRef
 */
export interface InstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRef(obj: InstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceSpecPublishConnectionDetailsTo
 */
export interface InstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsTo(obj: InstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceSpecWriteConnectionSecretToRef
 */
export interface InstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecWriteConnectionSecretToRef(obj: InstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection in servicenetworking to populate authorizedNetwork.
 *
 * @schema InstanceSpecForProviderAuthorizedNetworkRef
 */
export interface InstanceSpecForProviderAuthorizedNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderAuthorizedNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderAuthorizedNetworkRef#policy
   */
  readonly policy?: InstanceSpecForProviderAuthorizedNetworkRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderAuthorizedNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderAuthorizedNetworkRef(obj: InstanceSpecForProviderAuthorizedNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderAuthorizedNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection in servicenetworking to populate authorizedNetwork.
 *
 * @schema InstanceSpecForProviderAuthorizedNetworkSelector
 */
export interface InstanceSpecForProviderAuthorizedNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderAuthorizedNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderAuthorizedNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderAuthorizedNetworkSelector#policy
   */
  readonly policy?: InstanceSpecForProviderAuthorizedNetworkSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderAuthorizedNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderAuthorizedNetworkSelector(obj: InstanceSpecForProviderAuthorizedNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderAuthorizedNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderMaintenancePolicy
 */
export interface InstanceSpecForProviderMaintenancePolicy {
  /**
   * Optional. Description of what this policy is for. Create/Update methods return INVALID_ARGUMENT if the length is greater than 512.
   *
   * @schema InstanceSpecForProviderMaintenancePolicy#description
   */
  readonly description?: string;

  /**
   * Required. Maintenance window that is applied to resources covered by this policy. Minimum 1. For the current version, the maximum number of weekly_maintenance_windows is expected to be one. Structure is documented below.
   *
   * @schema InstanceSpecForProviderMaintenancePolicy#weeklyMaintenanceWindow
   */
  readonly weeklyMaintenanceWindow?: InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow[];

}

/**
 * Converts an object of type 'InstanceSpecForProviderMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMaintenancePolicy(obj: InstanceSpecForProviderMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'weeklyMaintenanceWindow': obj.weeklyMaintenanceWindow?.map(y => toJson_InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderMemcacheParameters
 */
export interface InstanceSpecForProviderMemcacheParameters {
  /**
   * User-defined set of parameters to use in the memcache process.
   *
   * @schema InstanceSpecForProviderMemcacheParameters#params
   */
  readonly params?: { [key: string]: string };

}

/**
 * Converts an object of type 'InstanceSpecForProviderMemcacheParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMemcacheParameters(obj: InstanceSpecForProviderMemcacheParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderNodeConfig
 */
export interface InstanceSpecForProviderNodeConfig {
  /**
   * Number of CPUs per node.
   *
   * @schema InstanceSpecForProviderNodeConfig#cpuCount
   */
  readonly cpuCount?: number;

  /**
   * Memory size in Mebibytes for each memcache node.
   *
   * @schema InstanceSpecForProviderNodeConfig#memorySizeMb
   */
  readonly memorySizeMb?: number;

}

/**
 * Converts an object of type 'InstanceSpecForProviderNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderNodeConfig(obj: InstanceSpecForProviderNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpuCount': obj.cpuCount,
    'memorySizeMb': obj.memorySizeMb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderMaintenancePolicy
 */
export interface InstanceSpecInitProviderMaintenancePolicy {
  /**
   * Optional. Description of what this policy is for. Create/Update methods return INVALID_ARGUMENT if the length is greater than 512.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicy#description
   */
  readonly description?: string;

  /**
   * Required. Maintenance window that is applied to resources covered by this policy. Minimum 1. For the current version, the maximum number of weekly_maintenance_windows is expected to be one. Structure is documented below.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicy#weeklyMaintenanceWindow
   */
  readonly weeklyMaintenanceWindow?: InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow[];

}

/**
 * Converts an object of type 'InstanceSpecInitProviderMaintenancePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderMaintenancePolicy(obj: InstanceSpecInitProviderMaintenancePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'weeklyMaintenanceWindow': obj.weeklyMaintenanceWindow?.map(y => toJson_InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderMemcacheParameters
 */
export interface InstanceSpecInitProviderMemcacheParameters {
  /**
   * User-defined set of parameters to use in the memcache process.
   *
   * @schema InstanceSpecInitProviderMemcacheParameters#params
   */
  readonly params?: { [key: string]: string };

}

/**
 * Converts an object of type 'InstanceSpecInitProviderMemcacheParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderMemcacheParameters(obj: InstanceSpecInitProviderMemcacheParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'params': ((obj.params) === undefined) ? undefined : (Object.entries(obj.params).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderNodeConfig
 */
export interface InstanceSpecInitProviderNodeConfig {
  /**
   * Number of CPUs per node.
   *
   * @schema InstanceSpecInitProviderNodeConfig#cpuCount
   */
  readonly cpuCount?: number;

  /**
   * Memory size in Mebibytes for each memcache node.
   *
   * @schema InstanceSpecInitProviderNodeConfig#memorySizeMb
   */
  readonly memorySizeMb?: number;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderNodeConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderNodeConfig(obj: InstanceSpecInitProviderNodeConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpuCount': obj.cpuCount,
    'memorySizeMb': obj.memorySizeMb,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderConfigRefPolicy
 */
export interface InstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRefPolicy(obj: InstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj: InstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj: InstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderAuthorizedNetworkRefPolicy
 */
export interface InstanceSpecForProviderAuthorizedNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderAuthorizedNetworkRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderAuthorizedNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderAuthorizedNetworkRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderAuthorizedNetworkRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderAuthorizedNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderAuthorizedNetworkRefPolicy(obj: InstanceSpecForProviderAuthorizedNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderAuthorizedNetworkSelectorPolicy
 */
export interface InstanceSpecForProviderAuthorizedNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderAuthorizedNetworkSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderAuthorizedNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderAuthorizedNetworkSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderAuthorizedNetworkSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderAuthorizedNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderAuthorizedNetworkSelectorPolicy(obj: InstanceSpecForProviderAuthorizedNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow
 */
export interface InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow {
  /**
   * Required. The day of week that maintenance updates occur.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow#day
   */
  readonly day?: string;

  /**
   * Required. The length of the maintenance window, ranging from 3 hours to 8 hours. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow#duration
   */
  readonly duration?: string;

  /**
   * Required. Start time of the window in UTC time. Structure is documented below.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow#startTime
   */
  readonly startTime?: InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime[];

}

/**
 * Converts an object of type 'InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow(obj: InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'duration': obj.duration,
    'startTime': obj.startTime?.map(y => toJson_InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow
 */
export interface InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow {
  /**
   * Required. The day of week that maintenance updates occur.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow#day
   */
  readonly day?: string;

  /**
   * Required. The length of the maintenance window, ranging from 3 hours to 8 hours. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow#duration
   */
  readonly duration?: string;

  /**
   * Required. Start time of the window in UTC time. Structure is documented below.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow#startTime
   */
  readonly startTime?: InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime[];

}

/**
 * Converts an object of type 'InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow(obj: InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'day': obj.day,
    'duration': obj.duration,
    'startTime': obj.startTime?.map(y => toJson_InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolution
 */
export enum InstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolve
 */
export enum InstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderAuthorizedNetworkRefPolicyResolution
 */
export enum InstanceSpecForProviderAuthorizedNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderAuthorizedNetworkRefPolicyResolve
 */
export enum InstanceSpecForProviderAuthorizedNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderAuthorizedNetworkSelectorPolicyResolution
 */
export enum InstanceSpecForProviderAuthorizedNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderAuthorizedNetworkSelectorPolicyResolve
 */
export enum InstanceSpecForProviderAuthorizedNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime
 */
export interface InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime(obj: InstanceSpecForProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime
 */
export interface InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime {
  /**
   * Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#hours
   */
  readonly hours?: number;

  /**
   * Minutes of hour of day. Must be from 0 to 59.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#minutes
   */
  readonly minutes?: number;

  /**
   * Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#nanos
   */
  readonly nanos?: number;

  /**
   * Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
   *
   * @schema InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime#seconds
   */
  readonly seconds?: number;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime(obj: InstanceSpecInitProviderMaintenancePolicyWeeklyMaintenanceWindowStartTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hours': obj.hours,
    'minutes': obj.minutes,
    'nanos': obj.nanos,
    'seconds': obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

