// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Instance is the Schema for the Instances API. Represents a Data Fusion instance.
 *
 * @schema Instance
 */
export class Instance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Instance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datafusion.gcp.upbound.io/v1beta1',
    kind: 'Instance',
  }

  /**
   * Renders a Kubernetes manifest for "Instance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceProps): any {
    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(props),
    };
  }

  /**
   * Defines a "Instance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceProps) {
    super(scope, id, {
      ...Instance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(resolved),
    };
  }
}

/**
 * Instance is the Schema for the Instances API. Represents a Data Fusion instance.
 *
 * @schema Instance
 */
export interface InstanceProps {
  /**
   * @schema Instance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceSpec defines the desired state of Instance
   *
   * @schema Instance#spec
   */
  readonly spec: InstanceSpec;

}

/**
 * Converts an object of type 'InstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProps(obj: InstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSpec defines the desired state of Instance
 *
 * @schema InstanceSpec
 */
export interface InstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceSpecDeletionPolicy;

  /**
   * @schema InstanceSpec#forProvider
   */
  readonly forProvider: InstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema InstanceSpec#initProvider
   */
  readonly initProvider?: InstanceSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InstanceSpec#managementPolicies
   */
  readonly managementPolicies?: InstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpec(obj: InstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceSpecForProvider(obj.forProvider),
    'initProvider': toJson_InstanceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecDeletionPolicy
 */
export enum InstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceSpecForProvider
 */
export interface InstanceSpecForProvider {
  /**
   * List of accelerators enabled for this CDF instance. If accelerators are enabled it is possible a permadiff will be created with the Options field. Users will need to either manually update their state file to include these diffed options, or include the field in a lifecycle ignore changes block. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#accelerators
   */
  readonly accelerators?: InstanceSpecForProviderAccelerators[];

  /**
   * The crypto key configuration. This field is used by the Customer-Managed Encryption Keys (CMEK) feature. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#cryptoKeyConfig
   */
  readonly cryptoKeyConfig?: InstanceSpecForProviderCryptoKeyConfig[];

  /**
   * User-managed service account to set on Dataproc when Cloud Data Fusion creates Dataproc to run data processing pipelines.
   *
   * @schema InstanceSpecForProvider#dataprocServiceAccount
   */
  readonly dataprocServiceAccount?: string;

  /**
   * An optional description of the instance.
   *
   * @schema InstanceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Display name for an instance.
   *
   * @schema InstanceSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Option to enable granular role-based access control.
   *
   * @schema InstanceSpecForProvider#enableRbac
   */
  readonly enableRbac?: boolean;

  /**
   * Option to enable Stackdriver Logging.
   *
   * @schema InstanceSpecForProvider#enableStackdriverLogging
   */
  readonly enableStackdriverLogging?: boolean;

  /**
   * Option to enable Stackdriver Monitoring.
   *
   * @schema InstanceSpecForProvider#enableStackdriverMonitoring
   */
  readonly enableStackdriverMonitoring?: boolean;

  /**
   * Option to enable and pass metadata for event publishing. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#eventPublishConfig
   */
  readonly eventPublishConfig?: InstanceSpecForProviderEventPublishConfig[];

  /**
   * The resource labels for instance to use to annotate any related underlying resources, such as Compute Engine VMs.
   *
   * @schema InstanceSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Network configuration options. These are required when a private Data Fusion instance is to be created. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#networkConfig
   */
  readonly networkConfig?: InstanceSpecForProviderNetworkConfig[];

  /**
   * Map of additional options used to configure the behavior of Data Fusion instance.
   *
   * @schema InstanceSpecForProvider#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Specifies whether the Data Fusion instance should be private. If set to true, all Data Fusion nodes will have private IP addresses and will not be able to access the public internet.
   *
   * @schema InstanceSpecForProvider#privateInstance
   */
  readonly privateInstance?: boolean;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema InstanceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region of the Data Fusion instance.
   *
   * @schema InstanceSpecForProvider#region
   */
  readonly region?: string;

  /**
   * Represents the type of Data Fusion instance. Each type is configured with the default settings for processing and memory.
   *
   * @schema InstanceSpecForProvider#type
   */
  readonly type?: string;

  /**
   * Current version of the Data Fusion.
   *
   * @schema InstanceSpecForProvider#version
   */
  readonly version?: string;

  /**
   * Name of the zone in which the Data Fusion instance will be created. Only DEVELOPER instances use this field.
   *
   * @schema InstanceSpecForProvider#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProvider(obj: InstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accelerators': obj.accelerators?.map(y => toJson_InstanceSpecForProviderAccelerators(y)),
    'cryptoKeyConfig': obj.cryptoKeyConfig?.map(y => toJson_InstanceSpecForProviderCryptoKeyConfig(y)),
    'dataprocServiceAccount': obj.dataprocServiceAccount,
    'description': obj.description,
    'displayName': obj.displayName,
    'enableRbac': obj.enableRbac,
    'enableStackdriverLogging': obj.enableStackdriverLogging,
    'enableStackdriverMonitoring': obj.enableStackdriverMonitoring,
    'eventPublishConfig': obj.eventPublishConfig?.map(y => toJson_InstanceSpecForProviderEventPublishConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'networkConfig': obj.networkConfig?.map(y => toJson_InstanceSpecForProviderNetworkConfig(y)),
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'privateInstance': obj.privateInstance,
    'project': obj.project,
    'region': obj.region,
    'type': obj.type,
    'version': obj.version,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema InstanceSpecInitProvider
 */
export interface InstanceSpecInitProvider {
  /**
   * List of accelerators enabled for this CDF instance. If accelerators are enabled it is possible a permadiff will be created with the Options field. Users will need to either manually update their state file to include these diffed options, or include the field in a lifecycle ignore changes block. Structure is documented below.
   *
   * @schema InstanceSpecInitProvider#accelerators
   */
  readonly accelerators?: InstanceSpecInitProviderAccelerators[];

  /**
   * The crypto key configuration. This field is used by the Customer-Managed Encryption Keys (CMEK) feature. Structure is documented below.
   *
   * @schema InstanceSpecInitProvider#cryptoKeyConfig
   */
  readonly cryptoKeyConfig?: any[];

  /**
   * User-managed service account to set on Dataproc when Cloud Data Fusion creates Dataproc to run data processing pipelines.
   *
   * @schema InstanceSpecInitProvider#dataprocServiceAccount
   */
  readonly dataprocServiceAccount?: string;

  /**
   * An optional description of the instance.
   *
   * @schema InstanceSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Display name for an instance.
   *
   * @schema InstanceSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Option to enable granular role-based access control.
   *
   * @schema InstanceSpecInitProvider#enableRbac
   */
  readonly enableRbac?: boolean;

  /**
   * Option to enable Stackdriver Logging.
   *
   * @schema InstanceSpecInitProvider#enableStackdriverLogging
   */
  readonly enableStackdriverLogging?: boolean;

  /**
   * Option to enable Stackdriver Monitoring.
   *
   * @schema InstanceSpecInitProvider#enableStackdriverMonitoring
   */
  readonly enableStackdriverMonitoring?: boolean;

  /**
   * Option to enable and pass metadata for event publishing. Structure is documented below.
   *
   * @schema InstanceSpecInitProvider#eventPublishConfig
   */
  readonly eventPublishConfig?: InstanceSpecInitProviderEventPublishConfig[];

  /**
   * The resource labels for instance to use to annotate any related underlying resources, such as Compute Engine VMs.
   *
   * @schema InstanceSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Network configuration options. These are required when a private Data Fusion instance is to be created. Structure is documented below.
   *
   * @schema InstanceSpecInitProvider#networkConfig
   */
  readonly networkConfig?: InstanceSpecInitProviderNetworkConfig[];

  /**
   * Map of additional options used to configure the behavior of Data Fusion instance.
   *
   * @schema InstanceSpecInitProvider#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Specifies whether the Data Fusion instance should be private. If set to true, all Data Fusion nodes will have private IP addresses and will not be able to access the public internet.
   *
   * @schema InstanceSpecInitProvider#privateInstance
   */
  readonly privateInstance?: boolean;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema InstanceSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Represents the type of Data Fusion instance. Each type is configured with the default settings for processing and memory.
   *
   * @schema InstanceSpecInitProvider#type
   */
  readonly type?: string;

  /**
   * Current version of the Data Fusion.
   *
   * @schema InstanceSpecInitProvider#version
   */
  readonly version?: string;

  /**
   * Name of the zone in which the Data Fusion instance will be created. Only DEVELOPER instances use this field.
   *
   * @schema InstanceSpecInitProvider#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'InstanceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProvider(obj: InstanceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accelerators': obj.accelerators?.map(y => toJson_InstanceSpecInitProviderAccelerators(y)),
    'cryptoKeyConfig': obj.cryptoKeyConfig?.map(y => y),
    'dataprocServiceAccount': obj.dataprocServiceAccount,
    'description': obj.description,
    'displayName': obj.displayName,
    'enableRbac': obj.enableRbac,
    'enableStackdriverLogging': obj.enableStackdriverLogging,
    'enableStackdriverMonitoring': obj.enableStackdriverMonitoring,
    'eventPublishConfig': obj.eventPublishConfig?.map(y => toJson_InstanceSpecInitProviderEventPublishConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'networkConfig': obj.networkConfig?.map(y => toJson_InstanceSpecInitProviderNetworkConfig(y)),
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'privateInstance': obj.privateInstance,
    'project': obj.project,
    'type': obj.type,
    'version': obj.version,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InstanceSpecManagementPolicies
 */
export enum InstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceSpecProviderConfigRef
 */
export interface InstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRef(obj: InstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceSpecPublishConnectionDetailsTo
 */
export interface InstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsTo(obj: InstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceSpecWriteConnectionSecretToRef
 */
export interface InstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecWriteConnectionSecretToRef(obj: InstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderAccelerators
 */
export interface InstanceSpecForProviderAccelerators {
  /**
   * The type of an accelator for a CDF instance. Possible values are: CDC, HEALTHCARE, CCAI_INSIGHTS.
   *
   * @schema InstanceSpecForProviderAccelerators#acceleratorType
   */
  readonly acceleratorType?: string;

  /**
   * The type of an accelator for a CDF instance. Possible values are: ENABLED, DISABLED.
   *
   * @schema InstanceSpecForProviderAccelerators#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderAccelerators' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderAccelerators(obj: InstanceSpecForProviderAccelerators | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorType': obj.acceleratorType,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderCryptoKeyConfig
 */
export interface InstanceSpecForProviderCryptoKeyConfig {
  /**
   * The name of the key which is used to encrypt/decrypt customer data. For key in Cloud KMS, the key should be in the format of projects//locations//keyRings//cryptoKeys/.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfig#keyReference
   */
  readonly keyReference?: string;

  /**
   * Reference to a CryptoKey in kms to populate keyReference.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfig#keyReferenceRef
   */
  readonly keyReferenceRef?: InstanceSpecForProviderCryptoKeyConfigKeyReferenceRef;

  /**
   * Selector for a CryptoKey in kms to populate keyReference.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfig#keyReferenceSelector
   */
  readonly keyReferenceSelector?: InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelector;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCryptoKeyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCryptoKeyConfig(obj: InstanceSpecForProviderCryptoKeyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyReference': obj.keyReference,
    'keyReferenceRef': toJson_InstanceSpecForProviderCryptoKeyConfigKeyReferenceRef(obj.keyReferenceRef),
    'keyReferenceSelector': toJson_InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelector(obj.keyReferenceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderEventPublishConfig
 */
export interface InstanceSpecForProviderEventPublishConfig {
  /**
   * Option to enable Event Publishing.
   *
   * @schema InstanceSpecForProviderEventPublishConfig#enabled
   */
  readonly enabled?: boolean;

  /**
   * The resource name of the Pub/Sub topic. Format: projects/{projectId}/topics/{topic_id}
   *
   * @schema InstanceSpecForProviderEventPublishConfig#topic
   */
  readonly topic?: string;

  /**
   * Reference to a Topic in pubsub to populate topic.
   *
   * @schema InstanceSpecForProviderEventPublishConfig#topicRef
   */
  readonly topicRef?: InstanceSpecForProviderEventPublishConfigTopicRef;

  /**
   * Selector for a Topic in pubsub to populate topic.
   *
   * @schema InstanceSpecForProviderEventPublishConfig#topicSelector
   */
  readonly topicSelector?: InstanceSpecForProviderEventPublishConfigTopicSelector;

}

/**
 * Converts an object of type 'InstanceSpecForProviderEventPublishConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderEventPublishConfig(obj: InstanceSpecForProviderEventPublishConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'topic': obj.topic,
    'topicRef': toJson_InstanceSpecForProviderEventPublishConfigTopicRef(obj.topicRef),
    'topicSelector': toJson_InstanceSpecForProviderEventPublishConfigTopicSelector(obj.topicSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderNetworkConfig
 */
export interface InstanceSpecForProviderNetworkConfig {
  /**
   * The IP range in CIDR notation to use for the managed Data Fusion instance nodes. This range must not overlap with any other ranges used in the Data Fusion instance network.
   *
   * @schema InstanceSpecForProviderNetworkConfig#ipAllocation
   */
  readonly ipAllocation?: string;

  /**
   * Name of the network in the project with which the tenant project will be peered for executing pipelines. In case of shared VPC where the network resides in another host project the network should specified in the form of projects/{host-project-id}/global/networks/{network}
   *
   * @schema InstanceSpecForProviderNetworkConfig#network
   */
  readonly network?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderNetworkConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderNetworkConfig(obj: InstanceSpecForProviderNetworkConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAllocation': obj.ipAllocation,
    'network': obj.network,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderAccelerators
 */
export interface InstanceSpecInitProviderAccelerators {
  /**
   * The type of an accelator for a CDF instance. Possible values are: CDC, HEALTHCARE, CCAI_INSIGHTS.
   *
   * @schema InstanceSpecInitProviderAccelerators#acceleratorType
   */
  readonly acceleratorType?: string;

  /**
   * The type of an accelator for a CDF instance. Possible values are: ENABLED, DISABLED.
   *
   * @schema InstanceSpecInitProviderAccelerators#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderAccelerators' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderAccelerators(obj: InstanceSpecInitProviderAccelerators | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorType': obj.acceleratorType,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderEventPublishConfig
 */
export interface InstanceSpecInitProviderEventPublishConfig {
  /**
   * Option to enable Event Publishing.
   *
   * @schema InstanceSpecInitProviderEventPublishConfig#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderEventPublishConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderEventPublishConfig(obj: InstanceSpecInitProviderEventPublishConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderNetworkConfig
 */
export interface InstanceSpecInitProviderNetworkConfig {
  /**
   * The IP range in CIDR notation to use for the managed Data Fusion instance nodes. This range must not overlap with any other ranges used in the Data Fusion instance network.
   *
   * @schema InstanceSpecInitProviderNetworkConfig#ipAllocation
   */
  readonly ipAllocation?: string;

  /**
   * Name of the network in the project with which the tenant project will be peered for executing pipelines. In case of shared VPC where the network resides in another host project the network should specified in the form of projects/{host-project-id}/global/networks/{network}
   *
   * @schema InstanceSpecInitProviderNetworkConfig#network
   */
  readonly network?: string;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderNetworkConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderNetworkConfig(obj: InstanceSpecInitProviderNetworkConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAllocation': obj.ipAllocation,
    'network': obj.network,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderConfigRefPolicy
 */
export interface InstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRefPolicy(obj: InstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj: InstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj: InstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate keyReference.
 *
 * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceRef
 */
export interface InstanceSpecForProviderCryptoKeyConfigKeyReferenceRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceRef#policy
   */
  readonly policy?: InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCryptoKeyConfigKeyReferenceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCryptoKeyConfigKeyReferenceRef(obj: InstanceSpecForProviderCryptoKeyConfigKeyReferenceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate keyReference.
 *
 * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelector
 */
export interface InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelector#policy
   */
  readonly policy?: InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelector(obj: InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in pubsub to populate topic.
 *
 * @schema InstanceSpecForProviderEventPublishConfigTopicRef
 */
export interface InstanceSpecForProviderEventPublishConfigTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderEventPublishConfigTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderEventPublishConfigTopicRef#policy
   */
  readonly policy?: InstanceSpecForProviderEventPublishConfigTopicRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderEventPublishConfigTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderEventPublishConfigTopicRef(obj: InstanceSpecForProviderEventPublishConfigTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderEventPublishConfigTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in pubsub to populate topic.
 *
 * @schema InstanceSpecForProviderEventPublishConfigTopicSelector
 */
export interface InstanceSpecForProviderEventPublishConfigTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderEventPublishConfigTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderEventPublishConfigTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderEventPublishConfigTopicSelector#policy
   */
  readonly policy?: InstanceSpecForProviderEventPublishConfigTopicSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderEventPublishConfigTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderEventPublishConfigTopicSelector(obj: InstanceSpecForProviderEventPublishConfigTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderEventPublishConfigTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolution
 */
export enum InstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolve
 */
export enum InstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicy
 */
export interface InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicy(obj: InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicy
 */
export interface InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicy(obj: InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderEventPublishConfigTopicRefPolicy
 */
export interface InstanceSpecForProviderEventPublishConfigTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderEventPublishConfigTopicRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderEventPublishConfigTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderEventPublishConfigTopicRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderEventPublishConfigTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderEventPublishConfigTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderEventPublishConfigTopicRefPolicy(obj: InstanceSpecForProviderEventPublishConfigTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderEventPublishConfigTopicSelectorPolicy
 */
export interface InstanceSpecForProviderEventPublishConfigTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderEventPublishConfigTopicSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderEventPublishConfigTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderEventPublishConfigTopicSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderEventPublishConfigTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderEventPublishConfigTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderEventPublishConfigTopicSelectorPolicy(obj: InstanceSpecForProviderEventPublishConfigTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicyResolution
 */
export enum InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicyResolve
 */
export enum InstanceSpecForProviderCryptoKeyConfigKeyReferenceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicyResolution
 */
export enum InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicyResolve
 */
export enum InstanceSpecForProviderCryptoKeyConfigKeyReferenceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderEventPublishConfigTopicRefPolicyResolution
 */
export enum InstanceSpecForProviderEventPublishConfigTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderEventPublishConfigTopicRefPolicyResolve
 */
export enum InstanceSpecForProviderEventPublishConfigTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderEventPublishConfigTopicSelectorPolicyResolution
 */
export enum InstanceSpecForProviderEventPublishConfigTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderEventPublishConfigTopicSelectorPolicyResolve
 */
export enum InstanceSpecForProviderEventPublishConfigTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

