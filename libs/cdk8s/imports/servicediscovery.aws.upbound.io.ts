// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * HTTPNamespace is the Schema for the HTTPNamespaces API. Provides a Service Discovery HTTP Namespace resource.
 *
 * @schema HTTPNamespace
 */
export class HttpNamespace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HTTPNamespace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicediscovery.aws.upbound.io/v1beta1',
    kind: 'HTTPNamespace',
  }

  /**
   * Renders a Kubernetes manifest for "HTTPNamespace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HttpNamespaceProps): any {
    return {
      ...HttpNamespace.GVK,
      ...toJson_HttpNamespaceProps(props),
    };
  }

  /**
   * Defines a "HTTPNamespace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HttpNamespaceProps) {
    super(scope, id, {
      ...HttpNamespace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HttpNamespace.GVK,
      ...toJson_HttpNamespaceProps(resolved),
    };
  }
}

/**
 * HTTPNamespace is the Schema for the HTTPNamespaces API. Provides a Service Discovery HTTP Namespace resource.
 *
 * @schema HTTPNamespace
 */
export interface HttpNamespaceProps {
  /**
   * @schema HTTPNamespace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HTTPNamespaceSpec defines the desired state of HTTPNamespace
   *
   * @schema HTTPNamespace#spec
   */
  readonly spec: HttpNamespaceSpec;

}

/**
 * Converts an object of type 'HttpNamespaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceProps(obj: HttpNamespaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HttpNamespaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPNamespaceSpec defines the desired state of HTTPNamespace
 *
 * @schema HttpNamespaceSpec
 */
export interface HttpNamespaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HttpNamespaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: HttpNamespaceSpecDeletionPolicy;

  /**
   * @schema HttpNamespaceSpec#forProvider
   */
  readonly forProvider: HttpNamespaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema HttpNamespaceSpec#initProvider
   */
  readonly initProvider?: HttpNamespaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema HttpNamespaceSpec#managementPolicies
   */
  readonly managementPolicies?: HttpNamespaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema HttpNamespaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: HttpNamespaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema HttpNamespaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HttpNamespaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema HttpNamespaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HttpNamespaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HttpNamespaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpec(obj: HttpNamespaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HttpNamespaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_HttpNamespaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_HttpNamespaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_HttpNamespaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HttpNamespaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HttpNamespaceSpecDeletionPolicy
 */
export enum HttpNamespaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HttpNamespaceSpecForProvider
 */
export interface HttpNamespaceSpecForProvider {
  /**
   * The description that you specify for the namespace when you create it.
   *
   * @schema HttpNamespaceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the http namespace.
   *
   * @schema HttpNamespaceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HttpNamespaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HttpNamespaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'HttpNamespaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecForProvider(obj: HttpNamespaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema HttpNamespaceSpecInitProvider
 */
export interface HttpNamespaceSpecInitProvider {
  /**
   * The description that you specify for the namespace when you create it.
   *
   * @schema HttpNamespaceSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The name of the http namespace.
   *
   * @schema HttpNamespaceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HttpNamespaceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'HttpNamespaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecInitProvider(obj: HttpNamespaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema HttpNamespaceSpecManagementPolicies
 */
export enum HttpNamespaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema HttpNamespaceSpecProviderConfigRef
 */
export interface HttpNamespaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HttpNamespaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HttpNamespaceSpecProviderConfigRef#policy
   */
  readonly policy?: HttpNamespaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HttpNamespaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecProviderConfigRef(obj: HttpNamespaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HttpNamespaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsTo
 */
export interface HttpNamespaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HttpNamespaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HttpNamespaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HttpNamespaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecPublishConnectionDetailsTo(obj: HttpNamespaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HttpNamespaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HttpNamespaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema HttpNamespaceSpecWriteConnectionSecretToRef
 */
export interface HttpNamespaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HttpNamespaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HttpNamespaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HttpNamespaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecWriteConnectionSecretToRef(obj: HttpNamespaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HttpNamespaceSpecProviderConfigRefPolicy
 */
export interface HttpNamespaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HttpNamespaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HttpNamespaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HttpNamespaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HttpNamespaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HttpNamespaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecProviderConfigRefPolicy(obj: HttpNamespaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRef
 */
export interface HttpNamespaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HttpNamespaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecPublishConnectionDetailsToConfigRef(obj: HttpNamespaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsToMetadata
 */
export interface HttpNamespaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HttpNamespaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecPublishConnectionDetailsToMetadata(obj: HttpNamespaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HttpNamespaceSpecProviderConfigRefPolicyResolution
 */
export enum HttpNamespaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HttpNamespaceSpecProviderConfigRefPolicyResolve
 */
export enum HttpNamespaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HttpNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PrivateDNSNamespace is the Schema for the PrivateDNSNamespaces API. Provides a Service Discovery Private DNS Namespace resource.
 *
 * @schema PrivateDNSNamespace
 */
export class PrivateDnsNamespace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PrivateDNSNamespace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicediscovery.aws.upbound.io/v1beta1',
    kind: 'PrivateDNSNamespace',
  }

  /**
   * Renders a Kubernetes manifest for "PrivateDNSNamespace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PrivateDnsNamespaceProps): any {
    return {
      ...PrivateDnsNamespace.GVK,
      ...toJson_PrivateDnsNamespaceProps(props),
    };
  }

  /**
   * Defines a "PrivateDNSNamespace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PrivateDnsNamespaceProps) {
    super(scope, id, {
      ...PrivateDnsNamespace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PrivateDnsNamespace.GVK,
      ...toJson_PrivateDnsNamespaceProps(resolved),
    };
  }
}

/**
 * PrivateDNSNamespace is the Schema for the PrivateDNSNamespaces API. Provides a Service Discovery Private DNS Namespace resource.
 *
 * @schema PrivateDNSNamespace
 */
export interface PrivateDnsNamespaceProps {
  /**
   * @schema PrivateDNSNamespace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PrivateDNSNamespaceSpec defines the desired state of PrivateDNSNamespace
   *
   * @schema PrivateDNSNamespace#spec
   */
  readonly spec: PrivateDnsNamespaceSpec;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceProps(obj: PrivateDnsNamespaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PrivateDnsNamespaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrivateDNSNamespaceSpec defines the desired state of PrivateDNSNamespace
 *
 * @schema PrivateDnsNamespaceSpec
 */
export interface PrivateDnsNamespaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PrivateDnsNamespaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: PrivateDnsNamespaceSpecDeletionPolicy;

  /**
   * @schema PrivateDnsNamespaceSpec#forProvider
   */
  readonly forProvider: PrivateDnsNamespaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PrivateDnsNamespaceSpec#initProvider
   */
  readonly initProvider?: PrivateDnsNamespaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PrivateDnsNamespaceSpec#managementPolicies
   */
  readonly managementPolicies?: PrivateDnsNamespaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PrivateDnsNamespaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: PrivateDnsNamespaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PrivateDnsNamespaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PrivateDnsNamespaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PrivateDnsNamespaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PrivateDnsNamespaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpec(obj: PrivateDnsNamespaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PrivateDnsNamespaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_PrivateDnsNamespaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PrivateDnsNamespaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PrivateDnsNamespaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PrivateDnsNamespaceSpecDeletionPolicy
 */
export enum PrivateDnsNamespaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PrivateDnsNamespaceSpecForProvider
 */
export interface PrivateDnsNamespaceSpecForProvider {
  /**
   * The description that you specify for the namespace when you create it.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the namespace.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The ID of VPC that you want to associate the namespace with.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#vpc
   */
  readonly vpc?: string;

  /**
   * Reference to a VPC in ec2 to populate vpc.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#vpcRef
   */
  readonly vpcRef?: PrivateDnsNamespaceSpecForProviderVpcRef;

  /**
   * Selector for a VPC in ec2 to populate vpc.
   *
   * @schema PrivateDnsNamespaceSpecForProvider#vpcSelector
   */
  readonly vpcSelector?: PrivateDnsNamespaceSpecForProviderVpcSelector;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProvider(obj: PrivateDnsNamespaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpc': obj.vpc,
    'vpcRef': toJson_PrivateDnsNamespaceSpecForProviderVpcRef(obj.vpcRef),
    'vpcSelector': toJson_PrivateDnsNamespaceSpecForProviderVpcSelector(obj.vpcSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PrivateDnsNamespaceSpecInitProvider
 */
export interface PrivateDnsNamespaceSpecInitProvider {
  /**
   * The description that you specify for the namespace when you create it.
   *
   * @schema PrivateDnsNamespaceSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The name of the namespace.
   *
   * @schema PrivateDnsNamespaceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PrivateDnsNamespaceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecInitProvider(obj: PrivateDnsNamespaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PrivateDnsNamespaceSpecManagementPolicies
 */
export enum PrivateDnsNamespaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PrivateDnsNamespaceSpecProviderConfigRef
 */
export interface PrivateDnsNamespaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateDnsNamespaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateDnsNamespaceSpecProviderConfigRef#policy
   */
  readonly policy?: PrivateDnsNamespaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecProviderConfigRef(obj: PrivateDnsNamespaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateDnsNamespaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsTo
 */
export interface PrivateDnsNamespaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsTo(obj: PrivateDnsNamespaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PrivateDnsNamespaceSpecWriteConnectionSecretToRef
 */
export interface PrivateDnsNamespaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PrivateDnsNamespaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PrivateDnsNamespaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecWriteConnectionSecretToRef(obj: PrivateDnsNamespaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpc.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcRef
 */
export interface PrivateDnsNamespaceSpecForProviderVpcRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcRef#policy
   */
  readonly policy?: PrivateDnsNamespaceSpecForProviderVpcRefPolicy;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderVpcRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderVpcRef(obj: PrivateDnsNamespaceSpecForProviderVpcRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateDnsNamespaceSpecForProviderVpcRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpc.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcSelector
 */
export interface PrivateDnsNamespaceSpecForProviderVpcSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcSelector#policy
   */
  readonly policy?: PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderVpcSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderVpcSelector(obj: PrivateDnsNamespaceSpecForProviderVpcSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrivateDnsNamespaceSpecProviderConfigRefPolicy
 */
export interface PrivateDnsNamespaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateDnsNamespaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PrivateDnsNamespaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateDnsNamespaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PrivateDnsNamespaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecProviderConfigRefPolicy(obj: PrivateDnsNamespaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef
 */
export interface PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef(obj: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata
 */
export interface PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata(obj: PrivateDnsNamespaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcRefPolicy
 */
export interface PrivateDnsNamespaceSpecForProviderVpcRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcRefPolicy#resolution
   */
  readonly resolution?: PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcRefPolicy#resolve
   */
  readonly resolve?: PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderVpcRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderVpcRefPolicy(obj: PrivateDnsNamespaceSpecForProviderVpcRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy
 */
export interface PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy#resolution
   */
  readonly resolution?: PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy#resolve
   */
  readonly resolve?: PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy(obj: PrivateDnsNamespaceSpecForProviderVpcSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateDnsNamespaceSpecProviderConfigRefPolicyResolution
 */
export enum PrivateDnsNamespaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateDnsNamespaceSpecProviderConfigRefPolicyResolve
 */
export enum PrivateDnsNamespaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolution
 */
export enum PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolve
 */
export enum PrivateDnsNamespaceSpecForProviderVpcRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolution
 */
export enum PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolve
 */
export enum PrivateDnsNamespaceSpecForProviderVpcSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PrivateDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PublicDNSNamespace is the Schema for the PublicDNSNamespaces API. Provides a Service Discovery Public DNS Namespace resource.
 *
 * @schema PublicDNSNamespace
 */
export class PublicDnsNamespace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PublicDNSNamespace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicediscovery.aws.upbound.io/v1beta1',
    kind: 'PublicDNSNamespace',
  }

  /**
   * Renders a Kubernetes manifest for "PublicDNSNamespace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PublicDnsNamespaceProps): any {
    return {
      ...PublicDnsNamespace.GVK,
      ...toJson_PublicDnsNamespaceProps(props),
    };
  }

  /**
   * Defines a "PublicDNSNamespace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PublicDnsNamespaceProps) {
    super(scope, id, {
      ...PublicDnsNamespace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PublicDnsNamespace.GVK,
      ...toJson_PublicDnsNamespaceProps(resolved),
    };
  }
}

/**
 * PublicDNSNamespace is the Schema for the PublicDNSNamespaces API. Provides a Service Discovery Public DNS Namespace resource.
 *
 * @schema PublicDNSNamespace
 */
export interface PublicDnsNamespaceProps {
  /**
   * @schema PublicDNSNamespace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PublicDNSNamespaceSpec defines the desired state of PublicDNSNamespace
   *
   * @schema PublicDNSNamespace#spec
   */
  readonly spec: PublicDnsNamespaceSpec;

}

/**
 * Converts an object of type 'PublicDnsNamespaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceProps(obj: PublicDnsNamespaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PublicDnsNamespaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublicDNSNamespaceSpec defines the desired state of PublicDNSNamespace
 *
 * @schema PublicDnsNamespaceSpec
 */
export interface PublicDnsNamespaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PublicDnsNamespaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: PublicDnsNamespaceSpecDeletionPolicy;

  /**
   * @schema PublicDnsNamespaceSpec#forProvider
   */
  readonly forProvider: PublicDnsNamespaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PublicDnsNamespaceSpec#initProvider
   */
  readonly initProvider?: PublicDnsNamespaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PublicDnsNamespaceSpec#managementPolicies
   */
  readonly managementPolicies?: PublicDnsNamespaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PublicDnsNamespaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: PublicDnsNamespaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PublicDnsNamespaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PublicDnsNamespaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PublicDnsNamespaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PublicDnsNamespaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpec(obj: PublicDnsNamespaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PublicDnsNamespaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_PublicDnsNamespaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PublicDnsNamespaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PublicDnsNamespaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PublicDnsNamespaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PublicDnsNamespaceSpecDeletionPolicy
 */
export enum PublicDnsNamespaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PublicDnsNamespaceSpecForProvider
 */
export interface PublicDnsNamespaceSpecForProvider {
  /**
   * The description that you specify for the namespace when you create it.
   *
   * @schema PublicDnsNamespaceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the namespace.
   *
   * @schema PublicDnsNamespaceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PublicDnsNamespaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PublicDnsNamespaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecForProvider(obj: PublicDnsNamespaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PublicDnsNamespaceSpecInitProvider
 */
export interface PublicDnsNamespaceSpecInitProvider {
  /**
   * The description that you specify for the namespace when you create it.
   *
   * @schema PublicDnsNamespaceSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The name of the namespace.
   *
   * @schema PublicDnsNamespaceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PublicDnsNamespaceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecInitProvider(obj: PublicDnsNamespaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PublicDnsNamespaceSpecManagementPolicies
 */
export enum PublicDnsNamespaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PublicDnsNamespaceSpecProviderConfigRef
 */
export interface PublicDnsNamespaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PublicDnsNamespaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PublicDnsNamespaceSpecProviderConfigRef#policy
   */
  readonly policy?: PublicDnsNamespaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecProviderConfigRef(obj: PublicDnsNamespaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PublicDnsNamespaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsTo
 */
export interface PublicDnsNamespaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecPublishConnectionDetailsTo(obj: PublicDnsNamespaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PublicDnsNamespaceSpecWriteConnectionSecretToRef
 */
export interface PublicDnsNamespaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PublicDnsNamespaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PublicDnsNamespaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecWriteConnectionSecretToRef(obj: PublicDnsNamespaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PublicDnsNamespaceSpecProviderConfigRefPolicy
 */
export interface PublicDnsNamespaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PublicDnsNamespaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PublicDnsNamespaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PublicDnsNamespaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PublicDnsNamespaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecProviderConfigRefPolicy(obj: PublicDnsNamespaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef
 */
export interface PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef(obj: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata
 */
export interface PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata(obj: PublicDnsNamespaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PublicDnsNamespaceSpecProviderConfigRefPolicyResolution
 */
export enum PublicDnsNamespaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PublicDnsNamespaceSpecProviderConfigRefPolicyResolve
 */
export enum PublicDnsNamespaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PublicDnsNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Service is the Schema for the Services API. Provides a Service Discovery Service resource.
 *
 * @schema Service
 */
export class Service extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Service"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicediscovery.aws.upbound.io/v1beta1',
    kind: 'Service',
  }

  /**
   * Renders a Kubernetes manifest for "Service".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceProps): any {
    return {
      ...Service.GVK,
      ...toJson_ServiceProps(props),
    };
  }

  /**
   * Defines a "Service" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceProps) {
    super(scope, id, {
      ...Service.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Service.GVK,
      ...toJson_ServiceProps(resolved),
    };
  }
}

/**
 * Service is the Schema for the Services API. Provides a Service Discovery Service resource.
 *
 * @schema Service
 */
export interface ServiceProps {
  /**
   * @schema Service#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceSpec defines the desired state of Service
   *
   * @schema Service#spec
   */
  readonly spec: ServiceSpec;

}

/**
 * Converts an object of type 'ServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceProps(obj: ServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSpec defines the desired state of Service
 *
 * @schema ServiceSpec
 */
export interface ServiceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceSpecDeletionPolicy;

  /**
   * @schema ServiceSpec#forProvider
   */
  readonly forProvider: ServiceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ServiceSpec#initProvider
   */
  readonly initProvider?: ServiceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceSpec#managementPolicies
   */
  readonly managementPolicies?: ServiceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpec(obj: ServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServiceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceSpecDeletionPolicy
 */
export enum ServiceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceSpecForProvider
 */
export interface ServiceSpecForProvider {
  /**
   * The description of the service.
   *
   * @schema ServiceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A complex type that contains information about the resource record sets that you want Amazon Route 53 to create when you register an instance.
   *
   * @schema ServiceSpecForProvider#dnsConfig
   */
  readonly dnsConfig?: ServiceSpecForProviderDnsConfig[];

  /**
   * A boolean that indicates all instances should be deleted from the service so that the service can be destroyed without error. These instances are not recoverable.
   *
   * @schema ServiceSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * A complex type that contains settings for an optional health check. Only for Public DNS namespaces.
   *
   * @schema ServiceSpecForProvider#healthCheckConfig
   */
  readonly healthCheckConfig?: ServiceSpecForProviderHealthCheckConfig[];

  /**
   * A complex type that contains settings for ECS managed health checks.
   *
   * @schema ServiceSpecForProvider#healthCheckCustomConfig
   */
  readonly healthCheckCustomConfig?: ServiceSpecForProviderHealthCheckCustomConfig[];

  /**
   * The name of the service.
   *
   * @schema ServiceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the namespace that you want to use to create the service.
   *
   * @schema ServiceSpecForProvider#namespaceId
   */
  readonly namespaceId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ServiceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ServiceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * If present, specifies that the service instances are only discoverable using the DiscoverInstances API operation. No DNS records is registered for the service instances. The only valid value is HTTP.
   *
   * @schema ServiceSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProvider(obj: ServiceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'dnsConfig': obj.dnsConfig?.map(y => toJson_ServiceSpecForProviderDnsConfig(y)),
    'forceDestroy': obj.forceDestroy,
    'healthCheckConfig': obj.healthCheckConfig?.map(y => toJson_ServiceSpecForProviderHealthCheckConfig(y)),
    'healthCheckCustomConfig': obj.healthCheckCustomConfig?.map(y => toJson_ServiceSpecForProviderHealthCheckCustomConfig(y)),
    'name': obj.name,
    'namespaceId': obj.namespaceId,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ServiceSpecInitProvider
 */
export interface ServiceSpecInitProvider {
  /**
   * The description of the service.
   *
   * @schema ServiceSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * A complex type that contains information about the resource record sets that you want Amazon Route 53 to create when you register an instance.
   *
   * @schema ServiceSpecInitProvider#dnsConfig
   */
  readonly dnsConfig?: ServiceSpecInitProviderDnsConfig[];

  /**
   * A boolean that indicates all instances should be deleted from the service so that the service can be destroyed without error. These instances are not recoverable.
   *
   * @schema ServiceSpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * A complex type that contains settings for an optional health check. Only for Public DNS namespaces.
   *
   * @schema ServiceSpecInitProvider#healthCheckConfig
   */
  readonly healthCheckConfig?: ServiceSpecInitProviderHealthCheckConfig[];

  /**
   * A complex type that contains settings for ECS managed health checks.
   *
   * @schema ServiceSpecInitProvider#healthCheckCustomConfig
   */
  readonly healthCheckCustomConfig?: ServiceSpecInitProviderHealthCheckCustomConfig[];

  /**
   * The name of the service.
   *
   * @schema ServiceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the namespace that you want to use to create the service.
   *
   * @schema ServiceSpecInitProvider#namespaceId
   */
  readonly namespaceId?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ServiceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * If present, specifies that the service instances are only discoverable using the DiscoverInstances API operation. No DNS records is registered for the service instances. The only valid value is HTTP.
   *
   * @schema ServiceSpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProvider(obj: ServiceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'dnsConfig': obj.dnsConfig?.map(y => toJson_ServiceSpecInitProviderDnsConfig(y)),
    'forceDestroy': obj.forceDestroy,
    'healthCheckConfig': obj.healthCheckConfig?.map(y => toJson_ServiceSpecInitProviderHealthCheckConfig(y)),
    'healthCheckCustomConfig': obj.healthCheckCustomConfig?.map(y => toJson_ServiceSpecInitProviderHealthCheckCustomConfig(y)),
    'name': obj.name,
    'namespaceId': obj.namespaceId,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServiceSpecManagementPolicies
 */
export enum ServiceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceSpecProviderConfigRef
 */
export interface ServiceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRef(obj: ServiceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceSpecPublishConnectionDetailsTo
 */
export interface ServiceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsTo(obj: ServiceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceSpecWriteConnectionSecretToRef
 */
export interface ServiceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecWriteConnectionSecretToRef(obj: ServiceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderDnsConfig
 */
export interface ServiceSpecForProviderDnsConfig {
  /**
   * An array that contains one DnsRecord object for each resource record set.
   *
   * @schema ServiceSpecForProviderDnsConfig#dnsRecords
   */
  readonly dnsRecords?: ServiceSpecForProviderDnsConfigDnsRecords[];

  /**
   * The ID of the namespace to use for DNS configuration.
   *
   * @schema ServiceSpecForProviderDnsConfig#namespaceId
   */
  readonly namespaceId?: string;

  /**
   * Reference to a PrivateDNSNamespace in servicediscovery to populate namespaceId.
   *
   * @schema ServiceSpecForProviderDnsConfig#namespaceIdRef
   */
  readonly namespaceIdRef?: ServiceSpecForProviderDnsConfigNamespaceIdRef;

  /**
   * Selector for a PrivateDNSNamespace in servicediscovery to populate namespaceId.
   *
   * @schema ServiceSpecForProviderDnsConfig#namespaceIdSelector
   */
  readonly namespaceIdSelector?: ServiceSpecForProviderDnsConfigNamespaceIdSelector;

  /**
   * The routing policy that you want to apply to all records that Route 53 creates when you register an instance and specify the service. Valid Values: MULTIVALUE, WEIGHTED
   *
   * @schema ServiceSpecForProviderDnsConfig#routingPolicy
   */
  readonly routingPolicy?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDnsConfig(obj: ServiceSpecForProviderDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRecords': obj.dnsRecords?.map(y => toJson_ServiceSpecForProviderDnsConfigDnsRecords(y)),
    'namespaceId': obj.namespaceId,
    'namespaceIdRef': toJson_ServiceSpecForProviderDnsConfigNamespaceIdRef(obj.namespaceIdRef),
    'namespaceIdSelector': toJson_ServiceSpecForProviderDnsConfigNamespaceIdSelector(obj.namespaceIdSelector),
    'routingPolicy': obj.routingPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderHealthCheckConfig
 */
export interface ServiceSpecForProviderHealthCheckConfig {
  /**
   * The number of consecutive health checks. Maximum value of 10.
   *
   * @schema ServiceSpecForProviderHealthCheckConfig#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The path that you want Route 53 to request when performing health checks. Route 53 automatically adds the DNS name for the service. If you don't specify a value, the default value is /.
   *
   * @schema ServiceSpecForProviderHealthCheckConfig#resourcePath
   */
  readonly resourcePath?: string;

  /**
   * The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. Valid Values: HTTP, HTTPS, TCP
   *
   * @schema ServiceSpecForProviderHealthCheckConfig#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderHealthCheckConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderHealthCheckConfig(obj: ServiceSpecForProviderHealthCheckConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'resourcePath': obj.resourcePath,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderHealthCheckCustomConfig
 */
export interface ServiceSpecForProviderHealthCheckCustomConfig {
  /**
   * The number of 30-second intervals that you want service discovery to wait before it changes the health status of a service instance.  Maximum value of 10.
   *
   * @schema ServiceSpecForProviderHealthCheckCustomConfig#failureThreshold
   */
  readonly failureThreshold?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderHealthCheckCustomConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderHealthCheckCustomConfig(obj: ServiceSpecForProviderHealthCheckCustomConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderDnsConfig
 */
export interface ServiceSpecInitProviderDnsConfig {
  /**
   * An array that contains one DnsRecord object for each resource record set.
   *
   * @schema ServiceSpecInitProviderDnsConfig#dnsRecords
   */
  readonly dnsRecords?: ServiceSpecInitProviderDnsConfigDnsRecords[];

  /**
   * The routing policy that you want to apply to all records that Route 53 creates when you register an instance and specify the service. Valid Values: MULTIVALUE, WEIGHTED
   *
   * @schema ServiceSpecInitProviderDnsConfig#routingPolicy
   */
  readonly routingPolicy?: string;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderDnsConfig(obj: ServiceSpecInitProviderDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsRecords': obj.dnsRecords?.map(y => toJson_ServiceSpecInitProviderDnsConfigDnsRecords(y)),
    'routingPolicy': obj.routingPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderHealthCheckConfig
 */
export interface ServiceSpecInitProviderHealthCheckConfig {
  /**
   * The number of consecutive health checks. Maximum value of 10.
   *
   * @schema ServiceSpecInitProviderHealthCheckConfig#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The path that you want Route 53 to request when performing health checks. Route 53 automatically adds the DNS name for the service. If you don't specify a value, the default value is /.
   *
   * @schema ServiceSpecInitProviderHealthCheckConfig#resourcePath
   */
  readonly resourcePath?: string;

  /**
   * The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. Valid Values: HTTP, HTTPS, TCP
   *
   * @schema ServiceSpecInitProviderHealthCheckConfig#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderHealthCheckConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderHealthCheckConfig(obj: ServiceSpecInitProviderHealthCheckConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'resourcePath': obj.resourcePath,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderHealthCheckCustomConfig
 */
export interface ServiceSpecInitProviderHealthCheckCustomConfig {
  /**
   * The number of 30-second intervals that you want service discovery to wait before it changes the health status of a service instance.  Maximum value of 10.
   *
   * @schema ServiceSpecInitProviderHealthCheckCustomConfig#failureThreshold
   */
  readonly failureThreshold?: number;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderHealthCheckCustomConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderHealthCheckCustomConfig(obj: ServiceSpecInitProviderHealthCheckCustomConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecProviderConfigRefPolicy
 */
export interface ServiceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRefPolicy(obj: ServiceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj: ServiceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj: ServiceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderDnsConfigDnsRecords
 */
export interface ServiceSpecForProviderDnsConfigDnsRecords {
  /**
   * The amount of time, in seconds, that you want DNS resolvers to cache the settings for this resource record set.
   *
   * @schema ServiceSpecForProviderDnsConfigDnsRecords#ttl
   */
  readonly ttl?: number;

  /**
   * The type of the resource, which indicates the value that Amazon Route 53 returns in response to DNS queries. Valid Values: A, AAAA, SRV, CNAME
   *
   * @schema ServiceSpecForProviderDnsConfigDnsRecords#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDnsConfigDnsRecords' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDnsConfigDnsRecords(obj: ServiceSpecForProviderDnsConfigDnsRecords | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ttl': obj.ttl,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PrivateDNSNamespace in servicediscovery to populate namespaceId.
 *
 * @schema ServiceSpecForProviderDnsConfigNamespaceIdRef
 */
export interface ServiceSpecForProviderDnsConfigNamespaceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderDnsConfigNamespaceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderDnsConfigNamespaceIdRef#policy
   */
  readonly policy?: ServiceSpecForProviderDnsConfigNamespaceIdRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDnsConfigNamespaceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDnsConfigNamespaceIdRef(obj: ServiceSpecForProviderDnsConfigNamespaceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderDnsConfigNamespaceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PrivateDNSNamespace in servicediscovery to populate namespaceId.
 *
 * @schema ServiceSpecForProviderDnsConfigNamespaceIdSelector
 */
export interface ServiceSpecForProviderDnsConfigNamespaceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderDnsConfigNamespaceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderDnsConfigNamespaceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderDnsConfigNamespaceIdSelector#policy
   */
  readonly policy?: ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDnsConfigNamespaceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDnsConfigNamespaceIdSelector(obj: ServiceSpecForProviderDnsConfigNamespaceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderDnsConfigDnsRecords
 */
export interface ServiceSpecInitProviderDnsConfigDnsRecords {
  /**
   * The amount of time, in seconds, that you want DNS resolvers to cache the settings for this resource record set.
   *
   * @schema ServiceSpecInitProviderDnsConfigDnsRecords#ttl
   */
  readonly ttl?: number;

  /**
   * The type of the resource, which indicates the value that Amazon Route 53 returns in response to DNS queries. Valid Values: A, AAAA, SRV, CNAME
   *
   * @schema ServiceSpecInitProviderDnsConfigDnsRecords#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderDnsConfigDnsRecords' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderDnsConfigDnsRecords(obj: ServiceSpecInitProviderDnsConfigDnsRecords | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ttl': obj.ttl,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolution
 */
export enum ServiceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolve
 */
export enum ServiceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderDnsConfigNamespaceIdRefPolicy
 */
export interface ServiceSpecForProviderDnsConfigNamespaceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderDnsConfigNamespaceIdRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderDnsConfigNamespaceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderDnsConfigNamespaceIdRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderDnsConfigNamespaceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDnsConfigNamespaceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDnsConfigNamespaceIdRefPolicy(obj: ServiceSpecForProviderDnsConfigNamespaceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicy
 */
export interface ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicy(obj: ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderDnsConfigNamespaceIdRefPolicyResolution
 */
export enum ServiceSpecForProviderDnsConfigNamespaceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderDnsConfigNamespaceIdRefPolicyResolve
 */
export enum ServiceSpecForProviderDnsConfigNamespaceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicyResolution
 */
export enum ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicyResolve
 */
export enum ServiceSpecForProviderDnsConfigNamespaceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

