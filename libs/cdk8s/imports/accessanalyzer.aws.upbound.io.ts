// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Analyzer is the Schema for the Analyzers API. Manages an Access Analyzer Analyzer
 *
 * @schema Analyzer
 */
export class Analyzer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Analyzer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'accessanalyzer.aws.upbound.io/v1beta1',
    kind: 'Analyzer',
  }

  /**
   * Renders a Kubernetes manifest for "Analyzer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AnalyzerProps): any {
    return {
      ...Analyzer.GVK,
      ...toJson_AnalyzerProps(props),
    };
  }

  /**
   * Defines a "Analyzer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AnalyzerProps) {
    super(scope, id, {
      ...Analyzer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Analyzer.GVK,
      ...toJson_AnalyzerProps(resolved),
    };
  }
}

/**
 * Analyzer is the Schema for the Analyzers API. Manages an Access Analyzer Analyzer
 *
 * @schema Analyzer
 */
export interface AnalyzerProps {
  /**
   * @schema Analyzer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AnalyzerSpec defines the desired state of Analyzer
   *
   * @schema Analyzer#spec
   */
  readonly spec: AnalyzerSpec;

}

/**
 * Converts an object of type 'AnalyzerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerProps(obj: AnalyzerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AnalyzerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnalyzerSpec defines the desired state of Analyzer
 *
 * @schema AnalyzerSpec
 */
export interface AnalyzerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AnalyzerSpec#deletionPolicy
   */
  readonly deletionPolicy?: AnalyzerSpecDeletionPolicy;

  /**
   * @schema AnalyzerSpec#forProvider
   */
  readonly forProvider: AnalyzerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AnalyzerSpec#initProvider
   */
  readonly initProvider?: AnalyzerSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AnalyzerSpec#managementPolicies
   */
  readonly managementPolicies?: AnalyzerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AnalyzerSpec#providerConfigRef
   */
  readonly providerConfigRef?: AnalyzerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AnalyzerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AnalyzerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AnalyzerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AnalyzerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AnalyzerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpec(obj: AnalyzerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AnalyzerSpecForProvider(obj.forProvider),
    'initProvider': toJson_AnalyzerSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AnalyzerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AnalyzerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AnalyzerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AnalyzerSpecDeletionPolicy
 */
export enum AnalyzerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AnalyzerSpecForProvider
 */
export interface AnalyzerSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AnalyzerSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AnalyzerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Type of Analyzer. Valid values are ACCOUNT or ORGANIZATION. Defaults to ACCOUNT.
   *
   * @default ACCOUNT.
   * @schema AnalyzerSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AnalyzerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecForProvider(obj: AnalyzerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AnalyzerSpecInitProvider
 */
export interface AnalyzerSpecInitProvider {
  /**
   * Key-value map of resource tags.
   *
   * @schema AnalyzerSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Type of Analyzer. Valid values are ACCOUNT or ORGANIZATION. Defaults to ACCOUNT.
   *
   * @default ACCOUNT.
   * @schema AnalyzerSpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AnalyzerSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecInitProvider(obj: AnalyzerSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AnalyzerSpecManagementPolicies
 */
export enum AnalyzerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AnalyzerSpecProviderConfigRef
 */
export interface AnalyzerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyzerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyzerSpecProviderConfigRef#policy
   */
  readonly policy?: AnalyzerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AnalyzerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecProviderConfigRef(obj: AnalyzerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyzerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsTo
 */
export interface AnalyzerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AnalyzerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AnalyzerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AnalyzerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecPublishConnectionDetailsTo(obj: AnalyzerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AnalyzerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AnalyzerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AnalyzerSpecWriteConnectionSecretToRef
 */
export interface AnalyzerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AnalyzerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AnalyzerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AnalyzerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecWriteConnectionSecretToRef(obj: AnalyzerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyzerSpecProviderConfigRefPolicy
 */
export interface AnalyzerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyzerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AnalyzerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyzerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AnalyzerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyzerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecProviderConfigRefPolicy(obj: AnalyzerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsToConfigRef
 */
export interface AnalyzerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AnalyzerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecPublishConnectionDetailsToConfigRef(obj: AnalyzerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsToMetadata
 */
export interface AnalyzerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AnalyzerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecPublishConnectionDetailsToMetadata(obj: AnalyzerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyzerSpecProviderConfigRefPolicyResolution
 */
export enum AnalyzerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyzerSpecProviderConfigRefPolicyResolve
 */
export enum AnalyzerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy(obj: AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ArchiveRule is the Schema for the ArchiveRules API.
 *
 * @schema ArchiveRule
 */
export class ArchiveRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ArchiveRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'accessanalyzer.aws.upbound.io/v1beta1',
    kind: 'ArchiveRule',
  }

  /**
   * Renders a Kubernetes manifest for "ArchiveRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ArchiveRuleProps): any {
    return {
      ...ArchiveRule.GVK,
      ...toJson_ArchiveRuleProps(props),
    };
  }

  /**
   * Defines a "ArchiveRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ArchiveRuleProps) {
    super(scope, id, {
      ...ArchiveRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ArchiveRule.GVK,
      ...toJson_ArchiveRuleProps(resolved),
    };
  }
}

/**
 * ArchiveRule is the Schema for the ArchiveRules API.
 *
 * @schema ArchiveRule
 */
export interface ArchiveRuleProps {
  /**
   * @schema ArchiveRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ArchiveRuleSpec defines the desired state of ArchiveRule
   *
   * @schema ArchiveRule#spec
   */
  readonly spec: ArchiveRuleSpec;

}

/**
 * Converts an object of type 'ArchiveRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleProps(obj: ArchiveRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ArchiveRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ArchiveRuleSpec defines the desired state of ArchiveRule
 *
 * @schema ArchiveRuleSpec
 */
export interface ArchiveRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ArchiveRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: ArchiveRuleSpecDeletionPolicy;

  /**
   * @schema ArchiveRuleSpec#forProvider
   */
  readonly forProvider: ArchiveRuleSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ArchiveRuleSpec#initProvider
   */
  readonly initProvider?: ArchiveRuleSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ArchiveRuleSpec#managementPolicies
   */
  readonly managementPolicies?: ArchiveRuleSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ArchiveRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: ArchiveRuleSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ArchiveRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ArchiveRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ArchiveRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ArchiveRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ArchiveRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpec(obj: ArchiveRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ArchiveRuleSpecForProvider(obj.forProvider),
    'initProvider': toJson_ArchiveRuleSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ArchiveRuleSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ArchiveRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ArchiveRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ArchiveRuleSpecDeletionPolicy
 */
export enum ArchiveRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ArchiveRuleSpecForProvider
 */
export interface ArchiveRuleSpecForProvider {
  /**
   * Analyzer name.
   *
   * @schema ArchiveRuleSpecForProvider#analyzerName
   */
  readonly analyzerName: string;

  /**
   * Filter criteria for the archive rule. See Filter for more details.
   *
   * @schema ArchiveRuleSpecForProvider#filter
   */
  readonly filter?: ArchiveRuleSpecForProviderFilter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ArchiveRuleSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ArchiveRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecForProvider(obj: ArchiveRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'analyzerName': obj.analyzerName,
    'filter': obj.filter?.map(y => toJson_ArchiveRuleSpecForProviderFilter(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ArchiveRuleSpecInitProvider
 */
export interface ArchiveRuleSpecInitProvider {
  /**
   * Filter criteria for the archive rule. See Filter for more details.
   *
   * @schema ArchiveRuleSpecInitProvider#filter
   */
  readonly filter?: ArchiveRuleSpecInitProviderFilter[];

}

/**
 * Converts an object of type 'ArchiveRuleSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecInitProvider(obj: ArchiveRuleSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter?.map(y => toJson_ArchiveRuleSpecInitProviderFilter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ArchiveRuleSpecManagementPolicies
 */
export enum ArchiveRuleSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ArchiveRuleSpecProviderConfigRef
 */
export interface ArchiveRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ArchiveRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ArchiveRuleSpecProviderConfigRef#policy
   */
  readonly policy?: ArchiveRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ArchiveRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecProviderConfigRef(obj: ArchiveRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ArchiveRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsTo
 */
export interface ArchiveRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ArchiveRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ArchiveRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ArchiveRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecPublishConnectionDetailsTo(obj: ArchiveRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ArchiveRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ArchiveRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ArchiveRuleSpecWriteConnectionSecretToRef
 */
export interface ArchiveRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ArchiveRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ArchiveRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ArchiveRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecWriteConnectionSecretToRef(obj: ArchiveRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveRuleSpecForProviderFilter
 */
export interface ArchiveRuleSpecForProviderFilter {
  /**
   * Contains comparator.
   *
   * @schema ArchiveRuleSpecForProviderFilter#contains
   */
  readonly contains?: string[];

  /**
   * Filter criteria.
   *
   * @schema ArchiveRuleSpecForProviderFilter#criteria
   */
  readonly criteria?: string;

  /**
   * Equals comparator.
   *
   * @schema ArchiveRuleSpecForProviderFilter#eq
   */
  readonly eq?: string[];

  /**
   * Boolean comparator.
   *
   * @schema ArchiveRuleSpecForProviderFilter#exists
   */
  readonly exists?: string;

  /**
   * Not Equals comparator.
   *
   * @schema ArchiveRuleSpecForProviderFilter#neq
   */
  readonly neq?: string[];

}

/**
 * Converts an object of type 'ArchiveRuleSpecForProviderFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecForProviderFilter(obj: ArchiveRuleSpecForProviderFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains?.map(y => y),
    'criteria': obj.criteria,
    'eq': obj.eq?.map(y => y),
    'exists': obj.exists,
    'neq': obj.neq?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveRuleSpecInitProviderFilter
 */
export interface ArchiveRuleSpecInitProviderFilter {
  /**
   * Contains comparator.
   *
   * @schema ArchiveRuleSpecInitProviderFilter#contains
   */
  readonly contains?: string[];

  /**
   * Filter criteria.
   *
   * @schema ArchiveRuleSpecInitProviderFilter#criteria
   */
  readonly criteria?: string;

  /**
   * Equals comparator.
   *
   * @schema ArchiveRuleSpecInitProviderFilter#eq
   */
  readonly eq?: string[];

  /**
   * Boolean comparator.
   *
   * @schema ArchiveRuleSpecInitProviderFilter#exists
   */
  readonly exists?: string;

  /**
   * Not Equals comparator.
   *
   * @schema ArchiveRuleSpecInitProviderFilter#neq
   */
  readonly neq?: string[];

}

/**
 * Converts an object of type 'ArchiveRuleSpecInitProviderFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecInitProviderFilter(obj: ArchiveRuleSpecInitProviderFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains?.map(y => y),
    'criteria': obj.criteria,
    'eq': obj.eq?.map(y => y),
    'exists': obj.exists,
    'neq': obj.neq?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ArchiveRuleSpecProviderConfigRefPolicy
 */
export interface ArchiveRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ArchiveRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ArchiveRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ArchiveRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ArchiveRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ArchiveRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecProviderConfigRefPolicy(obj: ArchiveRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface ArchiveRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ArchiveRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecPublishConnectionDetailsToConfigRef(obj: ArchiveRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsToMetadata
 */
export interface ArchiveRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ArchiveRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecPublishConnectionDetailsToMetadata(obj: ArchiveRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ArchiveRuleSpecProviderConfigRefPolicyResolution
 */
export enum ArchiveRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ArchiveRuleSpecProviderConfigRefPolicyResolve
 */
export enum ArchiveRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

