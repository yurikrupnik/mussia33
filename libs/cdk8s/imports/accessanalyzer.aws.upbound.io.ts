// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Analyzer is the Schema for the Analyzers API. Manages an Access Analyzer Analyzer
 *
 * @schema Analyzer
 */
export class Analyzer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Analyzer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'accessanalyzer.aws.upbound.io/v1beta1',
    kind: 'Analyzer',
  }

  /**
   * Renders a Kubernetes manifest for "Analyzer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AnalyzerProps): any {
    return {
      ...Analyzer.GVK,
      ...toJson_AnalyzerProps(props),
    };
  }

  /**
   * Defines a "Analyzer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AnalyzerProps) {
    super(scope, id, {
      ...Analyzer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Analyzer.GVK,
      ...toJson_AnalyzerProps(resolved),
    };
  }
}

/**
 * Analyzer is the Schema for the Analyzers API. Manages an Access Analyzer Analyzer
 *
 * @schema Analyzer
 */
export interface AnalyzerProps {
  /**
   * @schema Analyzer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AnalyzerSpec defines the desired state of Analyzer
   *
   * @schema Analyzer#spec
   */
  readonly spec: AnalyzerSpec;

}

/**
 * Converts an object of type 'AnalyzerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerProps(obj: AnalyzerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AnalyzerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnalyzerSpec defines the desired state of Analyzer
 *
 * @schema AnalyzerSpec
 */
export interface AnalyzerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AnalyzerSpec#deletionPolicy
   */
  readonly deletionPolicy?: AnalyzerSpecDeletionPolicy;

  /**
   * @schema AnalyzerSpec#forProvider
   */
  readonly forProvider: AnalyzerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AnalyzerSpec#managementPolicy
   */
  readonly managementPolicy?: AnalyzerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AnalyzerSpec#providerConfigRef
   */
  readonly providerConfigRef?: AnalyzerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AnalyzerSpec#providerRef
   */
  readonly providerRef?: AnalyzerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AnalyzerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AnalyzerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AnalyzerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AnalyzerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AnalyzerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpec(obj: AnalyzerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AnalyzerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AnalyzerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AnalyzerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AnalyzerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AnalyzerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AnalyzerSpecDeletionPolicy
 */
export enum AnalyzerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AnalyzerSpecForProvider
 */
export interface AnalyzerSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AnalyzerSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AnalyzerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Type of Analyzer. Valid values are ACCOUNT or ORGANIZATION. Defaults to ACCOUNT.
   *
   * @default ACCOUNT.
   * @schema AnalyzerSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AnalyzerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecForProvider(obj: AnalyzerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AnalyzerSpecManagementPolicy
 */
export enum AnalyzerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AnalyzerSpecProviderConfigRef
 */
export interface AnalyzerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyzerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyzerSpecProviderConfigRef#policy
   */
  readonly policy?: AnalyzerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AnalyzerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecProviderConfigRef(obj: AnalyzerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyzerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AnalyzerSpecProviderRef
 */
export interface AnalyzerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyzerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyzerSpecProviderRef#policy
   */
  readonly policy?: AnalyzerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AnalyzerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecProviderRef(obj: AnalyzerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyzerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsTo
 */
export interface AnalyzerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AnalyzerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AnalyzerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AnalyzerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecPublishConnectionDetailsTo(obj: AnalyzerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AnalyzerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AnalyzerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AnalyzerSpecWriteConnectionSecretToRef
 */
export interface AnalyzerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AnalyzerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AnalyzerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AnalyzerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecWriteConnectionSecretToRef(obj: AnalyzerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyzerSpecProviderConfigRefPolicy
 */
export interface AnalyzerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyzerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AnalyzerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyzerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AnalyzerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyzerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecProviderConfigRefPolicy(obj: AnalyzerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AnalyzerSpecProviderRefPolicy
 */
export interface AnalyzerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyzerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AnalyzerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyzerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AnalyzerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyzerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecProviderRefPolicy(obj: AnalyzerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsToConfigRef
 */
export interface AnalyzerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AnalyzerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecPublishConnectionDetailsToConfigRef(obj: AnalyzerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsToMetadata
 */
export interface AnalyzerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AnalyzerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecPublishConnectionDetailsToMetadata(obj: AnalyzerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyzerSpecProviderConfigRefPolicyResolution
 */
export enum AnalyzerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyzerSpecProviderConfigRefPolicyResolve
 */
export enum AnalyzerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyzerSpecProviderRefPolicyResolution
 */
export enum AnalyzerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyzerSpecProviderRefPolicyResolve
 */
export enum AnalyzerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy(obj: AnalyzerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AnalyzerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ArchiveRule is the Schema for the ArchiveRules API.
 *
 * @schema ArchiveRule
 */
export class ArchiveRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ArchiveRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'accessanalyzer.aws.upbound.io/v1beta1',
    kind: 'ArchiveRule',
  }

  /**
   * Renders a Kubernetes manifest for "ArchiveRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ArchiveRuleProps): any {
    return {
      ...ArchiveRule.GVK,
      ...toJson_ArchiveRuleProps(props),
    };
  }

  /**
   * Defines a "ArchiveRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ArchiveRuleProps) {
    super(scope, id, {
      ...ArchiveRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ArchiveRule.GVK,
      ...toJson_ArchiveRuleProps(resolved),
    };
  }
}

/**
 * ArchiveRule is the Schema for the ArchiveRules API.
 *
 * @schema ArchiveRule
 */
export interface ArchiveRuleProps {
  /**
   * @schema ArchiveRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ArchiveRuleSpec defines the desired state of ArchiveRule
   *
   * @schema ArchiveRule#spec
   */
  readonly spec: ArchiveRuleSpec;

}

/**
 * Converts an object of type 'ArchiveRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleProps(obj: ArchiveRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ArchiveRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ArchiveRuleSpec defines the desired state of ArchiveRule
 *
 * @schema ArchiveRuleSpec
 */
export interface ArchiveRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ArchiveRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: ArchiveRuleSpecDeletionPolicy;

  /**
   * @schema ArchiveRuleSpec#forProvider
   */
  readonly forProvider: ArchiveRuleSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ArchiveRuleSpec#managementPolicy
   */
  readonly managementPolicy?: ArchiveRuleSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ArchiveRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: ArchiveRuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ArchiveRuleSpec#providerRef
   */
  readonly providerRef?: ArchiveRuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ArchiveRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ArchiveRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ArchiveRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ArchiveRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ArchiveRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpec(obj: ArchiveRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ArchiveRuleSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ArchiveRuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ArchiveRuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ArchiveRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ArchiveRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ArchiveRuleSpecDeletionPolicy
 */
export enum ArchiveRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ArchiveRuleSpecForProvider
 */
export interface ArchiveRuleSpecForProvider {
  /**
   * Analyzer name.
   *
   * @schema ArchiveRuleSpecForProvider#analyzerName
   */
  readonly analyzerName: string;

  /**
   * Filter criteria for the archive rule. See Filter for more details.
   *
   * @schema ArchiveRuleSpecForProvider#filter
   */
  readonly filter?: ArchiveRuleSpecForProviderFilter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ArchiveRuleSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ArchiveRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecForProvider(obj: ArchiveRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'analyzerName': obj.analyzerName,
    'filter': obj.filter?.map(y => toJson_ArchiveRuleSpecForProviderFilter(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ArchiveRuleSpecManagementPolicy
 */
export enum ArchiveRuleSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ArchiveRuleSpecProviderConfigRef
 */
export interface ArchiveRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ArchiveRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ArchiveRuleSpecProviderConfigRef#policy
   */
  readonly policy?: ArchiveRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ArchiveRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecProviderConfigRef(obj: ArchiveRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ArchiveRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ArchiveRuleSpecProviderRef
 */
export interface ArchiveRuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ArchiveRuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ArchiveRuleSpecProviderRef#policy
   */
  readonly policy?: ArchiveRuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ArchiveRuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecProviderRef(obj: ArchiveRuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ArchiveRuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsTo
 */
export interface ArchiveRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ArchiveRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ArchiveRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ArchiveRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecPublishConnectionDetailsTo(obj: ArchiveRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ArchiveRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ArchiveRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ArchiveRuleSpecWriteConnectionSecretToRef
 */
export interface ArchiveRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ArchiveRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ArchiveRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ArchiveRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecWriteConnectionSecretToRef(obj: ArchiveRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ArchiveRuleSpecForProviderFilter
 */
export interface ArchiveRuleSpecForProviderFilter {
  /**
   * Contains comparator.
   *
   * @schema ArchiveRuleSpecForProviderFilter#contains
   */
  readonly contains?: string[];

  /**
   * Filter criteria.
   *
   * @schema ArchiveRuleSpecForProviderFilter#criteria
   */
  readonly criteria: string;

  /**
   * Equals comparator.
   *
   * @schema ArchiveRuleSpecForProviderFilter#eq
   */
  readonly eq?: string[];

  /**
   * Boolean comparator.
   *
   * @schema ArchiveRuleSpecForProviderFilter#exists
   */
  readonly exists?: string;

  /**
   * Not Equals comparator.
   *
   * @schema ArchiveRuleSpecForProviderFilter#neq
   */
  readonly neq?: string[];

}

/**
 * Converts an object of type 'ArchiveRuleSpecForProviderFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecForProviderFilter(obj: ArchiveRuleSpecForProviderFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains?.map(y => y),
    'criteria': obj.criteria,
    'eq': obj.eq?.map(y => y),
    'exists': obj.exists,
    'neq': obj.neq?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ArchiveRuleSpecProviderConfigRefPolicy
 */
export interface ArchiveRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ArchiveRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ArchiveRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ArchiveRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ArchiveRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ArchiveRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecProviderConfigRefPolicy(obj: ArchiveRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ArchiveRuleSpecProviderRefPolicy
 */
export interface ArchiveRuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ArchiveRuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ArchiveRuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ArchiveRuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ArchiveRuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ArchiveRuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecProviderRefPolicy(obj: ArchiveRuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface ArchiveRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ArchiveRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecPublishConnectionDetailsToConfigRef(obj: ArchiveRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsToMetadata
 */
export interface ArchiveRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ArchiveRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecPublishConnectionDetailsToMetadata(obj: ArchiveRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ArchiveRuleSpecProviderConfigRefPolicyResolution
 */
export enum ArchiveRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ArchiveRuleSpecProviderConfigRefPolicyResolve
 */
export enum ArchiveRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ArchiveRuleSpecProviderRefPolicyResolution
 */
export enum ArchiveRuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ArchiveRuleSpecProviderRefPolicyResolve
 */
export enum ArchiveRuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ArchiveRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

