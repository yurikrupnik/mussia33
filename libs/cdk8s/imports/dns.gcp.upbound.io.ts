// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ManagedZone is the Schema for the ManagedZones API. A zone is a subtree of the DNS namespace under one administrative responsibility.
 *
 * @schema ManagedZone
 */
export class ManagedZone extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ManagedZone"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dns.gcp.upbound.io/v1beta1',
    kind: 'ManagedZone',
  }

  /**
   * Renders a Kubernetes manifest for "ManagedZone".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ManagedZoneProps): any {
    return {
      ...ManagedZone.GVK,
      ...toJson_ManagedZoneProps(props),
    };
  }

  /**
   * Defines a "ManagedZone" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ManagedZoneProps) {
    super(scope, id, {
      ...ManagedZone.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ManagedZone.GVK,
      ...toJson_ManagedZoneProps(resolved),
    };
  }
}

/**
 * ManagedZone is the Schema for the ManagedZones API. A zone is a subtree of the DNS namespace under one administrative responsibility.
 *
 * @schema ManagedZone
 */
export interface ManagedZoneProps {
  /**
   * @schema ManagedZone#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ManagedZoneSpec defines the desired state of ManagedZone
   *
   * @schema ManagedZone#spec
   */
  readonly spec: ManagedZoneSpec;

}

/**
 * Converts an object of type 'ManagedZoneProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneProps(obj: ManagedZoneProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ManagedZoneSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ManagedZoneSpec defines the desired state of ManagedZone
 *
 * @schema ManagedZoneSpec
 */
export interface ManagedZoneSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ManagedZoneSpec#deletionPolicy
   */
  readonly deletionPolicy?: ManagedZoneSpecDeletionPolicy;

  /**
   * @schema ManagedZoneSpec#forProvider
   */
  readonly forProvider: ManagedZoneSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ManagedZoneSpec#managementPolicy
   */
  readonly managementPolicy?: ManagedZoneSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ManagedZoneSpec#providerConfigRef
   */
  readonly providerConfigRef?: ManagedZoneSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ManagedZoneSpec#providerRef
   */
  readonly providerRef?: ManagedZoneSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ManagedZoneSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ManagedZoneSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ManagedZoneSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ManagedZoneSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ManagedZoneSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpec(obj: ManagedZoneSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ManagedZoneSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ManagedZoneSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ManagedZoneSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ManagedZoneSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ManagedZoneSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ManagedZoneSpecDeletionPolicy
 */
export enum ManagedZoneSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ManagedZoneSpecForProvider
 */
export interface ManagedZoneSpecForProvider {
  /**
   * Cloud logging configuration Structure is documented below.
   *
   * @schema ManagedZoneSpecForProvider#cloudLoggingConfig
   */
  readonly cloudLoggingConfig?: ManagedZoneSpecForProviderCloudLoggingConfig[];

  /**
   * A textual description field.
   *
   * @schema ManagedZoneSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The DNS name of this managed zone, for instance "example.com.".
   *
   * @schema ManagedZoneSpecForProvider#dnsName
   */
  readonly dnsName?: string;

  /**
   * DNSSEC configuration Structure is documented below.
   *
   * @schema ManagedZoneSpecForProvider#dnssecConfig
   */
  readonly dnssecConfig?: ManagedZoneSpecForProviderDnssecConfig[];

  /**
   * Set this true to delete all records in the zone.
   *
   * @schema ManagedZoneSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The presence for this field indicates that outbound forwarding is enabled for this zone. The value of this field contains the set of destinations to forward to. Structure is documented below.
   *
   * @schema ManagedZoneSpecForProvider#forwardingConfig
   */
  readonly forwardingConfig?: ManagedZoneSpecForProviderForwardingConfig[];

  /**
   * A set of key/value label pairs to assign to this ManagedZone.
   *
   * @schema ManagedZoneSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The presence of this field indicates that DNS Peering is enabled for this zone. The value of this field contains the network to peer with. Structure is documented below.
   *
   * @schema ManagedZoneSpecForProvider#peeringConfig
   */
  readonly peeringConfig?: ManagedZoneSpecForProviderPeeringConfig[];

  /**
   * For privately visible zones, the set of Virtual Private Cloud resources that the zone is visible from. Structure is documented below.
   *
   * @schema ManagedZoneSpecForProvider#privateVisibilityConfig
   */
  readonly privateVisibilityConfig?: ManagedZoneSpecForProviderPrivateVisibilityConfig[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema ManagedZoneSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The zone's visibility: public zones are exposed to the Internet, while private zones are visible only to Virtual Private Cloud resources. Default value is public. Possible values are: private, public.
   *
   * @schema ManagedZoneSpecForProvider#visibility
   */
  readonly visibility?: string;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProvider(obj: ManagedZoneSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudLoggingConfig': obj.cloudLoggingConfig?.map(y => toJson_ManagedZoneSpecForProviderCloudLoggingConfig(y)),
    'description': obj.description,
    'dnsName': obj.dnsName,
    'dnssecConfig': obj.dnssecConfig?.map(y => toJson_ManagedZoneSpecForProviderDnssecConfig(y)),
    'forceDestroy': obj.forceDestroy,
    'forwardingConfig': obj.forwardingConfig?.map(y => toJson_ManagedZoneSpecForProviderForwardingConfig(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'peeringConfig': obj.peeringConfig?.map(y => toJson_ManagedZoneSpecForProviderPeeringConfig(y)),
    'privateVisibilityConfig': obj.privateVisibilityConfig?.map(y => toJson_ManagedZoneSpecForProviderPrivateVisibilityConfig(y)),
    'project': obj.project,
    'visibility': obj.visibility,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ManagedZoneSpecManagementPolicy
 */
export enum ManagedZoneSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ManagedZoneSpecProviderConfigRef
 */
export interface ManagedZoneSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecProviderConfigRef#policy
   */
  readonly policy?: ManagedZoneSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ManagedZoneSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecProviderConfigRef(obj: ManagedZoneSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ManagedZoneSpecProviderRef
 */
export interface ManagedZoneSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecProviderRef#policy
   */
  readonly policy?: ManagedZoneSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ManagedZoneSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecProviderRef(obj: ManagedZoneSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ManagedZoneSpecPublishConnectionDetailsTo
 */
export interface ManagedZoneSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ManagedZoneSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ManagedZoneSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ManagedZoneSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ManagedZoneSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ManagedZoneSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ManagedZoneSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecPublishConnectionDetailsTo(obj: ManagedZoneSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ManagedZoneSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ManagedZoneSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ManagedZoneSpecWriteConnectionSecretToRef
 */
export interface ManagedZoneSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ManagedZoneSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ManagedZoneSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ManagedZoneSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecWriteConnectionSecretToRef(obj: ManagedZoneSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ManagedZoneSpecForProviderCloudLoggingConfig
 */
export interface ManagedZoneSpecForProviderCloudLoggingConfig {
  /**
   * If set, enable query logging for this ManagedZone. False by default, making logging opt-in.
   *
   * @schema ManagedZoneSpecForProviderCloudLoggingConfig#enableLogging
   */
  readonly enableLogging: boolean;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderCloudLoggingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderCloudLoggingConfig(obj: ManagedZoneSpecForProviderCloudLoggingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLogging': obj.enableLogging,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ManagedZoneSpecForProviderDnssecConfig
 */
export interface ManagedZoneSpecForProviderDnssecConfig {
  /**
   * Specifies parameters that will be used for generating initial DnsKeys for this ManagedZone. If you provide a spec for keySigning or zoneSigning, you must also provide one for the other. default_key_specs can only be updated when the state is off. Structure is documented below.
   *
   * @schema ManagedZoneSpecForProviderDnssecConfig#defaultKeySpecs
   */
  readonly defaultKeySpecs?: ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs[];

  /**
   * Identifies what kind of resource this is
   *
   * @schema ManagedZoneSpecForProviderDnssecConfig#kind
   */
  readonly kind?: string;

  /**
   * Specifies the mechanism used to provide authenticated denial-of-existence responses. non_existence can only be updated when the state is off. Possible values are: nsec, nsec3.
   *
   * @schema ManagedZoneSpecForProviderDnssecConfig#nonExistence
   */
  readonly nonExistence?: string;

  /**
   * Specifies whether DNSSEC is enabled, and what mode it is in Possible values are: off, on, transfer.
   *
   * @schema ManagedZoneSpecForProviderDnssecConfig#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderDnssecConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderDnssecConfig(obj: ManagedZoneSpecForProviderDnssecConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultKeySpecs': obj.defaultKeySpecs?.map(y => toJson_ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs(y)),
    'kind': obj.kind,
    'nonExistence': obj.nonExistence,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ManagedZoneSpecForProviderForwardingConfig
 */
export interface ManagedZoneSpecForProviderForwardingConfig {
  /**
   * List of target name servers to forward to. Cloud DNS will select the best available name server if more than one target is given. Structure is documented below.
   *
   * @schema ManagedZoneSpecForProviderForwardingConfig#targetNameServers
   */
  readonly targetNameServers: ManagedZoneSpecForProviderForwardingConfigTargetNameServers[];

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderForwardingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderForwardingConfig(obj: ManagedZoneSpecForProviderForwardingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNameServers': obj.targetNameServers?.map(y => toJson_ManagedZoneSpecForProviderForwardingConfigTargetNameServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ManagedZoneSpecForProviderPeeringConfig
 */
export interface ManagedZoneSpecForProviderPeeringConfig {
  /**
   * The network with which to peer. Structure is documented below.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfig#targetNetwork
   */
  readonly targetNetwork: ManagedZoneSpecForProviderPeeringConfigTargetNetwork[];

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfig(obj: ManagedZoneSpecForProviderPeeringConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNetwork': obj.targetNetwork?.map(y => toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetwork(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfig
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfig {
  /**
   * The list of Google Kubernetes Engine clusters that can see this zone. Structure is documented below.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfig#gkeClusters
   */
  readonly gkeClusters?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters[];

  /**
   * The list of VPC networks that can see this zone.12 SDK in a future release, you may experience issues with this resource while updating. If you encounter this issue, remove all networks blocks in an update and then apply another update adding all of them back simultaneously. Structure is documented below.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfig#networks
   */
  readonly networks: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks[];

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfig(obj: ManagedZoneSpecForProviderPrivateVisibilityConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusters': obj.gkeClusters?.map(y => toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters(y)),
    'networks': obj.networks?.map(y => toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecProviderConfigRefPolicy
 */
export interface ManagedZoneSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecProviderConfigRefPolicy(obj: ManagedZoneSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecProviderRefPolicy
 */
export interface ManagedZoneSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecProviderRefPolicy(obj: ManagedZoneSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ManagedZoneSpecPublishConnectionDetailsToConfigRef
 */
export interface ManagedZoneSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ManagedZoneSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecPublishConnectionDetailsToConfigRef(obj: ManagedZoneSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ManagedZoneSpecPublishConnectionDetailsToMetadata
 */
export interface ManagedZoneSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ManagedZoneSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ManagedZoneSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ManagedZoneSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ManagedZoneSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecPublishConnectionDetailsToMetadata(obj: ManagedZoneSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs
 */
export interface ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs {
  /**
   * String mnemonic specifying the DNSSEC algorithm of this key Possible values are: ecdsap256sha256, ecdsap384sha384, rsasha1, rsasha256, rsasha512.
   *
   * @schema ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs#algorithm
   */
  readonly algorithm?: string;

  /**
   * Length of the keys in bits
   *
   * @schema ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs#keyLength
   */
  readonly keyLength?: number;

  /**
   * Specifies whether this is a key signing key (KSK) or a zone signing key (ZSK). Key signing keys have the Secure Entry Point flag set and, when active, will only be used to sign resource record sets of type DNSKEY. Zone signing keys do not have the Secure Entry Point flag set and will be used to sign all other types of resource record sets. Possible values are: keySigning, zoneSigning.
   *
   * @schema ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs#keyType
   */
  readonly keyType?: string;

  /**
   * Identifies what kind of resource this is
   *
   * @schema ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs#kind
   */
  readonly kind?: string;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs(obj: ManagedZoneSpecForProviderDnssecConfigDefaultKeySpecs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'keyLength': obj.keyLength,
    'keyType': obj.keyType,
    'kind': obj.kind,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ManagedZoneSpecForProviderForwardingConfigTargetNameServers
 */
export interface ManagedZoneSpecForProviderForwardingConfigTargetNameServers {
  /**
   * Forwarding path for this TargetNameServer. If unset or default Cloud DNS will make forwarding decision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go to the Internet. When set to private, Cloud DNS will always send queries through VPC for this target Possible values are: default, private.
   *
   * @schema ManagedZoneSpecForProviderForwardingConfigTargetNameServers#forwardingPath
   */
  readonly forwardingPath?: string;

  /**
   * IPv4 address of a target name server.
   *
   * @schema ManagedZoneSpecForProviderForwardingConfigTargetNameServers#ipv4Address
   */
  readonly ipv4Address: string;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderForwardingConfigTargetNameServers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderForwardingConfigTargetNameServers(obj: ManagedZoneSpecForProviderForwardingConfigTargetNameServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forwardingPath': obj.forwardingPath,
    'ipv4Address': obj.ipv4Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetwork
 */
export interface ManagedZoneSpecForProviderPeeringConfigTargetNetwork {
  /**
   * The id or fully qualified URL of the VPC network to forward queries to. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetwork#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetwork#networkUrlRef
   */
  readonly networkUrlRef?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetwork#networkUrlSelector
   */
  readonly networkUrlSelector?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfigTargetNetwork' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetwork(obj: ManagedZoneSpecForProviderPeeringConfigTargetNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector(obj.networkUrlSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters {
  /**
   * The resource name of the cluster to bind this ManagedZone to. This should be specified in the format like projects/_/locations/_/clusters/*
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters#gkeClusterName
   */
  readonly gkeClusterName?: string;

  /**
   * Reference to a Cluster in container to populate gkeClusterName.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters#gkeClusterNameRef
   */
  readonly gkeClusterNameRef?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef;

  /**
   * Selector for a Cluster in container to populate gkeClusterName.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters#gkeClusterNameSelector
   */
  readonly gkeClusterNameSelector?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClusters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeClusterName': obj.gkeClusterName,
    'gkeClusterNameRef': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj.gkeClusterNameRef),
    'gkeClusterNameSelector': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector(obj.gkeClusterNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks {
  /**
   * The id or fully qualified URL of the VPC network to forward queries to. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks#networkUrlRef
   */
  readonly networkUrlRef?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks#networkUrlSelector
   */
  readonly networkUrlSelector?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector(obj.networkUrlSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecProviderConfigRefPolicyResolution
 */
export enum ManagedZoneSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneSpecProviderConfigRefPolicyResolve
 */
export enum ManagedZoneSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecProviderRefPolicyResolution
 */
export enum ManagedZoneSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneSpecProviderRefPolicyResolve
 */
export enum ManagedZoneSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicy(obj: ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef
 */
export interface ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef(obj: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector
 */
export interface ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector(obj: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in container to populate gkeClusterName.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in container to populate gkeClusterName.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector#policy
   */
  readonly policy?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ManagedZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy
 */
export interface ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy(obj: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy
 */
export interface ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy(obj: ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy
 */
export interface ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy(obj: ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution
 */
export enum ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve
 */
export enum ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution
 */
export enum ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve
 */
export enum ManagedZoneSpecForProviderPeeringConfigTargetNetworkNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigGkeClustersGkeClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve
 */
export enum ManagedZoneSpecForProviderPrivateVisibilityConfigNetworksNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ManagedZoneIAMMember is the Schema for the ManagedZoneIAMMembers API. <no value>
 *
 * @schema ManagedZoneIAMMember
 */
export class ManagedZoneIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ManagedZoneIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dns.gcp.upbound.io/v1beta1',
    kind: 'ManagedZoneIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "ManagedZoneIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ManagedZoneIamMemberProps): any {
    return {
      ...ManagedZoneIamMember.GVK,
      ...toJson_ManagedZoneIamMemberProps(props),
    };
  }

  /**
   * Defines a "ManagedZoneIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ManagedZoneIamMemberProps) {
    super(scope, id, {
      ...ManagedZoneIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ManagedZoneIamMember.GVK,
      ...toJson_ManagedZoneIamMemberProps(resolved),
    };
  }
}

/**
 * ManagedZoneIAMMember is the Schema for the ManagedZoneIAMMembers API. <no value>
 *
 * @schema ManagedZoneIAMMember
 */
export interface ManagedZoneIamMemberProps {
  /**
   * @schema ManagedZoneIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ManagedZoneIAMMemberSpec defines the desired state of ManagedZoneIAMMember
   *
   * @schema ManagedZoneIAMMember#spec
   */
  readonly spec: ManagedZoneIamMemberSpec;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberProps(obj: ManagedZoneIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ManagedZoneIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ManagedZoneIAMMemberSpec defines the desired state of ManagedZoneIAMMember
 *
 * @schema ManagedZoneIamMemberSpec
 */
export interface ManagedZoneIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ManagedZoneIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: ManagedZoneIamMemberSpecDeletionPolicy;

  /**
   * @schema ManagedZoneIamMemberSpec#forProvider
   */
  readonly forProvider: ManagedZoneIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ManagedZoneIamMemberSpec#managementPolicy
   */
  readonly managementPolicy?: ManagedZoneIamMemberSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ManagedZoneIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: ManagedZoneIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ManagedZoneIamMemberSpec#providerRef
   */
  readonly providerRef?: ManagedZoneIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ManagedZoneIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ManagedZoneIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ManagedZoneIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ManagedZoneIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpec(obj: ManagedZoneIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ManagedZoneIamMemberSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ManagedZoneIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ManagedZoneIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ManagedZoneIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ManagedZoneIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ManagedZoneIamMemberSpecDeletionPolicy
 */
export enum ManagedZoneIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ManagedZoneIamMemberSpecForProvider
 */
export interface ManagedZoneIamMemberSpecForProvider {
  /**
   * @schema ManagedZoneIamMemberSpecForProvider#condition
   */
  readonly condition?: ManagedZoneIamMemberSpecForProviderCondition[];

  /**
   * @schema ManagedZoneIamMemberSpecForProvider#managedZone
   */
  readonly managedZone?: string;

  /**
   * @schema ManagedZoneIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema ManagedZoneIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema ManagedZoneIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpecForProvider(obj: ManagedZoneIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_ManagedZoneIamMemberSpecForProviderCondition(y)),
    'managedZone': obj.managedZone,
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ManagedZoneIamMemberSpecManagementPolicy
 */
export enum ManagedZoneIamMemberSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ManagedZoneIamMemberSpecProviderConfigRef
 */
export interface ManagedZoneIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: ManagedZoneIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpecProviderConfigRef(obj: ManagedZoneIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ManagedZoneIamMemberSpecProviderRef
 */
export interface ManagedZoneIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneIamMemberSpecProviderRef#policy
   */
  readonly policy?: ManagedZoneIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpecProviderRef(obj: ManagedZoneIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsTo
 */
export interface ManagedZoneIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ManagedZoneIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpecPublishConnectionDetailsTo(obj: ManagedZoneIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ManagedZoneIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ManagedZoneIamMemberSpecWriteConnectionSecretToRef
 */
export interface ManagedZoneIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ManagedZoneIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ManagedZoneIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpecWriteConnectionSecretToRef(obj: ManagedZoneIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ManagedZoneIamMemberSpecForProviderCondition
 */
export interface ManagedZoneIamMemberSpecForProviderCondition {
  /**
   * @schema ManagedZoneIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema ManagedZoneIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema ManagedZoneIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpecForProviderCondition(obj: ManagedZoneIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneIamMemberSpecProviderConfigRefPolicy
 */
export interface ManagedZoneIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpecProviderConfigRefPolicy(obj: ManagedZoneIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneIamMemberSpecProviderRefPolicy
 */
export interface ManagedZoneIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpecProviderRefPolicy(obj: ManagedZoneIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRef(obj: ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface ManagedZoneIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpecPublishConnectionDetailsToMetadata(obj: ManagedZoneIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum ManagedZoneIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum ManagedZoneIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneIamMemberSpecProviderRefPolicyResolution
 */
export enum ManagedZoneIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneIamMemberSpecProviderRefPolicyResolve
 */
export enum ManagedZoneIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ManagedZoneIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Policy is the Schema for the Policys API. A policy is a collection of DNS rules applied to one or more Virtual Private Cloud resources.
 *
 * @schema Policy
 */
export class Policy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Policy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dns.gcp.upbound.io/v1beta1',
    kind: 'Policy',
  }

  /**
   * Renders a Kubernetes manifest for "Policy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyProps): any {
    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(props),
    };
  }

  /**
   * Defines a "Policy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyProps) {
    super(scope, id, {
      ...Policy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(resolved),
    };
  }
}

/**
 * Policy is the Schema for the Policys API. A policy is a collection of DNS rules applied to one or more Virtual Private Cloud resources.
 *
 * @schema Policy
 */
export interface PolicyProps {
  /**
   * @schema Policy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicySpec defines the desired state of Policy
   *
   * @schema Policy#spec
   */
  readonly spec: PolicySpec;

}

/**
 * Converts an object of type 'PolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyProps(obj: PolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicySpec defines the desired state of Policy
 *
 * @schema PolicySpec
 */
export interface PolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: PolicySpecDeletionPolicy;

  /**
   * @schema PolicySpec#forProvider
   */
  readonly forProvider: PolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#managementPolicy
   */
  readonly managementPolicy?: PolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: PolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PolicySpec#providerRef
   */
  readonly providerRef?: PolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpec(obj: PolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecDeletionPolicy
 */
export enum PolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PolicySpecForProvider
 */
export interface PolicySpecForProvider {
  /**
   * Sets an alternative name server for the associated networks. When specified, all DNS queries are forwarded to a name server that you choose. Names such as .internal are not available when an alternative name server is specified. Structure is documented below.
   *
   * @schema PolicySpecForProvider#alternativeNameServerConfig
   */
  readonly alternativeNameServerConfig?: PolicySpecForProviderAlternativeNameServerConfig[];

  /**
   * A textual description field.
   *
   * @schema PolicySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Allows networks bound to this policy to receive DNS queries sent by VMs or applications over VPN connections. When enabled, a virtual IP address will be allocated from each of the sub-networks that are bound to this policy.
   *
   * @schema PolicySpecForProvider#enableInboundForwarding
   */
  readonly enableInboundForwarding?: boolean;

  /**
   * Controls whether logging is enabled for the networks bound to this policy. Defaults to no logging if not set.
   *
   * @default no logging if not set.
   * @schema PolicySpecForProvider#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * List of network names specifying networks to which this policy is applied. Structure is documented below.
   *
   * @schema PolicySpecForProvider#networks
   */
  readonly networks?: PolicySpecForProviderNetworks[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema PolicySpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'PolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProvider(obj: PolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alternativeNameServerConfig': obj.alternativeNameServerConfig?.map(y => toJson_PolicySpecForProviderAlternativeNameServerConfig(y)),
    'description': obj.description,
    'enableInboundForwarding': obj.enableInboundForwarding,
    'enableLogging': obj.enableLogging,
    'networks': obj.networks?.map(y => toJson_PolicySpecForProviderNetworks(y)),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecManagementPolicy
 */
export enum PolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PolicySpecProviderConfigRef
 */
export interface PolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderConfigRef#policy
   */
  readonly policy?: PolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRef(obj: PolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PolicySpecProviderRef
 */
export interface PolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderRef#policy
   */
  readonly policy?: PolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderRef(obj: PolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PolicySpecPublishConnectionDetailsTo
 */
export interface PolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsTo(obj: PolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PolicySpecWriteConnectionSecretToRef
 */
export interface PolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWriteConnectionSecretToRef(obj: PolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderAlternativeNameServerConfig
 */
export interface PolicySpecForProviderAlternativeNameServerConfig {
  /**
   * Sets an alternative name server for the associated networks. When specified, all DNS queries are forwarded to a name server that you choose. Names such as .internal are not available when an alternative name server is specified. Structure is documented below.
   *
   * @schema PolicySpecForProviderAlternativeNameServerConfig#targetNameServers
   */
  readonly targetNameServers: PolicySpecForProviderAlternativeNameServerConfigTargetNameServers[];

}

/**
 * Converts an object of type 'PolicySpecForProviderAlternativeNameServerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderAlternativeNameServerConfig(obj: PolicySpecForProviderAlternativeNameServerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetNameServers': obj.targetNameServers?.map(y => toJson_PolicySpecForProviderAlternativeNameServerConfigTargetNameServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderNetworks
 */
export interface PolicySpecForProviderNetworks {
  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema PolicySpecForProviderNetworks#networkRef
   */
  readonly networkRef?: PolicySpecForProviderNetworksNetworkRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema PolicySpecForProviderNetworks#networkSelector
   */
  readonly networkSelector?: PolicySpecForProviderNetworksNetworkSelector;

  /**
   * The id or fully qualified URL of the VPC network to forward queries to. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
   *
   * @schema PolicySpecForProviderNetworks#networkUrl
   */
  readonly networkUrl?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderNetworks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderNetworks(obj: PolicySpecForProviderNetworks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkRef': toJson_PolicySpecForProviderNetworksNetworkRef(obj.networkRef),
    'networkSelector': toJson_PolicySpecForProviderNetworksNetworkSelector(obj.networkSelector),
    'networkUrl': obj.networkUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderConfigRefPolicy
 */
export interface PolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRefPolicy(obj: PolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderRefPolicy
 */
export interface PolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderRefPolicy(obj: PolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRef
 */
export interface PolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj: PolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PolicySpecPublishConnectionDetailsToMetadata
 */
export interface PolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToMetadata(obj: PolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderAlternativeNameServerConfigTargetNameServers
 */
export interface PolicySpecForProviderAlternativeNameServerConfigTargetNameServers {
  /**
   * Forwarding path for this TargetNameServer. If unset or default Cloud DNS will make forwarding decision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go to the Internet. When set to private, Cloud DNS will always send queries through VPC for this target Possible values are: default, private.
   *
   * @schema PolicySpecForProviderAlternativeNameServerConfigTargetNameServers#forwardingPath
   */
  readonly forwardingPath?: string;

  /**
   * IPv4 address to forward to.
   *
   * @schema PolicySpecForProviderAlternativeNameServerConfigTargetNameServers#ipv4Address
   */
  readonly ipv4Address: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderAlternativeNameServerConfigTargetNameServers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderAlternativeNameServerConfigTargetNameServers(obj: PolicySpecForProviderAlternativeNameServerConfigTargetNameServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forwardingPath': obj.forwardingPath,
    'ipv4Address': obj.ipv4Address,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema PolicySpecForProviderNetworksNetworkRef
 */
export interface PolicySpecForProviderNetworksNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecForProviderNetworksNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecForProviderNetworksNetworkRef#policy
   */
  readonly policy?: PolicySpecForProviderNetworksNetworkRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderNetworksNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderNetworksNetworkRef(obj: PolicySpecForProviderNetworksNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecForProviderNetworksNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema PolicySpecForProviderNetworksNetworkSelector
 */
export interface PolicySpecForProviderNetworksNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicySpecForProviderNetworksNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicySpecForProviderNetworksNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicySpecForProviderNetworksNetworkSelector#policy
   */
  readonly policy?: PolicySpecForProviderNetworksNetworkSelectorPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderNetworksNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderNetworksNetworkSelector(obj: PolicySpecForProviderNetworksNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicySpecForProviderNetworksNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolution
 */
export enum PolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolve
 */
export enum PolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderRefPolicyResolution
 */
export enum PolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderRefPolicyResolve
 */
export enum PolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: PolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecForProviderNetworksNetworkRefPolicy
 */
export interface PolicySpecForProviderNetworksNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderNetworksNetworkRefPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderNetworksNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderNetworksNetworkRefPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderNetworksNetworkRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderNetworksNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderNetworksNetworkRefPolicy(obj: PolicySpecForProviderNetworksNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicySpecForProviderNetworksNetworkSelectorPolicy
 */
export interface PolicySpecForProviderNetworksNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderNetworksNetworkSelectorPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderNetworksNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderNetworksNetworkSelectorPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderNetworksNetworkSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderNetworksNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderNetworksNetworkSelectorPolicy(obj: PolicySpecForProviderNetworksNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderNetworksNetworkRefPolicyResolution
 */
export enum PolicySpecForProviderNetworksNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderNetworksNetworkRefPolicyResolve
 */
export enum PolicySpecForProviderNetworksNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderNetworksNetworkSelectorPolicyResolution
 */
export enum PolicySpecForProviderNetworksNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderNetworksNetworkSelectorPolicyResolve
 */
export enum PolicySpecForProviderNetworksNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RecordSet is the Schema for the RecordSets API. Manages a set of DNS records within Google Cloud DNS.
 *
 * @schema RecordSet
 */
export class RecordSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RecordSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dns.gcp.upbound.io/v1beta1',
    kind: 'RecordSet',
  }

  /**
   * Renders a Kubernetes manifest for "RecordSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RecordSetProps): any {
    return {
      ...RecordSet.GVK,
      ...toJson_RecordSetProps(props),
    };
  }

  /**
   * Defines a "RecordSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RecordSetProps) {
    super(scope, id, {
      ...RecordSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RecordSet.GVK,
      ...toJson_RecordSetProps(resolved),
    };
  }
}

/**
 * RecordSet is the Schema for the RecordSets API. Manages a set of DNS records within Google Cloud DNS.
 *
 * @schema RecordSet
 */
export interface RecordSetProps {
  /**
   * @schema RecordSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RecordSetSpec defines the desired state of RecordSet
   *
   * @schema RecordSet#spec
   */
  readonly spec: RecordSetSpec;

}

/**
 * Converts an object of type 'RecordSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetProps(obj: RecordSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RecordSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RecordSetSpec defines the desired state of RecordSet
 *
 * @schema RecordSetSpec
 */
export interface RecordSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RecordSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: RecordSetSpecDeletionPolicy;

  /**
   * @schema RecordSetSpec#forProvider
   */
  readonly forProvider: RecordSetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RecordSetSpec#managementPolicy
   */
  readonly managementPolicy?: RecordSetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RecordSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: RecordSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RecordSetSpec#providerRef
   */
  readonly providerRef?: RecordSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RecordSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RecordSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RecordSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RecordSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RecordSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpec(obj: RecordSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RecordSetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RecordSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RecordSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RecordSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RecordSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RecordSetSpecDeletionPolicy
 */
export enum RecordSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RecordSetSpecForProvider
 */
export interface RecordSetSpecForProvider {
  /**
   * The name of the zone in which this record set will reside.
   *
   * @schema RecordSetSpecForProvider#managedZone
   */
  readonly managedZone?: string;

  /**
   * Reference to a ManagedZone in dns to populate managedZone.
   *
   * @schema RecordSetSpecForProvider#managedZoneRef
   */
  readonly managedZoneRef?: RecordSetSpecForProviderManagedZoneRef;

  /**
   * Selector for a ManagedZone in dns to populate managedZone.
   *
   * @schema RecordSetSpecForProvider#managedZoneSelector
   */
  readonly managedZoneSelector?: RecordSetSpecForProviderManagedZoneSelector;

  /**
   * The DNS name this record set will apply to.
   *
   * @schema RecordSetSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema RecordSetSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The configuration for steering traffic based on query. Now you can specify either Weighted Round Robin(WRR) type or Geolocation(GEO) type. Structure is documented below.
   *
   * @schema RecordSetSpecForProvider#routingPolicy
   */
  readonly routingPolicy?: RecordSetSpecForProviderRoutingPolicy[];

  /**
   * The string data for the records in this record set whose meaning depends on the DNS type. For TXT record, if the string data contains spaces, add surrounding \" if you don't want your string to get split on spaces.g. "first255characters\" \"morecharacters").
   *
   * @schema RecordSetSpecForProvider#rrdatas
   */
  readonly rrdatas?: string[];

  /**
   * The time-to-live of this record set (seconds).
   *
   * @schema RecordSetSpecForProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The DNS record set type.
   *
   * @schema RecordSetSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProvider(obj: RecordSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'managedZone': obj.managedZone,
    'managedZoneRef': toJson_RecordSetSpecForProviderManagedZoneRef(obj.managedZoneRef),
    'managedZoneSelector': toJson_RecordSetSpecForProviderManagedZoneSelector(obj.managedZoneSelector),
    'name': obj.name,
    'project': obj.project,
    'routingPolicy': obj.routingPolicy?.map(y => toJson_RecordSetSpecForProviderRoutingPolicy(y)),
    'rrdatas': obj.rrdatas?.map(y => y),
    'ttl': obj.ttl,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RecordSetSpecManagementPolicy
 */
export enum RecordSetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RecordSetSpecProviderConfigRef
 */
export interface RecordSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecProviderConfigRef#policy
   */
  readonly policy?: RecordSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecProviderConfigRef(obj: RecordSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RecordSetSpecProviderRef
 */
export interface RecordSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecProviderRef#policy
   */
  readonly policy?: RecordSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecProviderRef(obj: RecordSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RecordSetSpecPublishConnectionDetailsTo
 */
export interface RecordSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RecordSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RecordSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RecordSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RecordSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RecordSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RecordSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecPublishConnectionDetailsTo(obj: RecordSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RecordSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RecordSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RecordSetSpecWriteConnectionSecretToRef
 */
export interface RecordSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RecordSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RecordSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RecordSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecWriteConnectionSecretToRef(obj: RecordSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ManagedZone in dns to populate managedZone.
 *
 * @schema RecordSetSpecForProviderManagedZoneRef
 */
export interface RecordSetSpecForProviderManagedZoneRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecForProviderManagedZoneRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecForProviderManagedZoneRef#policy
   */
  readonly policy?: RecordSetSpecForProviderManagedZoneRefPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderManagedZoneRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderManagedZoneRef(obj: RecordSetSpecForProviderManagedZoneRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecForProviderManagedZoneRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ManagedZone in dns to populate managedZone.
 *
 * @schema RecordSetSpecForProviderManagedZoneSelector
 */
export interface RecordSetSpecForProviderManagedZoneSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RecordSetSpecForProviderManagedZoneSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecForProviderManagedZoneSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecForProviderManagedZoneSelector#policy
   */
  readonly policy?: RecordSetSpecForProviderManagedZoneSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderManagedZoneSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderManagedZoneSelector(obj: RecordSetSpecForProviderManagedZoneSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecForProviderManagedZoneSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicy {
  /**
   * Specifies whether to enable fencing for geo queries.
   *
   * @schema RecordSetSpecForProviderRoutingPolicy#enableGeoFencing
   */
  readonly enableGeoFencing?: boolean;

  /**
   * The configuration for Geolocation based routing policy. Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicy#geo
   */
  readonly geo?: RecordSetSpecForProviderRoutingPolicyGeo[];

  /**
   * The configuration for a primary-backup policy with global to regional failover. Queries are responded to with the global primary targets, but if none of the primary targets are healthy, then we fallback to a regional failover policy. Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicy#primaryBackup
   */
  readonly primaryBackup?: RecordSetSpecForProviderRoutingPolicyPrimaryBackup[];

  /**
   * The configuration for Weighted Round Robin based routing policy. Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicy#wrr
   */
  readonly wrr?: RecordSetSpecForProviderRoutingPolicyWrr[];

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicy(obj: RecordSetSpecForProviderRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableGeoFencing': obj.enableGeoFencing,
    'geo': obj.geo?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyGeo(y)),
    'primaryBackup': obj.primaryBackup?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackup(y)),
    'wrr': obj.wrr?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyWrr(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecProviderConfigRefPolicy
 */
export interface RecordSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecProviderConfigRefPolicy(obj: RecordSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecProviderRefPolicy
 */
export interface RecordSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecProviderRefPolicy(obj: RecordSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RecordSetSpecPublishConnectionDetailsToConfigRef
 */
export interface RecordSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RecordSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecPublishConnectionDetailsToConfigRef(obj: RecordSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RecordSetSpecPublishConnectionDetailsToMetadata
 */
export interface RecordSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RecordSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecPublishConnectionDetailsToMetadata(obj: RecordSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecForProviderManagedZoneRefPolicy
 */
export interface RecordSetSpecForProviderManagedZoneRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderManagedZoneRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderManagedZoneRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderManagedZoneRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderManagedZoneRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderManagedZoneRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderManagedZoneRefPolicy(obj: RecordSetSpecForProviderManagedZoneRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecForProviderManagedZoneSelectorPolicy
 */
export interface RecordSetSpecForProviderManagedZoneSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderManagedZoneSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderManagedZoneSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderManagedZoneSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderManagedZoneSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderManagedZoneSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderManagedZoneSelectorPolicy(obj: RecordSetSpecForProviderManagedZoneSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyGeo
 */
export interface RecordSetSpecForProviderRoutingPolicyGeo {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set. Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeo#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets[];

  /**
   * The location name defined in Google Cloud.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeo#location
   */
  readonly location: string;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeo#rrdatas
   */
  readonly rrdatas?: string[];

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyGeo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyGeo(obj: RecordSetSpecForProviderRoutingPolicyGeo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': obj.healthCheckedTargets?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets(y)),
    'location': obj.location,
    'rrdatas': obj.rrdatas?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackup
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackup {
  /**
   * The backup geo targets, which provide a regional failover policy for the otherwise global primary targets. Structure is document above.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackup#backupGeo
   */
  readonly backupGeo: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo[];

  /**
   * Specifies whether to enable fencing for backup geo queries.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackup#enableGeoFencingForBackups
   */
  readonly enableGeoFencingForBackups?: boolean;

  /**
   * The list of global primary targets to be health checked. Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackup#primary
   */
  readonly primary: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary[];

  /**
   * Specifies the percentage of traffic to send to the backup targets even when the primary targets are healthy.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackup#trickleRatio
   */
  readonly trickleRatio?: number;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackup(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'backupGeo': obj.backupGeo?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo(y)),
    'enableGeoFencingForBackups': obj.enableGeoFencingForBackups,
    'primary': obj.primary?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary(y)),
    'trickleRatio': obj.trickleRatio,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyWrr
 */
export interface RecordSetSpecForProviderRoutingPolicyWrr {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set. Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrr#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets[];

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrr#rrdatas
   */
  readonly rrdatas?: string[];

  /**
   * The ratio of traffic routed to the target.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrr#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyWrr' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyWrr(obj: RecordSetSpecForProviderRoutingPolicyWrr | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': obj.healthCheckedTargets?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets(y)),
    'rrdatas': obj.rrdatas?.map(y => y),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecProviderConfigRefPolicyResolution
 */
export enum RecordSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecProviderConfigRefPolicyResolve
 */
export enum RecordSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecProviderRefPolicyResolution
 */
export enum RecordSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecProviderRefPolicyResolve
 */
export enum RecordSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RecordSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: RecordSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderManagedZoneRefPolicyResolution
 */
export enum RecordSetSpecForProviderManagedZoneRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderManagedZoneRefPolicyResolve
 */
export enum RecordSetSpecForProviderManagedZoneRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderManagedZoneSelectorPolicyResolution
 */
export enum RecordSetSpecForProviderManagedZoneSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderManagedZoneSelectorPolicyResolve
 */
export enum RecordSetSpecForProviderManagedZoneSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets
 */
export interface RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets {
  /**
   * The list of internal load balancers to health check. Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers: RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers[];

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets(obj: RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo {
  /**
   * The list of targets to be health checked. Note that if DNSSEC is enabled for this zone, only one of rrdatas or health_checked_targets can be set. Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo#healthCheckedTargets
   */
  readonly healthCheckedTargets?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets[];

  /**
   * The location name defined in Google Cloud.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo#location
   */
  readonly location: string;

  /**
   * Same as rrdatas above.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo#rrdatas
   */
  readonly rrdatas?: string[];

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckedTargets': obj.healthCheckedTargets?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets(y)),
    'location': obj.location,
    'rrdatas': obj.rrdatas?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary {
  /**
   * The list of internal load balancers to health check. Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary#internalLoadBalancers
   */
  readonly internalLoadBalancers: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers[];

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets
 */
export interface RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets {
  /**
   * The list of internal load balancers to health check. Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers: RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers[];

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets(obj: RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RecordSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RecordSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetSpecForProviderRoutingPolicyGeoHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets {
  /**
   * The list of internal load balancers to health check. Structure is document below.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets#internalLoadBalancers
   */
  readonly internalLoadBalancers: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers[];

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'internalLoadBalancers': obj.internalLoadBalancers?.map(y => toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * Reference to a ForwardingRule in compute to populate ipAddress.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddressRef
   */
  readonly ipAddressRef?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef;

  /**
   * Selector for a ForwardingRule in compute to populate ipAddress.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipAddressSelector
   */
  readonly ipAddressSelector?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrl
   */
  readonly networkUrl?: string;

  /**
   * Reference to a Network in compute to populate networkUrl.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrlRef
   */
  readonly networkUrlRef?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef;

  /**
   * Selector for a Network in compute to populate networkUrl.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#networkUrlSelector
   */
  readonly networkUrlSelector?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#port
   */
  readonly port: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#project
   */
  readonly project?: string;

  /**
   * Reference to a ForwardingRule in compute to populate project.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#projectRef
   */
  readonly projectRef?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef;

  /**
   * Selector for a ForwardingRule in compute to populate project.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#projectSelector
   */
  readonly projectSelector?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#region
   */
  readonly region?: string;

  /**
   * Reference to a ForwardingRule in compute to populate region.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#regionRef
   */
  readonly regionRef?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef;

  /**
   * Selector for a ForwardingRule in compute to populate region.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers#regionSelector
   */
  readonly regionSelector?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipAddressRef': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef(obj.ipAddressRef),
    'ipAddressSelector': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector(obj.ipAddressSelector),
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'networkUrlRef': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef(obj.networkUrlRef),
    'networkUrlSelector': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector(obj.networkUrlSelector),
    'port': obj.port,
    'project': obj.project,
    'projectRef': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef(obj.projectRef),
    'projectSelector': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector(obj.projectSelector),
    'region': obj.region,
    'regionRef': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef(obj.regionRef),
    'regionSelector': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector(obj.regionSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetSpecForProviderRoutingPolicyWrrHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers {
  /**
   * The frontend IP address of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#ipAddress
   */
  readonly ipAddress: string;

  /**
   * The configured IP protocol of the load balancer. This value is case-sensitive. Possible values: ["tcp", "udp"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#ipProtocol
   */
  readonly ipProtocol: string;

  /**
   * The type of load balancer. This value is case-sensitive. Possible values: ["regionalL4ilb"]
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#loadBalancerType
   */
  readonly loadBalancerType: string;

  /**
   * The fully qualified url of the network in which the load balancer belongs. This should be formatted like projects/{project}/global/networks/{network} or https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#networkUrl
   */
  readonly networkUrl: string;

  /**
   * The configured port of the load balancer.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#port
   */
  readonly port: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#project
   */
  readonly project: string;

  /**
   * The region of the load balancer. Only needed for regional load balancers.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupBackupGeoHealthCheckedTargetsInternalLoadBalancers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipAddress': obj.ipAddress,
    'ipProtocol': obj.ipProtocol,
    'loadBalancerType': obj.loadBalancerType,
    'networkUrl': obj.networkUrl,
    'port': obj.port,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ForwardingRule in compute to populate ipAddress.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ForwardingRule in compute to populate ipAddress.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Network in compute to populate networkUrl.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Network in compute to populate networkUrl.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ForwardingRule in compute to populate project.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ForwardingRule in compute to populate project.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ForwardingRule in compute to populate region.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ForwardingRule in compute to populate region.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector#policy
   */
  readonly policy?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy
 */
export interface RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy#resolution
   */
  readonly resolution?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy#resolve
   */
  readonly resolve?: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy(obj: RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersIpAddressSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersNetworkUrlSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve
 */
export enum RecordSetSpecForProviderRoutingPolicyPrimaryBackupPrimaryInternalLoadBalancersRegionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

