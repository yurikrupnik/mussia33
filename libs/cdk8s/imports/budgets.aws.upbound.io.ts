// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Budget is the Schema for the Budgets API. Provides a budgets budget resource.
 *
 * @schema Budget
 */
export class Budget extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Budget"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'budgets.aws.upbound.io/v1beta1',
    kind: 'Budget',
  }

  /**
   * Renders a Kubernetes manifest for "Budget".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BudgetProps): any {
    return {
      ...Budget.GVK,
      ...toJson_BudgetProps(props),
    };
  }

  /**
   * Defines a "Budget" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BudgetProps) {
    super(scope, id, {
      ...Budget.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Budget.GVK,
      ...toJson_BudgetProps(resolved),
    };
  }
}

/**
 * Budget is the Schema for the Budgets API. Provides a budgets budget resource.
 *
 * @schema Budget
 */
export interface BudgetProps {
  /**
   * @schema Budget#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BudgetSpec defines the desired state of Budget
   *
   * @schema Budget#spec
   */
  readonly spec: BudgetSpec;

}

/**
 * Converts an object of type 'BudgetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetProps(obj: BudgetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BudgetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BudgetSpec defines the desired state of Budget
 *
 * @schema BudgetSpec
 */
export interface BudgetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BudgetSpec#deletionPolicy
   */
  readonly deletionPolicy?: BudgetSpecDeletionPolicy;

  /**
   * @schema BudgetSpec#forProvider
   */
  readonly forProvider: BudgetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BudgetSpec#providerConfigRef
   */
  readonly providerConfigRef?: BudgetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BudgetSpec#providerRef
   */
  readonly providerRef?: BudgetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BudgetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BudgetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BudgetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BudgetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BudgetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpec(obj: BudgetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BudgetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BudgetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BudgetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BudgetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BudgetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BudgetSpecDeletionPolicy
 */
export enum BudgetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BudgetSpecForProvider
 */
export interface BudgetSpecForProvider {
  /**
   * The ID of the target account for budget. Will use current user's account_id by default if omitted.
   *
   * @schema BudgetSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * Object containing [AutoAdjustData] which determines the budget amount for an auto-adjusting budget.
   *
   * @schema BudgetSpecForProvider#autoAdjustData
   */
  readonly autoAdjustData?: BudgetSpecForProviderAutoAdjustData[];

  /**
   * Whether this budget tracks monetary cost or usage.
   *
   * @schema BudgetSpecForProvider#budgetType
   */
  readonly budgetType: string;

  /**
   * A list of CostFilter name/values pair to apply to budget.
   *
   * @schema BudgetSpecForProvider#costFilter
   */
  readonly costFilter?: BudgetSpecForProviderCostFilter[];

  /**
   * Map of CostFilters key/value pairs to apply to the budget.
   *
   * @schema BudgetSpecForProvider#costFilters
   */
  readonly costFilters?: { [key: string]: string };

  /**
   * Object containing CostTypes The types of cost included in a budget, such as tax and subscriptions.
   *
   * @schema BudgetSpecForProvider#costTypes
   */
  readonly costTypes?: BudgetSpecForProviderCostTypes[];

  /**
   * The amount of cost or usage being measured for a budget.
   *
   * @schema BudgetSpecForProvider#limitAmount
   */
  readonly limitAmount?: string;

  /**
   * The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See Spend documentation.
   *
   * @schema BudgetSpecForProvider#limitUnit
   */
  readonly limitUnit?: string;

  /**
   * Object containing Budget Notifications. Can be used multiple times to define more than one budget notification.
   *
   * @schema BudgetSpecForProvider#notification
   */
  readonly notification?: BudgetSpecForProviderNotification[];

  /**
   * Object containing Planned Budget Limits. Can be used multiple times to plan more than one budget limit. See PlannedBudgetLimits documentation.
   *
   * @schema BudgetSpecForProvider#plannedLimit
   */
  readonly plannedLimit?: BudgetSpecForProviderPlannedLimit[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BudgetSpecForProvider#region
   */
  readonly region: string;

  /**
   * The end of the time period covered by the budget. There are no restrictions on the end date. Format: 2017-01-01_12:00.
   *
   * @schema BudgetSpecForProvider#timePeriodEnd
   */
  readonly timePeriodEnd?: string;

  /**
   * The start of the time period covered by the budget. If you don't specify a start date, AWS defaults to the start of your chosen time period. The start date must come before the end date. Format: 2017-01-01_12:00.
   *
   * @schema BudgetSpecForProvider#timePeriodStart
   */
  readonly timePeriodStart?: string;

  /**
   * The length of time until a budget resets the actual and forecasted spend. Valid values: MONTHLY, QUARTERLY, ANNUALLY, and DAILY.
   *
   * @schema BudgetSpecForProvider#timeUnit
   */
  readonly timeUnit: string;

}

/**
 * Converts an object of type 'BudgetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecForProvider(obj: BudgetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'autoAdjustData': obj.autoAdjustData?.map(y => toJson_BudgetSpecForProviderAutoAdjustData(y)),
    'budgetType': obj.budgetType,
    'costFilter': obj.costFilter?.map(y => toJson_BudgetSpecForProviderCostFilter(y)),
    'costFilters': ((obj.costFilters) === undefined) ? undefined : (Object.entries(obj.costFilters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'costTypes': obj.costTypes?.map(y => toJson_BudgetSpecForProviderCostTypes(y)),
    'limitAmount': obj.limitAmount,
    'limitUnit': obj.limitUnit,
    'notification': obj.notification?.map(y => toJson_BudgetSpecForProviderNotification(y)),
    'plannedLimit': obj.plannedLimit?.map(y => toJson_BudgetSpecForProviderPlannedLimit(y)),
    'region': obj.region,
    'timePeriodEnd': obj.timePeriodEnd,
    'timePeriodStart': obj.timePeriodStart,
    'timeUnit': obj.timeUnit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BudgetSpecProviderConfigRef
 */
export interface BudgetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetSpecProviderConfigRef#policy
   */
  readonly policy?: BudgetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BudgetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecProviderConfigRef(obj: BudgetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BudgetSpecProviderRef
 */
export interface BudgetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetSpecProviderRef#policy
   */
  readonly policy?: BudgetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BudgetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecProviderRef(obj: BudgetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BudgetSpecPublishConnectionDetailsTo
 */
export interface BudgetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BudgetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BudgetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BudgetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BudgetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BudgetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BudgetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecPublishConnectionDetailsTo(obj: BudgetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BudgetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BudgetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BudgetSpecWriteConnectionSecretToRef
 */
export interface BudgetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BudgetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BudgetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BudgetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecWriteConnectionSecretToRef(obj: BudgetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetSpecForProviderAutoAdjustData
 */
export interface BudgetSpecForProviderAutoAdjustData {
  /**
   * @schema BudgetSpecForProviderAutoAdjustData#autoAdjustType
   */
  readonly autoAdjustType: string;

  /**
   * @schema BudgetSpecForProviderAutoAdjustData#historicalOptions
   */
  readonly historicalOptions?: BudgetSpecForProviderAutoAdjustDataHistoricalOptions[];

}

/**
 * Converts an object of type 'BudgetSpecForProviderAutoAdjustData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecForProviderAutoAdjustData(obj: BudgetSpecForProviderAutoAdjustData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoAdjustType': obj.autoAdjustType,
    'historicalOptions': obj.historicalOptions?.map(y => toJson_BudgetSpecForProviderAutoAdjustDataHistoricalOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetSpecForProviderCostFilter
 */
export interface BudgetSpecForProviderCostFilter {
  /**
   * The name of a budget. Unique within accounts.
   *
   * @schema BudgetSpecForProviderCostFilter#name
   */
  readonly name: string;

  /**
   * @schema BudgetSpecForProviderCostFilter#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'BudgetSpecForProviderCostFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecForProviderCostFilter(obj: BudgetSpecForProviderCostFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetSpecForProviderCostTypes
 */
export interface BudgetSpecForProviderCostTypes {
  /**
   * A boolean value whether to include credits in the cost budget. Defaults to true
   *
   * @default true
   * @schema BudgetSpecForProviderCostTypes#includeCredit
   */
  readonly includeCredit?: boolean;

  /**
   * Whether a budget includes discounts. Defaults to true
   *
   * @default true
   * @schema BudgetSpecForProviderCostTypes#includeDiscount
   */
  readonly includeDiscount?: boolean;

  /**
   * A boolean value whether to include other subscription costs in the cost budget. Defaults to true
   *
   * @default true
   * @schema BudgetSpecForProviderCostTypes#includeOtherSubscription
   */
  readonly includeOtherSubscription?: boolean;

  /**
   * A boolean value whether to include recurring costs in the cost budget. Defaults to true
   *
   * @default true
   * @schema BudgetSpecForProviderCostTypes#includeRecurring
   */
  readonly includeRecurring?: boolean;

  /**
   * A boolean value whether to include refunds in the cost budget. Defaults to true
   *
   * @default true
   * @schema BudgetSpecForProviderCostTypes#includeRefund
   */
  readonly includeRefund?: boolean;

  /**
   * A boolean value whether to include subscriptions in the cost budget. Defaults to true
   *
   * @default true
   * @schema BudgetSpecForProviderCostTypes#includeSubscription
   */
  readonly includeSubscription?: boolean;

  /**
   * A boolean value whether to include support costs in the cost budget. Defaults to true
   *
   * @default true
   * @schema BudgetSpecForProviderCostTypes#includeSupport
   */
  readonly includeSupport?: boolean;

  /**
   * A boolean value whether to include tax in the cost budget. Defaults to true
   *
   * @default true
   * @schema BudgetSpecForProviderCostTypes#includeTax
   */
  readonly includeTax?: boolean;

  /**
   * A boolean value whether to include upfront costs in the cost budget. Defaults to true
   *
   * @default true
   * @schema BudgetSpecForProviderCostTypes#includeUpfront
   */
  readonly includeUpfront?: boolean;

  /**
   * Whether a budget uses the amortized rate. Defaults to false
   *
   * @default false
   * @schema BudgetSpecForProviderCostTypes#useAmortized
   */
  readonly useAmortized?: boolean;

  /**
   * A boolean value whether to use blended costs in the cost budget. Defaults to false
   *
   * @default false
   * @schema BudgetSpecForProviderCostTypes#useBlended
   */
  readonly useBlended?: boolean;

}

/**
 * Converts an object of type 'BudgetSpecForProviderCostTypes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecForProviderCostTypes(obj: BudgetSpecForProviderCostTypes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'includeCredit': obj.includeCredit,
    'includeDiscount': obj.includeDiscount,
    'includeOtherSubscription': obj.includeOtherSubscription,
    'includeRecurring': obj.includeRecurring,
    'includeRefund': obj.includeRefund,
    'includeSubscription': obj.includeSubscription,
    'includeSupport': obj.includeSupport,
    'includeTax': obj.includeTax,
    'includeUpfront': obj.includeUpfront,
    'useAmortized': obj.useAmortized,
    'useBlended': obj.useBlended,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetSpecForProviderNotification
 */
export interface BudgetSpecForProviderNotification {
  /**
   * Comparison operator to use to evaluate the condition. Can be LESS_THAN, EQUAL_TO or GREATER_THAN.
   *
   * @schema BudgetSpecForProviderNotification#comparisonOperator
   */
  readonly comparisonOperator: string;

  /**
   * What kind of budget value to notify on. Can be ACTUAL or FORECASTED
   *
   * @schema BudgetSpecForProviderNotification#notificationType
   */
  readonly notificationType: string;

  /**
   * E-Mail addresses to notify. Either this or subscriber_sns_topic_arns is required.
   *
   * @schema BudgetSpecForProviderNotification#subscriberEmailAddresses
   */
  readonly subscriberEmailAddresses?: string[];

  /**
   * SNS topics to notify. Either this or subscriber_email_addresses is required.
   *
   * @schema BudgetSpecForProviderNotification#subscriberSnsTopicArns
   */
  readonly subscriberSnsTopicArns?: string[];

  /**
   * Threshold when the notification should be sent.
   *
   * @schema BudgetSpecForProviderNotification#threshold
   */
  readonly threshold: number;

  /**
   * What kind of threshold is defined. Can be PERCENTAGE OR ABSOLUTE_VALUE.
   *
   * @schema BudgetSpecForProviderNotification#thresholdType
   */
  readonly thresholdType: string;

}

/**
 * Converts an object of type 'BudgetSpecForProviderNotification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecForProviderNotification(obj: BudgetSpecForProviderNotification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparisonOperator': obj.comparisonOperator,
    'notificationType': obj.notificationType,
    'subscriberEmailAddresses': obj.subscriberEmailAddresses?.map(y => y),
    'subscriberSnsTopicArns': obj.subscriberSnsTopicArns?.map(y => y),
    'threshold': obj.threshold,
    'thresholdType': obj.thresholdType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetSpecForProviderPlannedLimit
 */
export interface BudgetSpecForProviderPlannedLimit {
  /**
   * The amount of cost or usage being measured for a budget.
   *
   * @schema BudgetSpecForProviderPlannedLimit#amount
   */
  readonly amount: string;

  /**
   * The start time of the budget limit. Format: 2017-01-01_12:00. See PlannedBudgetLimits documentation.
   *
   * @schema BudgetSpecForProviderPlannedLimit#startTime
   */
  readonly startTime: string;

  /**
   * The unit of measurement used for the budget forecast, actual spend, or budget threshold, such as dollars or GB. See Spend documentation.
   *
   * @schema BudgetSpecForProviderPlannedLimit#unit
   */
  readonly unit: string;

}

/**
 * Converts an object of type 'BudgetSpecForProviderPlannedLimit' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecForProviderPlannedLimit(obj: BudgetSpecForProviderPlannedLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amount': obj.amount,
    'startTime': obj.startTime,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BudgetSpecProviderConfigRefPolicy
 */
export interface BudgetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BudgetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BudgetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecProviderConfigRefPolicy(obj: BudgetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BudgetSpecProviderRefPolicy
 */
export interface BudgetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BudgetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BudgetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecProviderRefPolicy(obj: BudgetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BudgetSpecPublishConnectionDetailsToConfigRef
 */
export interface BudgetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BudgetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BudgetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecPublishConnectionDetailsToConfigRef(obj: BudgetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BudgetSpecPublishConnectionDetailsToMetadata
 */
export interface BudgetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BudgetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BudgetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BudgetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BudgetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecPublishConnectionDetailsToMetadata(obj: BudgetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetSpecForProviderAutoAdjustDataHistoricalOptions
 */
export interface BudgetSpecForProviderAutoAdjustDataHistoricalOptions {
  /**
   * @schema BudgetSpecForProviderAutoAdjustDataHistoricalOptions#budgetAdjustmentPeriod
   */
  readonly budgetAdjustmentPeriod: number;

}

/**
 * Converts an object of type 'BudgetSpecForProviderAutoAdjustDataHistoricalOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecForProviderAutoAdjustDataHistoricalOptions(obj: BudgetSpecForProviderAutoAdjustDataHistoricalOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'budgetAdjustmentPeriod': obj.budgetAdjustmentPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetSpecProviderConfigRefPolicyResolution
 */
export enum BudgetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetSpecProviderConfigRefPolicyResolve
 */
export enum BudgetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetSpecProviderRefPolicyResolution
 */
export enum BudgetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetSpecProviderRefPolicyResolve
 */
export enum BudgetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BudgetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BudgetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BudgetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BudgetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetSpecPublishConnectionDetailsToConfigRefPolicy(obj: BudgetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BudgetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BudgetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BudgetAction is the Schema for the BudgetActions API. Provides a budget action resource.
 *
 * @schema BudgetAction
 */
export class BudgetAction extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BudgetAction"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'budgets.aws.upbound.io/v1beta1',
    kind: 'BudgetAction',
  }

  /**
   * Renders a Kubernetes manifest for "BudgetAction".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BudgetActionProps): any {
    return {
      ...BudgetAction.GVK,
      ...toJson_BudgetActionProps(props),
    };
  }

  /**
   * Defines a "BudgetAction" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BudgetActionProps) {
    super(scope, id, {
      ...BudgetAction.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BudgetAction.GVK,
      ...toJson_BudgetActionProps(resolved),
    };
  }
}

/**
 * BudgetAction is the Schema for the BudgetActions API. Provides a budget action resource.
 *
 * @schema BudgetAction
 */
export interface BudgetActionProps {
  /**
   * @schema BudgetAction#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BudgetActionSpec defines the desired state of BudgetAction
   *
   * @schema BudgetAction#spec
   */
  readonly spec: BudgetActionSpec;

}

/**
 * Converts an object of type 'BudgetActionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionProps(obj: BudgetActionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BudgetActionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BudgetActionSpec defines the desired state of BudgetAction
 *
 * @schema BudgetActionSpec
 */
export interface BudgetActionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BudgetActionSpec#deletionPolicy
   */
  readonly deletionPolicy?: BudgetActionSpecDeletionPolicy;

  /**
   * @schema BudgetActionSpec#forProvider
   */
  readonly forProvider: BudgetActionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BudgetActionSpec#providerConfigRef
   */
  readonly providerConfigRef?: BudgetActionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BudgetActionSpec#providerRef
   */
  readonly providerRef?: BudgetActionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BudgetActionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BudgetActionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BudgetActionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BudgetActionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BudgetActionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpec(obj: BudgetActionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BudgetActionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BudgetActionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BudgetActionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BudgetActionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BudgetActionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BudgetActionSpecDeletionPolicy
 */
export enum BudgetActionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BudgetActionSpecForProvider
 */
export interface BudgetActionSpecForProvider {
  /**
   * The ID of the target account for budget. Will use current user's account_id by default if omitted.
   *
   * @schema BudgetActionSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * The trigger threshold of the action. See Action Threshold.
   *
   * @schema BudgetActionSpecForProvider#actionThreshold
   */
  readonly actionThreshold: BudgetActionSpecForProviderActionThreshold[];

  /**
   * The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition. Valid values are APPLY_IAM_POLICY, APPLY_SCP_POLICY, and RUN_SSM_DOCUMENTS.
   *
   * @schema BudgetActionSpecForProvider#actionType
   */
  readonly actionType: string;

  /**
   * This specifies if the action needs manual or automatic approval. Valid values are AUTOMATIC and MANUAL.
   *
   * @schema BudgetActionSpecForProvider#approvalModel
   */
  readonly approvalModel: string;

  /**
   * The name of a budget.
   *
   * @schema BudgetActionSpecForProvider#budgetName
   */
  readonly budgetName?: string;

  /**
   * Reference to a Budget in budgets to populate budgetName.
   *
   * @schema BudgetActionSpecForProvider#budgetNameRef
   */
  readonly budgetNameRef?: BudgetActionSpecForProviderBudgetNameRef;

  /**
   * Selector for a Budget in budgets to populate budgetName.
   *
   * @schema BudgetActionSpecForProvider#budgetNameSelector
   */
  readonly budgetNameSelector?: BudgetActionSpecForProviderBudgetNameSelector;

  /**
   * Specifies all of the type-specific parameters. See Definition.
   *
   * @schema BudgetActionSpecForProvider#definition
   */
  readonly definition: BudgetActionSpecForProviderDefinition[];

  /**
   * The role passed for action execution and reversion. Roles and actions must be in the same account.
   *
   * @schema BudgetActionSpecForProvider#executionRoleArn
   */
  readonly executionRoleArn?: string;

  /**
   * Reference to a Role in iam to populate executionRoleArn.
   *
   * @schema BudgetActionSpecForProvider#executionRoleArnRef
   */
  readonly executionRoleArnRef?: BudgetActionSpecForProviderExecutionRoleArnRef;

  /**
   * Selector for a Role in iam to populate executionRoleArn.
   *
   * @schema BudgetActionSpecForProvider#executionRoleArnSelector
   */
  readonly executionRoleArnSelector?: BudgetActionSpecForProviderExecutionRoleArnSelector;

  /**
   * The type of a notification. Valid values are ACTUAL or FORECASTED.
   *
   * @schema BudgetActionSpecForProvider#notificationType
   */
  readonly notificationType: string;

  /**
   * The Region to run the SSM document. Region is the region you'd like your resource to be created in.
   *
   * @schema BudgetActionSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of subscribers. See Subscriber.
   *
   * @schema BudgetActionSpecForProvider#subscriber
   */
  readonly subscriber: BudgetActionSpecForProviderSubscriber[];

}

/**
 * Converts an object of type 'BudgetActionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProvider(obj: BudgetActionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'actionThreshold': obj.actionThreshold?.map(y => toJson_BudgetActionSpecForProviderActionThreshold(y)),
    'actionType': obj.actionType,
    'approvalModel': obj.approvalModel,
    'budgetName': obj.budgetName,
    'budgetNameRef': toJson_BudgetActionSpecForProviderBudgetNameRef(obj.budgetNameRef),
    'budgetNameSelector': toJson_BudgetActionSpecForProviderBudgetNameSelector(obj.budgetNameSelector),
    'definition': obj.definition?.map(y => toJson_BudgetActionSpecForProviderDefinition(y)),
    'executionRoleArn': obj.executionRoleArn,
    'executionRoleArnRef': toJson_BudgetActionSpecForProviderExecutionRoleArnRef(obj.executionRoleArnRef),
    'executionRoleArnSelector': toJson_BudgetActionSpecForProviderExecutionRoleArnSelector(obj.executionRoleArnSelector),
    'notificationType': obj.notificationType,
    'region': obj.region,
    'subscriber': obj.subscriber?.map(y => toJson_BudgetActionSpecForProviderSubscriber(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BudgetActionSpecProviderConfigRef
 */
export interface BudgetActionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetActionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetActionSpecProviderConfigRef#policy
   */
  readonly policy?: BudgetActionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BudgetActionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecProviderConfigRef(obj: BudgetActionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetActionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BudgetActionSpecProviderRef
 */
export interface BudgetActionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetActionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetActionSpecProviderRef#policy
   */
  readonly policy?: BudgetActionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BudgetActionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecProviderRef(obj: BudgetActionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetActionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BudgetActionSpecPublishConnectionDetailsTo
 */
export interface BudgetActionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BudgetActionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BudgetActionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BudgetActionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BudgetActionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BudgetActionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BudgetActionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecPublishConnectionDetailsTo(obj: BudgetActionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BudgetActionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BudgetActionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BudgetActionSpecWriteConnectionSecretToRef
 */
export interface BudgetActionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BudgetActionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BudgetActionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BudgetActionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecWriteConnectionSecretToRef(obj: BudgetActionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetActionSpecForProviderActionThreshold
 */
export interface BudgetActionSpecForProviderActionThreshold {
  /**
   * The type of threshold for a notification. Valid values are PERCENTAGE or ABSOLUTE_VALUE.
   *
   * @schema BudgetActionSpecForProviderActionThreshold#actionThresholdType
   */
  readonly actionThresholdType: string;

  /**
   * The threshold of a notification.
   *
   * @schema BudgetActionSpecForProviderActionThreshold#actionThresholdValue
   */
  readonly actionThresholdValue: number;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderActionThreshold' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderActionThreshold(obj: BudgetActionSpecForProviderActionThreshold | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionThresholdType': obj.actionThresholdType,
    'actionThresholdValue': obj.actionThresholdValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Budget in budgets to populate budgetName.
 *
 * @schema BudgetActionSpecForProviderBudgetNameRef
 */
export interface BudgetActionSpecForProviderBudgetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetActionSpecForProviderBudgetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetActionSpecForProviderBudgetNameRef#policy
   */
  readonly policy?: BudgetActionSpecForProviderBudgetNameRefPolicy;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderBudgetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderBudgetNameRef(obj: BudgetActionSpecForProviderBudgetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetActionSpecForProviderBudgetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Budget in budgets to populate budgetName.
 *
 * @schema BudgetActionSpecForProviderBudgetNameSelector
 */
export interface BudgetActionSpecForProviderBudgetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BudgetActionSpecForProviderBudgetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BudgetActionSpecForProviderBudgetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BudgetActionSpecForProviderBudgetNameSelector#policy
   */
  readonly policy?: BudgetActionSpecForProviderBudgetNameSelectorPolicy;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderBudgetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderBudgetNameSelector(obj: BudgetActionSpecForProviderBudgetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BudgetActionSpecForProviderBudgetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetActionSpecForProviderDefinition
 */
export interface BudgetActionSpecForProviderDefinition {
  /**
   * The AWS Identity and Access Management (IAM) action definition details. See IAM Action Definition.
   *
   * @schema BudgetActionSpecForProviderDefinition#iamActionDefinition
   */
  readonly iamActionDefinition?: BudgetActionSpecForProviderDefinitionIamActionDefinition[];

  /**
   * The service control policies (SCPs) action definition details. See SCP Action Definition.
   *
   * @schema BudgetActionSpecForProviderDefinition#scpActionDefinition
   */
  readonly scpActionDefinition?: BudgetActionSpecForProviderDefinitionScpActionDefinition[];

  /**
   * The AWS Systems Manager (SSM) action definition details. See SSM Action Definition.
   *
   * @schema BudgetActionSpecForProviderDefinition#ssmActionDefinition
   */
  readonly ssmActionDefinition?: BudgetActionSpecForProviderDefinitionSsmActionDefinition[];

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderDefinition(obj: BudgetActionSpecForProviderDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iamActionDefinition': obj.iamActionDefinition?.map(y => toJson_BudgetActionSpecForProviderDefinitionIamActionDefinition(y)),
    'scpActionDefinition': obj.scpActionDefinition?.map(y => toJson_BudgetActionSpecForProviderDefinitionScpActionDefinition(y)),
    'ssmActionDefinition': obj.ssmActionDefinition?.map(y => toJson_BudgetActionSpecForProviderDefinitionSsmActionDefinition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate executionRoleArn.
 *
 * @schema BudgetActionSpecForProviderExecutionRoleArnRef
 */
export interface BudgetActionSpecForProviderExecutionRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetActionSpecForProviderExecutionRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetActionSpecForProviderExecutionRoleArnRef#policy
   */
  readonly policy?: BudgetActionSpecForProviderExecutionRoleArnRefPolicy;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderExecutionRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderExecutionRoleArnRef(obj: BudgetActionSpecForProviderExecutionRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetActionSpecForProviderExecutionRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate executionRoleArn.
 *
 * @schema BudgetActionSpecForProviderExecutionRoleArnSelector
 */
export interface BudgetActionSpecForProviderExecutionRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BudgetActionSpecForProviderExecutionRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BudgetActionSpecForProviderExecutionRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BudgetActionSpecForProviderExecutionRoleArnSelector#policy
   */
  readonly policy?: BudgetActionSpecForProviderExecutionRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderExecutionRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderExecutionRoleArnSelector(obj: BudgetActionSpecForProviderExecutionRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BudgetActionSpecForProviderExecutionRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetActionSpecForProviderSubscriber
 */
export interface BudgetActionSpecForProviderSubscriber {
  /**
   * The address that AWS sends budget notifications to, either an SNS topic or an email.
   *
   * @schema BudgetActionSpecForProviderSubscriber#address
   */
  readonly address: string;

  /**
   * The type of notification that AWS sends to a subscriber. Valid values are SNS or EMAIL.
   *
   * @schema BudgetActionSpecForProviderSubscriber#subscriptionType
   */
  readonly subscriptionType: string;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderSubscriber' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderSubscriber(obj: BudgetActionSpecForProviderSubscriber | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'subscriptionType': obj.subscriptionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BudgetActionSpecProviderConfigRefPolicy
 */
export interface BudgetActionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetActionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BudgetActionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetActionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BudgetActionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetActionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecProviderConfigRefPolicy(obj: BudgetActionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BudgetActionSpecProviderRefPolicy
 */
export interface BudgetActionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetActionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BudgetActionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetActionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BudgetActionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetActionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecProviderRefPolicy(obj: BudgetActionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BudgetActionSpecPublishConnectionDetailsToConfigRef
 */
export interface BudgetActionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetActionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetActionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BudgetActionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BudgetActionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecPublishConnectionDetailsToConfigRef(obj: BudgetActionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetActionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BudgetActionSpecPublishConnectionDetailsToMetadata
 */
export interface BudgetActionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BudgetActionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BudgetActionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BudgetActionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BudgetActionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecPublishConnectionDetailsToMetadata(obj: BudgetActionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BudgetActionSpecForProviderBudgetNameRefPolicy
 */
export interface BudgetActionSpecForProviderBudgetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetActionSpecForProviderBudgetNameRefPolicy#resolution
   */
  readonly resolution?: BudgetActionSpecForProviderBudgetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetActionSpecForProviderBudgetNameRefPolicy#resolve
   */
  readonly resolve?: BudgetActionSpecForProviderBudgetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderBudgetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderBudgetNameRefPolicy(obj: BudgetActionSpecForProviderBudgetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BudgetActionSpecForProviderBudgetNameSelectorPolicy
 */
export interface BudgetActionSpecForProviderBudgetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetActionSpecForProviderBudgetNameSelectorPolicy#resolution
   */
  readonly resolution?: BudgetActionSpecForProviderBudgetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetActionSpecForProviderBudgetNameSelectorPolicy#resolve
   */
  readonly resolve?: BudgetActionSpecForProviderBudgetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderBudgetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderBudgetNameSelectorPolicy(obj: BudgetActionSpecForProviderBudgetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetActionSpecForProviderDefinitionIamActionDefinition
 */
export interface BudgetActionSpecForProviderDefinitionIamActionDefinition {
  /**
   * A list of groups to be attached. There must be at least one group.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinition#groups
   */
  readonly groups?: string[];

  /**
   * The Amazon Resource Name (ARN) of the policy to be attached.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinition#policyArn
   */
  readonly policyArn?: string;

  /**
   * Reference to a Policy in iam to populate policyArn.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinition#policyArnRef
   */
  readonly policyArnRef?: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRef;

  /**
   * Selector for a Policy in iam to populate policyArn.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinition#policyArnSelector
   */
  readonly policyArnSelector?: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelector;

  /**
   * A list of roles to be attached. There must be at least one role.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinition#roles
   */
  readonly roles?: string[];

  /**
   * A list of users to be attached. There must be at least one user.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinition#users
   */
  readonly users?: string[];

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderDefinitionIamActionDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderDefinitionIamActionDefinition(obj: BudgetActionSpecForProviderDefinitionIamActionDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groups': obj.groups?.map(y => y),
    'policyArn': obj.policyArn,
    'policyArnRef': toJson_BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRef(obj.policyArnRef),
    'policyArnSelector': toJson_BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelector(obj.policyArnSelector),
    'roles': obj.roles?.map(y => y),
    'users': obj.users?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetActionSpecForProviderDefinitionScpActionDefinition
 */
export interface BudgetActionSpecForProviderDefinitionScpActionDefinition {
  /**
   * The policy ID attached.
   *
   * @schema BudgetActionSpecForProviderDefinitionScpActionDefinition#policyId
   */
  readonly policyId: string;

  /**
   * A list of target IDs.
   *
   * @schema BudgetActionSpecForProviderDefinitionScpActionDefinition#targetIds
   */
  readonly targetIds: string[];

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderDefinitionScpActionDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderDefinitionScpActionDefinition(obj: BudgetActionSpecForProviderDefinitionScpActionDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policyId': obj.policyId,
    'targetIds': obj.targetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BudgetActionSpecForProviderDefinitionSsmActionDefinition
 */
export interface BudgetActionSpecForProviderDefinitionSsmActionDefinition {
  /**
   * The action subType. Valid values are STOP_EC2_INSTANCES or STOP_RDS_INSTANCES.
   *
   * @schema BudgetActionSpecForProviderDefinitionSsmActionDefinition#actionSubType
   */
  readonly actionSubType: string;

  /**
   * The EC2 and RDS instance IDs.
   *
   * @schema BudgetActionSpecForProviderDefinitionSsmActionDefinition#instanceIds
   */
  readonly instanceIds: string[];

  /**
   * The Region to run the SSM document.
   *
   * @schema BudgetActionSpecForProviderDefinitionSsmActionDefinition#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderDefinitionSsmActionDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderDefinitionSsmActionDefinition(obj: BudgetActionSpecForProviderDefinitionSsmActionDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionSubType': obj.actionSubType,
    'instanceIds': obj.instanceIds?.map(y => y),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BudgetActionSpecForProviderExecutionRoleArnRefPolicy
 */
export interface BudgetActionSpecForProviderExecutionRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetActionSpecForProviderExecutionRoleArnRefPolicy#resolution
   */
  readonly resolution?: BudgetActionSpecForProviderExecutionRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetActionSpecForProviderExecutionRoleArnRefPolicy#resolve
   */
  readonly resolve?: BudgetActionSpecForProviderExecutionRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderExecutionRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderExecutionRoleArnRefPolicy(obj: BudgetActionSpecForProviderExecutionRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BudgetActionSpecForProviderExecutionRoleArnSelectorPolicy
 */
export interface BudgetActionSpecForProviderExecutionRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetActionSpecForProviderExecutionRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: BudgetActionSpecForProviderExecutionRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetActionSpecForProviderExecutionRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: BudgetActionSpecForProviderExecutionRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderExecutionRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderExecutionRoleArnSelectorPolicy(obj: BudgetActionSpecForProviderExecutionRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetActionSpecProviderConfigRefPolicyResolution
 */
export enum BudgetActionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetActionSpecProviderConfigRefPolicyResolve
 */
export enum BudgetActionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetActionSpecProviderRefPolicyResolution
 */
export enum BudgetActionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetActionSpecProviderRefPolicyResolve
 */
export enum BudgetActionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BudgetActionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BudgetActionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetActionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BudgetActionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetActionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BudgetActionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetActionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecPublishConnectionDetailsToConfigRefPolicy(obj: BudgetActionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetActionSpecForProviderBudgetNameRefPolicyResolution
 */
export enum BudgetActionSpecForProviderBudgetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetActionSpecForProviderBudgetNameRefPolicyResolve
 */
export enum BudgetActionSpecForProviderBudgetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetActionSpecForProviderBudgetNameSelectorPolicyResolution
 */
export enum BudgetActionSpecForProviderBudgetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetActionSpecForProviderBudgetNameSelectorPolicyResolve
 */
export enum BudgetActionSpecForProviderBudgetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Policy in iam to populate policyArn.
 *
 * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRef
 */
export interface BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRef#policy
   */
  readonly policy?: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicy;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRef(obj: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in iam to populate policyArn.
 *
 * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelector
 */
export interface BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelector#policy
   */
  readonly policy?: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicy;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelector(obj: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetActionSpecForProviderExecutionRoleArnRefPolicyResolution
 */
export enum BudgetActionSpecForProviderExecutionRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetActionSpecForProviderExecutionRoleArnRefPolicyResolve
 */
export enum BudgetActionSpecForProviderExecutionRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetActionSpecForProviderExecutionRoleArnSelectorPolicyResolution
 */
export enum BudgetActionSpecForProviderExecutionRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetActionSpecForProviderExecutionRoleArnSelectorPolicyResolve
 */
export enum BudgetActionSpecForProviderExecutionRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetActionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BudgetActionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetActionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BudgetActionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicy
 */
export interface BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicy#resolution
   */
  readonly resolution?: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicy#resolve
   */
  readonly resolve?: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicy(obj: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicy
 */
export interface BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicy#resolution
   */
  readonly resolution?: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicy#resolve
   */
  readonly resolve?: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicy(obj: BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicyResolution
 */
export enum BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicyResolve
 */
export enum BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicyResolution
 */
export enum BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicyResolve
 */
export enum BudgetActionSpecForProviderDefinitionIamActionDefinitionPolicyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

