// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Certificate is the Schema for the Certificates API. Provides a resource to issue a certificate using AWS Certificate Manager Private Certificate Authority (ACM PCA)
 *
 * @schema Certificate
 */
export class Certificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Certificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acmpca.aws.upbound.io/v1beta1',
    kind: 'Certificate',
  }

  /**
   * Renders a Kubernetes manifest for "Certificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateProps): any {
    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(props),
    };
  }

  /**
   * Defines a "Certificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateProps) {
    super(scope, id, {
      ...Certificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(resolved),
    };
  }
}

/**
 * Certificate is the Schema for the Certificates API. Provides a resource to issue a certificate using AWS Certificate Manager Private Certificate Authority (ACM PCA)
 *
 * @schema Certificate
 */
export interface CertificateProps {
  /**
   * @schema Certificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateSpec defines the desired state of Certificate
   *
   * @schema Certificate#spec
   */
  readonly spec: CertificateSpec;

}

/**
 * Converts an object of type 'CertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateProps(obj: CertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateSpec defines the desired state of Certificate
 *
 * @schema CertificateSpec
 */
export interface CertificateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateSpecDeletionPolicy;

  /**
   * @schema CertificateSpec#forProvider
   */
  readonly forProvider: CertificateSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateSpec#managementPolicy
   */
  readonly managementPolicy?: CertificateSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CertificateSpec#providerRef
   */
  readonly providerRef?: CertificateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpec(obj: CertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_CertificateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CertificateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CertificateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateSpecDeletionPolicy
 */
export enum CertificateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateSpecForProvider
 */
export interface CertificateSpecForProvider {
  /**
   * Specifies X.509 certificate information to be included in the issued certificate. To use with API Passthrough templates
   *
   * @schema CertificateSpecForProvider#apiPassthrough
   */
  readonly apiPassthrough?: string;

  /**
   * ARN of the certificate authority.
   *
   * @schema CertificateSpecForProvider#certificateAuthorityArn
   */
  readonly certificateAuthorityArn?: string;

  /**
   * Reference to a CertificateAuthority to populate certificateAuthorityArn.
   *
   * @schema CertificateSpecForProvider#certificateAuthorityArnRef
   */
  readonly certificateAuthorityArnRef?: CertificateSpecForProviderCertificateAuthorityArnRef;

  /**
   * Selector for a CertificateAuthority to populate certificateAuthorityArn.
   *
   * @schema CertificateSpecForProvider#certificateAuthorityArnSelector
   */
  readonly certificateAuthorityArnSelector?: CertificateSpecForProviderCertificateAuthorityArnSelector;

  /**
   * Certificate Signing Request in PEM format.
   *
   * @schema CertificateSpecForProvider#certificateSigningRequestSecretRef
   */
  readonly certificateSigningRequestSecretRef?: CertificateSpecForProviderCertificateSigningRequestSecretRef;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CertificateSpecForProvider#region
   */
  readonly region: string;

  /**
   * Algorithm to use to sign certificate requests. Valid values: SHA256WITHRSA, SHA256WITHECDSA, SHA384WITHRSA, SHA384WITHECDSA, SHA512WITHRSA, SHA512WITHECDSA.
   *
   * @schema CertificateSpecForProvider#signingAlgorithm
   */
  readonly signingAlgorithm?: string;

  /**
   * Template to use when issuing a certificate. See ACM PCA Documentation for more information.
   *
   * @schema CertificateSpecForProvider#templateArn
   */
  readonly templateArn?: string;

  /**
   * Configures end of the validity period for the certificate. See validity block below.
   *
   * @schema CertificateSpecForProvider#validity
   */
  readonly validity?: CertificateSpecForProviderValidity[];

}

/**
 * Converts an object of type 'CertificateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProvider(obj: CertificateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiPassthrough': obj.apiPassthrough,
    'certificateAuthorityArn': obj.certificateAuthorityArn,
    'certificateAuthorityArnRef': toJson_CertificateSpecForProviderCertificateAuthorityArnRef(obj.certificateAuthorityArnRef),
    'certificateAuthorityArnSelector': toJson_CertificateSpecForProviderCertificateAuthorityArnSelector(obj.certificateAuthorityArnSelector),
    'certificateSigningRequestSecretRef': toJson_CertificateSpecForProviderCertificateSigningRequestSecretRef(obj.certificateSigningRequestSecretRef),
    'region': obj.region,
    'signingAlgorithm': obj.signingAlgorithm,
    'templateArn': obj.templateArn,
    'validity': obj.validity?.map(y => toJson_CertificateSpecForProviderValidity(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateSpecManagementPolicy
 */
export enum CertificateSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateSpecProviderConfigRef
 */
export interface CertificateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRef(obj: CertificateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CertificateSpecProviderRef
 */
export interface CertificateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecProviderRef#policy
   */
  readonly policy?: CertificateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderRef(obj: CertificateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateSpecPublishConnectionDetailsTo
 */
export interface CertificateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsTo(obj: CertificateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateSpecWriteConnectionSecretToRef
 */
export interface CertificateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecWriteConnectionSecretToRef(obj: CertificateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateAuthority to populate certificateAuthorityArn.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnRef
 */
export interface CertificateSpecForProviderCertificateAuthorityArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnRef#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateAuthorityArnRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityArnRef(obj: CertificateSpecForProviderCertificateAuthorityArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecForProviderCertificateAuthorityArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateAuthority to populate certificateAuthorityArn.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnSelector
 */
export interface CertificateSpecForProviderCertificateAuthorityArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnSelector#policy
   */
  readonly policy?: CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityArnSelector(obj: CertificateSpecForProviderCertificateAuthorityArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate Signing Request in PEM format.
 *
 * @schema CertificateSpecForProviderCertificateSigningRequestSecretRef
 */
export interface CertificateSpecForProviderCertificateSigningRequestSecretRef {
  /**
   * The key to select.
   *
   * @schema CertificateSpecForProviderCertificateSigningRequestSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema CertificateSpecForProviderCertificateSigningRequestSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecForProviderCertificateSigningRequestSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateSigningRequestSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateSigningRequestSecretRef(obj: CertificateSpecForProviderCertificateSigningRequestSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecForProviderValidity
 */
export interface CertificateSpecForProviderValidity {
  /**
   * Determines how value is interpreted. Valid values: DAYS, MONTHS, YEARS, ABSOLUTE, END_DATE.
   *
   * @schema CertificateSpecForProviderValidity#type
   */
  readonly type: string;

  /**
   * If type is DAYS, MONTHS, or YEARS, the relative time until the certificate expires. If type is ABSOLUTE, the date in seconds since the Unix epoch. If type is END_DATE, the  date in RFC 3339 format.
   *
   * @schema CertificateSpecForProviderValidity#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderValidity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderValidity(obj: CertificateSpecForProviderValidity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecProviderConfigRefPolicy
 */
export interface CertificateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRefPolicy(obj: CertificateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecProviderRefPolicy
 */
export interface CertificateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderRefPolicy(obj: CertificateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj: CertificateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj: CertificateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnRefPolicy
 */
export interface CertificateSpecForProviderCertificateAuthorityArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityArnRefPolicy(obj: CertificateSpecForProviderCertificateAuthorityArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy
 */
export interface CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy#resolution
   */
  readonly resolution?: CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy#resolve
   */
  readonly resolve?: CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy(obj: CertificateSpecForProviderCertificateAuthorityArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolution
 */
export enum CertificateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolve
 */
export enum CertificateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecProviderRefPolicyResolution
 */
export enum CertificateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecProviderRefPolicyResolve
 */
export enum CertificateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolution
 */
export enum CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolve
 */
export enum CertificateSpecForProviderCertificateAuthorityArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolution
 */
export enum CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolve
 */
export enum CertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CertificateAuthority is the Schema for the CertificateAuthoritys API. Provides a resource to manage AWS Certificate Manager Private Certificate Authorities
 *
 * @schema CertificateAuthority
 */
export class CertificateAuthority extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateAuthority"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acmpca.aws.upbound.io/v1beta1',
    kind: 'CertificateAuthority',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateAuthority".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateAuthorityProps): any {
    return {
      ...CertificateAuthority.GVK,
      ...toJson_CertificateAuthorityProps(props),
    };
  }

  /**
   * Defines a "CertificateAuthority" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateAuthorityProps) {
    super(scope, id, {
      ...CertificateAuthority.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateAuthority.GVK,
      ...toJson_CertificateAuthorityProps(resolved),
    };
  }
}

/**
 * CertificateAuthority is the Schema for the CertificateAuthoritys API. Provides a resource to manage AWS Certificate Manager Private Certificate Authorities
 *
 * @schema CertificateAuthority
 */
export interface CertificateAuthorityProps {
  /**
   * @schema CertificateAuthority#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateAuthoritySpec defines the desired state of CertificateAuthority
   *
   * @schema CertificateAuthority#spec
   */
  readonly spec: CertificateAuthoritySpec;

}

/**
 * Converts an object of type 'CertificateAuthorityProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityProps(obj: CertificateAuthorityProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateAuthoritySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthoritySpec defines the desired state of CertificateAuthority
 *
 * @schema CertificateAuthoritySpec
 */
export interface CertificateAuthoritySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateAuthoritySpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateAuthoritySpecDeletionPolicy;

  /**
   * @schema CertificateAuthoritySpec#forProvider
   */
  readonly forProvider: CertificateAuthoritySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateAuthoritySpec#managementPolicy
   */
  readonly managementPolicy?: CertificateAuthoritySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateAuthoritySpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateAuthoritySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CertificateAuthoritySpec#providerRef
   */
  readonly providerRef?: CertificateAuthoritySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateAuthoritySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateAuthoritySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateAuthoritySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateAuthoritySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateAuthoritySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpec(obj: CertificateAuthoritySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateAuthoritySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_CertificateAuthoritySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CertificateAuthoritySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CertificateAuthoritySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateAuthoritySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateAuthoritySpecDeletionPolicy
 */
export enum CertificateAuthoritySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateAuthoritySpecForProvider
 */
export interface CertificateAuthoritySpecForProvider {
  /**
   * Nested argument containing algorithms and certificate subject information. Defined below.
   *
   * @schema CertificateAuthoritySpecForProvider#certificateAuthorityConfiguration
   */
  readonly certificateAuthorityConfiguration?: CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration[];

  /**
   * Whether the certificate authority is enabled or disabled. Defaults to true. Can only be disabled if the CA is in an ACTIVE state.
   *
   * @default true. Can only be disabled if the CA is in an ACTIVE state.
   * @schema CertificateAuthoritySpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Number of days to make a CA restorable after it has been deleted, must be between 7 to 30 days, with default to 30 days.
   *
   * @schema CertificateAuthoritySpecForProvider#permanentDeletionTimeInDays
   */
  readonly permanentDeletionTimeInDays?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CertificateAuthoritySpecForProvider#region
   */
  readonly region: string;

  /**
   * Nested argument containing revocation configuration. Defined below.
   *
   * @schema CertificateAuthoritySpecForProvider#revocationConfiguration
   */
  readonly revocationConfiguration?: CertificateAuthoritySpecForProviderRevocationConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema CertificateAuthoritySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Type of the certificate authority. Defaults to SUBORDINATE. Valid values: ROOT and SUBORDINATE.
   *
   * @default SUBORDINATE. Valid values: ROOT and SUBORDINATE.
   * @schema CertificateAuthoritySpecForProvider#type
   */
  readonly type?: string;

  /**
   * Specifies whether the CA issues general-purpose certificates that typically require a revocation mechanism, or short-lived certificates that may optionally omit revocation because they expire quickly. Short-lived certificate validity is limited to seven days. Defaults to GENERAL_PURPOSE. Valid values: GENERAL_PURPOSE and SHORT_LIVED_CERTIFICATE.
   *
   * @default GENERAL_PURPOSE. Valid values: GENERAL_PURPOSE and SHORT_LIVED_CERTIFICATE.
   * @schema CertificateAuthoritySpecForProvider#usageMode
   */
  readonly usageMode?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProvider(obj: CertificateAuthoritySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityConfiguration': obj.certificateAuthorityConfiguration?.map(y => toJson_CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration(y)),
    'enabled': obj.enabled,
    'permanentDeletionTimeInDays': obj.permanentDeletionTimeInDays,
    'region': obj.region,
    'revocationConfiguration': obj.revocationConfiguration?.map(y => toJson_CertificateAuthoritySpecForProviderRevocationConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
    'usageMode': obj.usageMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateAuthoritySpecManagementPolicy
 */
export enum CertificateAuthoritySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateAuthoritySpecProviderConfigRef
 */
export interface CertificateAuthoritySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecProviderConfigRef#policy
   */
  readonly policy?: CertificateAuthoritySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderConfigRef(obj: CertificateAuthoritySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CertificateAuthoritySpecProviderRef
 */
export interface CertificateAuthoritySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecProviderRef#policy
   */
  readonly policy?: CertificateAuthoritySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderRef(obj: CertificateAuthoritySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsTo
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateAuthoritySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsTo(obj: CertificateAuthoritySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateAuthoritySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateAuthoritySpecWriteConnectionSecretToRef
 */
export interface CertificateAuthoritySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateAuthoritySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateAuthoritySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecWriteConnectionSecretToRef(obj: CertificateAuthoritySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration
 */
export interface CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration {
  /**
   * Type of the public key algorithm and size, in bits, of the key pair that your key pair creates when it issues a certificate. Valid values can be found in the ACM PCA Documentation.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration#keyAlgorithm
   */
  readonly keyAlgorithm: string;

  /**
   * Name of the algorithm your private CA uses to sign certificate requests. Valid values can be found in the ACM PCA Documentation.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration#signingAlgorithm
   */
  readonly signingAlgorithm: string;

  /**
   * Nested argument that contains X.500 distinguished name information. At least one nested attribute must be specified.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration#subject
   */
  readonly subject: CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration(obj: CertificateAuthoritySpecForProviderCertificateAuthorityConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyAlgorithm': obj.keyAlgorithm,
    'signingAlgorithm': obj.signingAlgorithm,
    'subject': obj.subject?.map(y => toJson_CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderRevocationConfiguration
 */
export interface CertificateAuthoritySpecForProviderRevocationConfiguration {
  /**
   * Nested argument containing configuration of the certificate revocation list (CRL), if any, maintained by the certificate authority. Defined below.
   *
   * @schema CertificateAuthoritySpecForProviderRevocationConfiguration#crlConfiguration
   */
  readonly crlConfiguration?: CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration[];

  /**
   * Nested argument containing configuration of the custom OCSP responder endpoint. Defined below.
   *
   * @schema CertificateAuthoritySpecForProviderRevocationConfiguration#ocspConfiguration
   */
  readonly ocspConfiguration?: CertificateAuthoritySpecForProviderRevocationConfigurationOcspConfiguration[];

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderRevocationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderRevocationConfiguration(obj: CertificateAuthoritySpecForProviderRevocationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crlConfiguration': obj.crlConfiguration?.map(y => toJson_CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration(y)),
    'ocspConfiguration': obj.ocspConfiguration?.map(y => toJson_CertificateAuthoritySpecForProviderRevocationConfigurationOcspConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicy
 */
export interface CertificateAuthoritySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderConfigRefPolicy(obj: CertificateAuthoritySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecProviderRefPolicy
 */
export interface CertificateAuthoritySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecProviderRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecProviderRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecProviderRefPolicy(obj: CertificateAuthoritySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRef(obj: CertificateAuthoritySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToMetadata(obj: CertificateAuthoritySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject
 */
export interface CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject {
  /**
   * Fully qualified domain name (FQDN) associated with the certificate subject. Must be less than or equal to 64 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#commonName
   */
  readonly commonName?: string;

  /**
   * Two digit code that specifies the country in which the certificate subject located. Must be less than or equal to 2 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#country
   */
  readonly country?: string;

  /**
   * Disambiguating information for the certificate subject. Must be less than or equal to 64 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#distinguishedNameQualifier
   */
  readonly distinguishedNameQualifier?: string;

  /**
   * Typically a qualifier appended to the name of an individual. Examples include Jr. for junior, Sr. for senior, and III for third. Must be less than or equal to 3 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#generationQualifier
   */
  readonly generationQualifier?: string;

  /**
   * First name. Must be less than or equal to 16 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#givenName
   */
  readonly givenName?: string;

  /**
   * Concatenation that typically contains the first letter of the given_name, the first letter of the middle name if one exists, and the first letter of the surname. Must be less than or equal to 5 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#initials
   */
  readonly initials?: string;

  /**
   * Locality (such as a city or town) in which the certificate subject is located. Must be less than or equal to 128 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#locality
   */
  readonly locality?: string;

  /**
   * Legal name of the organization with which the certificate subject is affiliated. Must be less than or equal to 64 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#organization
   */
  readonly organization?: string;

  /**
   * Subdivision or unit of the organization (such as sales or finance) with which the certificate subject is affiliated. Must be less than or equal to 64 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#organizationalUnit
   */
  readonly organizationalUnit?: string;

  /**
   * Typically a shortened version of a longer given_name. For example, Jonathan is often shortened to John. Elizabeth is often shortened to Beth, Liz, or Eliza. Must be less than or equal to 128 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#pseudonym
   */
  readonly pseudonym?: string;

  /**
   * State in which the subject of the certificate is located. Must be less than or equal to 128 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#state
   */
  readonly state?: string;

  /**
   * Family name. In the US and the UK for example, the surname of an individual is ordered last. In Asian cultures the surname is typically ordered first. Must be less than or equal to 40 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#surname
   */
  readonly surname?: string;

  /**
   * Title such as Mr. or Ms. which is pre-pended to the name to refer formally to the certificate subject. Must be less than or equal to 64 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject(obj: CertificateAuthoritySpecForProviderCertificateAuthorityConfigurationSubject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'commonName': obj.commonName,
    'country': obj.country,
    'distinguishedNameQualifier': obj.distinguishedNameQualifier,
    'generationQualifier': obj.generationQualifier,
    'givenName': obj.givenName,
    'initials': obj.initials,
    'locality': obj.locality,
    'organization': obj.organization,
    'organizationalUnit': obj.organizationalUnit,
    'pseudonym': obj.pseudonym,
    'state': obj.state,
    'surname': obj.surname,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration
 */
export interface CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration {
  /**
   * Name inserted into the certificate CRL Distribution Points extension that enables the use of an alias for the CRL distribution point. Use this value if you don't want the name of your S3 bucket to be public. Must be less than or equal to 253 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration#customCname
   */
  readonly customCname?: string;

  /**
   * Boolean value that specifies whether certificate revocation lists (CRLs) are enabled. Defaults to false.
   *
   * @default false.
   * @schema CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Number of days until a certificate expires. Must be between 1 and 5000.
   *
   * @schema CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration#expirationInDays
   */
  readonly expirationInDays?: number;

  /**
   * Name of the S3 bucket that contains the CRL. If you do not provide a value for the custom_cname argument, the name of your S3 bucket is placed into the CRL Distribution Points extension of the issued certificate. You must specify a bucket policy that allows ACM PCA to write the CRL to your bucket. Must be between 3 and 255 characters in length.
   *
   * @schema CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration#s3BucketName
   */
  readonly s3BucketName?: string;

  /**
   * Determines whether the CRL will be publicly readable or privately held in the CRL Amazon S3 bucket. Defaults to PUBLIC_READ.
   *
   * @default PUBLIC_READ.
   * @schema CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration#s3ObjectAcl
   */
  readonly s3ObjectAcl?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration(obj: CertificateAuthoritySpecForProviderRevocationConfigurationCrlConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customCname': obj.customCname,
    'enabled': obj.enabled,
    'expirationInDays': obj.expirationInDays,
    's3BucketName': obj.s3BucketName,
    's3ObjectAcl': obj.s3ObjectAcl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateAuthoritySpecForProviderRevocationConfigurationOcspConfiguration
 */
export interface CertificateAuthoritySpecForProviderRevocationConfigurationOcspConfiguration {
  /**
   * Boolean value that specifies whether a custom OCSP responder is enabled.
   *
   * @schema CertificateAuthoritySpecForProviderRevocationConfigurationOcspConfiguration#enabled
   */
  readonly enabled: boolean;

  /**
   * CNAME specifying a customized OCSP domain. Note: The value of the CNAME must not include a protocol prefix such as "http://" or "https://".
   *
   * @schema CertificateAuthoritySpecForProviderRevocationConfigurationOcspConfiguration#ocspCustomCname
   */
  readonly ocspCustomCname?: string;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecForProviderRevocationConfigurationOcspConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecForProviderRevocationConfigurationOcspConfiguration(obj: CertificateAuthoritySpecForProviderRevocationConfigurationOcspConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'ocspCustomCname': obj.ocspCustomCname,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicyResolution
 */
export enum CertificateAuthoritySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecProviderConfigRefPolicyResolve
 */
export enum CertificateAuthoritySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecProviderRefPolicyResolution
 */
export enum CertificateAuthoritySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecProviderRefPolicyResolve
 */
export enum CertificateAuthoritySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateAuthoritySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CertificateAuthorityCertificate is the Schema for the CertificateAuthorityCertificates API. Associates a certificate with an AWS Certificate Manager Private Certificate Authority
 *
 * @schema CertificateAuthorityCertificate
 */
export class CertificateAuthorityCertificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CertificateAuthorityCertificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acmpca.aws.upbound.io/v1beta1',
    kind: 'CertificateAuthorityCertificate',
  }

  /**
   * Renders a Kubernetes manifest for "CertificateAuthorityCertificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateAuthorityCertificateProps): any {
    return {
      ...CertificateAuthorityCertificate.GVK,
      ...toJson_CertificateAuthorityCertificateProps(props),
    };
  }

  /**
   * Defines a "CertificateAuthorityCertificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateAuthorityCertificateProps) {
    super(scope, id, {
      ...CertificateAuthorityCertificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CertificateAuthorityCertificate.GVK,
      ...toJson_CertificateAuthorityCertificateProps(resolved),
    };
  }
}

/**
 * CertificateAuthorityCertificate is the Schema for the CertificateAuthorityCertificates API. Associates a certificate with an AWS Certificate Manager Private Certificate Authority
 *
 * @schema CertificateAuthorityCertificate
 */
export interface CertificateAuthorityCertificateProps {
  /**
   * @schema CertificateAuthorityCertificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateAuthorityCertificateSpec defines the desired state of CertificateAuthorityCertificate
   *
   * @schema CertificateAuthorityCertificate#spec
   */
  readonly spec: CertificateAuthorityCertificateSpec;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateProps(obj: CertificateAuthorityCertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateAuthorityCertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAuthorityCertificateSpec defines the desired state of CertificateAuthorityCertificate
 *
 * @schema CertificateAuthorityCertificateSpec
 */
export interface CertificateAuthorityCertificateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateAuthorityCertificateSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateAuthorityCertificateSpecDeletionPolicy;

  /**
   * @schema CertificateAuthorityCertificateSpec#forProvider
   */
  readonly forProvider: CertificateAuthorityCertificateSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateAuthorityCertificateSpec#managementPolicy
   */
  readonly managementPolicy?: CertificateAuthorityCertificateSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateAuthorityCertificateSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateAuthorityCertificateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CertificateAuthorityCertificateSpec#providerRef
   */
  readonly providerRef?: CertificateAuthorityCertificateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateAuthorityCertificateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateAuthorityCertificateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateAuthorityCertificateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateAuthorityCertificateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpec(obj: CertificateAuthorityCertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateAuthorityCertificateSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_CertificateAuthorityCertificateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CertificateAuthorityCertificateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CertificateAuthorityCertificateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateAuthorityCertificateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateAuthorityCertificateSpecDeletionPolicy
 */
export enum CertificateAuthorityCertificateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateAuthorityCertificateSpecForProvider
 */
export interface CertificateAuthorityCertificateSpecForProvider {
  /**
   * ARN of the Certificate Authority.
   *
   * @schema CertificateAuthorityCertificateSpecForProvider#certificateAuthorityArn
   */
  readonly certificateAuthorityArn?: string;

  /**
   * Reference to a CertificateAuthority to populate certificateAuthorityArn.
   *
   * @schema CertificateAuthorityCertificateSpecForProvider#certificateAuthorityArnRef
   */
  readonly certificateAuthorityArnRef?: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRef;

  /**
   * Selector for a CertificateAuthority to populate certificateAuthorityArn.
   *
   * @schema CertificateAuthorityCertificateSpecForProvider#certificateAuthorityArnSelector
   */
  readonly certificateAuthorityArnSelector?: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelector;

  /**
   * PEM-encoded certificate chain that includes any intermediate certificates and chains up to root CA. Required for subordinate Certificate Authorities. Not allowed for root Certificate Authorities.
   *
   * @schema CertificateAuthorityCertificateSpecForProvider#certificateChainSecretRef
   */
  readonly certificateChainSecretRef?: CertificateAuthorityCertificateSpecForProviderCertificateChainSecretRef;

  /**
   * PEM-encoded certificate for the Certificate Authority.
   *
   * @schema CertificateAuthorityCertificateSpecForProvider#certificateSecretRef
   */
  readonly certificateSecretRef?: CertificateAuthorityCertificateSpecForProviderCertificateSecretRef;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CertificateAuthorityCertificateSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecForProvider(obj: CertificateAuthorityCertificateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateAuthorityArn': obj.certificateAuthorityArn,
    'certificateAuthorityArnRef': toJson_CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRef(obj.certificateAuthorityArnRef),
    'certificateAuthorityArnSelector': toJson_CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelector(obj.certificateAuthorityArnSelector),
    'certificateChainSecretRef': toJson_CertificateAuthorityCertificateSpecForProviderCertificateChainSecretRef(obj.certificateChainSecretRef),
    'certificateSecretRef': toJson_CertificateAuthorityCertificateSpecForProviderCertificateSecretRef(obj.certificateSecretRef),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateAuthorityCertificateSpecManagementPolicy
 */
export enum CertificateAuthorityCertificateSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateAuthorityCertificateSpecProviderConfigRef
 */
export interface CertificateAuthorityCertificateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityCertificateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityCertificateSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateAuthorityCertificateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecProviderConfigRef(obj: CertificateAuthorityCertificateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityCertificateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CertificateAuthorityCertificateSpecProviderRef
 */
export interface CertificateAuthorityCertificateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityCertificateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityCertificateSpecProviderRef#policy
   */
  readonly policy?: CertificateAuthorityCertificateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecProviderRef(obj: CertificateAuthorityCertificateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityCertificateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsTo
 */
export interface CertificateAuthorityCertificateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateAuthorityCertificateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecPublishConnectionDetailsTo(obj: CertificateAuthorityCertificateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateAuthorityCertificateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateAuthorityCertificateSpecWriteConnectionSecretToRef
 */
export interface CertificateAuthorityCertificateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateAuthorityCertificateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateAuthorityCertificateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecWriteConnectionSecretToRef(obj: CertificateAuthorityCertificateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateAuthority to populate certificateAuthorityArn.
 *
 * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRef
 */
export interface CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRef#policy
   */
  readonly policy?: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRef(obj: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateAuthority to populate certificateAuthorityArn.
 *
 * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelector
 */
export interface CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelector#policy
   */
  readonly policy?: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelector(obj: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PEM-encoded certificate chain that includes any intermediate certificates and chains up to root CA. Required for subordinate Certificate Authorities. Not allowed for root Certificate Authorities.
 *
 * @schema CertificateAuthorityCertificateSpecForProviderCertificateChainSecretRef
 */
export interface CertificateAuthorityCertificateSpecForProviderCertificateChainSecretRef {
  /**
   * The key to select.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateChainSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateChainSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateChainSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecForProviderCertificateChainSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecForProviderCertificateChainSecretRef(obj: CertificateAuthorityCertificateSpecForProviderCertificateChainSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PEM-encoded certificate for the Certificate Authority.
 *
 * @schema CertificateAuthorityCertificateSpecForProviderCertificateSecretRef
 */
export interface CertificateAuthorityCertificateSpecForProviderCertificateSecretRef {
  /**
   * The key to select.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecForProviderCertificateSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecForProviderCertificateSecretRef(obj: CertificateAuthorityCertificateSpecForProviderCertificateSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityCertificateSpecProviderConfigRefPolicy
 */
export interface CertificateAuthorityCertificateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityCertificateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityCertificateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityCertificateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityCertificateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecProviderConfigRefPolicy(obj: CertificateAuthorityCertificateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityCertificateSpecProviderRefPolicy
 */
export interface CertificateAuthorityCertificateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityCertificateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityCertificateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityCertificateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityCertificateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecProviderRefPolicy(obj: CertificateAuthorityCertificateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRef(obj: CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateAuthorityCertificateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecPublishConnectionDetailsToMetadata(obj: CertificateAuthorityCertificateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicy
 */
export interface CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicy(obj: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicy
 */
export interface CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicy(obj: CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityCertificateSpecProviderConfigRefPolicyResolution
 */
export enum CertificateAuthorityCertificateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityCertificateSpecProviderConfigRefPolicyResolve
 */
export enum CertificateAuthorityCertificateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityCertificateSpecProviderRefPolicyResolution
 */
export enum CertificateAuthorityCertificateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityCertificateSpecProviderRefPolicyResolve
 */
export enum CertificateAuthorityCertificateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicyResolution
 */
export enum CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicyResolve
 */
export enum CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolution
 */
export enum CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolve
 */
export enum CertificateAuthorityCertificateSpecForProviderCertificateAuthorityArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateAuthorityCertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Permission is the Schema for the Permissions API. Provides a resource to manage an AWS Certificate Manager Private Certificate Authorities Permission
 *
 * @schema Permission
 */
export class Permission extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Permission"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acmpca.aws.upbound.io/v1beta1',
    kind: 'Permission',
  }

  /**
   * Renders a Kubernetes manifest for "Permission".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionProps): any {
    return {
      ...Permission.GVK,
      ...toJson_PermissionProps(props),
    };
  }

  /**
   * Defines a "Permission" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionProps) {
    super(scope, id, {
      ...Permission.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Permission.GVK,
      ...toJson_PermissionProps(resolved),
    };
  }
}

/**
 * Permission is the Schema for the Permissions API. Provides a resource to manage an AWS Certificate Manager Private Certificate Authorities Permission
 *
 * @schema Permission
 */
export interface PermissionProps {
  /**
   * @schema Permission#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PermissionSpec defines the desired state of Permission
   *
   * @schema Permission#spec
   */
  readonly spec: PermissionSpec;

}

/**
 * Converts an object of type 'PermissionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionProps(obj: PermissionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionSpec defines the desired state of Permission
 *
 * @schema PermissionSpec
 */
export interface PermissionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSpec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionSpecDeletionPolicy;

  /**
   * @schema PermissionSpec#forProvider
   */
  readonly forProvider: PermissionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSpec#managementPolicy
   */
  readonly managementPolicy?: PermissionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PermissionSpec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PermissionSpec#providerRef
   */
  readonly providerRef?: PermissionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PermissionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PermissionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpec(obj: PermissionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PermissionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PermissionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PermissionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSpecDeletionPolicy
 */
export enum PermissionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PermissionSpecForProvider
 */
export interface PermissionSpecForProvider {
  /**
   * Actions that the specified AWS service principal can use. These include IssueCertificate, GetCertificate, and ListPermissions. Note that in order for ACM to automatically rotate certificates issued by a PCA, it must be granted permission on all 3 actions, as per the example above.
   *
   * @schema PermissionSpecForProvider#actions
   */
  readonly actions?: string[];

  /**
   * ARN of the CA that grants the permissions.
   *
   * @schema PermissionSpecForProvider#certificateAuthorityArn
   */
  readonly certificateAuthorityArn?: string;

  /**
   * Reference to a CertificateAuthority in acmpca to populate certificateAuthorityArn.
   *
   * @schema PermissionSpecForProvider#certificateAuthorityArnRef
   */
  readonly certificateAuthorityArnRef?: PermissionSpecForProviderCertificateAuthorityArnRef;

  /**
   * Selector for a CertificateAuthority in acmpca to populate certificateAuthorityArn.
   *
   * @schema PermissionSpecForProvider#certificateAuthorityArnSelector
   */
  readonly certificateAuthorityArnSelector?: PermissionSpecForProviderCertificateAuthorityArnSelector;

  /**
   * AWS service or identity that receives the permission. At this time, the only valid principal is acm.amazonaws.com.
   *
   * @schema PermissionSpecForProvider#principal
   */
  readonly principal?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PermissionSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the calling account
   *
   * @schema PermissionSpecForProvider#sourceAccount
   */
  readonly sourceAccount?: string;

}

/**
 * Converts an object of type 'PermissionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProvider(obj: PermissionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => y),
    'certificateAuthorityArn': obj.certificateAuthorityArn,
    'certificateAuthorityArnRef': toJson_PermissionSpecForProviderCertificateAuthorityArnRef(obj.certificateAuthorityArnRef),
    'certificateAuthorityArnSelector': toJson_PermissionSpecForProviderCertificateAuthorityArnSelector(obj.certificateAuthorityArnSelector),
    'principal': obj.principal,
    'region': obj.region,
    'sourceAccount': obj.sourceAccount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSpecManagementPolicy
 */
export enum PermissionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PermissionSpecProviderConfigRef
 */
export interface PermissionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecProviderConfigRef#policy
   */
  readonly policy?: PermissionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderConfigRef(obj: PermissionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PermissionSpecProviderRef
 */
export interface PermissionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecProviderRef#policy
   */
  readonly policy?: PermissionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderRef(obj: PermissionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PermissionSpecPublishConnectionDetailsTo
 */
export interface PermissionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsTo(obj: PermissionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PermissionSpecWriteConnectionSecretToRef
 */
export interface PermissionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecWriteConnectionSecretToRef(obj: PermissionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateAuthority in acmpca to populate certificateAuthorityArn.
 *
 * @schema PermissionSpecForProviderCertificateAuthorityArnRef
 */
export interface PermissionSpecForProviderCertificateAuthorityArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecForProviderCertificateAuthorityArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecForProviderCertificateAuthorityArnRef#policy
   */
  readonly policy?: PermissionSpecForProviderCertificateAuthorityArnRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderCertificateAuthorityArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderCertificateAuthorityArnRef(obj: PermissionSpecForProviderCertificateAuthorityArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecForProviderCertificateAuthorityArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateAuthority in acmpca to populate certificateAuthorityArn.
 *
 * @schema PermissionSpecForProviderCertificateAuthorityArnSelector
 */
export interface PermissionSpecForProviderCertificateAuthorityArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionSpecForProviderCertificateAuthorityArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionSpecForProviderCertificateAuthorityArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionSpecForProviderCertificateAuthorityArnSelector#policy
   */
  readonly policy?: PermissionSpecForProviderCertificateAuthorityArnSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionSpecForProviderCertificateAuthorityArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderCertificateAuthorityArnSelector(obj: PermissionSpecForProviderCertificateAuthorityArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionSpecForProviderCertificateAuthorityArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecProviderConfigRefPolicy
 */
export interface PermissionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderConfigRefPolicy(obj: PermissionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecProviderRefPolicy
 */
export interface PermissionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecProviderRefPolicy(obj: PermissionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToConfigRef(obj: PermissionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionSpecPublishConnectionDetailsToMetadata
 */
export interface PermissionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToMetadata(obj: PermissionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecForProviderCertificateAuthorityArnRefPolicy
 */
export interface PermissionSpecForProviderCertificateAuthorityArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderCertificateAuthorityArnRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderCertificateAuthorityArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderCertificateAuthorityArnRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderCertificateAuthorityArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderCertificateAuthorityArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderCertificateAuthorityArnRefPolicy(obj: PermissionSpecForProviderCertificateAuthorityArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionSpecForProviderCertificateAuthorityArnSelectorPolicy
 */
export interface PermissionSpecForProviderCertificateAuthorityArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecForProviderCertificateAuthorityArnSelectorPolicy#resolution
   */
  readonly resolution?: PermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecForProviderCertificateAuthorityArnSelectorPolicy#resolve
   */
  readonly resolve?: PermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecForProviderCertificateAuthorityArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecForProviderCertificateAuthorityArnSelectorPolicy(obj: PermissionSpecForProviderCertificateAuthorityArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecProviderConfigRefPolicyResolution
 */
export enum PermissionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecProviderConfigRefPolicyResolve
 */
export enum PermissionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecProviderRefPolicyResolution
 */
export enum PermissionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecProviderRefPolicyResolve
 */
export enum PermissionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderCertificateAuthorityArnRefPolicyResolution
 */
export enum PermissionSpecForProviderCertificateAuthorityArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderCertificateAuthorityArnRefPolicyResolve
 */
export enum PermissionSpecForProviderCertificateAuthorityArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolution
 */
export enum PermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolve
 */
export enum PermissionSpecForProviderCertificateAuthorityArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Policy is the Schema for the Policys API. Attaches a resource based policy to an AWS Certificate Manager Private Certificate Authority (ACM PCA)
 *
 * @schema Policy
 */
export class Policy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Policy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'acmpca.aws.upbound.io/v1beta1',
    kind: 'Policy',
  }

  /**
   * Renders a Kubernetes manifest for "Policy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyProps): any {
    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(props),
    };
  }

  /**
   * Defines a "Policy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyProps) {
    super(scope, id, {
      ...Policy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(resolved),
    };
  }
}

/**
 * Policy is the Schema for the Policys API. Attaches a resource based policy to an AWS Certificate Manager Private Certificate Authority (ACM PCA)
 *
 * @schema Policy
 */
export interface PolicyProps {
  /**
   * @schema Policy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicySpec defines the desired state of Policy
   *
   * @schema Policy#spec
   */
  readonly spec: PolicySpec;

}

/**
 * Converts an object of type 'PolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyProps(obj: PolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicySpec defines the desired state of Policy
 *
 * @schema PolicySpec
 */
export interface PolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: PolicySpecDeletionPolicy;

  /**
   * @schema PolicySpec#forProvider
   */
  readonly forProvider: PolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#managementPolicy
   */
  readonly managementPolicy?: PolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: PolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PolicySpec#providerRef
   */
  readonly providerRef?: PolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpec(obj: PolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecDeletionPolicy
 */
export enum PolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PolicySpecForProvider
 */
export interface PolicySpecForProvider {
  /**
   * JSON-formatted IAM policy to attach to the specified private CA resource.
   *
   * @schema PolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN of the private CA to associate with the policy.
   *
   * @schema PolicySpecForProvider#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a CertificateAuthority in acmpca to populate resourceArn.
   *
   * @schema PolicySpecForProvider#resourceArnRef
   */
  readonly resourceArnRef?: PolicySpecForProviderResourceArnRef;

  /**
   * Selector for a CertificateAuthority in acmpca to populate resourceArn.
   *
   * @schema PolicySpecForProvider#resourceArnSelector
   */
  readonly resourceArnSelector?: PolicySpecForProviderResourceArnSelector;

}

/**
 * Converts an object of type 'PolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProvider(obj: PolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
    'region': obj.region,
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_PolicySpecForProviderResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_PolicySpecForProviderResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecManagementPolicy
 */
export enum PolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PolicySpecProviderConfigRef
 */
export interface PolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderConfigRef#policy
   */
  readonly policy?: PolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRef(obj: PolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PolicySpecProviderRef
 */
export interface PolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderRef#policy
   */
  readonly policy?: PolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderRef(obj: PolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PolicySpecPublishConnectionDetailsTo
 */
export interface PolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsTo(obj: PolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PolicySpecWriteConnectionSecretToRef
 */
export interface PolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWriteConnectionSecretToRef(obj: PolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CertificateAuthority in acmpca to populate resourceArn.
 *
 * @schema PolicySpecForProviderResourceArnRef
 */
export interface PolicySpecForProviderResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecForProviderResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecForProviderResourceArnRef#policy
   */
  readonly policy?: PolicySpecForProviderResourceArnRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceArnRef(obj: PolicySpecForProviderResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecForProviderResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CertificateAuthority in acmpca to populate resourceArn.
 *
 * @schema PolicySpecForProviderResourceArnSelector
 */
export interface PolicySpecForProviderResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicySpecForProviderResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicySpecForProviderResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicySpecForProviderResourceArnSelector#policy
   */
  readonly policy?: PolicySpecForProviderResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceArnSelector(obj: PolicySpecForProviderResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicySpecForProviderResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderConfigRefPolicy
 */
export interface PolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRefPolicy(obj: PolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderRefPolicy
 */
export interface PolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderRefPolicy(obj: PolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRef
 */
export interface PolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj: PolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PolicySpecPublishConnectionDetailsToMetadata
 */
export interface PolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToMetadata(obj: PolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecForProviderResourceArnRefPolicy
 */
export interface PolicySpecForProviderResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderResourceArnRefPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderResourceArnRefPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceArnRefPolicy(obj: PolicySpecForProviderResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicySpecForProviderResourceArnSelectorPolicy
 */
export interface PolicySpecForProviderResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceArnSelectorPolicy(obj: PolicySpecForProviderResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolution
 */
export enum PolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolve
 */
export enum PolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderRefPolicyResolution
 */
export enum PolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderRefPolicyResolve
 */
export enum PolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: PolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderResourceArnRefPolicyResolution
 */
export enum PolicySpecForProviderResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderResourceArnRefPolicyResolve
 */
export enum PolicySpecForProviderResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderResourceArnSelectorPolicyResolution
 */
export enum PolicySpecForProviderResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderResourceArnSelectorPolicyResolve
 */
export enum PolicySpecForProviderResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

