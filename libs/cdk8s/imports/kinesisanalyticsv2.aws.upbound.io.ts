// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Application is the Schema for the Applications API. Manages a Kinesis Analytics v2 Application.
 *
 * @schema Application
 */
export class Application extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Application"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kinesisanalyticsv2.aws.upbound.io/v1beta1',
    kind: 'Application',
  }

  /**
   * Renders a Kubernetes manifest for "Application".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApplicationProps): any {
    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(props),
    };
  }

  /**
   * Defines a "Application" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApplicationProps) {
    super(scope, id, {
      ...Application.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(resolved),
    };
  }
}

/**
 * Application is the Schema for the Applications API. Manages a Kinesis Analytics v2 Application.
 *
 * @schema Application
 */
export interface ApplicationProps {
  /**
   * @schema Application#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApplicationSpec defines the desired state of Application
   *
   * @schema Application#spec
   */
  readonly spec: ApplicationSpec;

}

/**
 * Converts an object of type 'ApplicationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationProps(obj: ApplicationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApplicationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSpec defines the desired state of Application
 *
 * @schema ApplicationSpec
 */
export interface ApplicationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApplicationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApplicationSpecDeletionPolicy;

  /**
   * @schema ApplicationSpec#forProvider
   */
  readonly forProvider: ApplicationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ApplicationSpec#initProvider
   */
  readonly initProvider?: ApplicationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ApplicationSpec#managementPolicies
   */
  readonly managementPolicies?: ApplicationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApplicationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApplicationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApplicationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApplicationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApplicationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApplicationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApplicationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpec(obj: ApplicationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApplicationSpecForProvider(obj.forProvider),
    'initProvider': toJson_ApplicationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ApplicationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ApplicationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApplicationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApplicationSpecDeletionPolicy
 */
export enum ApplicationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApplicationSpecForProvider
 */
export interface ApplicationSpecForProvider {
  /**
   * The application's configuration
   *
   * @schema ApplicationSpecForProvider#applicationConfiguration
   */
  readonly applicationConfiguration?: ApplicationSpecForProviderApplicationConfiguration[];

  /**
   * A CloudWatch log stream to monitor application configuration errors.
   *
   * @schema ApplicationSpecForProvider#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: ApplicationSpecForProviderCloudwatchLoggingOptions[];

  /**
   * A summary description of the application.
   *
   * @schema ApplicationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether to force stop an unresponsive Flink-based application.
   *
   * @schema ApplicationSpecForProvider#forceStop
   */
  readonly forceStop?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApplicationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The runtime environment for the application. Valid values: SQL-1_0, FLINK-1_6, FLINK-1_8, FLINK-1_11, FLINK-1_13, FLINK-1_15.
   *
   * @schema ApplicationSpecForProvider#runtimeEnvironment
   */
  readonly runtimeEnvironment?: string;

  /**
   * The ARN of the IAM role used by the application to access Kinesis data streams, Kinesis Data Firehose delivery streams, Amazon S3 objects, and other external resources.
   *
   * @schema ApplicationSpecForProvider#serviceExecutionRole
   */
  readonly serviceExecutionRole?: string;

  /**
   * Reference to a Role in iam to populate serviceExecutionRole.
   *
   * @schema ApplicationSpecForProvider#serviceExecutionRoleRef
   */
  readonly serviceExecutionRoleRef?: ApplicationSpecForProviderServiceExecutionRoleRef;

  /**
   * Selector for a Role in iam to populate serviceExecutionRole.
   *
   * @schema ApplicationSpecForProvider#serviceExecutionRoleSelector
   */
  readonly serviceExecutionRoleSelector?: ApplicationSpecForProviderServiceExecutionRoleSelector;

  /**
   * Whether to start or stop the application.
   *
   * @schema ApplicationSpecForProvider#startApplication
   */
  readonly startApplication?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApplicationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProvider(obj: ApplicationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationConfiguration': obj.applicationConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfiguration(y)),
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => toJson_ApplicationSpecForProviderCloudwatchLoggingOptions(y)),
    'description': obj.description,
    'forceStop': obj.forceStop,
    'region': obj.region,
    'runtimeEnvironment': obj.runtimeEnvironment,
    'serviceExecutionRole': obj.serviceExecutionRole,
    'serviceExecutionRoleRef': toJson_ApplicationSpecForProviderServiceExecutionRoleRef(obj.serviceExecutionRoleRef),
    'serviceExecutionRoleSelector': toJson_ApplicationSpecForProviderServiceExecutionRoleSelector(obj.serviceExecutionRoleSelector),
    'startApplication': obj.startApplication,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ApplicationSpecInitProvider
 */
export interface ApplicationSpecInitProvider {
  /**
   * The application's configuration
   *
   * @schema ApplicationSpecInitProvider#applicationConfiguration
   */
  readonly applicationConfiguration?: ApplicationSpecInitProviderApplicationConfiguration[];

  /**
   * A CloudWatch log stream to monitor application configuration errors.
   *
   * @schema ApplicationSpecInitProvider#cloudwatchLoggingOptions
   */
  readonly cloudwatchLoggingOptions?: any[];

  /**
   * A summary description of the application.
   *
   * @schema ApplicationSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Whether to force stop an unresponsive Flink-based application.
   *
   * @schema ApplicationSpecInitProvider#forceStop
   */
  readonly forceStop?: boolean;

  /**
   * The runtime environment for the application. Valid values: SQL-1_0, FLINK-1_6, FLINK-1_8, FLINK-1_11, FLINK-1_13, FLINK-1_15.
   *
   * @schema ApplicationSpecInitProvider#runtimeEnvironment
   */
  readonly runtimeEnvironment?: string;

  /**
   * Whether to start or stop the application.
   *
   * @schema ApplicationSpecInitProvider#startApplication
   */
  readonly startApplication?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ApplicationSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProvider(obj: ApplicationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationConfiguration': obj.applicationConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfiguration(y)),
    'cloudwatchLoggingOptions': obj.cloudwatchLoggingOptions?.map(y => y),
    'description': obj.description,
    'forceStop': obj.forceStop,
    'runtimeEnvironment': obj.runtimeEnvironment,
    'startApplication': obj.startApplication,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ApplicationSpecManagementPolicies
 */
export enum ApplicationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApplicationSpecProviderConfigRef
 */
export interface ApplicationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderConfigRef#policy
   */
  readonly policy?: ApplicationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRef(obj: ApplicationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApplicationSpecPublishConnectionDetailsTo
 */
export interface ApplicationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApplicationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApplicationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsTo(obj: ApplicationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApplicationSpecWriteConnectionSecretToRef
 */
export interface ApplicationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecWriteConnectionSecretToRef(obj: ApplicationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfiguration {
  /**
   * The code location and type parameters for the application.
   *
   * @schema ApplicationSpecForProviderApplicationConfiguration#applicationCodeConfiguration
   */
  readonly applicationCodeConfiguration?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfiguration[];

  /**
   * Describes whether snapshots are enabled for a Flink-based application.
   *
   * @schema ApplicationSpecForProviderApplicationConfiguration#applicationSnapshotConfiguration
   */
  readonly applicationSnapshotConfiguration?: ApplicationSpecForProviderApplicationConfigurationApplicationSnapshotConfiguration[];

  /**
   * Describes execution properties for a Flink-based application.
   *
   * @schema ApplicationSpecForProviderApplicationConfiguration#environmentProperties
   */
  readonly environmentProperties?: ApplicationSpecForProviderApplicationConfigurationEnvironmentProperties[];

  /**
   * The configuration of a Flink-based application.
   *
   * @schema ApplicationSpecForProviderApplicationConfiguration#flinkApplicationConfiguration
   */
  readonly flinkApplicationConfiguration?: ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfiguration[];

  /**
   * Describes the starting properties for a Flink-based application.
   *
   * @schema ApplicationSpecForProviderApplicationConfiguration#runConfiguration
   */
  readonly runConfiguration?: ApplicationSpecForProviderApplicationConfigurationRunConfiguration[];

  /**
   * The configuration of a SQL-based application.
   *
   * @schema ApplicationSpecForProviderApplicationConfiguration#sqlApplicationConfiguration
   */
  readonly sqlApplicationConfiguration?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfiguration[];

  /**
   * The VPC configuration of a Flink-based application.
   *
   * @schema ApplicationSpecForProviderApplicationConfiguration#vpcConfiguration
   */
  readonly vpcConfiguration?: ApplicationSpecForProviderApplicationConfigurationVpcConfiguration[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfiguration(obj: ApplicationSpecForProviderApplicationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationCodeConfiguration': obj.applicationCodeConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfiguration(y)),
    'applicationSnapshotConfiguration': obj.applicationSnapshotConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationApplicationSnapshotConfiguration(y)),
    'environmentProperties': obj.environmentProperties?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationEnvironmentProperties(y)),
    'flinkApplicationConfiguration': obj.flinkApplicationConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfiguration(y)),
    'runConfiguration': obj.runConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationRunConfiguration(y)),
    'sqlApplicationConfiguration': obj.sqlApplicationConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfiguration(y)),
    'vpcConfiguration': obj.vpcConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationVpcConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptions
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptions {
  /**
   * The ARN of the CloudWatch log stream to receive application messages.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptions#logStreamArn
   */
  readonly logStreamArn?: string;

  /**
   * Reference to a Stream in cloudwatchlogs to populate logStreamArn.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptions#logStreamArnRef
   */
  readonly logStreamArnRef?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef;

  /**
   * Selector for a Stream in cloudwatchlogs to populate logStreamArn.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptions#logStreamArnSelector
   */
  readonly logStreamArnSelector?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptions(obj: ApplicationSpecForProviderCloudwatchLoggingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logStreamArn': obj.logStreamArn,
    'logStreamArnRef': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef(obj.logStreamArnRef),
    'logStreamArnSelector': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector(obj.logStreamArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate serviceExecutionRole.
 *
 * @schema ApplicationSpecForProviderServiceExecutionRoleRef
 */
export interface ApplicationSpecForProviderServiceExecutionRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderServiceExecutionRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderServiceExecutionRoleRef#policy
   */
  readonly policy?: ApplicationSpecForProviderServiceExecutionRoleRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderServiceExecutionRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderServiceExecutionRoleRef(obj: ApplicationSpecForProviderServiceExecutionRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderServiceExecutionRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate serviceExecutionRole.
 *
 * @schema ApplicationSpecForProviderServiceExecutionRoleSelector
 */
export interface ApplicationSpecForProviderServiceExecutionRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderServiceExecutionRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderServiceExecutionRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderServiceExecutionRoleSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderServiceExecutionRoleSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderServiceExecutionRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderServiceExecutionRoleSelector(obj: ApplicationSpecForProviderServiceExecutionRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderServiceExecutionRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfiguration {
  /**
   * The code location and type parameters for the application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfiguration#applicationCodeConfiguration
   */
  readonly applicationCodeConfiguration?: ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfiguration[];

  /**
   * Describes whether snapshots are enabled for a Flink-based application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfiguration#applicationSnapshotConfiguration
   */
  readonly applicationSnapshotConfiguration?: ApplicationSpecInitProviderApplicationConfigurationApplicationSnapshotConfiguration[];

  /**
   * Describes execution properties for a Flink-based application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfiguration#environmentProperties
   */
  readonly environmentProperties?: ApplicationSpecInitProviderApplicationConfigurationEnvironmentProperties[];

  /**
   * The configuration of a Flink-based application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfiguration#flinkApplicationConfiguration
   */
  readonly flinkApplicationConfiguration?: ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfiguration[];

  /**
   * Describes the starting properties for a Flink-based application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfiguration#runConfiguration
   */
  readonly runConfiguration?: ApplicationSpecInitProviderApplicationConfigurationRunConfiguration[];

  /**
   * The configuration of a SQL-based application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfiguration#sqlApplicationConfiguration
   */
  readonly sqlApplicationConfiguration?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfiguration[];

  /**
   * The VPC configuration of a Flink-based application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfiguration#vpcConfiguration
   */
  readonly vpcConfiguration?: ApplicationSpecInitProviderApplicationConfigurationVpcConfiguration[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfiguration(obj: ApplicationSpecInitProviderApplicationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationCodeConfiguration': obj.applicationCodeConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfiguration(y)),
    'applicationSnapshotConfiguration': obj.applicationSnapshotConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationApplicationSnapshotConfiguration(y)),
    'environmentProperties': obj.environmentProperties?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationEnvironmentProperties(y)),
    'flinkApplicationConfiguration': obj.flinkApplicationConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfiguration(y)),
    'runConfiguration': obj.runConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationRunConfiguration(y)),
    'sqlApplicationConfiguration': obj.sqlApplicationConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfiguration(y)),
    'vpcConfiguration': obj.vpcConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationVpcConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderConfigRefPolicy
 */
export interface ApplicationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRefPolicy(obj: ApplicationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRef
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj: ApplicationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToMetadata
 */
export interface ApplicationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj: ApplicationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfiguration {
  /**
   * The location and type of the application code.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfiguration#codeContent
   */
  readonly codeContent?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContent[];

  /**
   * Specifies whether the code content is in text or zip format. Valid values: PLAINTEXT, ZIPFILE.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfiguration#codeContentType
   */
  readonly codeContentType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeContent': obj.codeContent?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContent(y)),
    'codeContentType': obj.codeContentType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationSnapshotConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationSnapshotConfiguration {
  /**
   * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationSnapshotConfiguration#snapshotsEnabled
   */
  readonly snapshotsEnabled?: boolean;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationSnapshotConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationSnapshotConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationApplicationSnapshotConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'snapshotsEnabled': obj.snapshotsEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationEnvironmentProperties
 */
export interface ApplicationSpecForProviderApplicationConfigurationEnvironmentProperties {
  /**
   * Describes the execution property groups.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationEnvironmentProperties#propertyGroup
   */
  readonly propertyGroup?: ApplicationSpecForProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationEnvironmentProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationEnvironmentProperties(obj: ApplicationSpecForProviderApplicationConfigurationEnvironmentProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'propertyGroup': obj.propertyGroup?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfiguration {
  /**
   * Describes an application's checkpointing configuration.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfiguration#checkpointConfiguration
   */
  readonly checkpointConfiguration?: ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration[];

  /**
   * Describes configuration parameters for CloudWatch logging for an application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfiguration#monitoringConfiguration
   */
  readonly monitoringConfiguration?: ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration[];

  /**
   * Describes parameters for how an application executes multiple tasks simultaneously.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfiguration#parallelismConfiguration
   */
  readonly parallelismConfiguration?: ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkpointConfiguration': obj.checkpointConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration(y)),
    'monitoringConfiguration': obj.monitoringConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration(y)),
    'parallelismConfiguration': obj.parallelismConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationRunConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationRunConfiguration {
  /**
   * The restore behavior of a restarting application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationRunConfiguration#applicationRestoreConfiguration
   */
  readonly applicationRestoreConfiguration?: ApplicationSpecForProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration[];

  /**
   * The starting parameters for a Flink-based Kinesis Data Analytics application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationRunConfiguration#flinkRunConfiguration
   */
  readonly flinkRunConfiguration?: ApplicationSpecForProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationRunConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationRunConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationRunConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationRestoreConfiguration': obj.applicationRestoreConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration(y)),
    'flinkRunConfiguration': obj.flinkRunConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfiguration {
  /**
   * The input stream used by the application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfiguration#input
   */
  readonly input?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput[];

  /**
   * The destination streams used by the application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfiguration#output
   */
  readonly output?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput[];

  /**
   * The reference data source used by the application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfiguration#referenceDataSource
   */
  readonly referenceDataSource?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'input': obj.input?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput(y)),
    'output': obj.output?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput(y)),
    'referenceDataSource': obj.referenceDataSource?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationVpcConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationVpcConfiguration {
  /**
   * The Security Group IDs used by the VPC configuration.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationVpcConfiguration#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * The Subnet IDs used by the VPC configuration.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationVpcConfiguration#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationVpcConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationVpcConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationVpcConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stream in cloudwatchlogs to populate logStreamArn.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stream in cloudwatchlogs to populate logStreamArn.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderServiceExecutionRoleRefPolicy
 */
export interface ApplicationSpecForProviderServiceExecutionRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderServiceExecutionRoleRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderServiceExecutionRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderServiceExecutionRoleRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderServiceExecutionRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderServiceExecutionRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderServiceExecutionRoleRefPolicy(obj: ApplicationSpecForProviderServiceExecutionRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderServiceExecutionRoleSelectorPolicy
 */
export interface ApplicationSpecForProviderServiceExecutionRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderServiceExecutionRoleSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderServiceExecutionRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderServiceExecutionRoleSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderServiceExecutionRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderServiceExecutionRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderServiceExecutionRoleSelectorPolicy(obj: ApplicationSpecForProviderServiceExecutionRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfiguration {
  /**
   * The location and type of the application code.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfiguration#codeContent
   */
  readonly codeContent?: ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContent[];

  /**
   * Specifies whether the code content is in text or zip format. Valid values: PLAINTEXT, ZIPFILE.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfiguration#codeContentType
   */
  readonly codeContentType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeContent': obj.codeContent?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContent(y)),
    'codeContentType': obj.codeContentType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationApplicationSnapshotConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationApplicationSnapshotConfiguration {
  /**
   * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationApplicationSnapshotConfiguration#snapshotsEnabled
   */
  readonly snapshotsEnabled?: boolean;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationApplicationSnapshotConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationApplicationSnapshotConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationApplicationSnapshotConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'snapshotsEnabled': obj.snapshotsEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationEnvironmentProperties
 */
export interface ApplicationSpecInitProviderApplicationConfigurationEnvironmentProperties {
  /**
   * Describes the execution property groups.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationEnvironmentProperties#propertyGroup
   */
  readonly propertyGroup?: ApplicationSpecInitProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationEnvironmentProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationEnvironmentProperties(obj: ApplicationSpecInitProviderApplicationConfigurationEnvironmentProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'propertyGroup': obj.propertyGroup?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfiguration {
  /**
   * Describes an application's checkpointing configuration.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfiguration#checkpointConfiguration
   */
  readonly checkpointConfiguration?: ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration[];

  /**
   * Describes configuration parameters for CloudWatch logging for an application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfiguration#monitoringConfiguration
   */
  readonly monitoringConfiguration?: ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration[];

  /**
   * Describes parameters for how an application executes multiple tasks simultaneously.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfiguration#parallelismConfiguration
   */
  readonly parallelismConfiguration?: ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkpointConfiguration': obj.checkpointConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration(y)),
    'monitoringConfiguration': obj.monitoringConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration(y)),
    'parallelismConfiguration': obj.parallelismConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationRunConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationRunConfiguration {
  /**
   * The restore behavior of a restarting application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationRunConfiguration#applicationRestoreConfiguration
   */
  readonly applicationRestoreConfiguration?: ApplicationSpecInitProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration[];

  /**
   * The starting parameters for a Flink-based Kinesis Data Analytics application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationRunConfiguration#flinkRunConfiguration
   */
  readonly flinkRunConfiguration?: ApplicationSpecInitProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationRunConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationRunConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationRunConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationRestoreConfiguration': obj.applicationRestoreConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration(y)),
    'flinkRunConfiguration': obj.flinkRunConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfiguration {
  /**
   * The input stream used by the application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfiguration#input
   */
  readonly input?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput[];

  /**
   * The destination streams used by the application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfiguration#output
   */
  readonly output?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput[];

  /**
   * The reference data source used by the application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfiguration#referenceDataSource
   */
  readonly referenceDataSource?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'input': obj.input?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput(y)),
    'output': obj.output?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput(y)),
    'referenceDataSource': obj.referenceDataSource?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationVpcConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationVpcConfiguration {
  /**
   * The Security Group IDs used by the VPC configuration.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationVpcConfiguration#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * The Subnet IDs used by the VPC configuration.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationVpcConfiguration#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationVpcConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationVpcConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationVpcConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolution
 */
export enum ApplicationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolve
 */
export enum ApplicationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContent
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContent {
  /**
   * Information about the Amazon S3 bucket containing the application code.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContent#s3ContentLocation
   */
  readonly s3ContentLocation?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation[];

  /**
   * The text-format code for the application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContent#textContent
   */
  readonly textContent?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContent(obj: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3ContentLocation': obj.s3ContentLocation?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation(y)),
    'textContent': obj.textContent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup
 */
export interface ApplicationSpecForProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup {
  /**
   * The key of the application execution property key-value map.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup#propertyGroupId
   */
  readonly propertyGroupId?: string;

  /**
   * Application execution property key-value map.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup#propertyMap
   */
  readonly propertyMap?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup(obj: ApplicationSpecForProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'propertyGroupId': obj.propertyGroupId,
    'propertyMap': ((obj.propertyMap) === undefined) ? undefined : (Object.entries(obj.propertyMap).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration {
  /**
   * Describes the interval in milliseconds between checkpoint operations.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration#checkpointInterval
   */
  readonly checkpointInterval?: number;

  /**
   * Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration#checkpointingEnabled
   */
  readonly checkpointingEnabled?: boolean;

  /**
   * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration#configurationType
   */
  readonly configurationType?: string;

  /**
   * Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration#minPauseBetweenCheckpoints
   */
  readonly minPauseBetweenCheckpoints?: number;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkpointInterval': obj.checkpointInterval,
    'checkpointingEnabled': obj.checkpointingEnabled,
    'configurationType': obj.configurationType,
    'minPauseBetweenCheckpoints': obj.minPauseBetweenCheckpoints,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration {
  /**
   * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration#configurationType
   */
  readonly configurationType?: string;

  /**
   * Describes the verbosity of the CloudWatch Logs for an application. Valid values: DEBUG, ERROR, INFO, WARN.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration#logLevel
   */
  readonly logLevel?: string;

  /**
   * Describes the granularity of the CloudWatch Logs for an application. Valid values: APPLICATION, OPERATOR, PARALLELISM, TASK.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration#metricsLevel
   */
  readonly metricsLevel?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configurationType': obj.configurationType,
    'logLevel': obj.logLevel,
    'metricsLevel': obj.metricsLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration {
  /**
   * Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration#autoScalingEnabled
   */
  readonly autoScalingEnabled?: boolean;

  /**
   * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration#configurationType
   */
  readonly configurationType?: string;

  /**
   * Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration#parallelism
   */
  readonly parallelism?: number;

  /**
   * Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration#parallelismPerKpu
   */
  readonly parallelismPerKpu?: number;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoScalingEnabled': obj.autoScalingEnabled,
    'configurationType': obj.configurationType,
    'parallelism': obj.parallelism,
    'parallelismPerKpu': obj.parallelismPerKpu,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration {
  /**
   * Specifies how the application should be restored. Valid values: RESTORE_FROM_CUSTOM_SNAPSHOT, RESTORE_FROM_LATEST_SNAPSHOT, SKIP_RESTORE_FROM_SNAPSHOT.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration#applicationRestoreType
   */
  readonly applicationRestoreType?: string;

  /**
   * The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for application_restore_type.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration#snapshotName
   */
  readonly snapshotName?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationRestoreType': obj.applicationRestoreType,
    'snapshotName': obj.snapshotName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration {
  /**
   * When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Default is false.
   *
   * @default false.
   * @schema ApplicationSpecForProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration#allowNonRestoredState
   */
  readonly allowNonRestoredState?: boolean;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowNonRestoredState': obj.allowNonRestoredState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput {
  /**
   * Describes the number of in-application streams to create.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput#inputParallelism
   */
  readonly inputParallelism?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism[];

  /**
   * The input processing configuration for the input. An input processor transforms records as they are received from the stream, before the application's SQL code executes.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput#inputProcessingConfiguration
   */
  readonly inputProcessingConfiguration?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration[];

  /**
   * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput#inputSchema
   */
  readonly inputSchema?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema[];

  /**
   * The point at which the application starts processing records from the streaming source.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput#inputStartingPositionConfiguration
   */
  readonly inputStartingPositionConfiguration?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration[];

  /**
   * If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput#kinesisFirehoseInput
   */
  readonly kinesisFirehoseInput?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput[];

  /**
   * If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput#kinesisStreamsInput
   */
  readonly kinesisStreamsInput?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput[];

  /**
   * The name prefix to use when creating an in-application stream.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput#namePrefix
   */
  readonly namePrefix?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputParallelism': obj.inputParallelism?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism(y)),
    'inputProcessingConfiguration': obj.inputProcessingConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration(y)),
    'inputSchema': obj.inputSchema?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema(y)),
    'inputStartingPositionConfiguration': obj.inputStartingPositionConfiguration?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration(y)),
    'kinesisFirehoseInput': obj.kinesisFirehoseInput?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput(y)),
    'kinesisStreamsInput': obj.kinesisStreamsInput?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput(y)),
    'namePrefix': obj.namePrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput {
  /**
   * Describes the data format when records are written to the destination.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput#destinationSchema
   */
  readonly destinationSchema?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema[];

  /**
   * Identifies a Kinesis Data Firehose delivery stream as the destination.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput#kinesisFirehoseOutput
   */
  readonly kinesisFirehoseOutput?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput[];

  /**
   * Identifies a Kinesis data stream as the destination.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput#kinesisStreamsOutput
   */
  readonly kinesisStreamsOutput?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput[];

  /**
   * Identifies a Lambda function as the destination.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput#lambdaOutput
   */
  readonly lambdaOutput?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput[];

  /**
   * The name of the application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSchema': obj.destinationSchema?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema(y)),
    'kinesisFirehoseOutput': obj.kinesisFirehoseOutput?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput(y)),
    'kinesisStreamsOutput': obj.kinesisStreamsOutput?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput(y)),
    'lambdaOutput': obj.lambdaOutput?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource {
  /**
   * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource#referenceSchema
   */
  readonly referenceSchema?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema[];

  /**
   * Identifies the S3 bucket and object that contains the reference data.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource#s3ReferenceDataSource
   */
  readonly s3ReferenceDataSource?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource[];

  /**
   * The name of the in-application table to create.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'referenceSchema': obj.referenceSchema?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema(y)),
    's3ReferenceDataSource': obj.s3ReferenceDataSource?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource(y)),
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy
 */
export interface ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy(obj: ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderServiceExecutionRoleRefPolicyResolution
 */
export enum ApplicationSpecForProviderServiceExecutionRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderServiceExecutionRoleRefPolicyResolve
 */
export enum ApplicationSpecForProviderServiceExecutionRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderServiceExecutionRoleSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderServiceExecutionRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderServiceExecutionRoleSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderServiceExecutionRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContent
 */
export interface ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContent {
  /**
   * Information about the Amazon S3 bucket containing the application code.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContent#s3ContentLocation
   */
  readonly s3ContentLocation?: ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation[];

  /**
   * The text-format code for the application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContent#textContent
   */
  readonly textContent?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContent(obj: ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3ContentLocation': obj.s3ContentLocation?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation(y)),
    'textContent': obj.textContent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup
 */
export interface ApplicationSpecInitProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup {
  /**
   * The key of the application execution property key-value map.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup#propertyGroupId
   */
  readonly propertyGroupId?: string;

  /**
   * Application execution property key-value map.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup#propertyMap
   */
  readonly propertyMap?: { [key: string]: string };

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup(obj: ApplicationSpecInitProviderApplicationConfigurationEnvironmentPropertiesPropertyGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'propertyGroupId': obj.propertyGroupId,
    'propertyMap': ((obj.propertyMap) === undefined) ? undefined : (Object.entries(obj.propertyMap).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration {
  /**
   * Describes the interval in milliseconds between checkpoint operations.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration#checkpointInterval
   */
  readonly checkpointInterval?: number;

  /**
   * Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration#checkpointingEnabled
   */
  readonly checkpointingEnabled?: boolean;

  /**
   * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration#configurationType
   */
  readonly configurationType?: string;

  /**
   * Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration#minPauseBetweenCheckpoints
   */
  readonly minPauseBetweenCheckpoints?: number;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkpointInterval': obj.checkpointInterval,
    'checkpointingEnabled': obj.checkpointingEnabled,
    'configurationType': obj.configurationType,
    'minPauseBetweenCheckpoints': obj.minPauseBetweenCheckpoints,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration {
  /**
   * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration#configurationType
   */
  readonly configurationType?: string;

  /**
   * Describes the verbosity of the CloudWatch Logs for an application. Valid values: DEBUG, ERROR, INFO, WARN.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration#logLevel
   */
  readonly logLevel?: string;

  /**
   * Describes the granularity of the CloudWatch Logs for an application. Valid values: APPLICATION, OPERATOR, PARALLELISM, TASK.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration#metricsLevel
   */
  readonly metricsLevel?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configurationType': obj.configurationType,
    'logLevel': obj.logLevel,
    'metricsLevel': obj.metricsLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration {
  /**
   * Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration#autoScalingEnabled
   */
  readonly autoScalingEnabled?: boolean;

  /**
   * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. Valid values: CUSTOM, DEFAULT. Set this attribute to CUSTOM in order for any specified checkpointing_enabled, checkpoint_interval, or min_pause_between_checkpoints attribute values to be effective. If this attribute is set to DEFAULT, the application will always use the following values:
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration#configurationType
   */
  readonly configurationType?: string;

  /**
   * Describes the initial number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration#parallelism
   */
  readonly parallelism?: number;

  /**
   * Describes the number of parallel tasks that a Flink-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration#parallelismPerKpu
   */
  readonly parallelismPerKpu?: number;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoScalingEnabled': obj.autoScalingEnabled,
    'configurationType': obj.configurationType,
    'parallelism': obj.parallelism,
    'parallelismPerKpu': obj.parallelismPerKpu,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration {
  /**
   * Specifies how the application should be restored. Valid values: RESTORE_FROM_CUSTOM_SNAPSHOT, RESTORE_FROM_LATEST_SNAPSHOT, SKIP_RESTORE_FROM_SNAPSHOT.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration#applicationRestoreType
   */
  readonly applicationRestoreType?: string;

  /**
   * The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for application_restore_type.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration#snapshotName
   */
  readonly snapshotName?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationRunConfigurationApplicationRestoreConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationRestoreType': obj.applicationRestoreType,
    'snapshotName': obj.snapshotName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration {
  /**
   * When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Default is false.
   *
   * @default false.
   * @schema ApplicationSpecInitProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration#allowNonRestoredState
   */
  readonly allowNonRestoredState?: boolean;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationRunConfigurationFlinkRunConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowNonRestoredState': obj.allowNonRestoredState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput {
  /**
   * Describes the number of in-application streams to create.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput#inputParallelism
   */
  readonly inputParallelism?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism[];

  /**
   * The input processing configuration for the input. An input processor transforms records as they are received from the stream, before the application's SQL code executes.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput#inputProcessingConfiguration
   */
  readonly inputProcessingConfiguration?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration[];

  /**
   * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput#inputSchema
   */
  readonly inputSchema?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema[];

  /**
   * The point at which the application starts processing records from the streaming source.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput#inputStartingPositionConfiguration
   */
  readonly inputStartingPositionConfiguration?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration[];

  /**
   * If the streaming source is a Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput#kinesisFirehoseInput
   */
  readonly kinesisFirehoseInput?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput[];

  /**
   * If the streaming source is a Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput#kinesisStreamsInput
   */
  readonly kinesisStreamsInput?: any[];

  /**
   * The name prefix to use when creating an in-application stream.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput#namePrefix
   */
  readonly namePrefix?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputParallelism': obj.inputParallelism?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism(y)),
    'inputProcessingConfiguration': obj.inputProcessingConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration(y)),
    'inputSchema': obj.inputSchema?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema(y)),
    'inputStartingPositionConfiguration': obj.inputStartingPositionConfiguration?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration(y)),
    'kinesisFirehoseInput': obj.kinesisFirehoseInput?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput(y)),
    'kinesisStreamsInput': obj.kinesisStreamsInput?.map(y => y),
    'namePrefix': obj.namePrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput {
  /**
   * Describes the data format when records are written to the destination.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput#destinationSchema
   */
  readonly destinationSchema?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema[];

  /**
   * Identifies a Kinesis Data Firehose delivery stream as the destination.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput#kinesisFirehoseOutput
   */
  readonly kinesisFirehoseOutput?: any[];

  /**
   * Identifies a Kinesis data stream as the destination.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput#kinesisStreamsOutput
   */
  readonly kinesisStreamsOutput?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput[];

  /**
   * Identifies a Lambda function as the destination.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput#lambdaOutput
   */
  readonly lambdaOutput?: any[];

  /**
   * The name of the application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSchema': obj.destinationSchema?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema(y)),
    'kinesisFirehoseOutput': obj.kinesisFirehoseOutput?.map(y => y),
    'kinesisStreamsOutput': obj.kinesisStreamsOutput?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput(y)),
    'lambdaOutput': obj.lambdaOutput?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource {
  /**
   * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource#referenceSchema
   */
  readonly referenceSchema?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema[];

  /**
   * Identifies the S3 bucket and object that contains the reference data.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource#s3ReferenceDataSource
   */
  readonly s3ReferenceDataSource?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource[];

  /**
   * The name of the in-application table to create.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource#tableName
   */
  readonly tableName?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'referenceSchema': obj.referenceSchema?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema(y)),
    's3ReferenceDataSource': obj.s3ReferenceDataSource?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource(y)),
    'tableName': obj.tableName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation {
  /**
   * The ARN for the S3 bucket containing the application code.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation#bucketArn
   */
  readonly bucketArn?: string;

  /**
   * Reference to a Bucket in s3 to populate bucketArn.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation#bucketArnRef
   */
  readonly bucketArnRef?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef;

  /**
   * Selector for a Bucket in s3 to populate bucketArn.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation#bucketArnSelector
   */
  readonly bucketArnSelector?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector;

  /**
   * The file key for the object containing the application code.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation#fileKey
   */
  readonly fileKey?: string;

  /**
   * Reference to a Object in s3 to populate fileKey.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation#fileKeyRef
   */
  readonly fileKeyRef?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef;

  /**
   * Selector for a Object in s3 to populate fileKey.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation#fileKeySelector
   */
  readonly fileKeySelector?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector;

  /**
   * The version of the object containing the application code.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation#objectVersion
   */
  readonly objectVersion?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation(obj: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketArn': obj.bucketArn,
    'bucketArnRef': toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef(obj.bucketArnRef),
    'bucketArnSelector': toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector(obj.bucketArnSelector),
    'fileKey': obj.fileKey,
    'fileKeyRef': toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef(obj.fileKeyRef),
    'fileKeySelector': toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector(obj.fileKeySelector),
    'objectVersion': obj.objectVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism {
  /**
   * The number of in-application streams to create.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism#count
   */
  readonly count?: number;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration {
  /**
   * Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration#inputLambdaProcessor
   */
  readonly inputLambdaProcessor?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputLambdaProcessor': obj.inputLambdaProcessor?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema {
  /**
   * Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema#recordColumn
   */
  readonly recordColumn?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn[];

  /**
   * Specifies the encoding of the records in the streaming source. For example, UTF-8.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema#recordEncoding
   */
  readonly recordEncoding?: string;

  /**
   * Specifies the format of the records on the streaming source.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema#recordFormat
   */
  readonly recordFormat?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumn': obj.recordColumn?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn(y)),
    'recordEncoding': obj.recordEncoding,
    'recordFormat': obj.recordFormat?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration {
  /**
   * The starting position on the stream. Valid values: LAST_STOPPED_POINT, NOW, TRIM_HORIZON.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration#inputStartingPosition
   */
  readonly inputStartingPosition?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputStartingPosition': obj.inputStartingPosition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput {
  /**
   * The ARN of the Lambda function that operates on records in the stream.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput#resourceArn
   */
  readonly resourceArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput {
  /**
   * The ARN of the Lambda function that operates on records in the stream.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a Stream in kinesis to populate resourceArn.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput#resourceArnRef
   */
  readonly resourceArnRef?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef;

  /**
   * Selector for a Stream in kinesis to populate resourceArn.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput#resourceArnSelector
   */
  readonly resourceArnSelector?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema {
  /**
   * The type of record format. Valid values: CSV, JSON.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema#recordFormatType
   */
  readonly recordFormatType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordFormatType': obj.recordFormatType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput {
  /**
   * The ARN of the Lambda function that operates on records in the stream.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a DeliveryStream in firehose to populate resourceArn.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput#resourceArnRef
   */
  readonly resourceArnRef?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef;

  /**
   * Selector for a DeliveryStream in firehose to populate resourceArn.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput#resourceArnSelector
   */
  readonly resourceArnSelector?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput {
  /**
   * The ARN of the Lambda function that operates on records in the stream.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput#resourceArn
   */
  readonly resourceArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput {
  /**
   * The ARN of the Lambda function that operates on records in the stream.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a Function in lambda to populate resourceArn.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput#resourceArnRef
   */
  readonly resourceArnRef?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef;

  /**
   * Selector for a Function in lambda to populate resourceArn.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput#resourceArnSelector
   */
  readonly resourceArnSelector?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema {
  /**
   * Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema#recordColumn
   */
  readonly recordColumn?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn[];

  /**
   * Specifies the encoding of the records in the streaming source. For example, UTF-8.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema#recordEncoding
   */
  readonly recordEncoding?: string;

  /**
   * Specifies the format of the records on the streaming source.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema#recordFormat
   */
  readonly recordFormat?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumn': obj.recordColumn?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn(y)),
    'recordEncoding': obj.recordEncoding,
    'recordFormat': obj.recordFormat?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource {
  /**
   * The ARN for the S3 bucket containing the application code.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource#bucketArn
   */
  readonly bucketArn?: string;

  /**
   * Reference to a Bucket in s3 to populate bucketArn.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource#bucketArnRef
   */
  readonly bucketArnRef?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef;

  /**
   * Selector for a Bucket in s3 to populate bucketArn.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource#bucketArnSelector
   */
  readonly bucketArnSelector?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector;

  /**
   * The file key for the object containing the application code.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource#fileKey
   */
  readonly fileKey?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketArn': obj.bucketArn,
    'bucketArnRef': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef(obj.bucketArnRef),
    'bucketArnSelector': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector(obj.bucketArnSelector),
    'fileKey': obj.fileKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderCloudwatchLoggingOptionsLogStreamArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation
 */
export interface ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation {
  /**
   * The version of the object containing the application code.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation#objectVersion
   */
  readonly objectVersion?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation(obj: ApplicationSpecInitProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectVersion': obj.objectVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism {
  /**
   * The number of in-application streams to create.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism#count
   */
  readonly count?: number;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputParallelism | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration {
  /**
   * Describes the Lambda function that is used to preprocess the records in the stream before being processed by your application code.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration#inputLambdaProcessor
   */
  readonly inputLambdaProcessor?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputLambdaProcessor': obj.inputLambdaProcessor?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema {
  /**
   * Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema#recordColumn
   */
  readonly recordColumn?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn[];

  /**
   * Specifies the encoding of the records in the streaming source. For example, UTF-8.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema#recordEncoding
   */
  readonly recordEncoding?: string;

  /**
   * Specifies the format of the records on the streaming source.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema#recordFormat
   */
  readonly recordFormat?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumn': obj.recordColumn?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn(y)),
    'recordEncoding': obj.recordEncoding,
    'recordFormat': obj.recordFormat?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration {
  /**
   * The starting position on the stream. Valid values: LAST_STOPPED_POINT, NOW, TRIM_HORIZON.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration#inputStartingPosition
   */
  readonly inputStartingPosition?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputStartingPositionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputStartingPosition': obj.inputStartingPosition,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput {
  /**
   * The ARN of the Lambda function that operates on records in the stream.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput#resourceArn
   */
  readonly resourceArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema {
  /**
   * The type of record format. Valid values: CSV, JSON.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema#recordFormatType
   */
  readonly recordFormatType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordFormatType': obj.recordFormatType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput {
  /**
   * The ARN of the Lambda function that operates on records in the stream.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput#resourceArn
   */
  readonly resourceArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema {
  /**
   * Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema#recordColumn
   */
  readonly recordColumn?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn[];

  /**
   * Specifies the encoding of the records in the streaming source. For example, UTF-8.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema#recordEncoding
   */
  readonly recordEncoding?: string;

  /**
   * Specifies the format of the records on the streaming source.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema#recordFormat
   */
  readonly recordFormat?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumn': obj.recordColumn?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn(y)),
    'recordEncoding': obj.recordEncoding,
    'recordFormat': obj.recordFormat?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource {
  /**
   * The file key for the object containing the application code.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource#fileKey
   */
  readonly fileKey?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileKey': obj.fileKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucketArn.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef(obj: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucketArn.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector(obj: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Object in s3 to populate fileKey.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef(obj: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Object in s3 to populate fileKey.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector(obj: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor {
  /**
   * The ARN of the Lambda function that operates on records in the stream.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor#resourceArn
   */
  readonly resourceArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn {
  /**
   * A reference to the data element in the streaming input or the reference data source.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn#mapping
   */
  readonly mapping?: string;

  /**
   * The name of the application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn#name
   */
  readonly name?: string;

  /**
   * The type of column created in the in-application input stream or reference table.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn#sqlType
   */
  readonly sqlType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mapping': obj.mapping,
    'name': obj.name,
    'sqlType': obj.sqlType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat {
  /**
   * Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat#mappingParameters
   */
  readonly mappingParameters?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters[];

  /**
   * The type of record format. Valid values: CSV, JSON.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat#recordFormatType
   */
  readonly recordFormatType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mappingParameters': obj.mappingParameters?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters(y)),
    'recordFormatType': obj.recordFormatType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Stream in kinesis to populate resourceArn.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Stream in kinesis to populate resourceArn.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DeliveryStream in firehose to populate resourceArn.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DeliveryStream in firehose to populate resourceArn.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate resourceArn.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate resourceArn.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn {
  /**
   * A reference to the data element in the streaming input or the reference data source.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn#mapping
   */
  readonly mapping?: string;

  /**
   * The name of the application.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn#name
   */
  readonly name?: string;

  /**
   * The type of column created in the in-application input stream or reference table.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn#sqlType
   */
  readonly sqlType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mapping': obj.mapping,
    'name': obj.name,
    'sqlType': obj.sqlType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat {
  /**
   * Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat#mappingParameters
   */
  readonly mappingParameters?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters[];

  /**
   * The type of record format. Valid values: CSV, JSON.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat#recordFormatType
   */
  readonly recordFormatType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mappingParameters': obj.mappingParameters?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters(y)),
    'recordFormatType': obj.recordFormatType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucketArn.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucketArn.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor {
  /**
   * The ARN of the Lambda function that operates on records in the stream.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor#resourceArn
   */
  readonly resourceArn?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceArn': obj.resourceArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn {
  /**
   * A reference to the data element in the streaming input or the reference data source.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn#mapping
   */
  readonly mapping?: string;

  /**
   * The name of the application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn#name
   */
  readonly name?: string;

  /**
   * The type of column created in the in-application input stream or reference table.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn#sqlType
   */
  readonly sqlType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordColumn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mapping': obj.mapping,
    'name': obj.name,
    'sqlType': obj.sqlType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat {
  /**
   * Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat#mappingParameters
   */
  readonly mappingParameters?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters[];

  /**
   * The type of record format. Valid values: CSV, JSON.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat#recordFormatType
   */
  readonly recordFormatType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mappingParameters': obj.mappingParameters?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters(y)),
    'recordFormatType': obj.recordFormatType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn {
  /**
   * A reference to the data element in the streaming input or the reference data source.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn#mapping
   */
  readonly mapping?: string;

  /**
   * The name of the application.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn#name
   */
  readonly name?: string;

  /**
   * The type of column created in the in-application input stream or reference table.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn#sqlType
   */
  readonly sqlType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordColumn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mapping': obj.mapping,
    'name': obj.name,
    'sqlType': obj.sqlType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat {
  /**
   * Provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat#mappingParameters
   */
  readonly mappingParameters?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters[];

  /**
   * The type of record format. Valid values: CSV, JSON.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat#recordFormatType
   */
  readonly recordFormatType?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mappingParameters': obj.mappingParameters?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters(y)),
    'recordFormatType': obj.recordFormatType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy(obj: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy(obj: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy(obj: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy(obj: ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters {
  /**
   * Provides additional mapping information when the record format uses delimiters (for example, CSV).
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters#csvMappingParameters
   */
  readonly csvMappingParameters?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters[];

  /**
   * Provides additional mapping information when JSON is the record format on the streaming source.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters#jsonMappingParameters
   */
  readonly jsonMappingParameters?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csvMappingParameters': obj.csvMappingParameters?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters(y)),
    'jsonMappingParameters': obj.jsonMappingParameters?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters {
  /**
   * Provides additional mapping information when the record format uses delimiters (for example, CSV).
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters#csvMappingParameters
   */
  readonly csvMappingParameters?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters[];

  /**
   * Provides additional mapping information when JSON is the record format on the streaming source.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters#jsonMappingParameters
   */
  readonly jsonMappingParameters?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters[];

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csvMappingParameters': obj.csvMappingParameters?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters(y)),
    'jsonMappingParameters': obj.jsonMappingParameters?.map(y => toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters {
  /**
   * Provides additional mapping information when the record format uses delimiters (for example, CSV).
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters#csvMappingParameters
   */
  readonly csvMappingParameters?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters[];

  /**
   * Provides additional mapping information when JSON is the record format on the streaming source.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters#jsonMappingParameters
   */
  readonly jsonMappingParameters?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csvMappingParameters': obj.csvMappingParameters?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters(y)),
    'jsonMappingParameters': obj.jsonMappingParameters?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters {
  /**
   * Provides additional mapping information when the record format uses delimiters (for example, CSV).
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters#csvMappingParameters
   */
  readonly csvMappingParameters?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters[];

  /**
   * Provides additional mapping information when JSON is the record format on the streaming source.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters#jsonMappingParameters
   */
  readonly jsonMappingParameters?: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters[];

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csvMappingParameters': obj.csvMappingParameters?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters(y)),
    'jsonMappingParameters': obj.jsonMappingParameters?.map(y => toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationBucketArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationFileKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters {
  /**
   * The column delimiter. For example, in a CSV format, a comma (,) is the typical column delimiter.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters#recordColumnDelimiter
   */
  readonly recordColumnDelimiter?: string;

  /**
   * The row delimiter. For example, in a CSV format, \n is the typical row delimiter.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters#recordRowDelimiter
   */
  readonly recordRowDelimiter?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumnDelimiter': obj.recordColumnDelimiter,
    'recordRowDelimiter': obj.recordRowDelimiter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters {
  /**
   * The path to the top-level parent that contains the records.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters#recordRowPath
   */
  readonly recordRowPath?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordRowPath': obj.recordRowPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters {
  /**
   * The column delimiter. For example, in a CSV format, a comma (,) is the typical column delimiter.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters#recordColumnDelimiter
   */
  readonly recordColumnDelimiter?: string;

  /**
   * The row delimiter. For example, in a CSV format, \n is the typical row delimiter.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters#recordRowDelimiter
   */
  readonly recordRowDelimiter?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumnDelimiter': obj.recordColumnDelimiter,
    'recordRowDelimiter': obj.recordRowDelimiter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters
 */
export interface ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters {
  /**
   * The path to the top-level parent that contains the records.
   *
   * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters#recordRowPath
   */
  readonly recordRowPath?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters(obj: ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordRowPath': obj.recordRowPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceBucketArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters {
  /**
   * The column delimiter. For example, in a CSV format, a comma (,) is the typical column delimiter.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters#recordColumnDelimiter
   */
  readonly recordColumnDelimiter?: string;

  /**
   * The row delimiter. For example, in a CSV format, \n is the typical row delimiter.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters#recordRowDelimiter
   */
  readonly recordRowDelimiter?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumnDelimiter': obj.recordColumnDelimiter,
    'recordRowDelimiter': obj.recordRowDelimiter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters {
  /**
   * The path to the top-level parent that contains the records.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters#recordRowPath
   */
  readonly recordRowPath?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordRowPath': obj.recordRowPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters {
  /**
   * The column delimiter. For example, in a CSV format, a comma (,) is the typical column delimiter.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters#recordColumnDelimiter
   */
  readonly recordColumnDelimiter?: string;

  /**
   * The row delimiter. For example, in a CSV format, \n is the typical row delimiter.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters#recordRowDelimiter
   */
  readonly recordRowDelimiter?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordColumnDelimiter': obj.recordColumnDelimiter,
    'recordRowDelimiter': obj.recordRowDelimiter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters
 */
export interface ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters {
  /**
   * The path to the top-level parent that contains the records.
   *
   * @schema ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters#recordRowPath
   */
  readonly recordRowPath?: string;

}

/**
 * Converts an object of type 'ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters(obj: ApplicationSpecInitProviderApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recordRowPath': obj.recordRowPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ApplicationSnapshot is the Schema for the ApplicationSnapshots API. Manages a Kinesis Analytics v2 Application Snapshot.
 *
 * @schema ApplicationSnapshot
 */
export class ApplicationSnapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ApplicationSnapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kinesisanalyticsv2.aws.upbound.io/v1beta1',
    kind: 'ApplicationSnapshot',
  }

  /**
   * Renders a Kubernetes manifest for "ApplicationSnapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApplicationSnapshotProps): any {
    return {
      ...ApplicationSnapshot.GVK,
      ...toJson_ApplicationSnapshotProps(props),
    };
  }

  /**
   * Defines a "ApplicationSnapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApplicationSnapshotProps) {
    super(scope, id, {
      ...ApplicationSnapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApplicationSnapshot.GVK,
      ...toJson_ApplicationSnapshotProps(resolved),
    };
  }
}

/**
 * ApplicationSnapshot is the Schema for the ApplicationSnapshots API. Manages a Kinesis Analytics v2 Application Snapshot.
 *
 * @schema ApplicationSnapshot
 */
export interface ApplicationSnapshotProps {
  /**
   * @schema ApplicationSnapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApplicationSnapshotSpec defines the desired state of ApplicationSnapshot
   *
   * @schema ApplicationSnapshot#spec
   */
  readonly spec: ApplicationSnapshotSpec;

}

/**
 * Converts an object of type 'ApplicationSnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotProps(obj: ApplicationSnapshotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApplicationSnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSnapshotSpec defines the desired state of ApplicationSnapshot
 *
 * @schema ApplicationSnapshotSpec
 */
export interface ApplicationSnapshotSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ApplicationSnapshotSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApplicationSnapshotSpecDeletionPolicy;

  /**
   * @schema ApplicationSnapshotSpec#forProvider
   */
  readonly forProvider: ApplicationSnapshotSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ApplicationSnapshotSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ApplicationSnapshotSpec#managementPolicies
   */
  readonly managementPolicies?: ApplicationSnapshotSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApplicationSnapshotSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApplicationSnapshotSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApplicationSnapshotSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApplicationSnapshotSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApplicationSnapshotSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApplicationSnapshotSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpec(obj: ApplicationSnapshotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApplicationSnapshotSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ApplicationSnapshotSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ApplicationSnapshotSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApplicationSnapshotSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ApplicationSnapshotSpecDeletionPolicy
 */
export enum ApplicationSnapshotSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApplicationSnapshotSpecForProvider
 */
export interface ApplicationSnapshotSpecForProvider {
  /**
   * The name of an existing  Kinesis Analytics v2 Application. Note that the application must be running for a snapshot to be created.
   *
   * @schema ApplicationSnapshotSpecForProvider#applicationName
   */
  readonly applicationName?: string;

  /**
   * Reference to a Application in kinesisanalyticsv2 to populate applicationName.
   *
   * @schema ApplicationSnapshotSpecForProvider#applicationNameRef
   */
  readonly applicationNameRef?: ApplicationSnapshotSpecForProviderApplicationNameRef;

  /**
   * Selector for a Application in kinesisanalyticsv2 to populate applicationName.
   *
   * @schema ApplicationSnapshotSpecForProvider#applicationNameSelector
   */
  readonly applicationNameSelector?: ApplicationSnapshotSpecForProviderApplicationNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApplicationSnapshotSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecForProvider(obj: ApplicationSnapshotSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationName': obj.applicationName,
    'applicationNameRef': toJson_ApplicationSnapshotSpecForProviderApplicationNameRef(obj.applicationNameRef),
    'applicationNameSelector': toJson_ApplicationSnapshotSpecForProviderApplicationNameSelector(obj.applicationNameSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ApplicationSnapshotSpecManagementPolicies
 */
export enum ApplicationSnapshotSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApplicationSnapshotSpecProviderConfigRef
 */
export interface ApplicationSnapshotSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSnapshotSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSnapshotSpecProviderConfigRef#policy
   */
  readonly policy?: ApplicationSnapshotSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecProviderConfigRef(obj: ApplicationSnapshotSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSnapshotSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApplicationSnapshotSpecPublishConnectionDetailsTo
 */
export interface ApplicationSnapshotSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApplicationSnapshotSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApplicationSnapshotSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApplicationSnapshotSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApplicationSnapshotSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApplicationSnapshotSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecPublishConnectionDetailsTo(obj: ApplicationSnapshotSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApplicationSnapshotSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApplicationSnapshotSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApplicationSnapshotSpecWriteConnectionSecretToRef
 */
export interface ApplicationSnapshotSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApplicationSnapshotSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSnapshotSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecWriteConnectionSecretToRef(obj: ApplicationSnapshotSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Application in kinesisanalyticsv2 to populate applicationName.
 *
 * @schema ApplicationSnapshotSpecForProviderApplicationNameRef
 */
export interface ApplicationSnapshotSpecForProviderApplicationNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSnapshotSpecForProviderApplicationNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSnapshotSpecForProviderApplicationNameRef#policy
   */
  readonly policy?: ApplicationSnapshotSpecForProviderApplicationNameRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecForProviderApplicationNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecForProviderApplicationNameRef(obj: ApplicationSnapshotSpecForProviderApplicationNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSnapshotSpecForProviderApplicationNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Application in kinesisanalyticsv2 to populate applicationName.
 *
 * @schema ApplicationSnapshotSpecForProviderApplicationNameSelector
 */
export interface ApplicationSnapshotSpecForProviderApplicationNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSnapshotSpecForProviderApplicationNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSnapshotSpecForProviderApplicationNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSnapshotSpecForProviderApplicationNameSelector#policy
   */
  readonly policy?: ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecForProviderApplicationNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecForProviderApplicationNameSelector(obj: ApplicationSnapshotSpecForProviderApplicationNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSnapshotSpecProviderConfigRefPolicy
 */
export interface ApplicationSnapshotSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSnapshotSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSnapshotSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSnapshotSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSnapshotSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecProviderConfigRefPolicy(obj: ApplicationSnapshotSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApplicationSnapshotSpecPublishConnectionDetailsToConfigRef
 */
export interface ApplicationSnapshotSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSnapshotSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSnapshotSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecPublishConnectionDetailsToConfigRef(obj: ApplicationSnapshotSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApplicationSnapshotSpecPublishConnectionDetailsToMetadata
 */
export interface ApplicationSnapshotSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSnapshotSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSnapshotSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApplicationSnapshotSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecPublishConnectionDetailsToMetadata(obj: ApplicationSnapshotSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSnapshotSpecForProviderApplicationNameRefPolicy
 */
export interface ApplicationSnapshotSpecForProviderApplicationNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSnapshotSpecForProviderApplicationNameRefPolicy#resolution
   */
  readonly resolution?: ApplicationSnapshotSpecForProviderApplicationNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSnapshotSpecForProviderApplicationNameRefPolicy#resolve
   */
  readonly resolve?: ApplicationSnapshotSpecForProviderApplicationNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecForProviderApplicationNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecForProviderApplicationNameRefPolicy(obj: ApplicationSnapshotSpecForProviderApplicationNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicy
 */
export interface ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicy(obj: ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSnapshotSpecProviderConfigRefPolicyResolution
 */
export enum ApplicationSnapshotSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSnapshotSpecProviderConfigRefPolicyResolve
 */
export enum ApplicationSnapshotSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSnapshotSpecForProviderApplicationNameRefPolicyResolution
 */
export enum ApplicationSnapshotSpecForProviderApplicationNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSnapshotSpecForProviderApplicationNameRefPolicyResolve
 */
export enum ApplicationSnapshotSpecForProviderApplicationNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicyResolution
 */
export enum ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicyResolve
 */
export enum ApplicationSnapshotSpecForProviderApplicationNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApplicationSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

