// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A ProviderConfig configures the AWS provider.
 *
 * @schema ProviderConfig
 */
export class ProviderConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'aws.upbound.io/v1beta1',
    kind: 'ProviderConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ProviderConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderConfigProps): any {
    return {
      ...ProviderConfig.GVK,
      ...toJson_ProviderConfigProps(props),
    };
  }

  /**
   * Defines a "ProviderConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderConfigProps) {
    super(scope, id, {
      ...ProviderConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderConfig.GVK,
      ...toJson_ProviderConfigProps(resolved),
    };
  }
}

/**
 * A ProviderConfig configures the AWS provider.
 *
 * @schema ProviderConfig
 */
export interface ProviderConfigProps {
  /**
   * @schema ProviderConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ProviderConfigSpec defines the desired state of a ProviderConfig.
   *
   * @schema ProviderConfig#spec
   */
  readonly spec: ProviderConfigSpec;

}

/**
 * Converts an object of type 'ProviderConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigProps(obj: ProviderConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProviderConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ProviderConfigSpec defines the desired state of a ProviderConfig.
 *
 * @schema ProviderConfigSpec
 */
export interface ProviderConfigSpec {
  /**
   * AssumeRoleChain defines the options for assuming an IAM role
   *
   * @schema ProviderConfigSpec#assumeRoleChain
   */
  readonly assumeRoleChain?: ProviderConfigSpecAssumeRoleChain[];

  /**
   * Credentials required to authenticate to this provider.
   *
   * @schema ProviderConfigSpec#credentials
   */
  readonly credentials: ProviderConfigSpecCredentials;

  /**
   * Endpoint is where you can override the default endpoint configuration of AWS calls made by the provider.
   *
   * @schema ProviderConfigSpec#endpoint
   */
  readonly endpoint?: ProviderConfigSpecEndpoint;

  /**
   * Whether to enable the request to use path-style addressing, i.e., https://s3.amazonaws.com/BUCKET/KEY.
   *
   * @schema ProviderConfigSpec#s3_use_path_style
   */
  readonly s3UsePathStyle?: boolean;

  /**
   * Whether to skip credentials validation via the STS API. This can be useful for testing and for AWS API implementations that do not have STS available.
   *
   * @schema ProviderConfigSpec#skip_credentials_validation
   */
  readonly skipCredentialsValidation?: boolean;

  /**
   * Whether to skip the AWS Metadata API check Useful for AWS API implementations that do not have a metadata API endpoint.
   *
   * @schema ProviderConfigSpec#skip_metadata_api_check
   */
  readonly skipMetadataApiCheck?: boolean;

  /**
   * Whether to skip requesting the account ID. Useful for AWS API implementations that do not have the IAM, STS API, or metadata API
   *
   * @schema ProviderConfigSpec#skip_requesting_account_id
   */
  readonly skipRequestingAccountId?: boolean;

}

/**
 * Converts an object of type 'ProviderConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpec(obj: ProviderConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'assumeRoleChain': obj.assumeRoleChain?.map(y => toJson_ProviderConfigSpecAssumeRoleChain(y)),
    'credentials': toJson_ProviderConfigSpecCredentials(obj.credentials),
    'endpoint': toJson_ProviderConfigSpecEndpoint(obj.endpoint),
    's3_use_path_style': obj.s3UsePathStyle,
    'skip_credentials_validation': obj.skipCredentialsValidation,
    'skip_metadata_api_check': obj.skipMetadataApiCheck,
    'skip_requesting_account_id': obj.skipRequestingAccountId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AssumeRoleOptions define the options for assuming an IAM Role Fields are similar to the STS AssumeRoleOptions in the AWS SDK
 *
 * @schema ProviderConfigSpecAssumeRoleChain
 */
export interface ProviderConfigSpecAssumeRoleChain {
  /**
   * ExternalID is the external ID used when assuming role.
   *
   * @schema ProviderConfigSpecAssumeRoleChain#externalID
   */
  readonly externalId?: string;

  /**
   * AssumeRoleARN to assume with provider credentials
   *
   * @schema ProviderConfigSpecAssumeRoleChain#roleARN
   */
  readonly roleArn?: string;

  /**
   * Tags is list of session tags that you want to pass. Each session tag consists of a key name and an associated value. For more information about session tags, see Tagging STS Sessions (https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html).
   *
   * @schema ProviderConfigSpecAssumeRoleChain#tags
   */
  readonly tags?: ProviderConfigSpecAssumeRoleChainTags[];

  /**
   * TransitiveTagKeys is a list of keys for session tags that you want to set as transitive. If you set a tag key as transitive, the corresponding key and value passes to subsequent sessions in a role chain. For more information, see Chaining Roles with Session Tags (https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html#id_session-tags_role-chaining).
   *
   * @schema ProviderConfigSpecAssumeRoleChain#transitiveTagKeys
   */
  readonly transitiveTagKeys?: string[];

}

/**
 * Converts an object of type 'ProviderConfigSpecAssumeRoleChain' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecAssumeRoleChain(obj: ProviderConfigSpecAssumeRoleChain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalID': obj.externalId,
    'roleARN': obj.roleArn,
    'tags': obj.tags?.map(y => toJson_ProviderConfigSpecAssumeRoleChainTags(y)),
    'transitiveTagKeys': obj.transitiveTagKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Credentials required to authenticate to this provider.
 *
 * @schema ProviderConfigSpecCredentials
 */
export interface ProviderConfigSpecCredentials {
  /**
   * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#env
   */
  readonly env?: ProviderConfigSpecCredentialsEnv;

  /**
   * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#fs
   */
  readonly fs?: ProviderConfigSpecCredentialsFs;

  /**
   * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
   *
   * @schema ProviderConfigSpecCredentials#secretRef
   */
  readonly secretRef?: ProviderConfigSpecCredentialsSecretRef;

  /**
   * Source of the provider credentials.
   *
   * @schema ProviderConfigSpecCredentials#source
   */
  readonly source: ProviderConfigSpecCredentialsSource;

  /**
   * Upbound defines the options for authenticating using Upbound as an identity provider.
   *
   * @schema ProviderConfigSpecCredentials#upbound
   */
  readonly upbound?: ProviderConfigSpecCredentialsUpbound;

  /**
   * WebIdentity defines the options for assuming an IAM role with a Web Identity.
   *
   * @schema ProviderConfigSpecCredentials#webIdentity
   */
  readonly webIdentity?: ProviderConfigSpecCredentialsWebIdentity;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentials(obj: ProviderConfigSpecCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': toJson_ProviderConfigSpecCredentialsEnv(obj.env),
    'fs': toJson_ProviderConfigSpecCredentialsFs(obj.fs),
    'secretRef': toJson_ProviderConfigSpecCredentialsSecretRef(obj.secretRef),
    'source': obj.source,
    'upbound': toJson_ProviderConfigSpecCredentialsUpbound(obj.upbound),
    'webIdentity': toJson_ProviderConfigSpecCredentialsWebIdentity(obj.webIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Endpoint is where you can override the default endpoint configuration of AWS calls made by the provider.
 *
 * @schema ProviderConfigSpecEndpoint
 */
export interface ProviderConfigSpecEndpoint {
  /**
   * Specifies if the endpoint's hostname can be modified by the SDK's API client.
   * If the hostname is mutable the SDK API clients may modify any part of the hostname based on the requirements of the API, (e.g. adding, or removing content in the hostname). Such as, Amazon S3 API client prefixing "bucketname" to the hostname, or changing the hostname service name component from "s3." to "s3-accesspoint.dualstack." for the dualstack endpoint of an S3 Accesspoint resource.
   * Care should be taken when providing a custom endpoint for an API. If the endpoint hostname is mutable, and the client cannot modify the endpoint correctly, the operation call will most likely fail, or have undefined behavior.
   * If hostname is immutable, the SDK API clients will not modify the hostname of the URL. This may cause the API client not to function correctly if the API requires the operation specific hostname values to be used by the client.
   * This flag does not modify the API client's behavior if this endpoint will be used instead of Endpoint Discovery, or if the endpoint will be used to perform Endpoint Discovery. That behavior is configured via the API Client's Options. Note that this is effective only for resources that use AWS SDK v2.
   *
   * @schema ProviderConfigSpecEndpoint#hostnameImmutable
   */
  readonly hostnameImmutable?: boolean;

  /**
   * The AWS partition the endpoint belongs to.
   *
   * @schema ProviderConfigSpecEndpoint#partitionId
   */
  readonly partitionId?: string;

  /**
   * Specifies the list of services you want endpoint to be used for
   *
   * @schema ProviderConfigSpecEndpoint#services
   */
  readonly services?: string[];

  /**
   * The signing method that should be used for signing the requests to the endpoint.
   *
   * @schema ProviderConfigSpecEndpoint#signingMethod
   */
  readonly signingMethod?: string;

  /**
   * The service name that should be used for signing the requests to the endpoint.
   *
   * @schema ProviderConfigSpecEndpoint#signingName
   */
  readonly signingName?: string;

  /**
   * The region that should be used for signing the request to the endpoint. For IAM, which doesn't have any region, us-east-1 is used to sign the requests, which is the only signing region of IAM.
   *
   * @schema ProviderConfigSpecEndpoint#signingRegion
   */
  readonly signingRegion?: string;

  /**
   * The source of the Endpoint. By default, this will be ServiceMetadata. When providing a custom endpoint, you should set the source as Custom. If source is not provided when providing a custom endpoint, the SDK may not perform required host mutations correctly. Source should be used along with HostnameImmutable property as per the usage requirement. Note that this is effective only for resources that use AWS SDK v2.
   *
   * @schema ProviderConfigSpecEndpoint#source
   */
  readonly source?: ProviderConfigSpecEndpointSource;

  /**
   * URL lets you configure the endpoint URL to be used in SDK calls.
   *
   * @schema ProviderConfigSpecEndpoint#url
   */
  readonly url: ProviderConfigSpecEndpointUrl;

}

/**
 * Converts an object of type 'ProviderConfigSpecEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecEndpoint(obj: ProviderConfigSpecEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnameImmutable': obj.hostnameImmutable,
    'partitionId': obj.partitionId,
    'services': obj.services?.map(y => y),
    'signingMethod': obj.signingMethod,
    'signingName': obj.signingName,
    'signingRegion': obj.signingRegion,
    'source': obj.source,
    'url': toJson_ProviderConfigSpecEndpointUrl(obj.url),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tag is session tag that can be used to assume an IAM Role
 *
 * @schema ProviderConfigSpecAssumeRoleChainTags
 */
export interface ProviderConfigSpecAssumeRoleChainTags {
  /**
   * Name of the tag. Key is a required field
   *
   * @schema ProviderConfigSpecAssumeRoleChainTags#key
   */
  readonly key: string;

  /**
   * Value of the tag. Value is a required field
   *
   * @schema ProviderConfigSpecAssumeRoleChainTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecAssumeRoleChainTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecAssumeRoleChainTags(obj: ProviderConfigSpecAssumeRoleChainTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsEnv
 */
export interface ProviderConfigSpecCredentialsEnv {
  /**
   * Name is the name of an environment variable.
   *
   * @schema ProviderConfigSpecCredentialsEnv#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsEnv(obj: ProviderConfigSpecCredentialsEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsFs
 */
export interface ProviderConfigSpecCredentialsFs {
  /**
   * Path is a filesystem path.
   *
   * @schema ProviderConfigSpecCredentialsFs#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsFs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsFs(obj: ProviderConfigSpecCredentialsFs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
 *
 * @schema ProviderConfigSpecCredentialsSecretRef
 */
export interface ProviderConfigSpecCredentialsSecretRef {
  /**
   * The key to select.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProviderConfigSpecCredentialsSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsSecretRef(obj: ProviderConfigSpecCredentialsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source of the provider credentials.
 *
 * @schema ProviderConfigSpecCredentialsSource
 */
export enum ProviderConfigSpecCredentialsSource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
  /** IRSA */
  IRSA = "IRSA",
  /** WebIdentity */
  WEB_IDENTITY = "WebIdentity",
  /** Upbound */
  UPBOUND = "Upbound",
}

/**
 * Upbound defines the options for authenticating using Upbound as an identity provider.
 *
 * @schema ProviderConfigSpecCredentialsUpbound
 */
export interface ProviderConfigSpecCredentialsUpbound {
  /**
   * WebIdentity defines the options for assuming an IAM role with a Web Identity.
   *
   * @schema ProviderConfigSpecCredentialsUpbound#webIdentity
   */
  readonly webIdentity?: ProviderConfigSpecCredentialsUpboundWebIdentity;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsUpbound' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsUpbound(obj: ProviderConfigSpecCredentialsUpbound | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'webIdentity': toJson_ProviderConfigSpecCredentialsUpboundWebIdentity(obj.webIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebIdentity defines the options for assuming an IAM role with a Web Identity.
 *
 * @schema ProviderConfigSpecCredentialsWebIdentity
 */
export interface ProviderConfigSpecCredentialsWebIdentity {
  /**
   * AssumeRoleARN to assume with provider credentials
   *
   * @schema ProviderConfigSpecCredentialsWebIdentity#roleARN
   */
  readonly roleArn?: string;

  /**
   * RoleSessionName is the session name, if you wish to uniquely identify this session.
   *
   * @schema ProviderConfigSpecCredentialsWebIdentity#roleSessionName
   */
  readonly roleSessionName?: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsWebIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsWebIdentity(obj: ProviderConfigSpecCredentialsWebIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleARN': obj.roleArn,
    'roleSessionName': obj.roleSessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The source of the Endpoint. By default, this will be ServiceMetadata. When providing a custom endpoint, you should set the source as Custom. If source is not provided when providing a custom endpoint, the SDK may not perform required host mutations correctly. Source should be used along with HostnameImmutable property as per the usage requirement. Note that this is effective only for resources that use AWS SDK v2.
 *
 * @schema ProviderConfigSpecEndpointSource
 */
export enum ProviderConfigSpecEndpointSource {
  /** ServiceMetadata */
  SERVICE_METADATA = "ServiceMetadata",
  /** Custom */
  CUSTOM = "Custom",
}

/**
 * URL lets you configure the endpoint URL to be used in SDK calls.
 *
 * @schema ProviderConfigSpecEndpointUrl
 */
export interface ProviderConfigSpecEndpointUrl {
  /**
   * Dynamic lets you configure the behavior of endpoint URL resolver.
   *
   * @schema ProviderConfigSpecEndpointUrl#dynamic
   */
  readonly dynamic?: ProviderConfigSpecEndpointUrlDynamic;

  /**
   * Static is the full URL you'd like the AWS SDK to use. Recommended for using tools like localstack where a single host is exposed for all services and regions.
   *
   * @schema ProviderConfigSpecEndpointUrl#static
   */
  readonly static?: string;

  /**
   * You can provide a static URL that will be used regardless of the service and region by choosing Static type. Alternatively, you can provide configuration for dynamically resolving the URL with the config you provide once you set the type as Dynamic.
   *
   * @schema ProviderConfigSpecEndpointUrl#type
   */
  readonly type: ProviderConfigSpecEndpointUrlType;

}

/**
 * Converts an object of type 'ProviderConfigSpecEndpointUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecEndpointUrl(obj: ProviderConfigSpecEndpointUrl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dynamic': toJson_ProviderConfigSpecEndpointUrlDynamic(obj.dynamic),
    'static': obj.static,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebIdentity defines the options for assuming an IAM role with a Web Identity.
 *
 * @schema ProviderConfigSpecCredentialsUpboundWebIdentity
 */
export interface ProviderConfigSpecCredentialsUpboundWebIdentity {
  /**
   * AssumeRoleARN to assume with provider credentials
   *
   * @schema ProviderConfigSpecCredentialsUpboundWebIdentity#roleARN
   */
  readonly roleArn?: string;

  /**
   * RoleSessionName is the session name, if you wish to uniquely identify this session.
   *
   * @schema ProviderConfigSpecCredentialsUpboundWebIdentity#roleSessionName
   */
  readonly roleSessionName?: string;

}

/**
 * Converts an object of type 'ProviderConfigSpecCredentialsUpboundWebIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecCredentialsUpboundWebIdentity(obj: ProviderConfigSpecCredentialsUpboundWebIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleARN': obj.roleArn,
    'roleSessionName': obj.roleSessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Dynamic lets you configure the behavior of endpoint URL resolver.
 *
 * @schema ProviderConfigSpecEndpointUrlDynamic
 */
export interface ProviderConfigSpecEndpointUrlDynamic {
  /**
   * Host is the address of the main host that the resolver will use to prepend protocol, service and region configurations. For example, the final URL for EC2 in us-east-1 looks like https://ec2.us-east-1.amazonaws.com You would need to use "amazonaws.com" as Host and "https" as protocol to have the resolver construct it.
   *
   * @schema ProviderConfigSpecEndpointUrlDynamic#host
   */
  readonly host: string;

  /**
   * Protocol is the HTTP protocol that will be used in the URL. Currently, only http and https are supported.
   *
   * @schema ProviderConfigSpecEndpointUrlDynamic#protocol
   */
  readonly protocol: ProviderConfigSpecEndpointUrlDynamicProtocol;

}

/**
 * Converts an object of type 'ProviderConfigSpecEndpointUrlDynamic' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigSpecEndpointUrlDynamic(obj: ProviderConfigSpecEndpointUrlDynamic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * You can provide a static URL that will be used regardless of the service and region by choosing Static type. Alternatively, you can provide configuration for dynamically resolving the URL with the config you provide once you set the type as Dynamic.
 *
 * @schema ProviderConfigSpecEndpointUrlType
 */
export enum ProviderConfigSpecEndpointUrlType {
  /** Static */
  STATIC = "Static",
  /** Dynamic */
  DYNAMIC = "Dynamic",
}

/**
 * Protocol is the HTTP protocol that will be used in the URL. Currently, only http and https are supported.
 *
 * @schema ProviderConfigSpecEndpointUrlDynamicProtocol
 */
export enum ProviderConfigSpecEndpointUrlDynamicProtocol {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}


/**
 * A ProviderConfigUsage indicates that a resource is using a ProviderConfig.
 *
 * @schema ProviderConfigUsage
 */
export class ProviderConfigUsage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderConfigUsage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'aws.upbound.io/v1beta1',
    kind: 'ProviderConfigUsage',
  }

  /**
   * Renders a Kubernetes manifest for "ProviderConfigUsage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderConfigUsageProps): any {
    return {
      ...ProviderConfigUsage.GVK,
      ...toJson_ProviderConfigUsageProps(props),
    };
  }

  /**
   * Defines a "ProviderConfigUsage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderConfigUsageProps) {
    super(scope, id, {
      ...ProviderConfigUsage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderConfigUsage.GVK,
      ...toJson_ProviderConfigUsageProps(resolved),
    };
  }
}

/**
 * A ProviderConfigUsage indicates that a resource is using a ProviderConfig.
 *
 * @schema ProviderConfigUsage
 */
export interface ProviderConfigUsageProps {
  /**
   * @schema ProviderConfigUsage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProviderConfigReference to the provider config being used.
   *
   * @schema ProviderConfigUsage#providerConfigRef
   */
  readonly providerConfigRef: ProviderConfigUsageProviderConfigRef;

  /**
   * ResourceReference to the managed resource using the provider config.
   *
   * @schema ProviderConfigUsage#resourceRef
   */
  readonly resourceRef: ProviderConfigUsageResourceRef;

}

/**
 * Converts an object of type 'ProviderConfigUsageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageProps(obj: ProviderConfigUsageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'providerConfigRef': toJson_ProviderConfigUsageProviderConfigRef(obj.providerConfigRef),
    'resourceRef': toJson_ProviderConfigUsageResourceRef(obj.resourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference to the provider config being used.
 *
 * @schema ProviderConfigUsageProviderConfigRef
 */
export interface ProviderConfigUsageProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProviderConfigUsageProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProviderConfigUsageProviderConfigRef#policy
   */
  readonly policy?: ProviderConfigUsageProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProviderConfigUsageProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageProviderConfigRef(obj: ProviderConfigUsageProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProviderConfigUsageProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceReference to the managed resource using the provider config.
 *
 * @schema ProviderConfigUsageResourceRef
 */
export interface ProviderConfigUsageResourceRef {
  /**
   * APIVersion of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#kind
   */
  readonly kind: string;

  /**
   * Name of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#name
   */
  readonly name: string;

  /**
   * UID of the referenced object.
   *
   * @schema ProviderConfigUsageResourceRef#uid
   */
  readonly uid?: string;

}

/**
 * Converts an object of type 'ProviderConfigUsageResourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageResourceRef(obj: ProviderConfigUsageResourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProviderConfigUsageProviderConfigRefPolicy
 */
export interface ProviderConfigUsageProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProviderConfigUsageProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProviderConfigUsageProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProviderConfigUsageProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProviderConfigUsageProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProviderConfigUsageProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderConfigUsageProviderConfigRefPolicy(obj: ProviderConfigUsageProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProviderConfigUsageProviderConfigRefPolicyResolution
 */
export enum ProviderConfigUsageProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProviderConfigUsageProviderConfigRefPolicyResolve
 */
export enum ProviderConfigUsageProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * A StoreConfig configures how AWS controller should store connection details.
 *
 * @schema StoreConfig
 */
export class StoreConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StoreConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'aws.upbound.io/v1alpha1',
    kind: 'StoreConfig',
  }

  /**
   * Renders a Kubernetes manifest for "StoreConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StoreConfigProps): any {
    return {
      ...StoreConfig.GVK,
      ...toJson_StoreConfigProps(props),
    };
  }

  /**
   * Defines a "StoreConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StoreConfigProps) {
    super(scope, id, {
      ...StoreConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StoreConfig.GVK,
      ...toJson_StoreConfigProps(resolved),
    };
  }
}

/**
 * A StoreConfig configures how AWS controller should store connection details.
 *
 * @schema StoreConfig
 */
export interface StoreConfigProps {
  /**
   * @schema StoreConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A StoreConfigSpec defines the desired state of a ProviderConfig.
   *
   * @schema StoreConfig#spec
   */
  readonly spec: StoreConfigSpec;

}

/**
 * Converts an object of type 'StoreConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigProps(obj: StoreConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StoreConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A StoreConfigSpec defines the desired state of a ProviderConfig.
 *
 * @schema StoreConfigSpec
 */
export interface StoreConfigSpec {
  /**
   * DefaultScope used for scoping secrets for "cluster-scoped" resources. If store type is "Kubernetes", this would mean the default namespace to store connection secrets for cluster scoped resources. In case of "Vault", this would be used as the default parent path. Typically, should be set as Crossplane installation namespace.
   *
   * @schema StoreConfigSpec#defaultScope
   */
  readonly defaultScope: string;

  /**
   * Kubernetes configures a Kubernetes secret store. If the "type" is "Kubernetes" but no config provided, in cluster config will be used.
   *
   * @schema StoreConfigSpec#kubernetes
   */
  readonly kubernetes?: StoreConfigSpecKubernetes;

  /**
   * Plugin configures External secret store as a plugin.
   *
   * @schema StoreConfigSpec#plugin
   */
  readonly plugin?: StoreConfigSpecPlugin;

  /**
   * Type configures which secret store to be used. Only the configuration block for this store will be used and others will be ignored if provided. Default is Kubernetes.
   *
   * @default Kubernetes.
   * @schema StoreConfigSpec#type
   */
  readonly type?: StoreConfigSpecType;

  /**
   * Vault configures a Vault secret store. Deprecated: This API is scheduled to be removed in a future release. Vault should be used as a plugin going forward. See https://github.com/crossplane-contrib/ess-plugin-vault for more information.
   *
   * @schema StoreConfigSpec#vault
   */
  readonly vault?: StoreConfigSpecVault;

}

/**
 * Converts an object of type 'StoreConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpec(obj: StoreConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultScope': obj.defaultScope,
    'kubernetes': toJson_StoreConfigSpecKubernetes(obj.kubernetes),
    'plugin': toJson_StoreConfigSpecPlugin(obj.plugin),
    'type': obj.type,
    'vault': toJson_StoreConfigSpecVault(obj.vault),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kubernetes configures a Kubernetes secret store. If the "type" is "Kubernetes" but no config provided, in cluster config will be used.
 *
 * @schema StoreConfigSpecKubernetes
 */
export interface StoreConfigSpecKubernetes {
  /**
   * Credentials used to connect to the Kubernetes API.
   *
   * @schema StoreConfigSpecKubernetes#auth
   */
  readonly auth: StoreConfigSpecKubernetesAuth;

}

/**
 * Converts an object of type 'StoreConfigSpecKubernetes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecKubernetes(obj: StoreConfigSpecKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_StoreConfigSpecKubernetesAuth(obj.auth),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Plugin configures External secret store as a plugin.
 *
 * @schema StoreConfigSpecPlugin
 */
export interface StoreConfigSpecPlugin {
  /**
   * ConfigRef contains store config reference info.
   *
   * @schema StoreConfigSpecPlugin#configRef
   */
  readonly configRef?: StoreConfigSpecPluginConfigRef;

  /**
   * Endpoint is the endpoint of the gRPC server.
   *
   * @schema StoreConfigSpecPlugin#endpoint
   */
  readonly endpoint?: string;

}

/**
 * Converts an object of type 'StoreConfigSpecPlugin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecPlugin(obj: StoreConfigSpecPlugin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StoreConfigSpecPluginConfigRef(obj.configRef),
    'endpoint': obj.endpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type configures which secret store to be used. Only the configuration block for this store will be used and others will be ignored if provided. Default is Kubernetes.
 *
 * @default Kubernetes.
 * @schema StoreConfigSpecType
 */
export enum StoreConfigSpecType {
  /** Kubernetes */
  KUBERNETES = "Kubernetes",
  /** Vault */
  VAULT = "Vault",
  /** Plugin */
  PLUGIN = "Plugin",
}

/**
 * Vault configures a Vault secret store. Deprecated: This API is scheduled to be removed in a future release. Vault should be used as a plugin going forward. See https://github.com/crossplane-contrib/ess-plugin-vault for more information.
 *
 * @schema StoreConfigSpecVault
 */
export interface StoreConfigSpecVault {
  /**
   * Auth configures an authentication method for Vault.
   *
   * @schema StoreConfigSpecVault#auth
   */
  readonly auth: StoreConfigSpecVaultAuth;

  /**
   * CABundle configures CA bundle for Vault Server.
   *
   * @schema StoreConfigSpecVault#caBundle
   */
  readonly caBundle?: StoreConfigSpecVaultCaBundle;

  /**
   * MountPath is the mount path of the KV secrets engine.
   *
   * @schema StoreConfigSpecVault#mountPath
   */
  readonly mountPath: string;

  /**
   * Server is the url of the Vault server, e.g. "https://vault.acme.org"
   *
   * @schema StoreConfigSpecVault#server
   */
  readonly server: string;

  /**
   * Version of the KV Secrets engine of Vault. https://www.vaultproject.io/docs/secrets/kv
   *
   * @schema StoreConfigSpecVault#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'StoreConfigSpecVault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecVault(obj: StoreConfigSpecVault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_StoreConfigSpecVaultAuth(obj.auth),
    'caBundle': toJson_StoreConfigSpecVaultCaBundle(obj.caBundle),
    'mountPath': obj.mountPath,
    'server': obj.server,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Credentials used to connect to the Kubernetes API.
 *
 * @schema StoreConfigSpecKubernetesAuth
 */
export interface StoreConfigSpecKubernetesAuth {
  /**
   * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
   *
   * @schema StoreConfigSpecKubernetesAuth#env
   */
  readonly env?: StoreConfigSpecKubernetesAuthEnv;

  /**
   * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
   *
   * @schema StoreConfigSpecKubernetesAuth#fs
   */
  readonly fs?: StoreConfigSpecKubernetesAuthFs;

  /**
   * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
   *
   * @schema StoreConfigSpecKubernetesAuth#secretRef
   */
  readonly secretRef?: StoreConfigSpecKubernetesAuthSecretRef;

  /**
   * Source of the credentials.
   *
   * @schema StoreConfigSpecKubernetesAuth#source
   */
  readonly source: StoreConfigSpecKubernetesAuthSource;

}

/**
 * Converts an object of type 'StoreConfigSpecKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecKubernetesAuth(obj: StoreConfigSpecKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': toJson_StoreConfigSpecKubernetesAuthEnv(obj.env),
    'fs': toJson_StoreConfigSpecKubernetesAuthFs(obj.fs),
    'secretRef': toJson_StoreConfigSpecKubernetesAuthSecretRef(obj.secretRef),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigRef contains store config reference info.
 *
 * @schema StoreConfigSpecPluginConfigRef
 */
export interface StoreConfigSpecPluginConfigRef {
  /**
   * APIVersion of the referenced config.
   *
   * @schema StoreConfigSpecPluginConfigRef#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Kind of the referenced config.
   *
   * @schema StoreConfigSpecPluginConfigRef#kind
   */
  readonly kind: string;

  /**
   * Name of the referenced config.
   *
   * @schema StoreConfigSpecPluginConfigRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StoreConfigSpecPluginConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecPluginConfigRef(obj: StoreConfigSpecPluginConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Auth configures an authentication method for Vault.
 *
 * @schema StoreConfigSpecVaultAuth
 */
export interface StoreConfigSpecVaultAuth {
  /**
   * Method configures which auth method will be used.
   *
   * @schema StoreConfigSpecVaultAuth#method
   */
  readonly method: string;

  /**
   * Token configures Token Auth for Vault.
   *
   * @schema StoreConfigSpecVaultAuth#token
   */
  readonly token?: StoreConfigSpecVaultAuthToken;

}

/**
 * Converts an object of type 'StoreConfigSpecVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecVaultAuth(obj: StoreConfigSpecVaultAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'method': obj.method,
    'token': toJson_StoreConfigSpecVaultAuthToken(obj.token),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CABundle configures CA bundle for Vault Server.
 *
 * @schema StoreConfigSpecVaultCaBundle
 */
export interface StoreConfigSpecVaultCaBundle {
  /**
   * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
   *
   * @schema StoreConfigSpecVaultCaBundle#env
   */
  readonly env?: StoreConfigSpecVaultCaBundleEnv;

  /**
   * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
   *
   * @schema StoreConfigSpecVaultCaBundle#fs
   */
  readonly fs?: StoreConfigSpecVaultCaBundleFs;

  /**
   * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
   *
   * @schema StoreConfigSpecVaultCaBundle#secretRef
   */
  readonly secretRef?: StoreConfigSpecVaultCaBundleSecretRef;

  /**
   * Source of the credentials.
   *
   * @schema StoreConfigSpecVaultCaBundle#source
   */
  readonly source: StoreConfigSpecVaultCaBundleSource;

}

/**
 * Converts an object of type 'StoreConfigSpecVaultCaBundle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecVaultCaBundle(obj: StoreConfigSpecVaultCaBundle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': toJson_StoreConfigSpecVaultCaBundleEnv(obj.env),
    'fs': toJson_StoreConfigSpecVaultCaBundleFs(obj.fs),
    'secretRef': toJson_StoreConfigSpecVaultCaBundleSecretRef(obj.secretRef),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
 *
 * @schema StoreConfigSpecKubernetesAuthEnv
 */
export interface StoreConfigSpecKubernetesAuthEnv {
  /**
   * Name is the name of an environment variable.
   *
   * @schema StoreConfigSpecKubernetesAuthEnv#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StoreConfigSpecKubernetesAuthEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecKubernetesAuthEnv(obj: StoreConfigSpecKubernetesAuthEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
 *
 * @schema StoreConfigSpecKubernetesAuthFs
 */
export interface StoreConfigSpecKubernetesAuthFs {
  /**
   * Path is a filesystem path.
   *
   * @schema StoreConfigSpecKubernetesAuthFs#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'StoreConfigSpecKubernetesAuthFs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecKubernetesAuthFs(obj: StoreConfigSpecKubernetesAuthFs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
 *
 * @schema StoreConfigSpecKubernetesAuthSecretRef
 */
export interface StoreConfigSpecKubernetesAuthSecretRef {
  /**
   * The key to select.
   *
   * @schema StoreConfigSpecKubernetesAuthSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema StoreConfigSpecKubernetesAuthSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StoreConfigSpecKubernetesAuthSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StoreConfigSpecKubernetesAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecKubernetesAuthSecretRef(obj: StoreConfigSpecKubernetesAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source of the credentials.
 *
 * @schema StoreConfigSpecKubernetesAuthSource
 */
export enum StoreConfigSpecKubernetesAuthSource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** Filesystem */
  FILESYSTEM = "Filesystem",
}

/**
 * Token configures Token Auth for Vault.
 *
 * @schema StoreConfigSpecVaultAuthToken
 */
export interface StoreConfigSpecVaultAuthToken {
  /**
   * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
   *
   * @schema StoreConfigSpecVaultAuthToken#env
   */
  readonly env?: StoreConfigSpecVaultAuthTokenEnv;

  /**
   * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
   *
   * @schema StoreConfigSpecVaultAuthToken#fs
   */
  readonly fs?: StoreConfigSpecVaultAuthTokenFs;

  /**
   * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
   *
   * @schema StoreConfigSpecVaultAuthToken#secretRef
   */
  readonly secretRef?: StoreConfigSpecVaultAuthTokenSecretRef;

  /**
   * Source of the credentials.
   *
   * @schema StoreConfigSpecVaultAuthToken#source
   */
  readonly source: StoreConfigSpecVaultAuthTokenSource;

}

/**
 * Converts an object of type 'StoreConfigSpecVaultAuthToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecVaultAuthToken(obj: StoreConfigSpecVaultAuthToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': toJson_StoreConfigSpecVaultAuthTokenEnv(obj.env),
    'fs': toJson_StoreConfigSpecVaultAuthTokenFs(obj.fs),
    'secretRef': toJson_StoreConfigSpecVaultAuthTokenSecretRef(obj.secretRef),
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
 *
 * @schema StoreConfigSpecVaultCaBundleEnv
 */
export interface StoreConfigSpecVaultCaBundleEnv {
  /**
   * Name is the name of an environment variable.
   *
   * @schema StoreConfigSpecVaultCaBundleEnv#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StoreConfigSpecVaultCaBundleEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecVaultCaBundleEnv(obj: StoreConfigSpecVaultCaBundleEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
 *
 * @schema StoreConfigSpecVaultCaBundleFs
 */
export interface StoreConfigSpecVaultCaBundleFs {
  /**
   * Path is a filesystem path.
   *
   * @schema StoreConfigSpecVaultCaBundleFs#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'StoreConfigSpecVaultCaBundleFs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecVaultCaBundleFs(obj: StoreConfigSpecVaultCaBundleFs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
 *
 * @schema StoreConfigSpecVaultCaBundleSecretRef
 */
export interface StoreConfigSpecVaultCaBundleSecretRef {
  /**
   * The key to select.
   *
   * @schema StoreConfigSpecVaultCaBundleSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema StoreConfigSpecVaultCaBundleSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StoreConfigSpecVaultCaBundleSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StoreConfigSpecVaultCaBundleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecVaultCaBundleSecretRef(obj: StoreConfigSpecVaultCaBundleSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source of the credentials.
 *
 * @schema StoreConfigSpecVaultCaBundleSource
 */
export enum StoreConfigSpecVaultCaBundleSource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** Filesystem */
  FILESYSTEM = "Filesystem",
}

/**
 * Env is a reference to an environment variable that contains credentials that must be used to connect to the provider.
 *
 * @schema StoreConfigSpecVaultAuthTokenEnv
 */
export interface StoreConfigSpecVaultAuthTokenEnv {
  /**
   * Name is the name of an environment variable.
   *
   * @schema StoreConfigSpecVaultAuthTokenEnv#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StoreConfigSpecVaultAuthTokenEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecVaultAuthTokenEnv(obj: StoreConfigSpecVaultAuthTokenEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fs is a reference to a filesystem location that contains credentials that must be used to connect to the provider.
 *
 * @schema StoreConfigSpecVaultAuthTokenFs
 */
export interface StoreConfigSpecVaultAuthTokenFs {
  /**
   * Path is a filesystem path.
   *
   * @schema StoreConfigSpecVaultAuthTokenFs#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'StoreConfigSpecVaultAuthTokenFs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecVaultAuthTokenFs(obj: StoreConfigSpecVaultAuthTokenFs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A SecretRef is a reference to a secret key that contains the credentials that must be used to connect to the provider.
 *
 * @schema StoreConfigSpecVaultAuthTokenSecretRef
 */
export interface StoreConfigSpecVaultAuthTokenSecretRef {
  /**
   * The key to select.
   *
   * @schema StoreConfigSpecVaultAuthTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema StoreConfigSpecVaultAuthTokenSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StoreConfigSpecVaultAuthTokenSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StoreConfigSpecVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StoreConfigSpecVaultAuthTokenSecretRef(obj: StoreConfigSpecVaultAuthTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source of the credentials.
 *
 * @schema StoreConfigSpecVaultAuthTokenSource
 */
export enum StoreConfigSpecVaultAuthTokenSource {
  /** None */
  NONE = "None",
  /** Secret */
  SECRET = "Secret",
  /** Environment */
  ENVIRONMENT = "Environment",
  /** Filesystem */
  FILESYSTEM = "Filesystem",
}

