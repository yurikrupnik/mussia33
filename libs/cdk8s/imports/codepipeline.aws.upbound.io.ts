// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Codepipeline is the Schema for the Codepipelines API. Provides a CodePipeline
 *
 * @schema Codepipeline
 */
export class Codepipeline extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Codepipeline"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'codepipeline.aws.upbound.io/v1beta1',
    kind: 'Codepipeline',
  }

  /**
   * Renders a Kubernetes manifest for "Codepipeline".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CodepipelineProps): any {
    return {
      ...Codepipeline.GVK,
      ...toJson_CodepipelineProps(props),
    };
  }

  /**
   * Defines a "Codepipeline" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CodepipelineProps) {
    super(scope, id, {
      ...Codepipeline.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Codepipeline.GVK,
      ...toJson_CodepipelineProps(resolved),
    };
  }
}

/**
 * Codepipeline is the Schema for the Codepipelines API. Provides a CodePipeline
 *
 * @schema Codepipeline
 */
export interface CodepipelineProps {
  /**
   * @schema Codepipeline#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CodepipelineSpec defines the desired state of Codepipeline
   *
   * @schema Codepipeline#spec
   */
  readonly spec: CodepipelineSpec;

}

/**
 * Converts an object of type 'CodepipelineProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineProps(obj: CodepipelineProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CodepipelineSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CodepipelineSpec defines the desired state of Codepipeline
 *
 * @schema CodepipelineSpec
 */
export interface CodepipelineSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema CodepipelineSpec#deletionPolicy
   */
  readonly deletionPolicy?: CodepipelineSpecDeletionPolicy;

  /**
   * @schema CodepipelineSpec#forProvider
   */
  readonly forProvider: CodepipelineSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CodepipelineSpec#providerConfigRef
   */
  readonly providerConfigRef?: CodepipelineSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CodepipelineSpec#providerRef
   */
  readonly providerRef?: CodepipelineSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CodepipelineSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CodepipelineSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CodepipelineSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CodepipelineSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CodepipelineSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpec(obj: CodepipelineSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CodepipelineSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_CodepipelineSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CodepipelineSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CodepipelineSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CodepipelineSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema CodepipelineSpecDeletionPolicy
 */
export enum CodepipelineSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CodepipelineSpecForProvider
 */
export interface CodepipelineSpecForProvider {
  /**
   * One or more artifact_store blocks. Artifact stores are documented below.
   *
   * @schema CodepipelineSpecForProvider#artifactStore
   */
  readonly artifactStore: CodepipelineSpecForProviderArtifactStore[];

  /**
   * The region in which to run the action. Region is the region you'd like your resource to be created in.
   *
   * @schema CodepipelineSpecForProvider#region
   */
  readonly region: string;

  /**
   * A service role Amazon Resource Name (ARN) that grants AWS CodePipeline permission to make calls to AWS services on your behalf.
   *
   * @schema CodepipelineSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema CodepipelineSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: CodepipelineSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema CodepipelineSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: CodepipelineSpecForProviderRoleArnSelector;

  /**
   * (Minimum of at least two stage blocks is required) A stage block. Stages are documented below.
   *
   * @schema CodepipelineSpecForProvider#stage
   */
  readonly stage: CodepipelineSpecForProviderStage[];

  /**
   * Key-value map of resource tags.
   *
   * @schema CodepipelineSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CodepipelineSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProvider(obj: CodepipelineSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'artifactStore': obj.artifactStore?.map(y => toJson_CodepipelineSpecForProviderArtifactStore(y)),
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_CodepipelineSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_CodepipelineSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'stage': obj.stage?.map(y => toJson_CodepipelineSpecForProviderStage(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CodepipelineSpecProviderConfigRef
 */
export interface CodepipelineSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodepipelineSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodepipelineSpecProviderConfigRef#policy
   */
  readonly policy?: CodepipelineSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecProviderConfigRef(obj: CodepipelineSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodepipelineSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CodepipelineSpecProviderRef
 */
export interface CodepipelineSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodepipelineSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodepipelineSpecProviderRef#policy
   */
  readonly policy?: CodepipelineSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecProviderRef(obj: CodepipelineSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodepipelineSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsTo
 */
export interface CodepipelineSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CodepipelineSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CodepipelineSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CodepipelineSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecPublishConnectionDetailsTo(obj: CodepipelineSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CodepipelineSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CodepipelineSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CodepipelineSpecWriteConnectionSecretToRef
 */
export interface CodepipelineSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CodepipelineSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CodepipelineSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CodepipelineSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecWriteConnectionSecretToRef(obj: CodepipelineSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecForProviderArtifactStore
 */
export interface CodepipelineSpecForProviderArtifactStore {
  /**
   * The encryption key block AWS CodePipeline uses to encrypt the data in the artifact store, such as an AWS Key Management Service (AWS KMS) key. If you don't specify a key, AWS CodePipeline uses the default key for Amazon Simple Storage Service (Amazon S3). An encryption_key block is documented below.
   *
   * @schema CodepipelineSpecForProviderArtifactStore#encryptionKey
   */
  readonly encryptionKey?: CodepipelineSpecForProviderArtifactStoreEncryptionKey[];

  /**
   * The location where AWS CodePipeline stores artifacts for a pipeline; currently only S3 is supported.
   *
   * @schema CodepipelineSpecForProviderArtifactStore#location
   */
  readonly location?: string;

  /**
   * Reference to a Bucket in s3 to populate location.
   *
   * @schema CodepipelineSpecForProviderArtifactStore#locationRef
   */
  readonly locationRef?: CodepipelineSpecForProviderArtifactStoreLocationRef;

  /**
   * Selector for a Bucket in s3 to populate location.
   *
   * @schema CodepipelineSpecForProviderArtifactStore#locationSelector
   */
  readonly locationSelector?: CodepipelineSpecForProviderArtifactStoreLocationSelector;

  /**
   * The region where the artifact store is located. Required for a cross-region CodePipeline, do not provide for a single-region CodePipeline.
   *
   * @schema CodepipelineSpecForProviderArtifactStore#region
   */
  readonly region?: string;

  /**
   * The type of the artifact store, such as Amazon S3
   *
   * @schema CodepipelineSpecForProviderArtifactStore#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStore(obj: CodepipelineSpecForProviderArtifactStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionKey': obj.encryptionKey?.map(y => toJson_CodepipelineSpecForProviderArtifactStoreEncryptionKey(y)),
    'location': obj.location,
    'locationRef': toJson_CodepipelineSpecForProviderArtifactStoreLocationRef(obj.locationRef),
    'locationSelector': toJson_CodepipelineSpecForProviderArtifactStoreLocationSelector(obj.locationSelector),
    'region': obj.region,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema CodepipelineSpecForProviderRoleArnRef
 */
export interface CodepipelineSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodepipelineSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodepipelineSpecForProviderRoleArnRef#policy
   */
  readonly policy?: CodepipelineSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderRoleArnRef(obj: CodepipelineSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodepipelineSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema CodepipelineSpecForProviderRoleArnSelector
 */
export interface CodepipelineSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CodepipelineSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CodepipelineSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CodepipelineSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: CodepipelineSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderRoleArnSelector(obj: CodepipelineSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CodepipelineSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecForProviderStage
 */
export interface CodepipelineSpecForProviderStage {
  /**
   * The action(s) to include in the stage. Defined as an action block below
   *
   * @schema CodepipelineSpecForProviderStage#action
   */
  readonly action: CodepipelineSpecForProviderStageAction[];

  /**
   * The name of the stage.
   *
   * @schema CodepipelineSpecForProviderStage#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderStage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderStage(obj: CodepipelineSpecForProviderStage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_CodepipelineSpecForProviderStageAction(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodepipelineSpecProviderConfigRefPolicy
 */
export interface CodepipelineSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecProviderConfigRefPolicy(obj: CodepipelineSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodepipelineSpecProviderRefPolicy
 */
export interface CodepipelineSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecProviderRefPolicy(obj: CodepipelineSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsToConfigRef
 */
export interface CodepipelineSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecPublishConnectionDetailsToConfigRef(obj: CodepipelineSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsToMetadata
 */
export interface CodepipelineSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CodepipelineSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecPublishConnectionDetailsToMetadata(obj: CodepipelineSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecForProviderArtifactStoreEncryptionKey
 */
export interface CodepipelineSpecForProviderArtifactStoreEncryptionKey {
  /**
   * The KMS key ARN or ID
   *
   * @schema CodepipelineSpecForProviderArtifactStoreEncryptionKey#id
   */
  readonly id: string;

  /**
   * The type of key; currently only KMS is supported
   *
   * @schema CodepipelineSpecForProviderArtifactStoreEncryptionKey#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStoreEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStoreEncryptionKey(obj: CodepipelineSpecForProviderArtifactStoreEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate location.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationRef
 */
export interface CodepipelineSpecForProviderArtifactStoreLocationRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationRef#policy
   */
  readonly policy?: CodepipelineSpecForProviderArtifactStoreLocationRefPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStoreLocationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStoreLocationRef(obj: CodepipelineSpecForProviderArtifactStoreLocationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodepipelineSpecForProviderArtifactStoreLocationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate location.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationSelector
 */
export interface CodepipelineSpecForProviderArtifactStoreLocationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationSelector#policy
   */
  readonly policy?: CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStoreLocationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStoreLocationSelector(obj: CodepipelineSpecForProviderArtifactStoreLocationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodepipelineSpecForProviderRoleArnRefPolicy
 */
export interface CodepipelineSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderRoleArnRefPolicy(obj: CodepipelineSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CodepipelineSpecForProviderRoleArnSelectorPolicy
 */
export interface CodepipelineSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderRoleArnSelectorPolicy(obj: CodepipelineSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecForProviderStageAction
 */
export interface CodepipelineSpecForProviderStageAction {
  /**
   * A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Possible values are Approval, Build, Deploy, Invoke, Source and Test.
   *
   * @schema CodepipelineSpecForProviderStageAction#category
   */
  readonly category: string;

  /**
   * A map of the action declaration's configuration. Configurations options for action types and providers can be found in the Pipeline Structure Reference and Action Structure Reference documentation.
   *
   * @schema CodepipelineSpecForProviderStageAction#configuration
   */
  readonly configuration?: { [key: string]: string };

  /**
   * A list of artifact names to be worked on.
   *
   * @schema CodepipelineSpecForProviderStageAction#inputArtifacts
   */
  readonly inputArtifacts?: string[];

  /**
   * The action declaration's name.
   *
   * @schema CodepipelineSpecForProviderStageAction#name
   */
  readonly name: string;

  /**
   * The namespace all output variables will be accessed from.
   *
   * @schema CodepipelineSpecForProviderStageAction#namespace
   */
  readonly namespace?: string;

  /**
   * A list of artifact names to output. Output artifact names must be unique within a pipeline.
   *
   * @schema CodepipelineSpecForProviderStageAction#outputArtifacts
   */
  readonly outputArtifacts?: string[];

  /**
   * The creator of the action being called. Possible values are AWS, Custom and ThirdParty.
   *
   * @schema CodepipelineSpecForProviderStageAction#owner
   */
  readonly owner: string;

  /**
   * The provider of the service being called by the action. Valid providers are determined by the action category. Provider names are listed in the Action Structure Reference documentation.
   *
   * @schema CodepipelineSpecForProviderStageAction#provider
   */
  readonly provider: string;

  /**
   * The region in which to run the action.
   *
   * @schema CodepipelineSpecForProviderStageAction#region
   */
  readonly region?: string;

  /**
   * The ARN of the IAM service role that will perform the declared action. This is assumed through the roleArn for the pipeline.
   *
   * @schema CodepipelineSpecForProviderStageAction#roleArn
   */
  readonly roleArn?: string;

  /**
   * The order in which actions are run.
   *
   * @schema CodepipelineSpecForProviderStageAction#runOrder
   */
  readonly runOrder?: number;

  /**
   * A string that identifies the action type.
   *
   * @schema CodepipelineSpecForProviderStageAction#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderStageAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderStageAction(obj: CodepipelineSpecForProviderStageAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'category': obj.category,
    'configuration': ((obj.configuration) === undefined) ? undefined : (Object.entries(obj.configuration).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'inputArtifacts': obj.inputArtifacts?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
    'outputArtifacts': obj.outputArtifacts?.map(y => y),
    'owner': obj.owner,
    'provider': obj.provider,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'runOrder': obj.runOrder,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecProviderConfigRefPolicyResolution
 */
export enum CodepipelineSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecProviderConfigRefPolicyResolve
 */
export enum CodepipelineSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecProviderRefPolicyResolution
 */
export enum CodepipelineSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecProviderRefPolicyResolve
 */
export enum CodepipelineSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy(obj: CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationRefPolicy
 */
export interface CodepipelineSpecForProviderArtifactStoreLocationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationRefPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationRefPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStoreLocationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStoreLocationRefPolicy(obj: CodepipelineSpecForProviderArtifactStoreLocationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy
 */
export interface CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy(obj: CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecForProviderRoleArnRefPolicyResolution
 */
export enum CodepipelineSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecForProviderRoleArnRefPolicyResolve
 */
export enum CodepipelineSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum CodepipelineSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum CodepipelineSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolution
 */
export enum CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolve
 */
export enum CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolution
 */
export enum CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolve
 */
export enum CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CustomActionType is the Schema for the CustomActionTypes API. Provides a CodePipeline CustomActionType.
 *
 * @schema CustomActionType
 */
export class CustomActionType extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CustomActionType"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'codepipeline.aws.upbound.io/v1beta1',
    kind: 'CustomActionType',
  }

  /**
   * Renders a Kubernetes manifest for "CustomActionType".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CustomActionTypeProps): any {
    return {
      ...CustomActionType.GVK,
      ...toJson_CustomActionTypeProps(props),
    };
  }

  /**
   * Defines a "CustomActionType" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CustomActionTypeProps) {
    super(scope, id, {
      ...CustomActionType.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CustomActionType.GVK,
      ...toJson_CustomActionTypeProps(resolved),
    };
  }
}

/**
 * CustomActionType is the Schema for the CustomActionTypes API. Provides a CodePipeline CustomActionType.
 *
 * @schema CustomActionType
 */
export interface CustomActionTypeProps {
  /**
   * @schema CustomActionType#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CustomActionTypeSpec defines the desired state of CustomActionType
   *
   * @schema CustomActionType#spec
   */
  readonly spec: CustomActionTypeSpec;

}

/**
 * Converts an object of type 'CustomActionTypeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeProps(obj: CustomActionTypeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CustomActionTypeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomActionTypeSpec defines the desired state of CustomActionType
 *
 * @schema CustomActionTypeSpec
 */
export interface CustomActionTypeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema CustomActionTypeSpec#deletionPolicy
   */
  readonly deletionPolicy?: CustomActionTypeSpecDeletionPolicy;

  /**
   * @schema CustomActionTypeSpec#forProvider
   */
  readonly forProvider: CustomActionTypeSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CustomActionTypeSpec#providerConfigRef
   */
  readonly providerConfigRef?: CustomActionTypeSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CustomActionTypeSpec#providerRef
   */
  readonly providerRef?: CustomActionTypeSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CustomActionTypeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CustomActionTypeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CustomActionTypeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CustomActionTypeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CustomActionTypeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpec(obj: CustomActionTypeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CustomActionTypeSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_CustomActionTypeSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CustomActionTypeSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CustomActionTypeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CustomActionTypeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema CustomActionTypeSpecDeletionPolicy
 */
export enum CustomActionTypeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CustomActionTypeSpecForProvider
 */
export interface CustomActionTypeSpecForProvider {
  /**
   * The category of the custom action. Valid values: Source, Build, Deploy, Test, Invoke, Approval
   *
   * @schema CustomActionTypeSpecForProvider#category
   */
  readonly category: string;

  /**
   * The configuration properties for the custom action. Max 10 items.
   *
   * @schema CustomActionTypeSpecForProvider#configurationProperty
   */
  readonly configurationProperty?: CustomActionTypeSpecForProviderConfigurationProperty[];

  /**
   * The details of the input artifact for the action.
   *
   * @schema CustomActionTypeSpecForProvider#inputArtifactDetails
   */
  readonly inputArtifactDetails: CustomActionTypeSpecForProviderInputArtifactDetails[];

  /**
   * The details of the output artifact of the action.
   *
   * @schema CustomActionTypeSpecForProvider#outputArtifactDetails
   */
  readonly outputArtifactDetails: CustomActionTypeSpecForProviderOutputArtifactDetails[];

  /**
   * The provider of the service used in the custom action
   *
   * @schema CustomActionTypeSpecForProvider#providerName
   */
  readonly providerName: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CustomActionTypeSpecForProvider#region
   */
  readonly region: string;

  /**
   * The settings for an action type.
   *
   * @schema CustomActionTypeSpecForProvider#settings
   */
  readonly settings?: CustomActionTypeSpecForProviderSettings[];

  /**
   * Key-value map of resource tags.
   *
   * @schema CustomActionTypeSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The version identifier of the custom action.
   *
   * @schema CustomActionTypeSpecForProvider#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecForProvider(obj: CustomActionTypeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'category': obj.category,
    'configurationProperty': obj.configurationProperty?.map(y => toJson_CustomActionTypeSpecForProviderConfigurationProperty(y)),
    'inputArtifactDetails': obj.inputArtifactDetails?.map(y => toJson_CustomActionTypeSpecForProviderInputArtifactDetails(y)),
    'outputArtifactDetails': obj.outputArtifactDetails?.map(y => toJson_CustomActionTypeSpecForProviderOutputArtifactDetails(y)),
    'providerName': obj.providerName,
    'region': obj.region,
    'settings': obj.settings?.map(y => toJson_CustomActionTypeSpecForProviderSettings(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CustomActionTypeSpecProviderConfigRef
 */
export interface CustomActionTypeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomActionTypeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomActionTypeSpecProviderConfigRef#policy
   */
  readonly policy?: CustomActionTypeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomActionTypeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecProviderConfigRef(obj: CustomActionTypeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomActionTypeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CustomActionTypeSpecProviderRef
 */
export interface CustomActionTypeSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomActionTypeSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomActionTypeSpecProviderRef#policy
   */
  readonly policy?: CustomActionTypeSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CustomActionTypeSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecProviderRef(obj: CustomActionTypeSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomActionTypeSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsTo
 */
export interface CustomActionTypeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CustomActionTypeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CustomActionTypeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecPublishConnectionDetailsTo(obj: CustomActionTypeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CustomActionTypeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CustomActionTypeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CustomActionTypeSpecWriteConnectionSecretToRef
 */
export interface CustomActionTypeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CustomActionTypeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CustomActionTypeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecWriteConnectionSecretToRef(obj: CustomActionTypeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecForProviderConfigurationProperty
 */
export interface CustomActionTypeSpecForProviderConfigurationProperty {
  /**
   * The description of the action configuration property.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#description
   */
  readonly description?: string;

  /**
   * Whether the configuration property is a key.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#key
   */
  readonly key: boolean;

  /**
   * The name of the action configuration property.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#name
   */
  readonly name: string;

  /**
   * Indicates that the property will be used in conjunction with PollForJobs.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#queryable
   */
  readonly queryable?: boolean;

  /**
   * Whether the configuration property is a required value.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#required
   */
  readonly required: boolean;

  /**
   * Whether the configuration property is secret.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#secret
   */
  readonly secret: boolean;

  /**
   * The type of the configuration property. Valid values: String, Number, Boolean
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecForProviderConfigurationProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecForProviderConfigurationProperty(obj: CustomActionTypeSpecForProviderConfigurationProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'key': obj.key,
    'name': obj.name,
    'queryable': obj.queryable,
    'required': obj.required,
    'secret': obj.secret,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecForProviderInputArtifactDetails
 */
export interface CustomActionTypeSpecForProviderInputArtifactDetails {
  /**
   * The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecForProviderInputArtifactDetails#maximumCount
   */
  readonly maximumCount: number;

  /**
   * The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecForProviderInputArtifactDetails#minimumCount
   */
  readonly minimumCount: number;

}

/**
 * Converts an object of type 'CustomActionTypeSpecForProviderInputArtifactDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecForProviderInputArtifactDetails(obj: CustomActionTypeSpecForProviderInputArtifactDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumCount': obj.maximumCount,
    'minimumCount': obj.minimumCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecForProviderOutputArtifactDetails
 */
export interface CustomActionTypeSpecForProviderOutputArtifactDetails {
  /**
   * The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecForProviderOutputArtifactDetails#maximumCount
   */
  readonly maximumCount: number;

  /**
   * The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecForProviderOutputArtifactDetails#minimumCount
   */
  readonly minimumCount: number;

}

/**
 * Converts an object of type 'CustomActionTypeSpecForProviderOutputArtifactDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecForProviderOutputArtifactDetails(obj: CustomActionTypeSpecForProviderOutputArtifactDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumCount': obj.maximumCount,
    'minimumCount': obj.minimumCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecForProviderSettings
 */
export interface CustomActionTypeSpecForProviderSettings {
  /**
   * The URL returned to the AWS CodePipeline console that provides a deep link to the resources of the external system.
   *
   * @schema CustomActionTypeSpecForProviderSettings#entityUrlTemplate
   */
  readonly entityUrlTemplate?: string;

  /**
   * The URL returned to the AWS CodePipeline console that contains a link to the top-level landing page for the external system.
   *
   * @schema CustomActionTypeSpecForProviderSettings#executionUrlTemplate
   */
  readonly executionUrlTemplate?: string;

  /**
   * The URL returned to the AWS CodePipeline console that contains a link to the page where customers can update or change the configuration of the external action.
   *
   * @schema CustomActionTypeSpecForProviderSettings#revisionUrlTemplate
   */
  readonly revisionUrlTemplate?: string;

  /**
   * The URL of a sign-up page where users can sign up for an external service and perform initial configuration of the action provided by that service.
   *
   * @schema CustomActionTypeSpecForProviderSettings#thirdPartyConfigurationUrl
   */
  readonly thirdPartyConfigurationUrl?: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecForProviderSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecForProviderSettings(obj: CustomActionTypeSpecForProviderSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entityUrlTemplate': obj.entityUrlTemplate,
    'executionUrlTemplate': obj.executionUrlTemplate,
    'revisionUrlTemplate': obj.revisionUrlTemplate,
    'thirdPartyConfigurationUrl': obj.thirdPartyConfigurationUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomActionTypeSpecProviderConfigRefPolicy
 */
export interface CustomActionTypeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomActionTypeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CustomActionTypeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomActionTypeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CustomActionTypeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomActionTypeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecProviderConfigRefPolicy(obj: CustomActionTypeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomActionTypeSpecProviderRefPolicy
 */
export interface CustomActionTypeSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomActionTypeSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CustomActionTypeSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomActionTypeSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CustomActionTypeSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomActionTypeSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecProviderRefPolicy(obj: CustomActionTypeSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRef
 */
export interface CustomActionTypeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomActionTypeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecPublishConnectionDetailsToConfigRef(obj: CustomActionTypeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsToMetadata
 */
export interface CustomActionTypeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecPublishConnectionDetailsToMetadata(obj: CustomActionTypeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomActionTypeSpecProviderConfigRefPolicyResolution
 */
export enum CustomActionTypeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomActionTypeSpecProviderConfigRefPolicyResolve
 */
export enum CustomActionTypeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomActionTypeSpecProviderRefPolicyResolution
 */
export enum CustomActionTypeSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomActionTypeSpecProviderRefPolicyResolve
 */
export enum CustomActionTypeSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj: CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Webhook is the Schema for the Webhooks API. Provides a CodePipeline Webhook
 *
 * @schema Webhook
 */
export class Webhook extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Webhook"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'codepipeline.aws.upbound.io/v1beta1',
    kind: 'Webhook',
  }

  /**
   * Renders a Kubernetes manifest for "Webhook".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WebhookProps): any {
    return {
      ...Webhook.GVK,
      ...toJson_WebhookProps(props),
    };
  }

  /**
   * Defines a "Webhook" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WebhookProps) {
    super(scope, id, {
      ...Webhook.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Webhook.GVK,
      ...toJson_WebhookProps(resolved),
    };
  }
}

/**
 * Webhook is the Schema for the Webhooks API. Provides a CodePipeline Webhook
 *
 * @schema Webhook
 */
export interface WebhookProps {
  /**
   * @schema Webhook#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WebhookSpec defines the desired state of Webhook
   *
   * @schema Webhook#spec
   */
  readonly spec: WebhookSpec;

}

/**
 * Converts an object of type 'WebhookProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookProps(obj: WebhookProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WebhookSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebhookSpec defines the desired state of Webhook
 *
 * @schema WebhookSpec
 */
export interface WebhookSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema WebhookSpec#deletionPolicy
   */
  readonly deletionPolicy?: WebhookSpecDeletionPolicy;

  /**
   * @schema WebhookSpec#forProvider
   */
  readonly forProvider: WebhookSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WebhookSpec#providerConfigRef
   */
  readonly providerConfigRef?: WebhookSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WebhookSpec#providerRef
   */
  readonly providerRef?: WebhookSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WebhookSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WebhookSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WebhookSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WebhookSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WebhookSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpec(obj: WebhookSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WebhookSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_WebhookSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WebhookSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WebhookSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WebhookSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema WebhookSpecDeletionPolicy
 */
export enum WebhookSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WebhookSpecForProvider
 */
export interface WebhookSpecForProvider {
  /**
   * The type of authentication  to use. One of IP, GITHUB_HMAC, or UNAUTHENTICATED.
   *
   * @schema WebhookSpecForProvider#authentication
   */
  readonly authentication: string;

  /**
   * An auth block. Required for IP and GITHUB_HMAC. Auth blocks are documented below.
   *
   * @schema WebhookSpecForProvider#authenticationConfiguration
   */
  readonly authenticationConfiguration?: WebhookSpecForProviderAuthenticationConfiguration[];

  /**
   * One or more filter blocks. Filter blocks are documented below.
   *
   * @schema WebhookSpecForProvider#filter
   */
  readonly filter: WebhookSpecForProviderFilter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WebhookSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WebhookSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The name of the action in a pipeline you want to connect to the webhook. The action must be from the source (first) stage of the pipeline.
   *
   * @schema WebhookSpecForProvider#targetAction
   */
  readonly targetAction: string;

  /**
   * The name of the pipeline.
   *
   * @schema WebhookSpecForProvider#targetPipeline
   */
  readonly targetPipeline?: string;

  /**
   * Reference to a Codepipeline in codepipeline to populate targetPipeline.
   *
   * @schema WebhookSpecForProvider#targetPipelineRef
   */
  readonly targetPipelineRef?: WebhookSpecForProviderTargetPipelineRef;

  /**
   * Selector for a Codepipeline in codepipeline to populate targetPipeline.
   *
   * @schema WebhookSpecForProvider#targetPipelineSelector
   */
  readonly targetPipelineSelector?: WebhookSpecForProviderTargetPipelineSelector;

}

/**
 * Converts an object of type 'WebhookSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProvider(obj: WebhookSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': obj.authentication,
    'authenticationConfiguration': obj.authenticationConfiguration?.map(y => toJson_WebhookSpecForProviderAuthenticationConfiguration(y)),
    'filter': obj.filter?.map(y => toJson_WebhookSpecForProviderFilter(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetAction': obj.targetAction,
    'targetPipeline': obj.targetPipeline,
    'targetPipelineRef': toJson_WebhookSpecForProviderTargetPipelineRef(obj.targetPipelineRef),
    'targetPipelineSelector': toJson_WebhookSpecForProviderTargetPipelineSelector(obj.targetPipelineSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WebhookSpecProviderConfigRef
 */
export interface WebhookSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecProviderConfigRef#policy
   */
  readonly policy?: WebhookSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderConfigRef(obj: WebhookSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WebhookSpecProviderRef
 */
export interface WebhookSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecProviderRef#policy
   */
  readonly policy?: WebhookSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderRef(obj: WebhookSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WebhookSpecPublishConnectionDetailsTo
 */
export interface WebhookSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WebhookSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WebhookSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsTo(obj: WebhookSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WebhookSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WebhookSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WebhookSpecWriteConnectionSecretToRef
 */
export interface WebhookSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WebhookSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WebhookSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WebhookSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecWriteConnectionSecretToRef(obj: WebhookSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebhookSpecForProviderAuthenticationConfiguration
 */
export interface WebhookSpecForProviderAuthenticationConfiguration {
  /**
   * A valid CIDR block for IP filtering. Required for IP.
   *
   * @schema WebhookSpecForProviderAuthenticationConfiguration#allowedIpRange
   */
  readonly allowedIpRange?: string;

  /**
   * The shared secret for the GitHub repository webhook. Set this as secret in your github_repository_webhook's configuration block. Required for GITHUB_HMAC.
   *
   * @schema WebhookSpecForProviderAuthenticationConfiguration#secretTokenSecretRef
   */
  readonly secretTokenSecretRef?: WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef;

}

/**
 * Converts an object of type 'WebhookSpecForProviderAuthenticationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderAuthenticationConfiguration(obj: WebhookSpecForProviderAuthenticationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpRange': obj.allowedIpRange,
    'secretTokenSecretRef': toJson_WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef(obj.secretTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebhookSpecForProviderFilter
 */
export interface WebhookSpecForProviderFilter {
  /**
   * The JSON path to filter on.
   *
   * @schema WebhookSpecForProviderFilter#jsonPath
   */
  readonly jsonPath: string;

  /**
   * The value to match on (e.g., refs/heads/{Branch}). See AWS docs for details.
   *
   * @schema WebhookSpecForProviderFilter#matchEquals
   */
  readonly matchEquals: string;

}

/**
 * Converts an object of type 'WebhookSpecForProviderFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderFilter(obj: WebhookSpecForProviderFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
    'matchEquals': obj.matchEquals,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Codepipeline in codepipeline to populate targetPipeline.
 *
 * @schema WebhookSpecForProviderTargetPipelineRef
 */
export interface WebhookSpecForProviderTargetPipelineRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecForProviderTargetPipelineRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecForProviderTargetPipelineRef#policy
   */
  readonly policy?: WebhookSpecForProviderTargetPipelineRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecForProviderTargetPipelineRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderTargetPipelineRef(obj: WebhookSpecForProviderTargetPipelineRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecForProviderTargetPipelineRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Codepipeline in codepipeline to populate targetPipeline.
 *
 * @schema WebhookSpecForProviderTargetPipelineSelector
 */
export interface WebhookSpecForProviderTargetPipelineSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WebhookSpecForProviderTargetPipelineSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WebhookSpecForProviderTargetPipelineSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WebhookSpecForProviderTargetPipelineSelector#policy
   */
  readonly policy?: WebhookSpecForProviderTargetPipelineSelectorPolicy;

}

/**
 * Converts an object of type 'WebhookSpecForProviderTargetPipelineSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderTargetPipelineSelector(obj: WebhookSpecForProviderTargetPipelineSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WebhookSpecForProviderTargetPipelineSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecProviderConfigRefPolicy
 */
export interface WebhookSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderConfigRefPolicy(obj: WebhookSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecProviderRefPolicy
 */
export interface WebhookSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderRefPolicy(obj: WebhookSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRef
 */
export interface WebhookSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WebhookSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToConfigRef(obj: WebhookSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WebhookSpecPublishConnectionDetailsToMetadata
 */
export interface WebhookSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToMetadata(obj: WebhookSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The shared secret for the GitHub repository webhook. Set this as secret in your github_repository_webhook's configuration block. Required for GITHUB_HMAC.
 *
 * @schema WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef
 */
export interface WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef {
  /**
   * The key to select.
   *
   * @schema WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef(obj: WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecForProviderTargetPipelineRefPolicy
 */
export interface WebhookSpecForProviderTargetPipelineRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecForProviderTargetPipelineRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecForProviderTargetPipelineRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecForProviderTargetPipelineRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecForProviderTargetPipelineRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecForProviderTargetPipelineRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderTargetPipelineRefPolicy(obj: WebhookSpecForProviderTargetPipelineRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WebhookSpecForProviderTargetPipelineSelectorPolicy
 */
export interface WebhookSpecForProviderTargetPipelineSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecForProviderTargetPipelineSelectorPolicy#resolution
   */
  readonly resolution?: WebhookSpecForProviderTargetPipelineSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecForProviderTargetPipelineSelectorPolicy#resolve
   */
  readonly resolve?: WebhookSpecForProviderTargetPipelineSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecForProviderTargetPipelineSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderTargetPipelineSelectorPolicy(obj: WebhookSpecForProviderTargetPipelineSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecProviderConfigRefPolicyResolution
 */
export enum WebhookSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecProviderConfigRefPolicyResolve
 */
export enum WebhookSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecProviderRefPolicyResolution
 */
export enum WebhookSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecProviderRefPolicyResolve
 */
export enum WebhookSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WebhookSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToConfigRefPolicy(obj: WebhookSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecForProviderTargetPipelineRefPolicyResolution
 */
export enum WebhookSpecForProviderTargetPipelineRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecForProviderTargetPipelineRefPolicyResolve
 */
export enum WebhookSpecForProviderTargetPipelineRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecForProviderTargetPipelineSelectorPolicyResolution
 */
export enum WebhookSpecForProviderTargetPipelineSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecForProviderTargetPipelineSelectorPolicyResolve
 */
export enum WebhookSpecForProviderTargetPipelineSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

