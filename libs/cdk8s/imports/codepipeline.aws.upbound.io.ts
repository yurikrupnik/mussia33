// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Codepipeline is the Schema for the Codepipelines API. Provides a CodePipeline
 *
 * @schema Codepipeline
 */
export class Codepipeline extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Codepipeline"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'codepipeline.aws.upbound.io/v1beta1',
    kind: 'Codepipeline',
  }

  /**
   * Renders a Kubernetes manifest for "Codepipeline".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CodepipelineProps): any {
    return {
      ...Codepipeline.GVK,
      ...toJson_CodepipelineProps(props),
    };
  }

  /**
   * Defines a "Codepipeline" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CodepipelineProps) {
    super(scope, id, {
      ...Codepipeline.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Codepipeline.GVK,
      ...toJson_CodepipelineProps(resolved),
    };
  }
}

/**
 * Codepipeline is the Schema for the Codepipelines API. Provides a CodePipeline
 *
 * @schema Codepipeline
 */
export interface CodepipelineProps {
  /**
   * @schema Codepipeline#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CodepipelineSpec defines the desired state of Codepipeline
   *
   * @schema Codepipeline#spec
   */
  readonly spec: CodepipelineSpec;

}

/**
 * Converts an object of type 'CodepipelineProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineProps(obj: CodepipelineProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CodepipelineSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CodepipelineSpec defines the desired state of Codepipeline
 *
 * @schema CodepipelineSpec
 */
export interface CodepipelineSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CodepipelineSpec#deletionPolicy
   */
  readonly deletionPolicy?: CodepipelineSpecDeletionPolicy;

  /**
   * @schema CodepipelineSpec#forProvider
   */
  readonly forProvider: CodepipelineSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CodepipelineSpec#initProvider
   */
  readonly initProvider?: CodepipelineSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CodepipelineSpec#managementPolicies
   */
  readonly managementPolicies?: CodepipelineSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CodepipelineSpec#providerConfigRef
   */
  readonly providerConfigRef?: CodepipelineSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CodepipelineSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CodepipelineSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CodepipelineSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CodepipelineSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CodepipelineSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpec(obj: CodepipelineSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CodepipelineSpecForProvider(obj.forProvider),
    'initProvider': toJson_CodepipelineSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CodepipelineSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CodepipelineSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CodepipelineSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CodepipelineSpecDeletionPolicy
 */
export enum CodepipelineSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CodepipelineSpecForProvider
 */
export interface CodepipelineSpecForProvider {
  /**
   * One or more artifact_store blocks. Artifact stores are documented below.
   *
   * @schema CodepipelineSpecForProvider#artifactStore
   */
  readonly artifactStore?: CodepipelineSpecForProviderArtifactStore[];

  /**
   * The region in which to run the action. Region is the region you'd like your resource to be created in.
   *
   * @schema CodepipelineSpecForProvider#region
   */
  readonly region: string;

  /**
   * A service role Amazon Resource Name (ARN) that grants AWS CodePipeline permission to make calls to AWS services on your behalf.
   *
   * @schema CodepipelineSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema CodepipelineSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: CodepipelineSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema CodepipelineSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: CodepipelineSpecForProviderRoleArnSelector;

  /**
   * (Minimum of at least two stage blocks is required) A stage block. Stages are documented below.
   *
   * @schema CodepipelineSpecForProvider#stage
   */
  readonly stage?: CodepipelineSpecForProviderStage[];

  /**
   * Key-value map of resource tags.
   *
   * @schema CodepipelineSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CodepipelineSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProvider(obj: CodepipelineSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'artifactStore': obj.artifactStore?.map(y => toJson_CodepipelineSpecForProviderArtifactStore(y)),
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_CodepipelineSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_CodepipelineSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'stage': obj.stage?.map(y => toJson_CodepipelineSpecForProviderStage(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CodepipelineSpecInitProvider
 */
export interface CodepipelineSpecInitProvider {
  /**
   * One or more artifact_store blocks. Artifact stores are documented below.
   *
   * @schema CodepipelineSpecInitProvider#artifactStore
   */
  readonly artifactStore?: CodepipelineSpecInitProviderArtifactStore[];

  /**
   * (Minimum of at least two stage blocks is required) A stage block. Stages are documented below.
   *
   * @schema CodepipelineSpecInitProvider#stage
   */
  readonly stage?: CodepipelineSpecInitProviderStage[];

  /**
   * Key-value map of resource tags.
   *
   * @schema CodepipelineSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CodepipelineSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecInitProvider(obj: CodepipelineSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'artifactStore': obj.artifactStore?.map(y => toJson_CodepipelineSpecInitProviderArtifactStore(y)),
    'stage': obj.stage?.map(y => toJson_CodepipelineSpecInitProviderStage(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CodepipelineSpecManagementPolicies
 */
export enum CodepipelineSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CodepipelineSpecProviderConfigRef
 */
export interface CodepipelineSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodepipelineSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodepipelineSpecProviderConfigRef#policy
   */
  readonly policy?: CodepipelineSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecProviderConfigRef(obj: CodepipelineSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodepipelineSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsTo
 */
export interface CodepipelineSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CodepipelineSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CodepipelineSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CodepipelineSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecPublishConnectionDetailsTo(obj: CodepipelineSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CodepipelineSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CodepipelineSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CodepipelineSpecWriteConnectionSecretToRef
 */
export interface CodepipelineSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CodepipelineSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CodepipelineSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CodepipelineSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecWriteConnectionSecretToRef(obj: CodepipelineSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecForProviderArtifactStore
 */
export interface CodepipelineSpecForProviderArtifactStore {
  /**
   * The encryption key block AWS CodePipeline uses to encrypt the data in the artifact store, such as an AWS Key Management Service (AWS KMS) key. If you don't specify a key, AWS CodePipeline uses the default key for Amazon Simple Storage Service (Amazon S3). An encryption_key block is documented below.
   *
   * @schema CodepipelineSpecForProviderArtifactStore#encryptionKey
   */
  readonly encryptionKey?: CodepipelineSpecForProviderArtifactStoreEncryptionKey[];

  /**
   * The location where AWS CodePipeline stores artifacts for a pipeline; currently only S3 is supported.
   *
   * @schema CodepipelineSpecForProviderArtifactStore#location
   */
  readonly location?: string;

  /**
   * Reference to a Bucket in s3 to populate location.
   *
   * @schema CodepipelineSpecForProviderArtifactStore#locationRef
   */
  readonly locationRef?: CodepipelineSpecForProviderArtifactStoreLocationRef;

  /**
   * Selector for a Bucket in s3 to populate location.
   *
   * @schema CodepipelineSpecForProviderArtifactStore#locationSelector
   */
  readonly locationSelector?: CodepipelineSpecForProviderArtifactStoreLocationSelector;

  /**
   * The region where the artifact store is located. Required for a cross-region CodePipeline, do not provide for a single-region CodePipeline.
   *
   * @schema CodepipelineSpecForProviderArtifactStore#region
   */
  readonly region?: string;

  /**
   * The type of the artifact store, such as Amazon S3
   *
   * @schema CodepipelineSpecForProviderArtifactStore#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStore(obj: CodepipelineSpecForProviderArtifactStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionKey': obj.encryptionKey?.map(y => toJson_CodepipelineSpecForProviderArtifactStoreEncryptionKey(y)),
    'location': obj.location,
    'locationRef': toJson_CodepipelineSpecForProviderArtifactStoreLocationRef(obj.locationRef),
    'locationSelector': toJson_CodepipelineSpecForProviderArtifactStoreLocationSelector(obj.locationSelector),
    'region': obj.region,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema CodepipelineSpecForProviderRoleArnRef
 */
export interface CodepipelineSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodepipelineSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodepipelineSpecForProviderRoleArnRef#policy
   */
  readonly policy?: CodepipelineSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderRoleArnRef(obj: CodepipelineSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodepipelineSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema CodepipelineSpecForProviderRoleArnSelector
 */
export interface CodepipelineSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CodepipelineSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CodepipelineSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CodepipelineSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: CodepipelineSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderRoleArnSelector(obj: CodepipelineSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CodepipelineSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecForProviderStage
 */
export interface CodepipelineSpecForProviderStage {
  /**
   * The action(s) to include in the stage. Defined as an action block below
   *
   * @schema CodepipelineSpecForProviderStage#action
   */
  readonly action?: CodepipelineSpecForProviderStageAction[];

  /**
   * The name of the stage.
   *
   * @schema CodepipelineSpecForProviderStage#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderStage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderStage(obj: CodepipelineSpecForProviderStage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_CodepipelineSpecForProviderStageAction(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecInitProviderArtifactStore
 */
export interface CodepipelineSpecInitProviderArtifactStore {
  /**
   * The encryption key block AWS CodePipeline uses to encrypt the data in the artifact store, such as an AWS Key Management Service (AWS KMS) key. If you don't specify a key, AWS CodePipeline uses the default key for Amazon Simple Storage Service (Amazon S3). An encryption_key block is documented below.
   *
   * @schema CodepipelineSpecInitProviderArtifactStore#encryptionKey
   */
  readonly encryptionKey?: CodepipelineSpecInitProviderArtifactStoreEncryptionKey[];

  /**
   * The type of the artifact store, such as Amazon S3
   *
   * @schema CodepipelineSpecInitProviderArtifactStore#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CodepipelineSpecInitProviderArtifactStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecInitProviderArtifactStore(obj: CodepipelineSpecInitProviderArtifactStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionKey': obj.encryptionKey?.map(y => toJson_CodepipelineSpecInitProviderArtifactStoreEncryptionKey(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecInitProviderStage
 */
export interface CodepipelineSpecInitProviderStage {
  /**
   * The action(s) to include in the stage. Defined as an action block below
   *
   * @schema CodepipelineSpecInitProviderStage#action
   */
  readonly action?: CodepipelineSpecInitProviderStageAction[];

  /**
   * The name of the stage.
   *
   * @schema CodepipelineSpecInitProviderStage#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'CodepipelineSpecInitProviderStage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecInitProviderStage(obj: CodepipelineSpecInitProviderStage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_CodepipelineSpecInitProviderStageAction(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodepipelineSpecProviderConfigRefPolicy
 */
export interface CodepipelineSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecProviderConfigRefPolicy(obj: CodepipelineSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsToConfigRef
 */
export interface CodepipelineSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecPublishConnectionDetailsToConfigRef(obj: CodepipelineSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsToMetadata
 */
export interface CodepipelineSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CodepipelineSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecPublishConnectionDetailsToMetadata(obj: CodepipelineSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecForProviderArtifactStoreEncryptionKey
 */
export interface CodepipelineSpecForProviderArtifactStoreEncryptionKey {
  /**
   * The KMS key ARN or ID
   *
   * @schema CodepipelineSpecForProviderArtifactStoreEncryptionKey#id
   */
  readonly id?: string;

  /**
   * The type of key; currently only KMS is supported
   *
   * @schema CodepipelineSpecForProviderArtifactStoreEncryptionKey#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStoreEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStoreEncryptionKey(obj: CodepipelineSpecForProviderArtifactStoreEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate location.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationRef
 */
export interface CodepipelineSpecForProviderArtifactStoreLocationRef {
  /**
   * Name of the referenced object.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationRef#policy
   */
  readonly policy?: CodepipelineSpecForProviderArtifactStoreLocationRefPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStoreLocationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStoreLocationRef(obj: CodepipelineSpecForProviderArtifactStoreLocationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CodepipelineSpecForProviderArtifactStoreLocationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate location.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationSelector
 */
export interface CodepipelineSpecForProviderArtifactStoreLocationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationSelector#policy
   */
  readonly policy?: CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStoreLocationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStoreLocationSelector(obj: CodepipelineSpecForProviderArtifactStoreLocationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodepipelineSpecForProviderRoleArnRefPolicy
 */
export interface CodepipelineSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderRoleArnRefPolicy(obj: CodepipelineSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CodepipelineSpecForProviderRoleArnSelectorPolicy
 */
export interface CodepipelineSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderRoleArnSelectorPolicy(obj: CodepipelineSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecForProviderStageAction
 */
export interface CodepipelineSpecForProviderStageAction {
  /**
   * A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Possible values are Approval, Build, Deploy, Invoke, Source and Test.
   *
   * @schema CodepipelineSpecForProviderStageAction#category
   */
  readonly category?: string;

  /**
   * A map of the action declaration's configuration. Configurations options for action types and providers can be found in the Pipeline Structure Reference and Action Structure Reference documentation.
   *
   * @schema CodepipelineSpecForProviderStageAction#configuration
   */
  readonly configuration?: { [key: string]: string };

  /**
   * A list of artifact names to be worked on.
   *
   * @schema CodepipelineSpecForProviderStageAction#inputArtifacts
   */
  readonly inputArtifacts?: string[];

  /**
   * The action declaration's name.
   *
   * @schema CodepipelineSpecForProviderStageAction#name
   */
  readonly name?: string;

  /**
   * The namespace all output variables will be accessed from.
   *
   * @schema CodepipelineSpecForProviderStageAction#namespace
   */
  readonly namespace?: string;

  /**
   * A list of artifact names to output. Output artifact names must be unique within a pipeline.
   *
   * @schema CodepipelineSpecForProviderStageAction#outputArtifacts
   */
  readonly outputArtifacts?: string[];

  /**
   * The creator of the action being called. Possible values are AWS, Custom and ThirdParty.
   *
   * @schema CodepipelineSpecForProviderStageAction#owner
   */
  readonly owner?: string;

  /**
   * The provider of the service being called by the action. Valid providers are determined by the action category. Provider names are listed in the Action Structure Reference documentation.
   *
   * @schema CodepipelineSpecForProviderStageAction#provider
   */
  readonly provider?: string;

  /**
   * The region in which to run the action.
   *
   * @schema CodepipelineSpecForProviderStageAction#region
   */
  readonly region?: string;

  /**
   * The ARN of the IAM service role that will perform the declared action. This is assumed through the roleArn for the pipeline.
   *
   * @schema CodepipelineSpecForProviderStageAction#roleArn
   */
  readonly roleArn?: string;

  /**
   * The order in which actions are run.
   *
   * @schema CodepipelineSpecForProviderStageAction#runOrder
   */
  readonly runOrder?: number;

  /**
   * A string that identifies the action type.
   *
   * @schema CodepipelineSpecForProviderStageAction#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderStageAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderStageAction(obj: CodepipelineSpecForProviderStageAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'category': obj.category,
    'configuration': ((obj.configuration) === undefined) ? undefined : (Object.entries(obj.configuration).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'inputArtifacts': obj.inputArtifacts?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
    'outputArtifacts': obj.outputArtifacts?.map(y => y),
    'owner': obj.owner,
    'provider': obj.provider,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'runOrder': obj.runOrder,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecInitProviderArtifactStoreEncryptionKey
 */
export interface CodepipelineSpecInitProviderArtifactStoreEncryptionKey {
  /**
   * The KMS key ARN or ID
   *
   * @schema CodepipelineSpecInitProviderArtifactStoreEncryptionKey#id
   */
  readonly id?: string;

  /**
   * The type of key; currently only KMS is supported
   *
   * @schema CodepipelineSpecInitProviderArtifactStoreEncryptionKey#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CodepipelineSpecInitProviderArtifactStoreEncryptionKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecInitProviderArtifactStoreEncryptionKey(obj: CodepipelineSpecInitProviderArtifactStoreEncryptionKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'id': obj.id,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CodepipelineSpecInitProviderStageAction
 */
export interface CodepipelineSpecInitProviderStageAction {
  /**
   * A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Possible values are Approval, Build, Deploy, Invoke, Source and Test.
   *
   * @schema CodepipelineSpecInitProviderStageAction#category
   */
  readonly category?: string;

  /**
   * A map of the action declaration's configuration. Configurations options for action types and providers can be found in the Pipeline Structure Reference and Action Structure Reference documentation.
   *
   * @schema CodepipelineSpecInitProviderStageAction#configuration
   */
  readonly configuration?: { [key: string]: string };

  /**
   * A list of artifact names to be worked on.
   *
   * @schema CodepipelineSpecInitProviderStageAction#inputArtifacts
   */
  readonly inputArtifacts?: string[];

  /**
   * The action declaration's name.
   *
   * @schema CodepipelineSpecInitProviderStageAction#name
   */
  readonly name?: string;

  /**
   * The namespace all output variables will be accessed from.
   *
   * @schema CodepipelineSpecInitProviderStageAction#namespace
   */
  readonly namespace?: string;

  /**
   * A list of artifact names to output. Output artifact names must be unique within a pipeline.
   *
   * @schema CodepipelineSpecInitProviderStageAction#outputArtifacts
   */
  readonly outputArtifacts?: string[];

  /**
   * The creator of the action being called. Possible values are AWS, Custom and ThirdParty.
   *
   * @schema CodepipelineSpecInitProviderStageAction#owner
   */
  readonly owner?: string;

  /**
   * The provider of the service being called by the action. Valid providers are determined by the action category. Provider names are listed in the Action Structure Reference documentation.
   *
   * @schema CodepipelineSpecInitProviderStageAction#provider
   */
  readonly provider?: string;

  /**
   * The ARN of the IAM service role that will perform the declared action. This is assumed through the roleArn for the pipeline.
   *
   * @schema CodepipelineSpecInitProviderStageAction#roleArn
   */
  readonly roleArn?: string;

  /**
   * The order in which actions are run.
   *
   * @schema CodepipelineSpecInitProviderStageAction#runOrder
   */
  readonly runOrder?: number;

  /**
   * A string that identifies the action type.
   *
   * @schema CodepipelineSpecInitProviderStageAction#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'CodepipelineSpecInitProviderStageAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecInitProviderStageAction(obj: CodepipelineSpecInitProviderStageAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'category': obj.category,
    'configuration': ((obj.configuration) === undefined) ? undefined : (Object.entries(obj.configuration).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'inputArtifacts': obj.inputArtifacts?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
    'outputArtifacts': obj.outputArtifacts?.map(y => y),
    'owner': obj.owner,
    'provider': obj.provider,
    'roleArn': obj.roleArn,
    'runOrder': obj.runOrder,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecProviderConfigRefPolicyResolution
 */
export enum CodepipelineSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecProviderConfigRefPolicyResolve
 */
export enum CodepipelineSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy(obj: CodepipelineSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationRefPolicy
 */
export interface CodepipelineSpecForProviderArtifactStoreLocationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationRefPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationRefPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStoreLocationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStoreLocationRefPolicy(obj: CodepipelineSpecForProviderArtifactStoreLocationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy
 */
export interface CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy#resolution
   */
  readonly resolution?: CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy#resolve
   */
  readonly resolve?: CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy(obj: CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecForProviderRoleArnRefPolicyResolution
 */
export enum CodepipelineSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecForProviderRoleArnRefPolicyResolve
 */
export enum CodepipelineSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum CodepipelineSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum CodepipelineSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CodepipelineSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolution
 */
export enum CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolve
 */
export enum CodepipelineSpecForProviderArtifactStoreLocationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolution
 */
export enum CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolve
 */
export enum CodepipelineSpecForProviderArtifactStoreLocationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CustomActionType is the Schema for the CustomActionTypes API. Provides a CodePipeline CustomActionType.
 *
 * @schema CustomActionType
 */
export class CustomActionType extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CustomActionType"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'codepipeline.aws.upbound.io/v1beta1',
    kind: 'CustomActionType',
  }

  /**
   * Renders a Kubernetes manifest for "CustomActionType".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CustomActionTypeProps): any {
    return {
      ...CustomActionType.GVK,
      ...toJson_CustomActionTypeProps(props),
    };
  }

  /**
   * Defines a "CustomActionType" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CustomActionTypeProps) {
    super(scope, id, {
      ...CustomActionType.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CustomActionType.GVK,
      ...toJson_CustomActionTypeProps(resolved),
    };
  }
}

/**
 * CustomActionType is the Schema for the CustomActionTypes API. Provides a CodePipeline CustomActionType.
 *
 * @schema CustomActionType
 */
export interface CustomActionTypeProps {
  /**
   * @schema CustomActionType#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CustomActionTypeSpec defines the desired state of CustomActionType
   *
   * @schema CustomActionType#spec
   */
  readonly spec: CustomActionTypeSpec;

}

/**
 * Converts an object of type 'CustomActionTypeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeProps(obj: CustomActionTypeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CustomActionTypeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomActionTypeSpec defines the desired state of CustomActionType
 *
 * @schema CustomActionTypeSpec
 */
export interface CustomActionTypeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CustomActionTypeSpec#deletionPolicy
   */
  readonly deletionPolicy?: CustomActionTypeSpecDeletionPolicy;

  /**
   * @schema CustomActionTypeSpec#forProvider
   */
  readonly forProvider: CustomActionTypeSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CustomActionTypeSpec#initProvider
   */
  readonly initProvider?: CustomActionTypeSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CustomActionTypeSpec#managementPolicies
   */
  readonly managementPolicies?: CustomActionTypeSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CustomActionTypeSpec#providerConfigRef
   */
  readonly providerConfigRef?: CustomActionTypeSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CustomActionTypeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CustomActionTypeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CustomActionTypeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CustomActionTypeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CustomActionTypeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpec(obj: CustomActionTypeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CustomActionTypeSpecForProvider(obj.forProvider),
    'initProvider': toJson_CustomActionTypeSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CustomActionTypeSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CustomActionTypeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CustomActionTypeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CustomActionTypeSpecDeletionPolicy
 */
export enum CustomActionTypeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CustomActionTypeSpecForProvider
 */
export interface CustomActionTypeSpecForProvider {
  /**
   * The category of the custom action. Valid values: Source, Build, Deploy, Test, Invoke, Approval
   *
   * @schema CustomActionTypeSpecForProvider#category
   */
  readonly category?: string;

  /**
   * The configuration properties for the custom action. Max 10 items.
   *
   * @schema CustomActionTypeSpecForProvider#configurationProperty
   */
  readonly configurationProperty?: CustomActionTypeSpecForProviderConfigurationProperty[];

  /**
   * The details of the input artifact for the action.
   *
   * @schema CustomActionTypeSpecForProvider#inputArtifactDetails
   */
  readonly inputArtifactDetails?: CustomActionTypeSpecForProviderInputArtifactDetails[];

  /**
   * The details of the output artifact of the action.
   *
   * @schema CustomActionTypeSpecForProvider#outputArtifactDetails
   */
  readonly outputArtifactDetails?: CustomActionTypeSpecForProviderOutputArtifactDetails[];

  /**
   * The provider of the service used in the custom action
   *
   * @schema CustomActionTypeSpecForProvider#providerName
   */
  readonly providerName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CustomActionTypeSpecForProvider#region
   */
  readonly region: string;

  /**
   * The settings for an action type.
   *
   * @schema CustomActionTypeSpecForProvider#settings
   */
  readonly settings?: CustomActionTypeSpecForProviderSettings[];

  /**
   * Key-value map of resource tags.
   *
   * @schema CustomActionTypeSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The version identifier of the custom action.
   *
   * @schema CustomActionTypeSpecForProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecForProvider(obj: CustomActionTypeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'category': obj.category,
    'configurationProperty': obj.configurationProperty?.map(y => toJson_CustomActionTypeSpecForProviderConfigurationProperty(y)),
    'inputArtifactDetails': obj.inputArtifactDetails?.map(y => toJson_CustomActionTypeSpecForProviderInputArtifactDetails(y)),
    'outputArtifactDetails': obj.outputArtifactDetails?.map(y => toJson_CustomActionTypeSpecForProviderOutputArtifactDetails(y)),
    'providerName': obj.providerName,
    'region': obj.region,
    'settings': obj.settings?.map(y => toJson_CustomActionTypeSpecForProviderSettings(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CustomActionTypeSpecInitProvider
 */
export interface CustomActionTypeSpecInitProvider {
  /**
   * The category of the custom action. Valid values: Source, Build, Deploy, Test, Invoke, Approval
   *
   * @schema CustomActionTypeSpecInitProvider#category
   */
  readonly category?: string;

  /**
   * The configuration properties for the custom action. Max 10 items.
   *
   * @schema CustomActionTypeSpecInitProvider#configurationProperty
   */
  readonly configurationProperty?: CustomActionTypeSpecInitProviderConfigurationProperty[];

  /**
   * The details of the input artifact for the action.
   *
   * @schema CustomActionTypeSpecInitProvider#inputArtifactDetails
   */
  readonly inputArtifactDetails?: CustomActionTypeSpecInitProviderInputArtifactDetails[];

  /**
   * The details of the output artifact of the action.
   *
   * @schema CustomActionTypeSpecInitProvider#outputArtifactDetails
   */
  readonly outputArtifactDetails?: CustomActionTypeSpecInitProviderOutputArtifactDetails[];

  /**
   * The provider of the service used in the custom action
   *
   * @schema CustomActionTypeSpecInitProvider#providerName
   */
  readonly providerName?: string;

  /**
   * The settings for an action type.
   *
   * @schema CustomActionTypeSpecInitProvider#settings
   */
  readonly settings?: CustomActionTypeSpecInitProviderSettings[];

  /**
   * Key-value map of resource tags.
   *
   * @schema CustomActionTypeSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The version identifier of the custom action.
   *
   * @schema CustomActionTypeSpecInitProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecInitProvider(obj: CustomActionTypeSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'category': obj.category,
    'configurationProperty': obj.configurationProperty?.map(y => toJson_CustomActionTypeSpecInitProviderConfigurationProperty(y)),
    'inputArtifactDetails': obj.inputArtifactDetails?.map(y => toJson_CustomActionTypeSpecInitProviderInputArtifactDetails(y)),
    'outputArtifactDetails': obj.outputArtifactDetails?.map(y => toJson_CustomActionTypeSpecInitProviderOutputArtifactDetails(y)),
    'providerName': obj.providerName,
    'settings': obj.settings?.map(y => toJson_CustomActionTypeSpecInitProviderSettings(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CustomActionTypeSpecManagementPolicies
 */
export enum CustomActionTypeSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CustomActionTypeSpecProviderConfigRef
 */
export interface CustomActionTypeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomActionTypeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomActionTypeSpecProviderConfigRef#policy
   */
  readonly policy?: CustomActionTypeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomActionTypeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecProviderConfigRef(obj: CustomActionTypeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomActionTypeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsTo
 */
export interface CustomActionTypeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CustomActionTypeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CustomActionTypeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecPublishConnectionDetailsTo(obj: CustomActionTypeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CustomActionTypeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CustomActionTypeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CustomActionTypeSpecWriteConnectionSecretToRef
 */
export interface CustomActionTypeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CustomActionTypeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CustomActionTypeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecWriteConnectionSecretToRef(obj: CustomActionTypeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecForProviderConfigurationProperty
 */
export interface CustomActionTypeSpecForProviderConfigurationProperty {
  /**
   * The description of the action configuration property.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#description
   */
  readonly description?: string;

  /**
   * Whether the configuration property is a key.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#key
   */
  readonly key?: boolean;

  /**
   * The name of the action configuration property.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#name
   */
  readonly name?: string;

  /**
   * Indicates that the property will be used in conjunction with PollForJobs.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#queryable
   */
  readonly queryable?: boolean;

  /**
   * Whether the configuration property is a required value.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#required
   */
  readonly required?: boolean;

  /**
   * Whether the configuration property is secret.
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#secret
   */
  readonly secret?: boolean;

  /**
   * The type of the configuration property. Valid values: String, Number, Boolean
   *
   * @schema CustomActionTypeSpecForProviderConfigurationProperty#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecForProviderConfigurationProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecForProviderConfigurationProperty(obj: CustomActionTypeSpecForProviderConfigurationProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'key': obj.key,
    'name': obj.name,
    'queryable': obj.queryable,
    'required': obj.required,
    'secret': obj.secret,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecForProviderInputArtifactDetails
 */
export interface CustomActionTypeSpecForProviderInputArtifactDetails {
  /**
   * The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecForProviderInputArtifactDetails#maximumCount
   */
  readonly maximumCount?: number;

  /**
   * The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecForProviderInputArtifactDetails#minimumCount
   */
  readonly minimumCount?: number;

}

/**
 * Converts an object of type 'CustomActionTypeSpecForProviderInputArtifactDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecForProviderInputArtifactDetails(obj: CustomActionTypeSpecForProviderInputArtifactDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumCount': obj.maximumCount,
    'minimumCount': obj.minimumCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecForProviderOutputArtifactDetails
 */
export interface CustomActionTypeSpecForProviderOutputArtifactDetails {
  /**
   * The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecForProviderOutputArtifactDetails#maximumCount
   */
  readonly maximumCount?: number;

  /**
   * The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecForProviderOutputArtifactDetails#minimumCount
   */
  readonly minimumCount?: number;

}

/**
 * Converts an object of type 'CustomActionTypeSpecForProviderOutputArtifactDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecForProviderOutputArtifactDetails(obj: CustomActionTypeSpecForProviderOutputArtifactDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumCount': obj.maximumCount,
    'minimumCount': obj.minimumCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecForProviderSettings
 */
export interface CustomActionTypeSpecForProviderSettings {
  /**
   * The URL returned to the AWS CodePipeline console that provides a deep link to the resources of the external system.
   *
   * @schema CustomActionTypeSpecForProviderSettings#entityUrlTemplate
   */
  readonly entityUrlTemplate?: string;

  /**
   * The URL returned to the AWS CodePipeline console that contains a link to the top-level landing page for the external system.
   *
   * @schema CustomActionTypeSpecForProviderSettings#executionUrlTemplate
   */
  readonly executionUrlTemplate?: string;

  /**
   * The URL returned to the AWS CodePipeline console that contains a link to the page where customers can update or change the configuration of the external action.
   *
   * @schema CustomActionTypeSpecForProviderSettings#revisionUrlTemplate
   */
  readonly revisionUrlTemplate?: string;

  /**
   * The URL of a sign-up page where users can sign up for an external service and perform initial configuration of the action provided by that service.
   *
   * @schema CustomActionTypeSpecForProviderSettings#thirdPartyConfigurationUrl
   */
  readonly thirdPartyConfigurationUrl?: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecForProviderSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecForProviderSettings(obj: CustomActionTypeSpecForProviderSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entityUrlTemplate': obj.entityUrlTemplate,
    'executionUrlTemplate': obj.executionUrlTemplate,
    'revisionUrlTemplate': obj.revisionUrlTemplate,
    'thirdPartyConfigurationUrl': obj.thirdPartyConfigurationUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecInitProviderConfigurationProperty
 */
export interface CustomActionTypeSpecInitProviderConfigurationProperty {
  /**
   * The description of the action configuration property.
   *
   * @schema CustomActionTypeSpecInitProviderConfigurationProperty#description
   */
  readonly description?: string;

  /**
   * Whether the configuration property is a key.
   *
   * @schema CustomActionTypeSpecInitProviderConfigurationProperty#key
   */
  readonly key?: boolean;

  /**
   * The name of the action configuration property.
   *
   * @schema CustomActionTypeSpecInitProviderConfigurationProperty#name
   */
  readonly name?: string;

  /**
   * Indicates that the property will be used in conjunction with PollForJobs.
   *
   * @schema CustomActionTypeSpecInitProviderConfigurationProperty#queryable
   */
  readonly queryable?: boolean;

  /**
   * Whether the configuration property is a required value.
   *
   * @schema CustomActionTypeSpecInitProviderConfigurationProperty#required
   */
  readonly required?: boolean;

  /**
   * Whether the configuration property is secret.
   *
   * @schema CustomActionTypeSpecInitProviderConfigurationProperty#secret
   */
  readonly secret?: boolean;

  /**
   * The type of the configuration property. Valid values: String, Number, Boolean
   *
   * @schema CustomActionTypeSpecInitProviderConfigurationProperty#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecInitProviderConfigurationProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecInitProviderConfigurationProperty(obj: CustomActionTypeSpecInitProviderConfigurationProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'key': obj.key,
    'name': obj.name,
    'queryable': obj.queryable,
    'required': obj.required,
    'secret': obj.secret,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecInitProviderInputArtifactDetails
 */
export interface CustomActionTypeSpecInitProviderInputArtifactDetails {
  /**
   * The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecInitProviderInputArtifactDetails#maximumCount
   */
  readonly maximumCount?: number;

  /**
   * The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecInitProviderInputArtifactDetails#minimumCount
   */
  readonly minimumCount?: number;

}

/**
 * Converts an object of type 'CustomActionTypeSpecInitProviderInputArtifactDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecInitProviderInputArtifactDetails(obj: CustomActionTypeSpecInitProviderInputArtifactDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumCount': obj.maximumCount,
    'minimumCount': obj.minimumCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecInitProviderOutputArtifactDetails
 */
export interface CustomActionTypeSpecInitProviderOutputArtifactDetails {
  /**
   * The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecInitProviderOutputArtifactDetails#maximumCount
   */
  readonly maximumCount?: number;

  /**
   * The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
   *
   * @schema CustomActionTypeSpecInitProviderOutputArtifactDetails#minimumCount
   */
  readonly minimumCount?: number;

}

/**
 * Converts an object of type 'CustomActionTypeSpecInitProviderOutputArtifactDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecInitProviderOutputArtifactDetails(obj: CustomActionTypeSpecInitProviderOutputArtifactDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumCount': obj.maximumCount,
    'minimumCount': obj.minimumCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomActionTypeSpecInitProviderSettings
 */
export interface CustomActionTypeSpecInitProviderSettings {
  /**
   * The URL returned to the AWS CodePipeline console that provides a deep link to the resources of the external system.
   *
   * @schema CustomActionTypeSpecInitProviderSettings#entityUrlTemplate
   */
  readonly entityUrlTemplate?: string;

  /**
   * The URL returned to the AWS CodePipeline console that contains a link to the top-level landing page for the external system.
   *
   * @schema CustomActionTypeSpecInitProviderSettings#executionUrlTemplate
   */
  readonly executionUrlTemplate?: string;

  /**
   * The URL returned to the AWS CodePipeline console that contains a link to the page where customers can update or change the configuration of the external action.
   *
   * @schema CustomActionTypeSpecInitProviderSettings#revisionUrlTemplate
   */
  readonly revisionUrlTemplate?: string;

  /**
   * The URL of a sign-up page where users can sign up for an external service and perform initial configuration of the action provided by that service.
   *
   * @schema CustomActionTypeSpecInitProviderSettings#thirdPartyConfigurationUrl
   */
  readonly thirdPartyConfigurationUrl?: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecInitProviderSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecInitProviderSettings(obj: CustomActionTypeSpecInitProviderSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entityUrlTemplate': obj.entityUrlTemplate,
    'executionUrlTemplate': obj.executionUrlTemplate,
    'revisionUrlTemplate': obj.revisionUrlTemplate,
    'thirdPartyConfigurationUrl': obj.thirdPartyConfigurationUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomActionTypeSpecProviderConfigRefPolicy
 */
export interface CustomActionTypeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomActionTypeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CustomActionTypeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomActionTypeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CustomActionTypeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomActionTypeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecProviderConfigRefPolicy(obj: CustomActionTypeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRef
 */
export interface CustomActionTypeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomActionTypeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecPublishConnectionDetailsToConfigRef(obj: CustomActionTypeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsToMetadata
 */
export interface CustomActionTypeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomActionTypeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecPublishConnectionDetailsToMetadata(obj: CustomActionTypeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomActionTypeSpecProviderConfigRefPolicyResolution
 */
export enum CustomActionTypeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomActionTypeSpecProviderConfigRefPolicyResolve
 */
export enum CustomActionTypeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy(obj: CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CustomActionTypeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Webhook is the Schema for the Webhooks API. Provides a CodePipeline Webhook
 *
 * @schema Webhook
 */
export class Webhook extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Webhook"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'codepipeline.aws.upbound.io/v1beta1',
    kind: 'Webhook',
  }

  /**
   * Renders a Kubernetes manifest for "Webhook".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WebhookProps): any {
    return {
      ...Webhook.GVK,
      ...toJson_WebhookProps(props),
    };
  }

  /**
   * Defines a "Webhook" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WebhookProps) {
    super(scope, id, {
      ...Webhook.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Webhook.GVK,
      ...toJson_WebhookProps(resolved),
    };
  }
}

/**
 * Webhook is the Schema for the Webhooks API. Provides a CodePipeline Webhook
 *
 * @schema Webhook
 */
export interface WebhookProps {
  /**
   * @schema Webhook#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WebhookSpec defines the desired state of Webhook
   *
   * @schema Webhook#spec
   */
  readonly spec: WebhookSpec;

}

/**
 * Converts an object of type 'WebhookProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookProps(obj: WebhookProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WebhookSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebhookSpec defines the desired state of Webhook
 *
 * @schema WebhookSpec
 */
export interface WebhookSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WebhookSpec#deletionPolicy
   */
  readonly deletionPolicy?: WebhookSpecDeletionPolicy;

  /**
   * @schema WebhookSpec#forProvider
   */
  readonly forProvider: WebhookSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema WebhookSpec#initProvider
   */
  readonly initProvider?: WebhookSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WebhookSpec#managementPolicies
   */
  readonly managementPolicies?: WebhookSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WebhookSpec#providerConfigRef
   */
  readonly providerConfigRef?: WebhookSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WebhookSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WebhookSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WebhookSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WebhookSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WebhookSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpec(obj: WebhookSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WebhookSpecForProvider(obj.forProvider),
    'initProvider': toJson_WebhookSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WebhookSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WebhookSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WebhookSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WebhookSpecDeletionPolicy
 */
export enum WebhookSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WebhookSpecForProvider
 */
export interface WebhookSpecForProvider {
  /**
   * The type of authentication  to use. One of IP, GITHUB_HMAC, or UNAUTHENTICATED.
   *
   * @schema WebhookSpecForProvider#authentication
   */
  readonly authentication?: string;

  /**
   * An auth block. Required for IP and GITHUB_HMAC. Auth blocks are documented below.
   *
   * @schema WebhookSpecForProvider#authenticationConfiguration
   */
  readonly authenticationConfiguration?: WebhookSpecForProviderAuthenticationConfiguration[];

  /**
   * One or more filter blocks. Filter blocks are documented below.
   *
   * @schema WebhookSpecForProvider#filter
   */
  readonly filter?: WebhookSpecForProviderFilter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WebhookSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WebhookSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The name of the action in a pipeline you want to connect to the webhook. The action must be from the source (first) stage of the pipeline.
   *
   * @schema WebhookSpecForProvider#targetAction
   */
  readonly targetAction?: string;

  /**
   * The name of the pipeline.
   *
   * @schema WebhookSpecForProvider#targetPipeline
   */
  readonly targetPipeline?: string;

  /**
   * Reference to a Codepipeline in codepipeline to populate targetPipeline.
   *
   * @schema WebhookSpecForProvider#targetPipelineRef
   */
  readonly targetPipelineRef?: WebhookSpecForProviderTargetPipelineRef;

  /**
   * Selector for a Codepipeline in codepipeline to populate targetPipeline.
   *
   * @schema WebhookSpecForProvider#targetPipelineSelector
   */
  readonly targetPipelineSelector?: WebhookSpecForProviderTargetPipelineSelector;

}

/**
 * Converts an object of type 'WebhookSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProvider(obj: WebhookSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': obj.authentication,
    'authenticationConfiguration': obj.authenticationConfiguration?.map(y => toJson_WebhookSpecForProviderAuthenticationConfiguration(y)),
    'filter': obj.filter?.map(y => toJson_WebhookSpecForProviderFilter(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetAction': obj.targetAction,
    'targetPipeline': obj.targetPipeline,
    'targetPipelineRef': toJson_WebhookSpecForProviderTargetPipelineRef(obj.targetPipelineRef),
    'targetPipelineSelector': toJson_WebhookSpecForProviderTargetPipelineSelector(obj.targetPipelineSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema WebhookSpecInitProvider
 */
export interface WebhookSpecInitProvider {
  /**
   * The type of authentication  to use. One of IP, GITHUB_HMAC, or UNAUTHENTICATED.
   *
   * @schema WebhookSpecInitProvider#authentication
   */
  readonly authentication?: string;

  /**
   * An auth block. Required for IP and GITHUB_HMAC. Auth blocks are documented below.
   *
   * @schema WebhookSpecInitProvider#authenticationConfiguration
   */
  readonly authenticationConfiguration?: WebhookSpecInitProviderAuthenticationConfiguration[];

  /**
   * One or more filter blocks. Filter blocks are documented below.
   *
   * @schema WebhookSpecInitProvider#filter
   */
  readonly filter?: WebhookSpecInitProviderFilter[];

  /**
   * Key-value map of resource tags.
   *
   * @schema WebhookSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The name of the action in a pipeline you want to connect to the webhook. The action must be from the source (first) stage of the pipeline.
   *
   * @schema WebhookSpecInitProvider#targetAction
   */
  readonly targetAction?: string;

}

/**
 * Converts an object of type 'WebhookSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecInitProvider(obj: WebhookSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': obj.authentication,
    'authenticationConfiguration': obj.authenticationConfiguration?.map(y => toJson_WebhookSpecInitProviderAuthenticationConfiguration(y)),
    'filter': obj.filter?.map(y => toJson_WebhookSpecInitProviderFilter(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetAction': obj.targetAction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WebhookSpecManagementPolicies
 */
export enum WebhookSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WebhookSpecProviderConfigRef
 */
export interface WebhookSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecProviderConfigRef#policy
   */
  readonly policy?: WebhookSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderConfigRef(obj: WebhookSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WebhookSpecPublishConnectionDetailsTo
 */
export interface WebhookSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WebhookSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WebhookSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WebhookSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsTo(obj: WebhookSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WebhookSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WebhookSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WebhookSpecWriteConnectionSecretToRef
 */
export interface WebhookSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WebhookSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WebhookSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WebhookSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecWriteConnectionSecretToRef(obj: WebhookSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebhookSpecForProviderAuthenticationConfiguration
 */
export interface WebhookSpecForProviderAuthenticationConfiguration {
  /**
   * A valid CIDR block for IP filtering. Required for IP.
   *
   * @schema WebhookSpecForProviderAuthenticationConfiguration#allowedIpRange
   */
  readonly allowedIpRange?: string;

  /**
   * The shared secret for the GitHub repository webhook. Set this as secret in your github_repository_webhook's configuration block. Required for GITHUB_HMAC.
   *
   * @schema WebhookSpecForProviderAuthenticationConfiguration#secretTokenSecretRef
   */
  readonly secretTokenSecretRef?: WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef;

}

/**
 * Converts an object of type 'WebhookSpecForProviderAuthenticationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderAuthenticationConfiguration(obj: WebhookSpecForProviderAuthenticationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpRange': obj.allowedIpRange,
    'secretTokenSecretRef': toJson_WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef(obj.secretTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebhookSpecForProviderFilter
 */
export interface WebhookSpecForProviderFilter {
  /**
   * The JSON path to filter on.
   *
   * @schema WebhookSpecForProviderFilter#jsonPath
   */
  readonly jsonPath?: string;

  /**
   * The value to match on (e.g., refs/heads/{Branch}). See AWS docs for details.
   *
   * @schema WebhookSpecForProviderFilter#matchEquals
   */
  readonly matchEquals?: string;

}

/**
 * Converts an object of type 'WebhookSpecForProviderFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderFilter(obj: WebhookSpecForProviderFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
    'matchEquals': obj.matchEquals,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Codepipeline in codepipeline to populate targetPipeline.
 *
 * @schema WebhookSpecForProviderTargetPipelineRef
 */
export interface WebhookSpecForProviderTargetPipelineRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecForProviderTargetPipelineRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecForProviderTargetPipelineRef#policy
   */
  readonly policy?: WebhookSpecForProviderTargetPipelineRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecForProviderTargetPipelineRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderTargetPipelineRef(obj: WebhookSpecForProviderTargetPipelineRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecForProviderTargetPipelineRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Codepipeline in codepipeline to populate targetPipeline.
 *
 * @schema WebhookSpecForProviderTargetPipelineSelector
 */
export interface WebhookSpecForProviderTargetPipelineSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WebhookSpecForProviderTargetPipelineSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WebhookSpecForProviderTargetPipelineSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WebhookSpecForProviderTargetPipelineSelector#policy
   */
  readonly policy?: WebhookSpecForProviderTargetPipelineSelectorPolicy;

}

/**
 * Converts an object of type 'WebhookSpecForProviderTargetPipelineSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderTargetPipelineSelector(obj: WebhookSpecForProviderTargetPipelineSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WebhookSpecForProviderTargetPipelineSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebhookSpecInitProviderAuthenticationConfiguration
 */
export interface WebhookSpecInitProviderAuthenticationConfiguration {
  /**
   * A valid CIDR block for IP filtering. Required for IP.
   *
   * @schema WebhookSpecInitProviderAuthenticationConfiguration#allowedIpRange
   */
  readonly allowedIpRange?: string;

}

/**
 * Converts an object of type 'WebhookSpecInitProviderAuthenticationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecInitProviderAuthenticationConfiguration(obj: WebhookSpecInitProviderAuthenticationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedIpRange': obj.allowedIpRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebhookSpecInitProviderFilter
 */
export interface WebhookSpecInitProviderFilter {
  /**
   * The JSON path to filter on.
   *
   * @schema WebhookSpecInitProviderFilter#jsonPath
   */
  readonly jsonPath?: string;

  /**
   * The value to match on (e.g., refs/heads/{Branch}). See AWS docs for details.
   *
   * @schema WebhookSpecInitProviderFilter#matchEquals
   */
  readonly matchEquals?: string;

}

/**
 * Converts an object of type 'WebhookSpecInitProviderFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecInitProviderFilter(obj: WebhookSpecInitProviderFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
    'matchEquals': obj.matchEquals,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecProviderConfigRefPolicy
 */
export interface WebhookSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecProviderConfigRefPolicy(obj: WebhookSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRef
 */
export interface WebhookSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WebhookSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToConfigRef(obj: WebhookSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebhookSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WebhookSpecPublishConnectionDetailsToMetadata
 */
export interface WebhookSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WebhookSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToMetadata(obj: WebhookSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The shared secret for the GitHub repository webhook. Set this as secret in your github_repository_webhook's configuration block. Required for GITHUB_HMAC.
 *
 * @schema WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef
 */
export interface WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef {
  /**
   * The key to select.
   *
   * @schema WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef(obj: WebhookSpecForProviderAuthenticationConfigurationSecretTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecForProviderTargetPipelineRefPolicy
 */
export interface WebhookSpecForProviderTargetPipelineRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecForProviderTargetPipelineRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecForProviderTargetPipelineRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecForProviderTargetPipelineRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecForProviderTargetPipelineRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecForProviderTargetPipelineRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderTargetPipelineRefPolicy(obj: WebhookSpecForProviderTargetPipelineRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WebhookSpecForProviderTargetPipelineSelectorPolicy
 */
export interface WebhookSpecForProviderTargetPipelineSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecForProviderTargetPipelineSelectorPolicy#resolution
   */
  readonly resolution?: WebhookSpecForProviderTargetPipelineSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecForProviderTargetPipelineSelectorPolicy#resolve
   */
  readonly resolve?: WebhookSpecForProviderTargetPipelineSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecForProviderTargetPipelineSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecForProviderTargetPipelineSelectorPolicy(obj: WebhookSpecForProviderTargetPipelineSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecProviderConfigRefPolicyResolution
 */
export enum WebhookSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecProviderConfigRefPolicyResolve
 */
export enum WebhookSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WebhookSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebhookSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebhookSpecPublishConnectionDetailsToConfigRefPolicy(obj: WebhookSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecForProviderTargetPipelineRefPolicyResolution
 */
export enum WebhookSpecForProviderTargetPipelineRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecForProviderTargetPipelineRefPolicyResolve
 */
export enum WebhookSpecForProviderTargetPipelineRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecForProviderTargetPipelineSelectorPolicyResolution
 */
export enum WebhookSpecForProviderTargetPipelineSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecForProviderTargetPipelineSelectorPolicyResolve
 */
export enum WebhookSpecForProviderTargetPipelineSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WebhookSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

