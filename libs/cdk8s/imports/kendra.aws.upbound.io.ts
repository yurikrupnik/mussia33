// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DataSource is the Schema for the DataSources API.
 *
 * @schema DataSource
 */
export class DataSource extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DataSource"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kendra.aws.upbound.io/v1beta1',
    kind: 'DataSource',
  }

  /**
   * Renders a Kubernetes manifest for "DataSource".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DataSourceProps): any {
    return {
      ...DataSource.GVK,
      ...toJson_DataSourceProps(props),
    };
  }

  /**
   * Defines a "DataSource" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DataSourceProps) {
    super(scope, id, {
      ...DataSource.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DataSource.GVK,
      ...toJson_DataSourceProps(resolved),
    };
  }
}

/**
 * DataSource is the Schema for the DataSources API.
 *
 * @schema DataSource
 */
export interface DataSourceProps {
  /**
   * @schema DataSource#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DataSourceSpec defines the desired state of DataSource
   *
   * @schema DataSource#spec
   */
  readonly spec: DataSourceSpec;

}

/**
 * Converts an object of type 'DataSourceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceProps(obj: DataSourceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DataSourceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataSourceSpec defines the desired state of DataSource
 *
 * @schema DataSourceSpec
 */
export interface DataSourceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DataSourceSpec#deletionPolicy
   */
  readonly deletionPolicy?: DataSourceSpecDeletionPolicy;

  /**
   * @schema DataSourceSpec#forProvider
   */
  readonly forProvider: DataSourceSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DataSourceSpec#providerConfigRef
   */
  readonly providerConfigRef?: DataSourceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DataSourceSpec#providerRef
   */
  readonly providerRef?: DataSourceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DataSourceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DataSourceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DataSourceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DataSourceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DataSourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpec(obj: DataSourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DataSourceSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DataSourceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DataSourceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DataSourceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DataSourceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DataSourceSpecDeletionPolicy
 */
export enum DataSourceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DataSourceSpecForProvider
 */
export interface DataSourceSpecForProvider {
  /**
   * A block with the configuration information to connect to your Data Source repository. You can't specify the configuration argument when the type parameter is set to CUSTOM. Detailed below.
   *
   * @schema DataSourceSpecForProvider#configuration
   */
  readonly configuration?: DataSourceSpecForProviderConfiguration[];

  /**
   * A block with the configuration information for altering document metadata and content during the document ingestion process. For more information on how to create, modify and delete document metadata, or make other content alterations when you ingest documents into Amazon Kendra, see Customizing document metadata during the ingestion process. Detailed below.
   *
   * @schema DataSourceSpecForProvider#customDocumentEnrichmentConfiguration
   */
  readonly customDocumentEnrichmentConfiguration?: DataSourceSpecForProviderCustomDocumentEnrichmentConfiguration[];

  /**
   * A description for the Data Source connector.
   *
   * @schema DataSourceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The identifier of the index for your Amazon Kendra data_source.
   *
   * @schema DataSourceSpecForProvider#indexId
   */
  readonly indexId?: string;

  /**
   * Reference to a Index in kendra to populate indexId.
   *
   * @schema DataSourceSpecForProvider#indexIdRef
   */
  readonly indexIdRef?: DataSourceSpecForProviderIndexIdRef;

  /**
   * Selector for a Index in kendra to populate indexId.
   *
   * @schema DataSourceSpecForProvider#indexIdSelector
   */
  readonly indexIdSelector?: DataSourceSpecForProviderIndexIdSelector;

  /**
   * The code for a language. This allows you to support a language for all documents when creating the Data Source connector. English is supported by default. For more information on supported languages, including their codes, see Adding documents in languages other than English.
   *
   * @schema DataSourceSpecForProvider#languageCode
   */
  readonly languageCode?: string;

  /**
   * A name for your Data Source connector.
   *
   * @schema DataSourceSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DataSourceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of a role with permission to access the data source connector. For more information, see IAM roles for Amazon Kendra. You can't specify the role_arn parameter when the type parameter is set to CUSTOM. The role_arn parameter is required for all other data sources.
   *
   * @schema DataSourceSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema DataSourceSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: DataSourceSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema DataSourceSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: DataSourceSpecForProviderRoleArnSelector;

  /**
   * Sets the frequency for Amazon Kendra to check the documents in your Data Source repository and update the index. If you don't set a schedule Amazon Kendra will not periodically update the index. You can call the StartDataSourceSyncJob API to update the index.
   *
   * @schema DataSourceSpecForProvider#schedule
   */
  readonly schedule?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DataSourceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The type of data source repository. For an updated list of values, refer to Valid Values for Type.
   *
   * @schema DataSourceSpecForProvider#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProvider(obj: DataSourceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': obj.configuration?.map(y => toJson_DataSourceSpecForProviderConfiguration(y)),
    'customDocumentEnrichmentConfiguration': obj.customDocumentEnrichmentConfiguration?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfiguration(y)),
    'description': obj.description,
    'indexId': obj.indexId,
    'indexIdRef': toJson_DataSourceSpecForProviderIndexIdRef(obj.indexIdRef),
    'indexIdSelector': toJson_DataSourceSpecForProviderIndexIdSelector(obj.indexIdSelector),
    'languageCode': obj.languageCode,
    'name': obj.name,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_DataSourceSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_DataSourceSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'schedule': obj.schedule,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DataSourceSpecProviderConfigRef
 */
export interface DataSourceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataSourceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataSourceSpecProviderConfigRef#policy
   */
  readonly policy?: DataSourceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecProviderConfigRef(obj: DataSourceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataSourceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DataSourceSpecProviderRef
 */
export interface DataSourceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataSourceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataSourceSpecProviderRef#policy
   */
  readonly policy?: DataSourceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecProviderRef(obj: DataSourceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataSourceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DataSourceSpecPublishConnectionDetailsTo
 */
export interface DataSourceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DataSourceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DataSourceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DataSourceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DataSourceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DataSourceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DataSourceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecPublishConnectionDetailsTo(obj: DataSourceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DataSourceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DataSourceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DataSourceSpecWriteConnectionSecretToRef
 */
export interface DataSourceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DataSourceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DataSourceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DataSourceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecWriteConnectionSecretToRef(obj: DataSourceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderConfiguration
 */
export interface DataSourceSpecForProviderConfiguration {
  /**
   * A block that provides the configuration information to connect to an Amazon S3 bucket as your data source. Detailed below.
   *
   * @schema DataSourceSpecForProviderConfiguration#s3Configuration
   */
  readonly s3Configuration?: DataSourceSpecForProviderConfigurationS3Configuration[];

  /**
   * A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below.
   *
   * @schema DataSourceSpecForProviderConfiguration#webCrawlerConfiguration
   */
  readonly webCrawlerConfiguration?: DataSourceSpecForProviderConfigurationWebCrawlerConfiguration[];

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfiguration(obj: DataSourceSpecForProviderConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3Configuration': obj.s3Configuration?.map(y => toJson_DataSourceSpecForProviderConfigurationS3Configuration(y)),
    'webCrawlerConfiguration': obj.webCrawlerConfiguration?.map(y => toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfiguration
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfiguration {
  /**
   * Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of 0 items. Maximum number of 100 items. Detailed below.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfiguration#inlineConfigurations
   */
  readonly inlineConfigurations?: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations[];

  /**
   * A block that specifies the configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfiguration#postExtractionHookConfiguration
   */
  readonly postExtractionHookConfiguration?: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration[];

  /**
   * Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfiguration#preExtractionHookConfiguration
   */
  readonly preExtractionHookConfiguration?: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration[];

  /**
   * The Amazon Resource Name (ARN) of a role with permission to run pre_extraction_hook_configuration and post_extraction_hook_configuration for altering document metadata and content during the document ingestion process. For more information, see IAM roles for Amazon Kendra.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfiguration#roleArn
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfiguration(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inlineConfigurations': obj.inlineConfigurations?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations(y)),
    'postExtractionHookConfiguration': obj.postExtractionHookConfiguration?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration(y)),
    'preExtractionHookConfiguration': obj.preExtractionHookConfiguration?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration(y)),
    'roleArn': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Index in kendra to populate indexId.
 *
 * @schema DataSourceSpecForProviderIndexIdRef
 */
export interface DataSourceSpecForProviderIndexIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataSourceSpecForProviderIndexIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataSourceSpecForProviderIndexIdRef#policy
   */
  readonly policy?: DataSourceSpecForProviderIndexIdRefPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderIndexIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderIndexIdRef(obj: DataSourceSpecForProviderIndexIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataSourceSpecForProviderIndexIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Index in kendra to populate indexId.
 *
 * @schema DataSourceSpecForProviderIndexIdSelector
 */
export interface DataSourceSpecForProviderIndexIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DataSourceSpecForProviderIndexIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DataSourceSpecForProviderIndexIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DataSourceSpecForProviderIndexIdSelector#policy
   */
  readonly policy?: DataSourceSpecForProviderIndexIdSelectorPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderIndexIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderIndexIdSelector(obj: DataSourceSpecForProviderIndexIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DataSourceSpecForProviderIndexIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema DataSourceSpecForProviderRoleArnRef
 */
export interface DataSourceSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataSourceSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataSourceSpecForProviderRoleArnRef#policy
   */
  readonly policy?: DataSourceSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderRoleArnRef(obj: DataSourceSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataSourceSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema DataSourceSpecForProviderRoleArnSelector
 */
export interface DataSourceSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DataSourceSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DataSourceSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DataSourceSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: DataSourceSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderRoleArnSelector(obj: DataSourceSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DataSourceSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataSourceSpecProviderConfigRefPolicy
 */
export interface DataSourceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DataSourceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DataSourceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecProviderConfigRefPolicy(obj: DataSourceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataSourceSpecProviderRefPolicy
 */
export interface DataSourceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DataSourceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DataSourceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecProviderRefPolicy(obj: DataSourceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DataSourceSpecPublishConnectionDetailsToConfigRef
 */
export interface DataSourceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataSourceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataSourceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DataSourceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecPublishConnectionDetailsToConfigRef(obj: DataSourceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataSourceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DataSourceSpecPublishConnectionDetailsToMetadata
 */
export interface DataSourceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataSourceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataSourceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DataSourceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DataSourceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecPublishConnectionDetailsToMetadata(obj: DataSourceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderConfigurationS3Configuration
 */
export interface DataSourceSpecForProviderConfigurationS3Configuration {
  /**
   * A block that provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see Access control for S3 data sources. Detailed below.
   *
   * @schema DataSourceSpecForProviderConfigurationS3Configuration#accessControlListConfiguration
   */
  readonly accessControlListConfiguration?: DataSourceSpecForProviderConfigurationS3ConfigurationAccessControlListConfiguration[];

  /**
   * The name of the bucket that contains the documents.
   *
   * @schema DataSourceSpecForProviderConfigurationS3Configuration#bucketName
   */
  readonly bucketName?: string;

  /**
   * Reference to a Bucket in s3 to populate bucketName.
   *
   * @schema DataSourceSpecForProviderConfigurationS3Configuration#bucketNameRef
   */
  readonly bucketNameRef?: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRef;

  /**
   * Selector for a Bucket in s3 to populate bucketName.
   *
   * @schema DataSourceSpecForProviderConfigurationS3Configuration#bucketNameSelector
   */
  readonly bucketNameSelector?: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelector;

  /**
   * A block that defines the Ddcument metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document. Detailed below.
   *
   * @schema DataSourceSpecForProviderConfigurationS3Configuration#documentsMetadataConfiguration
   */
  readonly documentsMetadataConfiguration?: DataSourceSpecForProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration[];

  /**
   * A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Exclusion Patterns for more examples.
   *
   * @schema DataSourceSpecForProviderConfigurationS3Configuration#exclusionPatterns
   */
  readonly exclusionPatterns?: string[];

  /**
   * A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Inclusion Patterns for more examples.
   *
   * @schema DataSourceSpecForProviderConfigurationS3Configuration#inclusionPatterns
   */
  readonly inclusionPatterns?: string[];

  /**
   * A list of S3 prefixes for the documents that should be included in the index.
   *
   * @schema DataSourceSpecForProviderConfigurationS3Configuration#inclusionPrefixes
   */
  readonly inclusionPrefixes?: string[];

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationS3Configuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationS3Configuration(obj: DataSourceSpecForProviderConfigurationS3Configuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControlListConfiguration': obj.accessControlListConfiguration?.map(y => toJson_DataSourceSpecForProviderConfigurationS3ConfigurationAccessControlListConfiguration(y)),
    'bucketName': obj.bucketName,
    'bucketNameRef': toJson_DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRef(obj.bucketNameRef),
    'bucketNameSelector': toJson_DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelector(obj.bucketNameSelector),
    'documentsMetadataConfiguration': obj.documentsMetadataConfiguration?.map(y => toJson_DataSourceSpecForProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration(y)),
    'exclusionPatterns': obj.exclusionPatterns?.map(y => y),
    'inclusionPatterns': obj.inclusionPatterns?.map(y => y),
    'inclusionPrefixes': obj.inclusionPrefixes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfiguration
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfiguration {
  /**
   * A block with the configuration information required to connect to websites using authentication. You can connect to websites using basic authentication of user name and password. You use a secret in AWS Secrets Manager to store your authentication credentials. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Detailed below.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfiguration#authenticationConfiguration
   */
  readonly authenticationConfiguration?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration[];

  /**
   * Specifies the number of levels in a website that you want to crawl. The first level begins from the website seed or starting point URL. For example, if a website has 3 levels – index level (i.e. seed in this example), sections level, and subsections level – and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1. The default crawl depth is set to 2. Minimum value of 0. Maximum value of 10.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfiguration#crawlDepth
   */
  readonly crawlDepth?: number;

  /**
   * The maximum size (in MB) of a webpage or attachment to crawl. Files larger than this size (in MB) are skipped/not crawled. The default maximum size of a webpage or attachment is set to 50 MB. Minimum value of 1.0e-06. Maximum value of 50.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfiguration#maxContentSizePerPageInMegaBytes
   */
  readonly maxContentSizePerPageInMegaBytes?: number;

  /**
   * The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage. As a website’s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance. The default maximum links per page is 100. Minimum value of 1. Maximum value of 1000.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfiguration#maxLinksPerPage
   */
  readonly maxLinksPerPage?: number;

  /**
   * The maximum number of URLs crawled per website host per minute. The default maximum number of URLs crawled per website host per minute is 300. Minimum value of 1. Maximum value of 300.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfiguration#maxUrlsPerMinuteCrawlRate
   */
  readonly maxUrlsPerMinuteCrawlRate?: number;

  /**
   * Configuration information required to connect to your internal websites via a web proxy. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is "a.example.com" and the port is 443, the standard port for HTTPS. Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in AWS Secrets Manager. Detailed below.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfiguration#proxyConfiguration
   */
  readonly proxyConfiguration?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration[];

  /**
   * A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfiguration#urlExclusionPatterns
   */
  readonly urlExclusionPatterns?: string[];

  /**
   * A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfiguration#urlInclusionPatterns
   */
  readonly urlInclusionPatterns?: string[];

  /**
   * A block that specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl. You can include website subdomains. You can list up to 100 seed URLs and up to 3 sitemap URLs. You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling. When selecting websites to index, you must adhere to the Amazon Acceptable Use Policy and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index. Detailed below.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfiguration#urls
   */
  readonly urls: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrls[];

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfiguration(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationConfiguration': obj.authenticationConfiguration?.map(y => toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration(y)),
    'crawlDepth': obj.crawlDepth,
    'maxContentSizePerPageInMegaBytes': obj.maxContentSizePerPageInMegaBytes,
    'maxLinksPerPage': obj.maxLinksPerPage,
    'maxUrlsPerMinuteCrawlRate': obj.maxUrlsPerMinuteCrawlRate,
    'proxyConfiguration': obj.proxyConfiguration?.map(y => toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration(y)),
    'urlExclusionPatterns': obj.urlExclusionPatterns?.map(y => y),
    'urlInclusionPatterns': obj.urlInclusionPatterns?.map(y => y),
    'urls': obj.urls?.map(y => toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations {
  /**
   * Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. See Document Attribute Condition.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations#condition
   */
  readonly condition?: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition[];

  /**
   * TRUE to delete content if the condition used for the target attribute is met.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations#documentContentDeletion
   */
  readonly documentContentDeletion?: boolean;

  /**
   * Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value. Detailed below.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations#target
   */
  readonly target?: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget[];

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition(y)),
    'documentContentDeletion': obj.documentContentDeletion,
    'target': obj.target?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration {
  /**
   * A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See Document Attribute Condition.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration#invocationCondition
   */
  readonly invocationCondition?: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition[];

  /**
   * The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration#lambdaArn
   */
  readonly lambdaArn: string;

  /**
   * Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration#s3Bucket
   */
  readonly s3Bucket: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invocationCondition': obj.invocationCondition?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition(y)),
    'lambdaArn': obj.lambdaArn,
    's3Bucket': obj.s3Bucket,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration {
  /**
   * A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See Document Attribute Condition.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration#invocationCondition
   */
  readonly invocationCondition?: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition[];

  /**
   * The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration#lambdaArn
   */
  readonly lambdaArn: string;

  /**
   * Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration#s3Bucket
   */
  readonly s3Bucket: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'invocationCondition': obj.invocationCondition?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition(y)),
    'lambdaArn': obj.lambdaArn,
    's3Bucket': obj.s3Bucket,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataSourceSpecForProviderIndexIdRefPolicy
 */
export interface DataSourceSpecForProviderIndexIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecForProviderIndexIdRefPolicy#resolution
   */
  readonly resolution?: DataSourceSpecForProviderIndexIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecForProviderIndexIdRefPolicy#resolve
   */
  readonly resolve?: DataSourceSpecForProviderIndexIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderIndexIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderIndexIdRefPolicy(obj: DataSourceSpecForProviderIndexIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DataSourceSpecForProviderIndexIdSelectorPolicy
 */
export interface DataSourceSpecForProviderIndexIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecForProviderIndexIdSelectorPolicy#resolution
   */
  readonly resolution?: DataSourceSpecForProviderIndexIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecForProviderIndexIdSelectorPolicy#resolve
   */
  readonly resolve?: DataSourceSpecForProviderIndexIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderIndexIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderIndexIdSelectorPolicy(obj: DataSourceSpecForProviderIndexIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataSourceSpecForProviderRoleArnRefPolicy
 */
export interface DataSourceSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: DataSourceSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: DataSourceSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderRoleArnRefPolicy(obj: DataSourceSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DataSourceSpecForProviderRoleArnSelectorPolicy
 */
export interface DataSourceSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DataSourceSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DataSourceSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderRoleArnSelectorPolicy(obj: DataSourceSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecProviderConfigRefPolicyResolution
 */
export enum DataSourceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecProviderConfigRefPolicyResolve
 */
export enum DataSourceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecProviderRefPolicyResolution
 */
export enum DataSourceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecProviderRefPolicyResolve
 */
export enum DataSourceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DataSourceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DataSourceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DataSourceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DataSourceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecPublishConnectionDetailsToConfigRefPolicy(obj: DataSourceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderConfigurationS3ConfigurationAccessControlListConfiguration
 */
export interface DataSourceSpecForProviderConfigurationS3ConfigurationAccessControlListConfiguration {
  /**
   * Path to the AWS S3 bucket that contains the ACL files.
   *
   * @schema DataSourceSpecForProviderConfigurationS3ConfigurationAccessControlListConfiguration#keyPath
   */
  readonly keyPath?: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationS3ConfigurationAccessControlListConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationS3ConfigurationAccessControlListConfiguration(obj: DataSourceSpecForProviderConfigurationS3ConfigurationAccessControlListConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyPath': obj.keyPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucketName.
 *
 * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRef
 */
export interface DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRef#policy
   */
  readonly policy?: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRef(obj: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucketName.
 *
 * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelector
 */
export interface DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelector#policy
   */
  readonly policy?: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelector(obj: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration
 */
export interface DataSourceSpecForProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration {
  /**
   * A prefix used to filter metadata configuration files in the AWS S3 bucket. The S3 bucket might contain multiple metadata files. Use s3_prefix to include only the desired metadata files.
   *
   * @schema DataSourceSpecForProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration#s3Prefix
   */
  readonly s3Prefix?: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration(obj: DataSourceSpecForProviderConfigurationS3ConfigurationDocumentsMetadataConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3Prefix': obj.s3Prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration {
  /**
   * The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration#basicAuthentication
   */
  readonly basicAuthentication?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication[];

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicAuthentication': obj.basicAuthentication?.map(y => toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration {
  /**
   * Your secret ARN, which you can create in AWS Secrets Manager. You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration#credentials
   */
  readonly credentials?: string;

  /**
   * Reference to a Secret in secretsmanager to populate credentials.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration#credentialsRef
   */
  readonly credentialsRef?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef;

  /**
   * Selector for a Secret in secretsmanager to populate credentials.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration#credentialsSelector
   */
  readonly credentialsSelector?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector;

  /**
   * The name of the website host you want to connect to using authentication credentials. For example, the host name of https://a.example.com/page1.html is "a.example.com".
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration#host
   */
  readonly host: string;

  /**
   * The port number of the website host you want to connect to using authentication credentials. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration#port
   */
  readonly port: number;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': obj.credentials,
    'credentialsRef': toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef(obj.credentialsRef),
    'credentialsSelector': toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector(obj.credentialsSelector),
    'host': obj.host,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrls
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrls {
  /**
   * A block that specifies the configuration of the seed or starting point URLs of the websites you want to crawl. You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to. You can list up to 100 seed URLs. Detailed below.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrls#seedUrlConfiguration
   */
  readonly seedUrlConfiguration?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration[];

  /**
   * A block that specifies the configuration of the sitemap URLs of the websites you want to crawl. Only URLs belonging to the same website host names are crawled. You can list up to 3 sitemap URLs. Detailed below.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrls#siteMapsConfiguration
   */
  readonly siteMapsConfiguration?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration[];

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrls(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seedUrlConfiguration': obj.seedUrlConfiguration?.map(y => toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration(y)),
    'siteMapsConfiguration': obj.siteMapsConfiguration?.map(y => toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition {
  /**
   * The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition#conditionDocumentAttributeKey
   */
  readonly conditionDocumentAttributeKey: string;

  /**
   * The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See Document Attribute Value.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition#conditionOnValue
   */
  readonly conditionOnValue?: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue[];

  /**
   * The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition#operator
   */
  readonly operator: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionDocumentAttributeKey': obj.conditionDocumentAttributeKey,
    'conditionOnValue': obj.conditionOnValue?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue(y)),
    'operator': obj.operator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget {
  /**
   * The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget#targetDocumentAttributeKey
   */
  readonly targetDocumentAttributeKey?: string;

  /**
   * The target value you want to create for the target attribute. For example, 'Finance' could be the target value for the target attribute key 'Department'. See Document Attribute Value.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget#targetDocumentAttributeValue
   */
  readonly targetDocumentAttributeValue?: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue[];

  /**
   * TRUE to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to TRUE. To create a target value (TargetDocumentAttributeValue), set this to FALSE.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget#targetDocumentAttributeValueDeletion
   */
  readonly targetDocumentAttributeValueDeletion?: boolean;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetDocumentAttributeKey': obj.targetDocumentAttributeKey,
    'targetDocumentAttributeValue': obj.targetDocumentAttributeValue?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue(y)),
    'targetDocumentAttributeValueDeletion': obj.targetDocumentAttributeValueDeletion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition {
  /**
   * The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition#conditionDocumentAttributeKey
   */
  readonly conditionDocumentAttributeKey: string;

  /**
   * The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See Document Attribute Value.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition#conditionOnValue
   */
  readonly conditionOnValue?: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue[];

  /**
   * The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition#operator
   */
  readonly operator: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionDocumentAttributeKey': obj.conditionDocumentAttributeKey,
    'conditionOnValue': obj.conditionOnValue?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue(y)),
    'operator': obj.operator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition {
  /**
   * The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition#conditionDocumentAttributeKey
   */
  readonly conditionDocumentAttributeKey: string;

  /**
   * The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See Document Attribute Value.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition#conditionOnValue
   */
  readonly conditionOnValue?: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue[];

  /**
   * The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition#operator
   */
  readonly operator: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionDocumentAttributeKey': obj.conditionDocumentAttributeKey,
    'conditionOnValue': obj.conditionOnValue?.map(y => toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue(y)),
    'operator': obj.operator,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecForProviderIndexIdRefPolicyResolution
 */
export enum DataSourceSpecForProviderIndexIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecForProviderIndexIdRefPolicyResolve
 */
export enum DataSourceSpecForProviderIndexIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecForProviderIndexIdSelectorPolicyResolution
 */
export enum DataSourceSpecForProviderIndexIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecForProviderIndexIdSelectorPolicyResolve
 */
export enum DataSourceSpecForProviderIndexIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecForProviderRoleArnRefPolicyResolution
 */
export enum DataSourceSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecForProviderRoleArnRefPolicyResolve
 */
export enum DataSourceSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum DataSourceSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum DataSourceSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DataSourceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DataSourceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicy
 */
export interface DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicy#resolution
   */
  readonly resolution?: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicy#resolve
   */
  readonly resolve?: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicy(obj: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicy
 */
export interface DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicy#resolution
   */
  readonly resolution?: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicy#resolve
   */
  readonly resolve?: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicy(obj: DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication {
  /**
   * Your secret ARN, which you can create in AWS Secrets Manager. You use a secret if basic authentication credentials are required to connect to a website. The secret stores your credentials of user name and password.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication#credentials
   */
  readonly credentials?: string;

  /**
   * Reference to a Secret in secretsmanager to populate credentials.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication#credentialsRef
   */
  readonly credentialsRef?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef;

  /**
   * Selector for a Secret in secretsmanager to populate credentials.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication#credentialsSelector
   */
  readonly credentialsSelector?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector;

  /**
   * The name of the website host you want to connect to using authentication credentials. For example, the host name of https://a.example.com/page1.html is "a.example.com".
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication#host
   */
  readonly host: string;

  /**
   * The port number of the website host you want to connect to using authentication credentials. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication#port
   */
  readonly port: number;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': obj.credentials,
    'credentialsRef': toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef(obj.credentialsRef),
    'credentialsSelector': toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector(obj.credentialsSelector),
    'host': obj.host,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretsmanager to populate credentials.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef#policy
   */
  readonly policy?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretsmanager to populate credentials.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector#policy
   */
  readonly policy?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration {
  /**
   * The list of seed or starting point URLs of the websites you want to crawl. The list can include a maximum of 100 seed URLs. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 2048.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration#seedUrls
   */
  readonly seedUrls: string[];

  /**
   * The default mode is set to HOST_ONLY. You can choose one of the following modes:
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration#webCrawlerMode
   */
  readonly webCrawlerMode?: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSeedUrlConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seedUrls': obj.seedUrls?.map(y => y),
    'webCrawlerMode': obj.webCrawlerMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration {
  /**
   * The list of sitemap URLs of the websites you want to crawl. The list can include a maximum of 3 sitemap URLs.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration#siteMaps
   */
  readonly siteMaps: string[];

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationUrlsSiteMapsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'siteMaps': obj.siteMaps?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue {
  /**
   * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue#dateValue
   */
  readonly dateValue?: string;

  /**
   * A long integer value.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue#longValue
   */
  readonly longValue?: number;

  /**
   * A list of strings.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue#stringListValue
   */
  readonly stringListValue?: string[];

  /**
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue#stringValue
   */
  readonly stringValue?: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsConditionConditionOnValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue,
    'longValue': obj.longValue,
    'stringListValue': obj.stringListValue?.map(y => y),
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue {
  /**
   * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue#dateValue
   */
  readonly dateValue?: string;

  /**
   * A long integer value.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue#longValue
   */
  readonly longValue?: number;

  /**
   * A list of strings.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue#stringListValue
   */
  readonly stringListValue?: string[];

  /**
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue#stringValue
   */
  readonly stringValue?: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationInlineConfigurationsTargetTargetDocumentAttributeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue,
    'longValue': obj.longValue,
    'stringListValue': obj.stringListValue?.map(y => y),
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue {
  /**
   * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue#dateValue
   */
  readonly dateValue?: string;

  /**
   * A long integer value.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue#longValue
   */
  readonly longValue?: number;

  /**
   * A list of strings.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue#stringListValue
   */
  readonly stringListValue?: string[];

  /**
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue#stringValue
   */
  readonly stringValue?: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPostExtractionHookConfigurationInvocationConditionConditionOnValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue,
    'longValue': obj.longValue,
    'stringListValue': obj.stringListValue?.map(y => y),
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue
 */
export interface DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue {
  /**
   * A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue#dateValue
   */
  readonly dateValue?: string;

  /**
   * A long integer value.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue#longValue
   */
  readonly longValue?: number;

  /**
   * A list of strings.
   *
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue#stringListValue
   */
  readonly stringListValue?: string[];

  /**
   * @schema DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue#stringValue
   */
  readonly stringValue?: string;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue(obj: DataSourceSpecForProviderCustomDocumentEnrichmentConfigurationPreExtractionHookConfigurationInvocationConditionConditionOnValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dateValue': obj.dateValue,
    'longValue': obj.longValue,
    'stringListValue': obj.stringListValue?.map(y => y),
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicyResolution
 */
export enum DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicyResolve
 */
export enum DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolution
 */
export enum DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolve
 */
export enum DataSourceSpecForProviderConfigurationS3ConfigurationBucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Secret in secretsmanager to populate credentials.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef#policy
   */
  readonly policy?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretsmanager to populate credentials.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector#policy
   */
  readonly policy?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy#resolution
   */
  readonly resolution?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy#resolve
   */
  readonly resolve?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy#resolution
   */
  readonly resolution?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy#resolve
   */
  readonly resolve?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy#resolution
   */
  readonly resolution?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy#resolve
   */
  readonly resolve?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy
 */
export interface DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy#resolution
   */
  readonly resolution?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy#resolve
   */
  readonly resolve?: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy(obj: DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolution
 */
export enum DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolve
 */
export enum DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolution
 */
export enum DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolve
 */
export enum DataSourceSpecForProviderConfigurationWebCrawlerConfigurationProxyConfigurationCredentialsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolution
 */
export enum DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolve
 */
export enum DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolution
 */
export enum DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolve
 */
export enum DataSourceSpecForProviderConfigurationWebCrawlerConfigurationAuthenticationConfigurationBasicAuthenticationCredentialsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Experience is the Schema for the Experiences API.
 *
 * @schema Experience
 */
export class Experience extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Experience"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kendra.aws.upbound.io/v1beta1',
    kind: 'Experience',
  }

  /**
   * Renders a Kubernetes manifest for "Experience".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExperienceProps): any {
    return {
      ...Experience.GVK,
      ...toJson_ExperienceProps(props),
    };
  }

  /**
   * Defines a "Experience" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExperienceProps) {
    super(scope, id, {
      ...Experience.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Experience.GVK,
      ...toJson_ExperienceProps(resolved),
    };
  }
}

/**
 * Experience is the Schema for the Experiences API.
 *
 * @schema Experience
 */
export interface ExperienceProps {
  /**
   * @schema Experience#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExperienceSpec defines the desired state of Experience
   *
   * @schema Experience#spec
   */
  readonly spec: ExperienceSpec;

}

/**
 * Converts an object of type 'ExperienceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceProps(obj: ExperienceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExperienceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExperienceSpec defines the desired state of Experience
 *
 * @schema ExperienceSpec
 */
export interface ExperienceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ExperienceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ExperienceSpecDeletionPolicy;

  /**
   * @schema ExperienceSpec#forProvider
   */
  readonly forProvider: ExperienceSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ExperienceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ExperienceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ExperienceSpec#providerRef
   */
  readonly providerRef?: ExperienceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ExperienceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ExperienceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ExperienceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ExperienceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ExperienceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpec(obj: ExperienceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ExperienceSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ExperienceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ExperienceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ExperienceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ExperienceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ExperienceSpecDeletionPolicy
 */
export enum ExperienceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ExperienceSpecForProvider
 */
export interface ExperienceSpecForProvider {
  /**
   * Configuration information for your Amazon Kendra experience. Detailed below.
   *
   * @schema ExperienceSpecForProvider#configuration
   */
  readonly configuration?: ExperienceSpecForProviderConfiguration[];

  /**
   * A description for your Amazon Kendra experience.
   *
   * @schema ExperienceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The identifier of the index for your Amazon Kendra experience.
   *
   * @schema ExperienceSpecForProvider#indexId
   */
  readonly indexId?: string;

  /**
   * Reference to a Index in kendra to populate indexId.
   *
   * @schema ExperienceSpecForProvider#indexIdRef
   */
  readonly indexIdRef?: ExperienceSpecForProviderIndexIdRef;

  /**
   * Selector for a Index in kendra to populate indexId.
   *
   * @schema ExperienceSpecForProvider#indexIdSelector
   */
  readonly indexIdSelector?: ExperienceSpecForProviderIndexIdSelector;

  /**
   * A name for your Amazon Kendra experience.
   *
   * @schema ExperienceSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ExperienceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of a role with permission to access Query API, QuerySuggestions API, SubmitFeedback API, and AWS SSO that stores your user and group information. For more information, see IAM roles for Amazon Kendra.
   *
   * @schema ExperienceSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ExperienceSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ExperienceSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ExperienceSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ExperienceSpecForProviderRoleArnSelector;

}

/**
 * Converts an object of type 'ExperienceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProvider(obj: ExperienceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': obj.configuration?.map(y => toJson_ExperienceSpecForProviderConfiguration(y)),
    'description': obj.description,
    'indexId': obj.indexId,
    'indexIdRef': toJson_ExperienceSpecForProviderIndexIdRef(obj.indexIdRef),
    'indexIdSelector': toJson_ExperienceSpecForProviderIndexIdSelector(obj.indexIdSelector),
    'name': obj.name,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ExperienceSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ExperienceSpecForProviderRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ExperienceSpecProviderConfigRef
 */
export interface ExperienceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExperienceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExperienceSpecProviderConfigRef#policy
   */
  readonly policy?: ExperienceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ExperienceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecProviderConfigRef(obj: ExperienceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExperienceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ExperienceSpecProviderRef
 */
export interface ExperienceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExperienceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExperienceSpecProviderRef#policy
   */
  readonly policy?: ExperienceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ExperienceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecProviderRef(obj: ExperienceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExperienceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ExperienceSpecPublishConnectionDetailsTo
 */
export interface ExperienceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ExperienceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ExperienceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ExperienceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ExperienceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ExperienceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExperienceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecPublishConnectionDetailsTo(obj: ExperienceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ExperienceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ExperienceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ExperienceSpecWriteConnectionSecretToRef
 */
export interface ExperienceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ExperienceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ExperienceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ExperienceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecWriteConnectionSecretToRef(obj: ExperienceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExperienceSpecForProviderConfiguration
 */
export interface ExperienceSpecForProviderConfiguration {
  /**
   * The identifiers of your data sources and FAQs. Or, you can specify that you want to use documents indexed via the BatchPutDocument API. Detailed below.
   *
   * @schema ExperienceSpecForProviderConfiguration#contentSourceConfiguration
   */
  readonly contentSourceConfiguration?: ExperienceSpecForProviderConfigurationContentSourceConfiguration[];

  /**
   * The AWS SSO field name that contains the identifiers of your users, such as their emails. Detailed below.
   *
   * @schema ExperienceSpecForProviderConfiguration#userIdentityConfiguration
   */
  readonly userIdentityConfiguration?: ExperienceSpecForProviderConfigurationUserIdentityConfiguration[];

}

/**
 * Converts an object of type 'ExperienceSpecForProviderConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProviderConfiguration(obj: ExperienceSpecForProviderConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentSourceConfiguration': obj.contentSourceConfiguration?.map(y => toJson_ExperienceSpecForProviderConfigurationContentSourceConfiguration(y)),
    'userIdentityConfiguration': obj.userIdentityConfiguration?.map(y => toJson_ExperienceSpecForProviderConfigurationUserIdentityConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Index in kendra to populate indexId.
 *
 * @schema ExperienceSpecForProviderIndexIdRef
 */
export interface ExperienceSpecForProviderIndexIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExperienceSpecForProviderIndexIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExperienceSpecForProviderIndexIdRef#policy
   */
  readonly policy?: ExperienceSpecForProviderIndexIdRefPolicy;

}

/**
 * Converts an object of type 'ExperienceSpecForProviderIndexIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProviderIndexIdRef(obj: ExperienceSpecForProviderIndexIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExperienceSpecForProviderIndexIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Index in kendra to populate indexId.
 *
 * @schema ExperienceSpecForProviderIndexIdSelector
 */
export interface ExperienceSpecForProviderIndexIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ExperienceSpecForProviderIndexIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ExperienceSpecForProviderIndexIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ExperienceSpecForProviderIndexIdSelector#policy
   */
  readonly policy?: ExperienceSpecForProviderIndexIdSelectorPolicy;

}

/**
 * Converts an object of type 'ExperienceSpecForProviderIndexIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProviderIndexIdSelector(obj: ExperienceSpecForProviderIndexIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ExperienceSpecForProviderIndexIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ExperienceSpecForProviderRoleArnRef
 */
export interface ExperienceSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExperienceSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExperienceSpecForProviderRoleArnRef#policy
   */
  readonly policy?: ExperienceSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ExperienceSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProviderRoleArnRef(obj: ExperienceSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExperienceSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ExperienceSpecForProviderRoleArnSelector
 */
export interface ExperienceSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ExperienceSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ExperienceSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ExperienceSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ExperienceSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ExperienceSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProviderRoleArnSelector(obj: ExperienceSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ExperienceSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExperienceSpecProviderConfigRefPolicy
 */
export interface ExperienceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperienceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ExperienceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperienceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ExperienceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ExperienceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecProviderConfigRefPolicy(obj: ExperienceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExperienceSpecProviderRefPolicy
 */
export interface ExperienceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperienceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ExperienceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperienceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ExperienceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ExperienceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecProviderRefPolicy(obj: ExperienceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ExperienceSpecPublishConnectionDetailsToConfigRef
 */
export interface ExperienceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ExperienceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ExperienceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ExperienceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ExperienceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecPublishConnectionDetailsToConfigRef(obj: ExperienceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ExperienceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ExperienceSpecPublishConnectionDetailsToMetadata
 */
export interface ExperienceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ExperienceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ExperienceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ExperienceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ExperienceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecPublishConnectionDetailsToMetadata(obj: ExperienceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExperienceSpecForProviderConfigurationContentSourceConfiguration
 */
export interface ExperienceSpecForProviderConfigurationContentSourceConfiguration {
  /**
   * The identifiers of the data sources you want to use for your Amazon Kendra experience. Maximum number of 100 items.
   *
   * @schema ExperienceSpecForProviderConfigurationContentSourceConfiguration#dataSourceIds
   */
  readonly dataSourceIds?: string[];

  /**
   * Whether to use documents you indexed directly using the BatchPutDocument API. Defaults to false.
   *
   * @default false.
   * @schema ExperienceSpecForProviderConfigurationContentSourceConfiguration#directPutContent
   */
  readonly directPutContent?: boolean;

  /**
   * The identifier of the FAQs that you want to use for your Amazon Kendra experience. Maximum number of 100 items.
   *
   * @schema ExperienceSpecForProviderConfigurationContentSourceConfiguration#faqIds
   */
  readonly faqIds?: string[];

}

/**
 * Converts an object of type 'ExperienceSpecForProviderConfigurationContentSourceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProviderConfigurationContentSourceConfiguration(obj: ExperienceSpecForProviderConfigurationContentSourceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataSourceIds': obj.dataSourceIds?.map(y => y),
    'directPutContent': obj.directPutContent,
    'faqIds': obj.faqIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ExperienceSpecForProviderConfigurationUserIdentityConfiguration
 */
export interface ExperienceSpecForProviderConfigurationUserIdentityConfiguration {
  /**
   * The AWS SSO field name that contains the identifiers of your users, such as their emails.
   *
   * @schema ExperienceSpecForProviderConfigurationUserIdentityConfiguration#identityAttributeName
   */
  readonly identityAttributeName: string;

}

/**
 * Converts an object of type 'ExperienceSpecForProviderConfigurationUserIdentityConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProviderConfigurationUserIdentityConfiguration(obj: ExperienceSpecForProviderConfigurationUserIdentityConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identityAttributeName': obj.identityAttributeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExperienceSpecForProviderIndexIdRefPolicy
 */
export interface ExperienceSpecForProviderIndexIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperienceSpecForProviderIndexIdRefPolicy#resolution
   */
  readonly resolution?: ExperienceSpecForProviderIndexIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperienceSpecForProviderIndexIdRefPolicy#resolve
   */
  readonly resolve?: ExperienceSpecForProviderIndexIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ExperienceSpecForProviderIndexIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProviderIndexIdRefPolicy(obj: ExperienceSpecForProviderIndexIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ExperienceSpecForProviderIndexIdSelectorPolicy
 */
export interface ExperienceSpecForProviderIndexIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperienceSpecForProviderIndexIdSelectorPolicy#resolution
   */
  readonly resolution?: ExperienceSpecForProviderIndexIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperienceSpecForProviderIndexIdSelectorPolicy#resolve
   */
  readonly resolve?: ExperienceSpecForProviderIndexIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ExperienceSpecForProviderIndexIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProviderIndexIdSelectorPolicy(obj: ExperienceSpecForProviderIndexIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ExperienceSpecForProviderRoleArnRefPolicy
 */
export interface ExperienceSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperienceSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ExperienceSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperienceSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ExperienceSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ExperienceSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProviderRoleArnRefPolicy(obj: ExperienceSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ExperienceSpecForProviderRoleArnSelectorPolicy
 */
export interface ExperienceSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperienceSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ExperienceSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperienceSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ExperienceSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ExperienceSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecForProviderRoleArnSelectorPolicy(obj: ExperienceSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperienceSpecProviderConfigRefPolicyResolution
 */
export enum ExperienceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperienceSpecProviderConfigRefPolicyResolve
 */
export enum ExperienceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperienceSpecProviderRefPolicyResolution
 */
export enum ExperienceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperienceSpecProviderRefPolicyResolve
 */
export enum ExperienceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ExperienceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ExperienceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ExperienceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ExperienceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ExperienceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ExperienceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ExperienceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExperienceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ExperienceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperienceSpecForProviderIndexIdRefPolicyResolution
 */
export enum ExperienceSpecForProviderIndexIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperienceSpecForProviderIndexIdRefPolicyResolve
 */
export enum ExperienceSpecForProviderIndexIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperienceSpecForProviderIndexIdSelectorPolicyResolution
 */
export enum ExperienceSpecForProviderIndexIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperienceSpecForProviderIndexIdSelectorPolicyResolve
 */
export enum ExperienceSpecForProviderIndexIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperienceSpecForProviderRoleArnRefPolicyResolution
 */
export enum ExperienceSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperienceSpecForProviderRoleArnRefPolicyResolve
 */
export enum ExperienceSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperienceSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ExperienceSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperienceSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ExperienceSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ExperienceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ExperienceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ExperienceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ExperienceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Index is the Schema for the Indexs API. Provides an Amazon Kendra Index resource.
 *
 * @schema Index
 */
export class Index extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Index"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kendra.aws.upbound.io/v1beta1',
    kind: 'Index',
  }

  /**
   * Renders a Kubernetes manifest for "Index".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IndexProps): any {
    return {
      ...Index.GVK,
      ...toJson_IndexProps(props),
    };
  }

  /**
   * Defines a "Index" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IndexProps) {
    super(scope, id, {
      ...Index.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Index.GVK,
      ...toJson_IndexProps(resolved),
    };
  }
}

/**
 * Index is the Schema for the Indexs API. Provides an Amazon Kendra Index resource.
 *
 * @schema Index
 */
export interface IndexProps {
  /**
   * @schema Index#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IndexSpec defines the desired state of Index
   *
   * @schema Index#spec
   */
  readonly spec: IndexSpec;

}

/**
 * Converts an object of type 'IndexProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexProps(obj: IndexProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IndexSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IndexSpec defines the desired state of Index
 *
 * @schema IndexSpec
 */
export interface IndexSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema IndexSpec#deletionPolicy
   */
  readonly deletionPolicy?: IndexSpecDeletionPolicy;

  /**
   * @schema IndexSpec#forProvider
   */
  readonly forProvider: IndexSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IndexSpec#providerConfigRef
   */
  readonly providerConfigRef?: IndexSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IndexSpec#providerRef
   */
  readonly providerRef?: IndexSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IndexSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IndexSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IndexSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IndexSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IndexSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpec(obj: IndexSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IndexSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_IndexSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IndexSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IndexSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IndexSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema IndexSpecDeletionPolicy
 */
export enum IndexSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IndexSpecForProvider
 */
export interface IndexSpecForProvider {
  /**
   * A block that sets the number of additional document storage and query capacity units that should be used by the index. Detailed below.
   *
   * @schema IndexSpecForProvider#capacityUnits
   */
  readonly capacityUnits?: IndexSpecForProviderCapacityUnits[];

  /**
   * The description of the Index.
   *
   * @schema IndexSpecForProvider#description
   */
  readonly description?: string;

  /**
   * One or more blocks that specify the configuration settings for any metadata applied to the documents in the index. Minimum number of 0 items. Maximum number of 500 items. If specified, you must define all elements, including those that are provided by default. These index fields are documented at Amazon Kendra Index documentation. For an example resource that defines these default index fields, refer to the default example above. For an example resource that appends additional index fields, refer to the append example above. All arguments for each block must be specified. Note that blocks cannot be removed since index fields cannot be deleted. This argument is detailed below.
   *
   * @schema IndexSpecForProvider#documentMetadataConfigurationUpdates
   */
  readonly documentMetadataConfigurationUpdates?: IndexSpecForProviderDocumentMetadataConfigurationUpdates[];

  /**
   * The Amazon Kendra edition to use for the index. Choose DEVELOPER_EDITION for indexes intended for development, testing, or proof of concept. Use ENTERPRISE_EDITION for your production databases. Once you set the edition for an index, it can't be changed. Defaults to ENTERPRISE_EDITION
   *
   * @default ENTERPRISE_EDITION
   * @schema IndexSpecForProvider#edition
   */
  readonly edition?: string;

  /**
   * Specifies the name of the Index.
   *
   * @schema IndexSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IndexSpecForProvider#region
   */
  readonly region: string;

  /**
   * An AWS Identity and Access Management (IAM) role that gives Amazon Kendra permissions to access your Amazon CloudWatch logs and metrics. This is also the role you use when you call the BatchPutDocument API to index documents from an Amazon S3 bucket.
   *
   * @schema IndexSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema IndexSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: IndexSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema IndexSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: IndexSpecForProviderRoleArnSelector;

  /**
   * A block that specifies the identifier of the AWS KMS customer managed key (CMK) that's used to encrypt data indexed by Amazon Kendra. Amazon Kendra doesn't support asymmetric CMKs. Detailed below.
   *
   * @schema IndexSpecForProvider#serverSideEncryptionConfiguration
   */
  readonly serverSideEncryptionConfiguration?: IndexSpecForProviderServerSideEncryptionConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema IndexSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The user context policy. Valid values are ATTRIBUTE_FILTER or USER_TOKEN. For more information, refer to UserContextPolicy. Defaults to ATTRIBUTE_FILTER.
   *
   * @default ATTRIBUTE_FILTER.
   * @schema IndexSpecForProvider#userContextPolicy
   */
  readonly userContextPolicy?: string;

  /**
   * A block that enables fetching access levels of groups and users from an AWS Single Sign-On identity source. To configure this, see UserGroupResolutionConfiguration. Detailed below.
   *
   * @schema IndexSpecForProvider#userGroupResolutionConfiguration
   */
  readonly userGroupResolutionConfiguration?: IndexSpecForProviderUserGroupResolutionConfiguration[];

  /**
   * A block that specifies the user token configuration. Detailed below.
   *
   * @schema IndexSpecForProvider#userTokenConfigurations
   */
  readonly userTokenConfigurations?: IndexSpecForProviderUserTokenConfigurations[];

}

/**
 * Converts an object of type 'IndexSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProvider(obj: IndexSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityUnits': obj.capacityUnits?.map(y => toJson_IndexSpecForProviderCapacityUnits(y)),
    'description': obj.description,
    'documentMetadataConfigurationUpdates': obj.documentMetadataConfigurationUpdates?.map(y => toJson_IndexSpecForProviderDocumentMetadataConfigurationUpdates(y)),
    'edition': obj.edition,
    'name': obj.name,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_IndexSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_IndexSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'serverSideEncryptionConfiguration': obj.serverSideEncryptionConfiguration?.map(y => toJson_IndexSpecForProviderServerSideEncryptionConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'userContextPolicy': obj.userContextPolicy,
    'userGroupResolutionConfiguration': obj.userGroupResolutionConfiguration?.map(y => toJson_IndexSpecForProviderUserGroupResolutionConfiguration(y)),
    'userTokenConfigurations': obj.userTokenConfigurations?.map(y => toJson_IndexSpecForProviderUserTokenConfigurations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IndexSpecProviderConfigRef
 */
export interface IndexSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IndexSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IndexSpecProviderConfigRef#policy
   */
  readonly policy?: IndexSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IndexSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecProviderConfigRef(obj: IndexSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IndexSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IndexSpecProviderRef
 */
export interface IndexSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IndexSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IndexSpecProviderRef#policy
   */
  readonly policy?: IndexSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IndexSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecProviderRef(obj: IndexSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IndexSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IndexSpecPublishConnectionDetailsTo
 */
export interface IndexSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IndexSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IndexSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IndexSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IndexSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IndexSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IndexSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecPublishConnectionDetailsTo(obj: IndexSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IndexSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IndexSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IndexSpecWriteConnectionSecretToRef
 */
export interface IndexSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IndexSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IndexSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IndexSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecWriteConnectionSecretToRef(obj: IndexSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexSpecForProviderCapacityUnits
 */
export interface IndexSpecForProviderCapacityUnits {
  /**
   * The amount of extra query capacity for an index and GetQuerySuggestions capacity. For more information, refer to QueryCapacityUnits.
   *
   * @schema IndexSpecForProviderCapacityUnits#queryCapacityUnits
   */
  readonly queryCapacityUnits?: number;

  /**
   * The amount of extra storage capacity for an index. A single capacity unit provides 30 GB of storage space or 100,000 documents, whichever is reached first. Minimum value of 0.
   *
   * @schema IndexSpecForProviderCapacityUnits#storageCapacityUnits
   */
  readonly storageCapacityUnits?: number;

}

/**
 * Converts an object of type 'IndexSpecForProviderCapacityUnits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderCapacityUnits(obj: IndexSpecForProviderCapacityUnits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'queryCapacityUnits': obj.queryCapacityUnits,
    'storageCapacityUnits': obj.storageCapacityUnits,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdates
 */
export interface IndexSpecForProviderDocumentMetadataConfigurationUpdates {
  /**
   * The name of the index field. Minimum length of 1. Maximum length of 30.
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdates#name
   */
  readonly name: string;

  /**
   * A block that provides manual tuning parameters to determine how the field affects the search results. Detailed below
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdates#relevance
   */
  readonly relevance?: IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance[];

  /**
   * A block that provides information about how the field is used during a search. Documented below. Detailed below
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdates#search
   */
  readonly search?: IndexSpecForProviderDocumentMetadataConfigurationUpdatesSearch[];

  /**
   * The data type of the index field. Valid values are STRING_VALUE, STRING_LIST_VALUE, LONG_VALUE, DATE_VALUE.
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdates#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'IndexSpecForProviderDocumentMetadataConfigurationUpdates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderDocumentMetadataConfigurationUpdates(obj: IndexSpecForProviderDocumentMetadataConfigurationUpdates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'relevance': obj.relevance?.map(y => toJson_IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance(y)),
    'search': obj.search?.map(y => toJson_IndexSpecForProviderDocumentMetadataConfigurationUpdatesSearch(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema IndexSpecForProviderRoleArnRef
 */
export interface IndexSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema IndexSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IndexSpecForProviderRoleArnRef#policy
   */
  readonly policy?: IndexSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'IndexSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderRoleArnRef(obj: IndexSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IndexSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema IndexSpecForProviderRoleArnSelector
 */
export interface IndexSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IndexSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IndexSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IndexSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: IndexSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'IndexSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderRoleArnSelector(obj: IndexSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IndexSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexSpecForProviderServerSideEncryptionConfiguration
 */
export interface IndexSpecForProviderServerSideEncryptionConfiguration {
  /**
   * The identifier of the AWS KMScustomer master key (CMK). Amazon Kendra doesn't support asymmetric CMKs.
   *
   * @schema IndexSpecForProviderServerSideEncryptionConfiguration#kmsKeyId
   */
  readonly kmsKeyId?: string;

}

/**
 * Converts an object of type 'IndexSpecForProviderServerSideEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderServerSideEncryptionConfiguration(obj: IndexSpecForProviderServerSideEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexSpecForProviderUserGroupResolutionConfiguration
 */
export interface IndexSpecForProviderUserGroupResolutionConfiguration {
  /**
   * The identity store provider (mode) you want to use to fetch access levels of groups and users. AWS Single Sign-On is currently the only available mode. Your users and groups must exist in an AWS SSO identity source in order to use this mode. Valid Values are AWS_SSO or NONE.
   *
   * @schema IndexSpecForProviderUserGroupResolutionConfiguration#userGroupResolutionMode
   */
  readonly userGroupResolutionMode: string;

}

/**
 * Converts an object of type 'IndexSpecForProviderUserGroupResolutionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderUserGroupResolutionConfiguration(obj: IndexSpecForProviderUserGroupResolutionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'userGroupResolutionMode': obj.userGroupResolutionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexSpecForProviderUserTokenConfigurations
 */
export interface IndexSpecForProviderUserTokenConfigurations {
  /**
   * A block that specifies the information about the JSON token type configuration. Detailed below.
   *
   * @schema IndexSpecForProviderUserTokenConfigurations#jsonTokenTypeConfiguration
   */
  readonly jsonTokenTypeConfiguration?: IndexSpecForProviderUserTokenConfigurationsJsonTokenTypeConfiguration[];

  /**
   * A block that specifies the information about the JWT token type configuration. Detailed below.
   *
   * @schema IndexSpecForProviderUserTokenConfigurations#jwtTokenTypeConfiguration
   */
  readonly jwtTokenTypeConfiguration?: IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration[];

}

/**
 * Converts an object of type 'IndexSpecForProviderUserTokenConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderUserTokenConfigurations(obj: IndexSpecForProviderUserTokenConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonTokenTypeConfiguration': obj.jsonTokenTypeConfiguration?.map(y => toJson_IndexSpecForProviderUserTokenConfigurationsJsonTokenTypeConfiguration(y)),
    'jwtTokenTypeConfiguration': obj.jwtTokenTypeConfiguration?.map(y => toJson_IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IndexSpecProviderConfigRefPolicy
 */
export interface IndexSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IndexSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IndexSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IndexSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IndexSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IndexSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecProviderConfigRefPolicy(obj: IndexSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IndexSpecProviderRefPolicy
 */
export interface IndexSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IndexSpecProviderRefPolicy#resolution
   */
  readonly resolution?: IndexSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IndexSpecProviderRefPolicy#resolve
   */
  readonly resolve?: IndexSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IndexSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecProviderRefPolicy(obj: IndexSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IndexSpecPublishConnectionDetailsToConfigRef
 */
export interface IndexSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IndexSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IndexSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IndexSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IndexSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecPublishConnectionDetailsToConfigRef(obj: IndexSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IndexSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IndexSpecPublishConnectionDetailsToMetadata
 */
export interface IndexSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IndexSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IndexSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IndexSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IndexSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecPublishConnectionDetailsToMetadata(obj: IndexSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance
 */
export interface IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance {
  /**
   * Specifies the time period that the boost applies to. For more information, refer to Duration.
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance#duration
   */
  readonly duration?: string;

  /**
   * Indicates that this field determines how "fresh" a document is. For more information, refer to Freshness.
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance#freshness
   */
  readonly freshness?: boolean;

  /**
   * The relative importance of the field in the search. Larger numbers provide more of a boost than smaller numbers. Minimum value of 1. Maximum value of 10.
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance#importance
   */
  readonly importance?: number;

  /**
   * Determines how values should be interpreted. For more information, refer to RankOrder.
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance#rankOrder
   */
  readonly rankOrder?: string;

  /**
   * A list of values that should be given a different boost when they appear in the result list. For more information, refer to ValueImportanceMap.
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance#valuesImportanceMap
   */
  readonly valuesImportanceMap?: { [key: string]: number };

}

/**
 * Converts an object of type 'IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance(obj: IndexSpecForProviderDocumentMetadataConfigurationUpdatesRelevance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'duration': obj.duration,
    'freshness': obj.freshness,
    'importance': obj.importance,
    'rankOrder': obj.rankOrder,
    'valuesImportanceMap': ((obj.valuesImportanceMap) === undefined) ? undefined : (Object.entries(obj.valuesImportanceMap).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdatesSearch
 */
export interface IndexSpecForProviderDocumentMetadataConfigurationUpdatesSearch {
  /**
   * Determines whether the field is returned in the query response. The default is true.
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdatesSearch#displayable
   */
  readonly displayable?: boolean;

  /**
   * Indicates that the field can be used to create search facets, a count of results for each value in the field. The default is false.
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdatesSearch#facetable
   */
  readonly facetable?: boolean;

  /**
   * Determines whether the field is used in the search. If the Searchable field is true, you can use relevance tuning to manually tune how Amazon Kendra weights the field in the search. The default is true for string fields and false for number and date fields.
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdatesSearch#searchable
   */
  readonly searchable?: boolean;

  /**
   * Determines whether the field can be used to sort the results of a query. If you specify sorting on a field that does not have Sortable set to true, Amazon Kendra returns an exception. The default is false.
   *
   * @schema IndexSpecForProviderDocumentMetadataConfigurationUpdatesSearch#sortable
   */
  readonly sortable?: boolean;

}

/**
 * Converts an object of type 'IndexSpecForProviderDocumentMetadataConfigurationUpdatesSearch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderDocumentMetadataConfigurationUpdatesSearch(obj: IndexSpecForProviderDocumentMetadataConfigurationUpdatesSearch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayable': obj.displayable,
    'facetable': obj.facetable,
    'searchable': obj.searchable,
    'sortable': obj.sortable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IndexSpecForProviderRoleArnRefPolicy
 */
export interface IndexSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IndexSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: IndexSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IndexSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: IndexSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'IndexSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderRoleArnRefPolicy(obj: IndexSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IndexSpecForProviderRoleArnSelectorPolicy
 */
export interface IndexSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IndexSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: IndexSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IndexSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: IndexSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IndexSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderRoleArnSelectorPolicy(obj: IndexSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexSpecForProviderUserTokenConfigurationsJsonTokenTypeConfiguration
 */
export interface IndexSpecForProviderUserTokenConfigurationsJsonTokenTypeConfiguration {
  /**
   * The group attribute field. Minimum length of 1. Maximum length of 2048.
   *
   * @schema IndexSpecForProviderUserTokenConfigurationsJsonTokenTypeConfiguration#groupAttributeField
   */
  readonly groupAttributeField: string;

  /**
   * The user name attribute field. Minimum length of 1. Maximum length of 2048.
   *
   * @schema IndexSpecForProviderUserTokenConfigurationsJsonTokenTypeConfiguration#userNameAttributeField
   */
  readonly userNameAttributeField: string;

}

/**
 * Converts an object of type 'IndexSpecForProviderUserTokenConfigurationsJsonTokenTypeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderUserTokenConfigurationsJsonTokenTypeConfiguration(obj: IndexSpecForProviderUserTokenConfigurationsJsonTokenTypeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupAttributeField': obj.groupAttributeField,
    'userNameAttributeField': obj.userNameAttributeField,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration
 */
export interface IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration {
  /**
   * The regular expression that identifies the claim. Minimum length of 1. Maximum length of 100.
   *
   * @schema IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration#claimRegex
   */
  readonly claimRegex?: string;

  /**
   * The group attribute field. Minimum length of 1. Maximum length of 2048.
   *
   * @schema IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration#groupAttributeField
   */
  readonly groupAttributeField?: string;

  /**
   * The issuer of the token. Minimum length of 1. Maximum length of 65.
   *
   * @schema IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration#issuer
   */
  readonly issuer?: string;

  /**
   * The location of the key. Valid values are URL or SECRET_MANAGER
   *
   * @schema IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration#keyLocation
   */
  readonly keyLocation: string;

  /**
   * The Amazon Resource Name (ARN) of the secret.
   *
   * @schema IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration#secretsManagerArn
   */
  readonly secretsManagerArn?: string;

  /**
   * The signing key URL. Valid pattern is ^(https?|ftp|file):\/\/([^\s]*)
   *
   * @schema IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration#url
   */
  readonly url?: string;

  /**
   * The user name attribute field. Minimum length of 1. Maximum length of 2048.
   *
   * @schema IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration#userNameAttributeField
   */
  readonly userNameAttributeField?: string;

}

/**
 * Converts an object of type 'IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration(obj: IndexSpecForProviderUserTokenConfigurationsJwtTokenTypeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimRegex': obj.claimRegex,
    'groupAttributeField': obj.groupAttributeField,
    'issuer': obj.issuer,
    'keyLocation': obj.keyLocation,
    'secretsManagerArn': obj.secretsManagerArn,
    'url': obj.url,
    'userNameAttributeField': obj.userNameAttributeField,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IndexSpecProviderConfigRefPolicyResolution
 */
export enum IndexSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IndexSpecProviderConfigRefPolicyResolve
 */
export enum IndexSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IndexSpecProviderRefPolicyResolution
 */
export enum IndexSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IndexSpecProviderRefPolicyResolve
 */
export enum IndexSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IndexSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IndexSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IndexSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IndexSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IndexSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IndexSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IndexSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IndexSpecPublishConnectionDetailsToConfigRefPolicy(obj: IndexSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IndexSpecForProviderRoleArnRefPolicyResolution
 */
export enum IndexSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IndexSpecForProviderRoleArnRefPolicyResolve
 */
export enum IndexSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IndexSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum IndexSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IndexSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum IndexSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IndexSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IndexSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IndexSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IndexSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * QuerySuggestionsBlockList is the Schema for the QuerySuggestionsBlockLists API. Upbound official provider resource for managing an aws kendra block list used for query suggestions for an index
 *
 * @schema QuerySuggestionsBlockList
 */
export class QuerySuggestionsBlockList extends ApiObject {
  /**
   * Returns the apiVersion and kind for "QuerySuggestionsBlockList"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kendra.aws.upbound.io/v1beta1',
    kind: 'QuerySuggestionsBlockList',
  }

  /**
   * Renders a Kubernetes manifest for "QuerySuggestionsBlockList".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: QuerySuggestionsBlockListProps): any {
    return {
      ...QuerySuggestionsBlockList.GVK,
      ...toJson_QuerySuggestionsBlockListProps(props),
    };
  }

  /**
   * Defines a "QuerySuggestionsBlockList" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: QuerySuggestionsBlockListProps) {
    super(scope, id, {
      ...QuerySuggestionsBlockList.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...QuerySuggestionsBlockList.GVK,
      ...toJson_QuerySuggestionsBlockListProps(resolved),
    };
  }
}

/**
 * QuerySuggestionsBlockList is the Schema for the QuerySuggestionsBlockLists API. Upbound official provider resource for managing an aws kendra block list used for query suggestions for an index
 *
 * @schema QuerySuggestionsBlockList
 */
export interface QuerySuggestionsBlockListProps {
  /**
   * @schema QuerySuggestionsBlockList#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * QuerySuggestionsBlockListSpec defines the desired state of QuerySuggestionsBlockList
   *
   * @schema QuerySuggestionsBlockList#spec
   */
  readonly spec: QuerySuggestionsBlockListSpec;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListProps(obj: QuerySuggestionsBlockListProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_QuerySuggestionsBlockListSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QuerySuggestionsBlockListSpec defines the desired state of QuerySuggestionsBlockList
 *
 * @schema QuerySuggestionsBlockListSpec
 */
export interface QuerySuggestionsBlockListSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema QuerySuggestionsBlockListSpec#deletionPolicy
   */
  readonly deletionPolicy?: QuerySuggestionsBlockListSpecDeletionPolicy;

  /**
   * @schema QuerySuggestionsBlockListSpec#forProvider
   */
  readonly forProvider: QuerySuggestionsBlockListSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema QuerySuggestionsBlockListSpec#providerConfigRef
   */
  readonly providerConfigRef?: QuerySuggestionsBlockListSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema QuerySuggestionsBlockListSpec#providerRef
   */
  readonly providerRef?: QuerySuggestionsBlockListSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema QuerySuggestionsBlockListSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: QuerySuggestionsBlockListSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema QuerySuggestionsBlockListSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: QuerySuggestionsBlockListSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpec(obj: QuerySuggestionsBlockListSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_QuerySuggestionsBlockListSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_QuerySuggestionsBlockListSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_QuerySuggestionsBlockListSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_QuerySuggestionsBlockListSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_QuerySuggestionsBlockListSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema QuerySuggestionsBlockListSpecDeletionPolicy
 */
export enum QuerySuggestionsBlockListSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema QuerySuggestionsBlockListSpecForProvider
 */
export interface QuerySuggestionsBlockListSpecForProvider {
  /**
   * The description for a block list.
   *
   * @schema QuerySuggestionsBlockListSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The identifier of the index for a block list.
   *
   * @schema QuerySuggestionsBlockListSpecForProvider#indexId
   */
  readonly indexId?: string;

  /**
   * Reference to a Index in kendra to populate indexId.
   *
   * @schema QuerySuggestionsBlockListSpecForProvider#indexIdRef
   */
  readonly indexIdRef?: QuerySuggestionsBlockListSpecForProviderIndexIdRef;

  /**
   * Selector for a Index in kendra to populate indexId.
   *
   * @schema QuerySuggestionsBlockListSpecForProvider#indexIdSelector
   */
  readonly indexIdSelector?: QuerySuggestionsBlockListSpecForProviderIndexIdSelector;

  /**
   * The name for the block list.
   *
   * @schema QuerySuggestionsBlockListSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema QuerySuggestionsBlockListSpecForProvider#region
   */
  readonly region: string;

  /**
   * The IAM (Identity and Access Management) role used to access the block list text file in S3.
   *
   * @schema QuerySuggestionsBlockListSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema QuerySuggestionsBlockListSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: QuerySuggestionsBlockListSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema QuerySuggestionsBlockListSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: QuerySuggestionsBlockListSpecForProviderRoleArnSelector;

  /**
   * The S3 path where your block list text file sits in S3. Detailed below.
   *
   * @schema QuerySuggestionsBlockListSpecForProvider#sourceS3Path
   */
  readonly sourceS3Path: QuerySuggestionsBlockListSpecForProviderSourceS3Path[];

  /**
   * Key-value map of resource tags. If configured with a provider default_tags configuration block present, tags with matching keys will overwrite those defined at the provider-level.
   *
   * @schema QuerySuggestionsBlockListSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProvider(obj: QuerySuggestionsBlockListSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'indexId': obj.indexId,
    'indexIdRef': toJson_QuerySuggestionsBlockListSpecForProviderIndexIdRef(obj.indexIdRef),
    'indexIdSelector': toJson_QuerySuggestionsBlockListSpecForProviderIndexIdSelector(obj.indexIdSelector),
    'name': obj.name,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_QuerySuggestionsBlockListSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_QuerySuggestionsBlockListSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'sourceS3Path': obj.sourceS3Path?.map(y => toJson_QuerySuggestionsBlockListSpecForProviderSourceS3Path(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema QuerySuggestionsBlockListSpecProviderConfigRef
 */
export interface QuerySuggestionsBlockListSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QuerySuggestionsBlockListSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QuerySuggestionsBlockListSpecProviderConfigRef#policy
   */
  readonly policy?: QuerySuggestionsBlockListSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecProviderConfigRef(obj: QuerySuggestionsBlockListSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QuerySuggestionsBlockListSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema QuerySuggestionsBlockListSpecProviderRef
 */
export interface QuerySuggestionsBlockListSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema QuerySuggestionsBlockListSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QuerySuggestionsBlockListSpecProviderRef#policy
   */
  readonly policy?: QuerySuggestionsBlockListSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecProviderRef(obj: QuerySuggestionsBlockListSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QuerySuggestionsBlockListSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsTo
 */
export interface QuerySuggestionsBlockListSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: QuerySuggestionsBlockListSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecPublishConnectionDetailsTo(obj: QuerySuggestionsBlockListSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_QuerySuggestionsBlockListSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema QuerySuggestionsBlockListSpecWriteConnectionSecretToRef
 */
export interface QuerySuggestionsBlockListSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema QuerySuggestionsBlockListSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema QuerySuggestionsBlockListSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecWriteConnectionSecretToRef(obj: QuerySuggestionsBlockListSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Index in kendra to populate indexId.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderIndexIdRef
 */
export interface QuerySuggestionsBlockListSpecForProviderIndexIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderIndexIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderIndexIdRef#policy
   */
  readonly policy?: QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicy;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderIndexIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderIndexIdRef(obj: QuerySuggestionsBlockListSpecForProviderIndexIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Index in kendra to populate indexId.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderIndexIdSelector
 */
export interface QuerySuggestionsBlockListSpecForProviderIndexIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderIndexIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderIndexIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderIndexIdSelector#policy
   */
  readonly policy?: QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicy;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderIndexIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderIndexIdSelector(obj: QuerySuggestionsBlockListSpecForProviderIndexIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderRoleArnRef
 */
export interface QuerySuggestionsBlockListSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderRoleArnRef#policy
   */
  readonly policy?: QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderRoleArnRef(obj: QuerySuggestionsBlockListSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderRoleArnSelector
 */
export interface QuerySuggestionsBlockListSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderRoleArnSelector(obj: QuerySuggestionsBlockListSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema QuerySuggestionsBlockListSpecForProviderSourceS3Path
 */
export interface QuerySuggestionsBlockListSpecForProviderSourceS3Path {
  /**
   * The name of the S3 bucket that contains the file.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3Path#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3Path#bucketRef
   */
  readonly bucketRef?: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3Path#bucketSelector
   */
  readonly bucketSelector?: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelector;

  /**
   * The name of the file.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3Path#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderSourceS3Path' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderSourceS3Path(obj: QuerySuggestionsBlockListSpecForProviderSourceS3Path | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRef(obj.bucketRef),
    'bucketSelector': toJson_QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelector(obj.bucketSelector),
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QuerySuggestionsBlockListSpecProviderConfigRefPolicy
 */
export interface QuerySuggestionsBlockListSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuerySuggestionsBlockListSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: QuerySuggestionsBlockListSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuerySuggestionsBlockListSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: QuerySuggestionsBlockListSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecProviderConfigRefPolicy(obj: QuerySuggestionsBlockListSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QuerySuggestionsBlockListSpecProviderRefPolicy
 */
export interface QuerySuggestionsBlockListSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuerySuggestionsBlockListSpecProviderRefPolicy#resolution
   */
  readonly resolution?: QuerySuggestionsBlockListSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuerySuggestionsBlockListSpecProviderRefPolicy#resolve
   */
  readonly resolve?: QuerySuggestionsBlockListSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecProviderRefPolicy(obj: QuerySuggestionsBlockListSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRef
 */
export interface QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRef(obj: QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToMetadata
 */
export interface QuerySuggestionsBlockListSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecPublishConnectionDetailsToMetadata(obj: QuerySuggestionsBlockListSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicy
 */
export interface QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicy#resolution
   */
  readonly resolution?: QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicy#resolve
   */
  readonly resolve?: QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicyResolve;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicy(obj: QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicy
 */
export interface QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicy#resolution
   */
  readonly resolution?: QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicy#resolve
   */
  readonly resolve?: QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicy(obj: QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicy
 */
export interface QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicy(obj: QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicy
 */
export interface QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicy(obj: QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRef
 */
export interface QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRef#policy
   */
  readonly policy?: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicy;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRef(obj: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelector
 */
export interface QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelector#policy
   */
  readonly policy?: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicy;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelector(obj: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuerySuggestionsBlockListSpecProviderConfigRefPolicyResolution
 */
export enum QuerySuggestionsBlockListSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuerySuggestionsBlockListSpecProviderConfigRefPolicyResolve
 */
export enum QuerySuggestionsBlockListSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuerySuggestionsBlockListSpecProviderRefPolicyResolution
 */
export enum QuerySuggestionsBlockListSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuerySuggestionsBlockListSpecProviderRefPolicyResolve
 */
export enum QuerySuggestionsBlockListSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicy(obj: QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicyResolution
 */
export enum QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicyResolve
 */
export enum QuerySuggestionsBlockListSpecForProviderIndexIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicyResolution
 */
export enum QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicyResolve
 */
export enum QuerySuggestionsBlockListSpecForProviderIndexIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicyResolution
 */
export enum QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicyResolve
 */
export enum QuerySuggestionsBlockListSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum QuerySuggestionsBlockListSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicy
 */
export interface QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicy#resolution
   */
  readonly resolution?: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicy#resolve
   */
  readonly resolve?: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicy(obj: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicy
 */
export interface QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicy#resolution
   */
  readonly resolution?: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicy#resolve
   */
  readonly resolve?: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicy(obj: QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum QuerySuggestionsBlockListSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicyResolution
 */
export enum QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicyResolve
 */
export enum QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicyResolution
 */
export enum QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicyResolve
 */
export enum QuerySuggestionsBlockListSpecForProviderSourceS3PathBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Thesaurus is the Schema for the Thesauruss API.
 *
 * @schema Thesaurus
 */
export class Thesaurus extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Thesaurus"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kendra.aws.upbound.io/v1beta1',
    kind: 'Thesaurus',
  }

  /**
   * Renders a Kubernetes manifest for "Thesaurus".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ThesaurusProps): any {
    return {
      ...Thesaurus.GVK,
      ...toJson_ThesaurusProps(props),
    };
  }

  /**
   * Defines a "Thesaurus" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ThesaurusProps) {
    super(scope, id, {
      ...Thesaurus.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Thesaurus.GVK,
      ...toJson_ThesaurusProps(resolved),
    };
  }
}

/**
 * Thesaurus is the Schema for the Thesauruss API.
 *
 * @schema Thesaurus
 */
export interface ThesaurusProps {
  /**
   * @schema Thesaurus#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ThesaurusSpec defines the desired state of Thesaurus
   *
   * @schema Thesaurus#spec
   */
  readonly spec: ThesaurusSpec;

}

/**
 * Converts an object of type 'ThesaurusProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusProps(obj: ThesaurusProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ThesaurusSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ThesaurusSpec defines the desired state of Thesaurus
 *
 * @schema ThesaurusSpec
 */
export interface ThesaurusSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ThesaurusSpec#deletionPolicy
   */
  readonly deletionPolicy?: ThesaurusSpecDeletionPolicy;

  /**
   * @schema ThesaurusSpec#forProvider
   */
  readonly forProvider: ThesaurusSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ThesaurusSpec#providerConfigRef
   */
  readonly providerConfigRef?: ThesaurusSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ThesaurusSpec#providerRef
   */
  readonly providerRef?: ThesaurusSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ThesaurusSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ThesaurusSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ThesaurusSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ThesaurusSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ThesaurusSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpec(obj: ThesaurusSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ThesaurusSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ThesaurusSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ThesaurusSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ThesaurusSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ThesaurusSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ThesaurusSpecDeletionPolicy
 */
export enum ThesaurusSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ThesaurusSpecForProvider
 */
export interface ThesaurusSpecForProvider {
  /**
   * The description for a thesaurus.
   *
   * @schema ThesaurusSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The identifier of the index for a thesaurus.
   *
   * @schema ThesaurusSpecForProvider#indexId
   */
  readonly indexId?: string;

  /**
   * Reference to a Index in kendra to populate indexId.
   *
   * @schema ThesaurusSpecForProvider#indexIdRef
   */
  readonly indexIdRef?: ThesaurusSpecForProviderIndexIdRef;

  /**
   * Selector for a Index in kendra to populate indexId.
   *
   * @schema ThesaurusSpecForProvider#indexIdSelector
   */
  readonly indexIdSelector?: ThesaurusSpecForProviderIndexIdSelector;

  /**
   * The name for the thesaurus.
   *
   * @schema ThesaurusSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ThesaurusSpecForProvider#region
   */
  readonly region: string;

  /**
   * The IAM (Identity and Access Management) role used to access the thesaurus file in S3.
   *
   * @schema ThesaurusSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ThesaurusSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ThesaurusSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ThesaurusSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ThesaurusSpecForProviderRoleArnSelector;

  /**
   * The S3 path where your thesaurus file sits in S3. Detailed below.
   *
   * @schema ThesaurusSpecForProvider#sourceS3Path
   */
  readonly sourceS3Path: ThesaurusSpecForProviderSourceS3Path[];

  /**
   * Key-value map of resource tags. If configured with a provider default_tags configuration block present, tags with matching keys will overwrite those defined at the provider-level.
   *
   * @schema ThesaurusSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ThesaurusSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProvider(obj: ThesaurusSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'indexId': obj.indexId,
    'indexIdRef': toJson_ThesaurusSpecForProviderIndexIdRef(obj.indexIdRef),
    'indexIdSelector': toJson_ThesaurusSpecForProviderIndexIdSelector(obj.indexIdSelector),
    'name': obj.name,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ThesaurusSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ThesaurusSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'sourceS3Path': obj.sourceS3Path?.map(y => toJson_ThesaurusSpecForProviderSourceS3Path(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ThesaurusSpecProviderConfigRef
 */
export interface ThesaurusSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThesaurusSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThesaurusSpecProviderConfigRef#policy
   */
  readonly policy?: ThesaurusSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ThesaurusSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecProviderConfigRef(obj: ThesaurusSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThesaurusSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ThesaurusSpecProviderRef
 */
export interface ThesaurusSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThesaurusSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThesaurusSpecProviderRef#policy
   */
  readonly policy?: ThesaurusSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ThesaurusSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecProviderRef(obj: ThesaurusSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThesaurusSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ThesaurusSpecPublishConnectionDetailsTo
 */
export interface ThesaurusSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ThesaurusSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ThesaurusSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ThesaurusSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ThesaurusSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ThesaurusSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ThesaurusSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecPublishConnectionDetailsTo(obj: ThesaurusSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ThesaurusSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ThesaurusSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ThesaurusSpecWriteConnectionSecretToRef
 */
export interface ThesaurusSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ThesaurusSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ThesaurusSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ThesaurusSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecWriteConnectionSecretToRef(obj: ThesaurusSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Index in kendra to populate indexId.
 *
 * @schema ThesaurusSpecForProviderIndexIdRef
 */
export interface ThesaurusSpecForProviderIndexIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThesaurusSpecForProviderIndexIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThesaurusSpecForProviderIndexIdRef#policy
   */
  readonly policy?: ThesaurusSpecForProviderIndexIdRefPolicy;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderIndexIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderIndexIdRef(obj: ThesaurusSpecForProviderIndexIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThesaurusSpecForProviderIndexIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Index in kendra to populate indexId.
 *
 * @schema ThesaurusSpecForProviderIndexIdSelector
 */
export interface ThesaurusSpecForProviderIndexIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ThesaurusSpecForProviderIndexIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ThesaurusSpecForProviderIndexIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ThesaurusSpecForProviderIndexIdSelector#policy
   */
  readonly policy?: ThesaurusSpecForProviderIndexIdSelectorPolicy;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderIndexIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderIndexIdSelector(obj: ThesaurusSpecForProviderIndexIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ThesaurusSpecForProviderIndexIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ThesaurusSpecForProviderRoleArnRef
 */
export interface ThesaurusSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThesaurusSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThesaurusSpecForProviderRoleArnRef#policy
   */
  readonly policy?: ThesaurusSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderRoleArnRef(obj: ThesaurusSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThesaurusSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ThesaurusSpecForProviderRoleArnSelector
 */
export interface ThesaurusSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ThesaurusSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ThesaurusSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ThesaurusSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ThesaurusSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderRoleArnSelector(obj: ThesaurusSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ThesaurusSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThesaurusSpecForProviderSourceS3Path
 */
export interface ThesaurusSpecForProviderSourceS3Path {
  /**
   * The name of the S3 bucket that contains the file.
   *
   * @schema ThesaurusSpecForProviderSourceS3Path#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema ThesaurusSpecForProviderSourceS3Path#bucketRef
   */
  readonly bucketRef?: ThesaurusSpecForProviderSourceS3PathBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema ThesaurusSpecForProviderSourceS3Path#bucketSelector
   */
  readonly bucketSelector?: ThesaurusSpecForProviderSourceS3PathBucketSelector;

  /**
   * The name of the file.
   *
   * @schema ThesaurusSpecForProviderSourceS3Path#key
   */
  readonly key?: string;

  /**
   * Reference to a Object in s3 to populate key.
   *
   * @schema ThesaurusSpecForProviderSourceS3Path#keyRef
   */
  readonly keyRef?: ThesaurusSpecForProviderSourceS3PathKeyRef;

  /**
   * Selector for a Object in s3 to populate key.
   *
   * @schema ThesaurusSpecForProviderSourceS3Path#keySelector
   */
  readonly keySelector?: ThesaurusSpecForProviderSourceS3PathKeySelector;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderSourceS3Path' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderSourceS3Path(obj: ThesaurusSpecForProviderSourceS3Path | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_ThesaurusSpecForProviderSourceS3PathBucketRef(obj.bucketRef),
    'bucketSelector': toJson_ThesaurusSpecForProviderSourceS3PathBucketSelector(obj.bucketSelector),
    'key': obj.key,
    'keyRef': toJson_ThesaurusSpecForProviderSourceS3PathKeyRef(obj.keyRef),
    'keySelector': toJson_ThesaurusSpecForProviderSourceS3PathKeySelector(obj.keySelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThesaurusSpecProviderConfigRefPolicy
 */
export interface ThesaurusSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThesaurusSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ThesaurusSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThesaurusSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ThesaurusSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThesaurusSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecProviderConfigRefPolicy(obj: ThesaurusSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThesaurusSpecProviderRefPolicy
 */
export interface ThesaurusSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThesaurusSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ThesaurusSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThesaurusSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ThesaurusSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ThesaurusSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecProviderRefPolicy(obj: ThesaurusSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ThesaurusSpecPublishConnectionDetailsToConfigRef
 */
export interface ThesaurusSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThesaurusSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThesaurusSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ThesaurusSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ThesaurusSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecPublishConnectionDetailsToConfigRef(obj: ThesaurusSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThesaurusSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ThesaurusSpecPublishConnectionDetailsToMetadata
 */
export interface ThesaurusSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThesaurusSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ThesaurusSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ThesaurusSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ThesaurusSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecPublishConnectionDetailsToMetadata(obj: ThesaurusSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThesaurusSpecForProviderIndexIdRefPolicy
 */
export interface ThesaurusSpecForProviderIndexIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThesaurusSpecForProviderIndexIdRefPolicy#resolution
   */
  readonly resolution?: ThesaurusSpecForProviderIndexIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThesaurusSpecForProviderIndexIdRefPolicy#resolve
   */
  readonly resolve?: ThesaurusSpecForProviderIndexIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderIndexIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderIndexIdRefPolicy(obj: ThesaurusSpecForProviderIndexIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ThesaurusSpecForProviderIndexIdSelectorPolicy
 */
export interface ThesaurusSpecForProviderIndexIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThesaurusSpecForProviderIndexIdSelectorPolicy#resolution
   */
  readonly resolution?: ThesaurusSpecForProviderIndexIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThesaurusSpecForProviderIndexIdSelectorPolicy#resolve
   */
  readonly resolve?: ThesaurusSpecForProviderIndexIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderIndexIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderIndexIdSelectorPolicy(obj: ThesaurusSpecForProviderIndexIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThesaurusSpecForProviderRoleArnRefPolicy
 */
export interface ThesaurusSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThesaurusSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ThesaurusSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThesaurusSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ThesaurusSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderRoleArnRefPolicy(obj: ThesaurusSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ThesaurusSpecForProviderRoleArnSelectorPolicy
 */
export interface ThesaurusSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThesaurusSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ThesaurusSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThesaurusSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ThesaurusSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderRoleArnSelectorPolicy(obj: ThesaurusSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathBucketRef
 */
export interface ThesaurusSpecForProviderSourceS3PathBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathBucketRef#policy
   */
  readonly policy?: ThesaurusSpecForProviderSourceS3PathBucketRefPolicy;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderSourceS3PathBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderSourceS3PathBucketRef(obj: ThesaurusSpecForProviderSourceS3PathBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThesaurusSpecForProviderSourceS3PathBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathBucketSelector
 */
export interface ThesaurusSpecForProviderSourceS3PathBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathBucketSelector#policy
   */
  readonly policy?: ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicy;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderSourceS3PathBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderSourceS3PathBucketSelector(obj: ThesaurusSpecForProviderSourceS3PathBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Object in s3 to populate key.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathKeyRef
 */
export interface ThesaurusSpecForProviderSourceS3PathKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathKeyRef#policy
   */
  readonly policy?: ThesaurusSpecForProviderSourceS3PathKeyRefPolicy;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderSourceS3PathKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderSourceS3PathKeyRef(obj: ThesaurusSpecForProviderSourceS3PathKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ThesaurusSpecForProviderSourceS3PathKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Object in s3 to populate key.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathKeySelector
 */
export interface ThesaurusSpecForProviderSourceS3PathKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathKeySelector#policy
   */
  readonly policy?: ThesaurusSpecForProviderSourceS3PathKeySelectorPolicy;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderSourceS3PathKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderSourceS3PathKeySelector(obj: ThesaurusSpecForProviderSourceS3PathKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ThesaurusSpecForProviderSourceS3PathKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThesaurusSpecProviderConfigRefPolicyResolution
 */
export enum ThesaurusSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThesaurusSpecProviderConfigRefPolicyResolve
 */
export enum ThesaurusSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThesaurusSpecProviderRefPolicyResolution
 */
export enum ThesaurusSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThesaurusSpecProviderRefPolicyResolve
 */
export enum ThesaurusSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ThesaurusSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ThesaurusSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThesaurusSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ThesaurusSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThesaurusSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ThesaurusSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ThesaurusSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecPublishConnectionDetailsToConfigRefPolicy(obj: ThesaurusSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThesaurusSpecForProviderIndexIdRefPolicyResolution
 */
export enum ThesaurusSpecForProviderIndexIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThesaurusSpecForProviderIndexIdRefPolicyResolve
 */
export enum ThesaurusSpecForProviderIndexIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThesaurusSpecForProviderIndexIdSelectorPolicyResolution
 */
export enum ThesaurusSpecForProviderIndexIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThesaurusSpecForProviderIndexIdSelectorPolicyResolve
 */
export enum ThesaurusSpecForProviderIndexIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThesaurusSpecForProviderRoleArnRefPolicyResolution
 */
export enum ThesaurusSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThesaurusSpecForProviderRoleArnRefPolicyResolve
 */
export enum ThesaurusSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThesaurusSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ThesaurusSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThesaurusSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ThesaurusSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathBucketRefPolicy
 */
export interface ThesaurusSpecForProviderSourceS3PathBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathBucketRefPolicy#resolution
   */
  readonly resolution?: ThesaurusSpecForProviderSourceS3PathBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathBucketRefPolicy#resolve
   */
  readonly resolve?: ThesaurusSpecForProviderSourceS3PathBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderSourceS3PathBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderSourceS3PathBucketRefPolicy(obj: ThesaurusSpecForProviderSourceS3PathBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicy
 */
export interface ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicy#resolution
   */
  readonly resolution?: ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicy#resolve
   */
  readonly resolve?: ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicy(obj: ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathKeyRefPolicy
 */
export interface ThesaurusSpecForProviderSourceS3PathKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathKeyRefPolicy#resolution
   */
  readonly resolution?: ThesaurusSpecForProviderSourceS3PathKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathKeyRefPolicy#resolve
   */
  readonly resolve?: ThesaurusSpecForProviderSourceS3PathKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderSourceS3PathKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderSourceS3PathKeyRefPolicy(obj: ThesaurusSpecForProviderSourceS3PathKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathKeySelectorPolicy
 */
export interface ThesaurusSpecForProviderSourceS3PathKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathKeySelectorPolicy#resolution
   */
  readonly resolution?: ThesaurusSpecForProviderSourceS3PathKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ThesaurusSpecForProviderSourceS3PathKeySelectorPolicy#resolve
   */
  readonly resolve?: ThesaurusSpecForProviderSourceS3PathKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'ThesaurusSpecForProviderSourceS3PathKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThesaurusSpecForProviderSourceS3PathKeySelectorPolicy(obj: ThesaurusSpecForProviderSourceS3PathKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThesaurusSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ThesaurusSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThesaurusSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ThesaurusSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathBucketRefPolicyResolution
 */
export enum ThesaurusSpecForProviderSourceS3PathBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathBucketRefPolicyResolve
 */
export enum ThesaurusSpecForProviderSourceS3PathBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicyResolution
 */
export enum ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicyResolve
 */
export enum ThesaurusSpecForProviderSourceS3PathBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathKeyRefPolicyResolution
 */
export enum ThesaurusSpecForProviderSourceS3PathKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathKeyRefPolicyResolve
 */
export enum ThesaurusSpecForProviderSourceS3PathKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathKeySelectorPolicyResolution
 */
export enum ThesaurusSpecForProviderSourceS3PathKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ThesaurusSpecForProviderSourceS3PathKeySelectorPolicyResolve
 */
export enum ThesaurusSpecForProviderSourceS3PathKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

