// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Domain is the Schema for the Domains API.
 *
 * @schema Domain
 */
export class Domain extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Domain"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elasticsearch.aws.upbound.io/v1beta1',
    kind: 'Domain',
  }

  /**
   * Renders a Kubernetes manifest for "Domain".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainProps): any {
    return {
      ...Domain.GVK,
      ...toJson_DomainProps(props),
    };
  }

  /**
   * Defines a "Domain" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainProps) {
    super(scope, id, {
      ...Domain.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Domain.GVK,
      ...toJson_DomainProps(resolved),
    };
  }
}

/**
 * Domain is the Schema for the Domains API.
 *
 * @schema Domain
 */
export interface DomainProps {
  /**
   * @schema Domain#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainSpec defines the desired state of Domain
   *
   * @schema Domain#spec
   */
  readonly spec: DomainSpec;

}

/**
 * Converts an object of type 'DomainProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainProps(obj: DomainProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainSpec defines the desired state of Domain
 *
 * @schema DomainSpec
 */
export interface DomainSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainSpecDeletionPolicy;

  /**
   * @schema DomainSpec#forProvider
   */
  readonly forProvider: DomainSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainSpec#managementPolicy
   */
  readonly managementPolicy?: DomainSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DomainSpec#providerRef
   */
  readonly providerRef?: DomainSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpec(obj: DomainSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DomainSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DomainSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DomainSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainSpecDeletionPolicy
 */
export enum DomainSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainSpecForProvider
 */
export interface DomainSpecForProvider {
  /**
   * IAM policy document specifying the access policies for the domain.
   *
   * @schema DomainSpecForProvider#accessPolicies
   */
  readonly accessPolicies?: string;

  /**
   * Key-value string pairs to specify advanced configuration options.
   *
   * @schema DomainSpecForProvider#advancedOptions
   */
  readonly advancedOptions?: { [key: string]: string };

  /**
   * Configuration block for fine-grained access control. Detailed below.
   *
   * @schema DomainSpecForProvider#advancedSecurityOptions
   */
  readonly advancedSecurityOptions?: DomainSpecForProviderAdvancedSecurityOptions[];

  /**
   * Configuration block for the Auto-Tune options of the domain. Detailed below.
   *
   * @schema DomainSpecForProvider#autoTuneOptions
   */
  readonly autoTuneOptions?: DomainSpecForProviderAutoTuneOptions[];

  /**
   * Configuration block for the cluster of the domain. Detailed below.
   *
   * @schema DomainSpecForProvider#clusterConfig
   */
  readonly clusterConfig?: DomainSpecForProviderClusterConfig[];

  /**
   * Configuration block for authenticating Kibana with Cognito. Detailed below.
   *
   * @schema DomainSpecForProvider#cognitoOptions
   */
  readonly cognitoOptions?: DomainSpecForProviderCognitoOptions[];

  /**
   * Configuration block for domain endpoint HTTP(S) related options. Detailed below.
   *
   * @schema DomainSpecForProvider#domainEndpointOptions
   */
  readonly domainEndpointOptions?: DomainSpecForProviderDomainEndpointOptions[];

  /**
   * Configuration block for EBS related options, may be required based on chosen instance size. Detailed below.
   *
   * @schema DomainSpecForProvider#ebsOptions
   */
  readonly ebsOptions?: DomainSpecForProviderEbsOptions[];

  /**
   * Version of Elasticsearch to deploy. Defaults to 1.5.
   *
   * @default 1.5.
   * @schema DomainSpecForProvider#elasticsearchVersion
   */
  readonly elasticsearchVersion?: string;

  /**
   * Configuration block for encrypt at rest options. Only available for certain instance types. Detailed below.
   *
   * @schema DomainSpecForProvider#encryptAtRest
   */
  readonly encryptAtRest?: DomainSpecForProviderEncryptAtRest[];

  /**
   * Configuration block for publishing slow and application logs to CloudWatch Logs. This block can be declared multiple times, for each log_type, within the same resource. Detailed below.
   *
   * @schema DomainSpecForProvider#logPublishingOptions
   */
  readonly logPublishingOptions?: DomainSpecForProviderLogPublishingOptions[];

  /**
   * Configuration block for node-to-node encryption options. Detailed below.
   *
   * @schema DomainSpecForProvider#nodeToNodeEncryption
   */
  readonly nodeToNodeEncryption?: DomainSpecForProviderNodeToNodeEncryption[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DomainSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block for snapshot related options. Detailed below. DEPRECATED. For domains running Elasticsearch 5.3 and later, Amazon ES takes hourly automated snapshots, making this setting irrelevant. For domains running earlier versions of Elasticsearch, Amazon ES takes daily automated snapshots.
   *
   * @schema DomainSpecForProvider#snapshotOptions
   */
  readonly snapshotOptions?: DomainSpecForProviderSnapshotOptions[];

  /**
   * Key-value map of resource tags.
   *
   * @schema DomainSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block for VPC related options. Adding or removing this configuration forces a new resource (documentation). Detailed below.
   *
   * @schema DomainSpecForProvider#vpcOptions
   */
  readonly vpcOptions?: DomainSpecForProviderVpcOptions[];

}

/**
 * Converts an object of type 'DomainSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProvider(obj: DomainSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPolicies': obj.accessPolicies,
    'advancedOptions': ((obj.advancedOptions) === undefined) ? undefined : (Object.entries(obj.advancedOptions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'advancedSecurityOptions': obj.advancedSecurityOptions?.map(y => toJson_DomainSpecForProviderAdvancedSecurityOptions(y)),
    'autoTuneOptions': obj.autoTuneOptions?.map(y => toJson_DomainSpecForProviderAutoTuneOptions(y)),
    'clusterConfig': obj.clusterConfig?.map(y => toJson_DomainSpecForProviderClusterConfig(y)),
    'cognitoOptions': obj.cognitoOptions?.map(y => toJson_DomainSpecForProviderCognitoOptions(y)),
    'domainEndpointOptions': obj.domainEndpointOptions?.map(y => toJson_DomainSpecForProviderDomainEndpointOptions(y)),
    'ebsOptions': obj.ebsOptions?.map(y => toJson_DomainSpecForProviderEbsOptions(y)),
    'elasticsearchVersion': obj.elasticsearchVersion,
    'encryptAtRest': obj.encryptAtRest?.map(y => toJson_DomainSpecForProviderEncryptAtRest(y)),
    'logPublishingOptions': obj.logPublishingOptions?.map(y => toJson_DomainSpecForProviderLogPublishingOptions(y)),
    'nodeToNodeEncryption': obj.nodeToNodeEncryption?.map(y => toJson_DomainSpecForProviderNodeToNodeEncryption(y)),
    'region': obj.region,
    'snapshotOptions': obj.snapshotOptions?.map(y => toJson_DomainSpecForProviderSnapshotOptions(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcOptions': obj.vpcOptions?.map(y => toJson_DomainSpecForProviderVpcOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainSpecManagementPolicy
 */
export enum DomainSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainSpecProviderConfigRef
 */
export interface DomainSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecProviderConfigRef#policy
   */
  readonly policy?: DomainSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecProviderConfigRef(obj: DomainSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DomainSpecProviderRef
 */
export interface DomainSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecProviderRef#policy
   */
  readonly policy?: DomainSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecProviderRef(obj: DomainSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainSpecPublishConnectionDetailsTo
 */
export interface DomainSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsTo(obj: DomainSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainSpecWriteConnectionSecretToRef
 */
export interface DomainSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecWriteConnectionSecretToRef(obj: DomainSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderAdvancedSecurityOptions
 */
export interface DomainSpecForProviderAdvancedSecurityOptions {
  /**
   * Whether advanced security is enabled.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptions#enabled
   */
  readonly enabled: boolean;

  /**
   * Whether the internal user database is enabled. If not set, defaults to false by the AWS API.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptions#internalUserDatabaseEnabled
   */
  readonly internalUserDatabaseEnabled?: boolean;

  /**
   * Configuration block for the main user. Detailed below.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptions#masterUserOptions
   */
  readonly masterUserOptions?: DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions[];

}

/**
 * Converts an object of type 'DomainSpecForProviderAdvancedSecurityOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAdvancedSecurityOptions(obj: DomainSpecForProviderAdvancedSecurityOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'internalUserDatabaseEnabled': obj.internalUserDatabaseEnabled,
    'masterUserOptions': obj.masterUserOptions?.map(y => toJson_DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderAutoTuneOptions
 */
export interface DomainSpecForProviderAutoTuneOptions {
  /**
   * The Auto-Tune desired state for the domain. Valid values: ENABLED or DISABLED.
   *
   * @schema DomainSpecForProviderAutoTuneOptions#desiredState
   */
  readonly desiredState: string;

  /**
   * Configuration block for Auto-Tune maintenance windows. Can be specified multiple times for each maintenance window. Detailed below.
   *
   * @schema DomainSpecForProviderAutoTuneOptions#maintenanceSchedule
   */
  readonly maintenanceSchedule?: DomainSpecForProviderAutoTuneOptionsMaintenanceSchedule[];

  /**
   * Whether to roll back to default Auto-Tune settings when disabling Auto-Tune. Valid values: DEFAULT_ROLLBACK or NO_ROLLBACK.
   *
   * @schema DomainSpecForProviderAutoTuneOptions#rollbackOnDisable
   */
  readonly rollbackOnDisable?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderAutoTuneOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAutoTuneOptions(obj: DomainSpecForProviderAutoTuneOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredState': obj.desiredState,
    'maintenanceSchedule': obj.maintenanceSchedule?.map(y => toJson_DomainSpecForProviderAutoTuneOptionsMaintenanceSchedule(y)),
    'rollbackOnDisable': obj.rollbackOnDisable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderClusterConfig
 */
export interface DomainSpecForProviderClusterConfig {
  /**
   * Configuration block containing cold storage configuration. Detailed below.
   *
   * @schema DomainSpecForProviderClusterConfig#coldStorageOptions
   */
  readonly coldStorageOptions?: DomainSpecForProviderClusterConfigColdStorageOptions[];

  /**
   * Number of dedicated main nodes in the cluster.
   *
   * @schema DomainSpecForProviderClusterConfig#dedicatedMasterCount
   */
  readonly dedicatedMasterCount?: number;

  /**
   * Whether dedicated main nodes are enabled for the cluster.
   *
   * @schema DomainSpecForProviderClusterConfig#dedicatedMasterEnabled
   */
  readonly dedicatedMasterEnabled?: boolean;

  /**
   * Instance type of the dedicated main nodes in the cluster.
   *
   * @schema DomainSpecForProviderClusterConfig#dedicatedMasterType
   */
  readonly dedicatedMasterType?: string;

  /**
   * Number of instances in the cluster.
   *
   * @schema DomainSpecForProviderClusterConfig#instanceCount
   */
  readonly instanceCount?: number;

  /**
   * Instance type of data nodes in the cluster.
   *
   * @schema DomainSpecForProviderClusterConfig#instanceType
   */
  readonly instanceType?: string;

  /**
   * Number of warm nodes in the cluster. Valid values are between 2 and 150. warm_count can be only and must be set when warm_enabled is set to true.
   *
   * @schema DomainSpecForProviderClusterConfig#warmCount
   */
  readonly warmCount?: number;

  /**
   * Whether to enable warm storage.
   *
   * @schema DomainSpecForProviderClusterConfig#warmEnabled
   */
  readonly warmEnabled?: boolean;

  /**
   * Instance type for the Elasticsearch cluster's warm nodes. Valid values are ultrawarm1.medium.elasticsearch, ultrawarm1.large.elasticsearch and ultrawarm1.xlarge.elasticsearch. warm_type can be only and must be set when warm_enabled is set to true.
   *
   * @schema DomainSpecForProviderClusterConfig#warmType
   */
  readonly warmType?: string;

  /**
   * Configuration block containing zone awareness settings. Detailed below.
   *
   * @schema DomainSpecForProviderClusterConfig#zoneAwarenessConfig
   */
  readonly zoneAwarenessConfig?: DomainSpecForProviderClusterConfigZoneAwarenessConfig[];

  /**
   * Whether zone awareness is enabled, set to true for multi-az deployment. To enable awareness with three Availability Zones, the availability_zone_count within the zone_awareness_config must be set to 3.
   *
   * @schema DomainSpecForProviderClusterConfig#zoneAwarenessEnabled
   */
  readonly zoneAwarenessEnabled?: boolean;

}

/**
 * Converts an object of type 'DomainSpecForProviderClusterConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderClusterConfig(obj: DomainSpecForProviderClusterConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'coldStorageOptions': obj.coldStorageOptions?.map(y => toJson_DomainSpecForProviderClusterConfigColdStorageOptions(y)),
    'dedicatedMasterCount': obj.dedicatedMasterCount,
    'dedicatedMasterEnabled': obj.dedicatedMasterEnabled,
    'dedicatedMasterType': obj.dedicatedMasterType,
    'instanceCount': obj.instanceCount,
    'instanceType': obj.instanceType,
    'warmCount': obj.warmCount,
    'warmEnabled': obj.warmEnabled,
    'warmType': obj.warmType,
    'zoneAwarenessConfig': obj.zoneAwarenessConfig?.map(y => toJson_DomainSpecForProviderClusterConfigZoneAwarenessConfig(y)),
    'zoneAwarenessEnabled': obj.zoneAwarenessEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderCognitoOptions
 */
export interface DomainSpecForProviderCognitoOptions {
  /**
   * Whether Amazon Cognito authentication with Kibana is enabled or not.
   *
   * @schema DomainSpecForProviderCognitoOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * ID of the Cognito Identity Pool to use.
   *
   * @schema DomainSpecForProviderCognitoOptions#identityPoolId
   */
  readonly identityPoolId: string;

  /**
   * ARN of the IAM role that has the AmazonESCognitoAccess policy attached.
   *
   * @schema DomainSpecForProviderCognitoOptions#roleArn
   */
  readonly roleArn: string;

  /**
   * ID of the Cognito User Pool to use.
   *
   * @schema DomainSpecForProviderCognitoOptions#userPoolId
   */
  readonly userPoolId: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderCognitoOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderCognitoOptions(obj: DomainSpecForProviderCognitoOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'identityPoolId': obj.identityPoolId,
    'roleArn': obj.roleArn,
    'userPoolId': obj.userPoolId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderDomainEndpointOptions
 */
export interface DomainSpecForProviderDomainEndpointOptions {
  /**
   * Fully qualified domain for your custom endpoint.
   *
   * @schema DomainSpecForProviderDomainEndpointOptions#customEndpoint
   */
  readonly customEndpoint?: string;

  /**
   * ACM certificate ARN for your custom endpoint.
   *
   * @schema DomainSpecForProviderDomainEndpointOptions#customEndpointCertificateArn
   */
  readonly customEndpointCertificateArn?: string;

  /**
   * Whether to enable custom endpoint for the Elasticsearch domain.
   *
   * @schema DomainSpecForProviderDomainEndpointOptions#customEndpointEnabled
   */
  readonly customEndpointEnabled?: boolean;

  /**
   * Whether or not to require HTTPS. Defaults to true.
   *
   * @default true.
   * @schema DomainSpecForProviderDomainEndpointOptions#enforceHttps
   */
  readonly enforceHttps?: boolean;

  /**
   * Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  Policy-Min-TLS-1-0-2019-07 and Policy-Min-TLS-1-2-2019-07.
   *
   * @schema DomainSpecForProviderDomainEndpointOptions#tlsSecurityPolicy
   */
  readonly tlsSecurityPolicy?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderDomainEndpointOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderDomainEndpointOptions(obj: DomainSpecForProviderDomainEndpointOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customEndpoint': obj.customEndpoint,
    'customEndpointCertificateArn': obj.customEndpointCertificateArn,
    'customEndpointEnabled': obj.customEndpointEnabled,
    'enforceHttps': obj.enforceHttps,
    'tlsSecurityPolicy': obj.tlsSecurityPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderEbsOptions
 */
export interface DomainSpecForProviderEbsOptions {
  /**
   * Whether EBS volumes are attached to data nodes in the domain.
   *
   * @schema DomainSpecForProviderEbsOptions#ebsEnabled
   */
  readonly ebsEnabled: boolean;

  /**
   * Baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the GP3 and Provisioned IOPS EBS volume types.
   *
   * @schema DomainSpecForProviderEbsOptions#iops
   */
  readonly iops?: number;

  /**
   * Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type.
   *
   * @schema DomainSpecForProviderEbsOptions#throughput
   */
  readonly throughput?: number;

  /**
   * Size of EBS volumes attached to data nodes (in GiB).
   *
   * @schema DomainSpecForProviderEbsOptions#volumeSize
   */
  readonly volumeSize?: number;

  /**
   * Type of EBS volumes attached to data nodes.
   *
   * @schema DomainSpecForProviderEbsOptions#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderEbsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderEbsOptions(obj: DomainSpecForProviderEbsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ebsEnabled': obj.ebsEnabled,
    'iops': obj.iops,
    'throughput': obj.throughput,
    'volumeSize': obj.volumeSize,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderEncryptAtRest
 */
export interface DomainSpecForProviderEncryptAtRest {
  /**
   * Whether to enable encryption at rest. If the encrypt_at_rest block is not provided then this defaults to false. Enabling encryption on new domains requires elasticsearch_version 5.1 or greater.
   *
   * @schema DomainSpecForProviderEncryptAtRest#enabled
   */
  readonly enabled: boolean;

  /**
   * KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the aws/es service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN.
   *
   * @schema DomainSpecForProviderEncryptAtRest#kmsKeyId
   */
  readonly kmsKeyId?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderEncryptAtRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderEncryptAtRest(obj: DomainSpecForProviderEncryptAtRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'kmsKeyId': obj.kmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderLogPublishingOptions
 */
export interface DomainSpecForProviderLogPublishingOptions {
  /**
   * ARN of the Cloudwatch log group to which log needs to be published.
   *
   * @schema DomainSpecForProviderLogPublishingOptions#cloudwatchLogGroupArn
   */
  readonly cloudwatchLogGroupArn?: string;

  /**
   * Reference to a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
   *
   * @schema DomainSpecForProviderLogPublishingOptions#cloudwatchLogGroupArnRef
   */
  readonly cloudwatchLogGroupArnRef?: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRef;

  /**
   * Selector for a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
   *
   * @schema DomainSpecForProviderLogPublishingOptions#cloudwatchLogGroupArnSelector
   */
  readonly cloudwatchLogGroupArnSelector?: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelector;

  /**
   * Whether given log publishing option is enabled or not.
   *
   * @schema DomainSpecForProviderLogPublishingOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * Type of Elasticsearch log. Valid values: INDEX_SLOW_LOGS, SEARCH_SLOW_LOGS, ES_APPLICATION_LOGS, AUDIT_LOGS.
   *
   * @schema DomainSpecForProviderLogPublishingOptions#logType
   */
  readonly logType: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderLogPublishingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderLogPublishingOptions(obj: DomainSpecForProviderLogPublishingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLogGroupArn': obj.cloudwatchLogGroupArn,
    'cloudwatchLogGroupArnRef': toJson_DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRef(obj.cloudwatchLogGroupArnRef),
    'cloudwatchLogGroupArnSelector': toJson_DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelector(obj.cloudwatchLogGroupArnSelector),
    'enabled': obj.enabled,
    'logType': obj.logType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderNodeToNodeEncryption
 */
export interface DomainSpecForProviderNodeToNodeEncryption {
  /**
   * Whether to enable node-to-node encryption. If the node_to_node_encryption block is not provided then this defaults to false. Enabling node-to-node encryption of a new domain requires an elasticsearch_version of 6.0 or greater.
   *
   * @schema DomainSpecForProviderNodeToNodeEncryption#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'DomainSpecForProviderNodeToNodeEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderNodeToNodeEncryption(obj: DomainSpecForProviderNodeToNodeEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderSnapshotOptions
 */
export interface DomainSpecForProviderSnapshotOptions {
  /**
   * Hour during which the service takes an automated daily snapshot of the indices in the domain.
   *
   * @schema DomainSpecForProviderSnapshotOptions#automatedSnapshotStartHour
   */
  readonly automatedSnapshotStartHour: number;

}

/**
 * Converts an object of type 'DomainSpecForProviderSnapshotOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderSnapshotOptions(obj: DomainSpecForProviderSnapshotOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automatedSnapshotStartHour': obj.automatedSnapshotStartHour,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderVpcOptions
 */
export interface DomainSpecForProviderVpcOptions {
  /**
   * List of VPC Security Group IDs to be applied to the Elasticsearch domain endpoints. If omitted, the default Security Group for the VPC will be used.
   *
   * @schema DomainSpecForProviderVpcOptions#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * List of VPC Subnet IDs for the Elasticsearch domain endpoints to be created in.
   *
   * @schema DomainSpecForProviderVpcOptions#subnetIds
   */
  readonly subnetIds?: string[];

}

/**
 * Converts an object of type 'DomainSpecForProviderVpcOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderVpcOptions(obj: DomainSpecForProviderVpcOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecProviderConfigRefPolicy
 */
export interface DomainSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecProviderConfigRefPolicy(obj: DomainSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecProviderRefPolicy
 */
export interface DomainSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DomainSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DomainSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecProviderRefPolicy(obj: DomainSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToConfigRef(obj: DomainSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainSpecPublishConnectionDetailsToMetadata
 */
export interface DomainSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToMetadata(obj: DomainSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions
 */
export interface DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions {
  /**
   * ARN for the main user. Only specify if internal_user_database_enabled is not set or set to false.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions#masterUserArn
   */
  readonly masterUserArn?: string;

  /**
   * Main user's username, which is stored in the Amazon Elasticsearch Service domain's internal database. Only specify if internal_user_database_enabled is set to true.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions#masterUserName
   */
  readonly masterUserName?: string;

  /**
   * Main user's password, which is stored in the Amazon Elasticsearch Service domain's internal database. Only specify if internal_user_database_enabled is set to true.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions#masterUserPasswordSecretRef
   */
  readonly masterUserPasswordSecretRef?: DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptionsMasterUserPasswordSecretRef;

}

/**
 * Converts an object of type 'DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions(obj: DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'masterUserArn': obj.masterUserArn,
    'masterUserName': obj.masterUserName,
    'masterUserPasswordSecretRef': toJson_DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptionsMasterUserPasswordSecretRef(obj.masterUserPasswordSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceSchedule
 */
export interface DomainSpecForProviderAutoTuneOptionsMaintenanceSchedule {
  /**
   * A cron expression specifying the recurrence pattern for an Auto-Tune maintenance schedule.
   *
   * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceSchedule#cronExpressionForRecurrence
   */
  readonly cronExpressionForRecurrence: string;

  /**
   * Configuration block for the duration of the Auto-Tune maintenance window. Detailed below.
   *
   * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceSchedule#duration
   */
  readonly duration: DomainSpecForProviderAutoTuneOptionsMaintenanceScheduleDuration[];

  /**
   * Date and time at which to start the Auto-Tune maintenance schedule in RFC3339 format.
   *
   * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceSchedule#startAt
   */
  readonly startAt: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderAutoTuneOptionsMaintenanceSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAutoTuneOptionsMaintenanceSchedule(obj: DomainSpecForProviderAutoTuneOptionsMaintenanceSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cronExpressionForRecurrence': obj.cronExpressionForRecurrence,
    'duration': obj.duration?.map(y => toJson_DomainSpecForProviderAutoTuneOptionsMaintenanceScheduleDuration(y)),
    'startAt': obj.startAt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderClusterConfigColdStorageOptions
 */
export interface DomainSpecForProviderClusterConfigColdStorageOptions {
  /**
   * Boolean to enable cold storage for an Elasticsearch domain. Defaults to false. Master and ultrawarm nodes must be enabled for cold storage.
   *
   * @default false. Master and ultrawarm nodes must be enabled for cold storage.
   * @schema DomainSpecForProviderClusterConfigColdStorageOptions#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DomainSpecForProviderClusterConfigColdStorageOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderClusterConfigColdStorageOptions(obj: DomainSpecForProviderClusterConfigColdStorageOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderClusterConfigZoneAwarenessConfig
 */
export interface DomainSpecForProviderClusterConfigZoneAwarenessConfig {
  /**
   * Number of Availability Zones for the domain to use with zone_awareness_enabled. Defaults to 2. Valid values: 2 or 3.
   *
   * @default 2. Valid values: 2 or 3.
   * @schema DomainSpecForProviderClusterConfigZoneAwarenessConfig#availabilityZoneCount
   */
  readonly availabilityZoneCount?: number;

}

/**
 * Converts an object of type 'DomainSpecForProviderClusterConfigZoneAwarenessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderClusterConfigZoneAwarenessConfig(obj: DomainSpecForProviderClusterConfigZoneAwarenessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZoneCount': obj.availabilityZoneCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
 *
 * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRef
 */
export interface DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRef#policy
   */
  readonly policy?: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRef(obj: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Group in cloudwatchlogs to populate cloudwatchLogGroupArn.
 *
 * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelector
 */
export interface DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelector#policy
   */
  readonly policy?: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelector(obj: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecProviderConfigRefPolicyResolution
 */
export enum DomainSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecProviderConfigRefPolicyResolve
 */
export enum DomainSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecProviderRefPolicyResolution
 */
export enum DomainSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecProviderRefPolicyResolve
 */
export enum DomainSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Main user's password, which is stored in the Amazon Elasticsearch Service domain's internal database. Only specify if internal_user_database_enabled is set to true.
 *
 * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptionsMasterUserPasswordSecretRef
 */
export interface DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptionsMasterUserPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptionsMasterUserPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptionsMasterUserPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptionsMasterUserPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptionsMasterUserPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptionsMasterUserPasswordSecretRef(obj: DomainSpecForProviderAdvancedSecurityOptionsMasterUserOptionsMasterUserPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceScheduleDuration
 */
export interface DomainSpecForProviderAutoTuneOptionsMaintenanceScheduleDuration {
  /**
   * The unit of time specifying the duration of an Auto-Tune maintenance window. Valid values: HOURS.
   *
   * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceScheduleDuration#unit
   */
  readonly unit: string;

  /**
   * An integer specifying the value of the duration of an Auto-Tune maintenance window.
   *
   * @schema DomainSpecForProviderAutoTuneOptionsMaintenanceScheduleDuration#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'DomainSpecForProviderAutoTuneOptionsMaintenanceScheduleDuration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderAutoTuneOptionsMaintenanceScheduleDuration(obj: DomainSpecForProviderAutoTuneOptionsMaintenanceScheduleDuration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'unit': obj.unit,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicy
 */
export interface DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicy(obj: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicy
 */
export interface DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicy(obj: DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicyResolution
 */
export enum DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicyResolve
 */
export enum DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicyResolution
 */
export enum DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicyResolve
 */
export enum DomainSpecForProviderLogPublishingOptionsCloudwatchLogGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DomainPolicy is the Schema for the DomainPolicys API. Provides an Elasticsearch Domain Policy.
 *
 * @schema DomainPolicy
 */
export class DomainPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DomainPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elasticsearch.aws.upbound.io/v1beta1',
    kind: 'DomainPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "DomainPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainPolicyProps): any {
    return {
      ...DomainPolicy.GVK,
      ...toJson_DomainPolicyProps(props),
    };
  }

  /**
   * Defines a "DomainPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainPolicyProps) {
    super(scope, id, {
      ...DomainPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DomainPolicy.GVK,
      ...toJson_DomainPolicyProps(resolved),
    };
  }
}

/**
 * DomainPolicy is the Schema for the DomainPolicys API. Provides an Elasticsearch Domain Policy.
 *
 * @schema DomainPolicy
 */
export interface DomainPolicyProps {
  /**
   * @schema DomainPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainPolicySpec defines the desired state of DomainPolicy
   *
   * @schema DomainPolicy#spec
   */
  readonly spec: DomainPolicySpec;

}

/**
 * Converts an object of type 'DomainPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicyProps(obj: DomainPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainPolicySpec defines the desired state of DomainPolicy
 *
 * @schema DomainPolicySpec
 */
export interface DomainPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainPolicySpecDeletionPolicy;

  /**
   * @schema DomainPolicySpec#forProvider
   */
  readonly forProvider: DomainPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainPolicySpec#managementPolicy
   */
  readonly managementPolicy?: DomainPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DomainPolicySpec#providerRef
   */
  readonly providerRef?: DomainPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpec(obj: DomainPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DomainPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DomainPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DomainPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainPolicySpecDeletionPolicy
 */
export enum DomainPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainPolicySpecForProvider
 */
export interface DomainPolicySpecForProvider {
  /**
   * IAM policy document specifying the access policies for the domain
   *
   * @schema DomainPolicySpecForProvider#accessPolicies
   */
  readonly accessPolicies?: string;

  /**
   * Name of the domain.
   *
   * @schema DomainPolicySpecForProvider#domainName
   */
  readonly domainName?: string;

  /**
   * Reference to a Domain in elasticsearch to populate domainName.
   *
   * @schema DomainPolicySpecForProvider#domainNameRef
   */
  readonly domainNameRef?: DomainPolicySpecForProviderDomainNameRef;

  /**
   * Selector for a Domain in elasticsearch to populate domainName.
   *
   * @schema DomainPolicySpecForProvider#domainNameSelector
   */
  readonly domainNameSelector?: DomainPolicySpecForProviderDomainNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DomainPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DomainPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecForProvider(obj: DomainPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPolicies': obj.accessPolicies,
    'domainName': obj.domainName,
    'domainNameRef': toJson_DomainPolicySpecForProviderDomainNameRef(obj.domainNameRef),
    'domainNameSelector': toJson_DomainPolicySpecForProviderDomainNameSelector(obj.domainNameSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainPolicySpecManagementPolicy
 */
export enum DomainPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainPolicySpecProviderConfigRef
 */
export interface DomainPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainPolicySpecProviderConfigRef#policy
   */
  readonly policy?: DomainPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecProviderConfigRef(obj: DomainPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DomainPolicySpecProviderRef
 */
export interface DomainPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainPolicySpecProviderRef#policy
   */
  readonly policy?: DomainPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DomainPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecProviderRef(obj: DomainPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainPolicySpecPublishConnectionDetailsTo
 */
export interface DomainPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecPublishConnectionDetailsTo(obj: DomainPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainPolicySpecWriteConnectionSecretToRef
 */
export interface DomainPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecWriteConnectionSecretToRef(obj: DomainPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Domain in elasticsearch to populate domainName.
 *
 * @schema DomainPolicySpecForProviderDomainNameRef
 */
export interface DomainPolicySpecForProviderDomainNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainPolicySpecForProviderDomainNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainPolicySpecForProviderDomainNameRef#policy
   */
  readonly policy?: DomainPolicySpecForProviderDomainNameRefPolicy;

}

/**
 * Converts an object of type 'DomainPolicySpecForProviderDomainNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecForProviderDomainNameRef(obj: DomainPolicySpecForProviderDomainNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainPolicySpecForProviderDomainNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Domain in elasticsearch to populate domainName.
 *
 * @schema DomainPolicySpecForProviderDomainNameSelector
 */
export interface DomainPolicySpecForProviderDomainNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainPolicySpecForProviderDomainNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainPolicySpecForProviderDomainNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainPolicySpecForProviderDomainNameSelector#policy
   */
  readonly policy?: DomainPolicySpecForProviderDomainNameSelectorPolicy;

}

/**
 * Converts an object of type 'DomainPolicySpecForProviderDomainNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecForProviderDomainNameSelector(obj: DomainPolicySpecForProviderDomainNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainPolicySpecForProviderDomainNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainPolicySpecProviderConfigRefPolicy
 */
export interface DomainPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecProviderConfigRefPolicy(obj: DomainPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainPolicySpecProviderRefPolicy
 */
export interface DomainPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: DomainPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: DomainPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecProviderRefPolicy(obj: DomainPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface DomainPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecPublishConnectionDetailsToConfigRef(obj: DomainPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainPolicySpecPublishConnectionDetailsToMetadata
 */
export interface DomainPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecPublishConnectionDetailsToMetadata(obj: DomainPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainPolicySpecForProviderDomainNameRefPolicy
 */
export interface DomainPolicySpecForProviderDomainNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainPolicySpecForProviderDomainNameRefPolicy#resolution
   */
  readonly resolution?: DomainPolicySpecForProviderDomainNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainPolicySpecForProviderDomainNameRefPolicy#resolve
   */
  readonly resolve?: DomainPolicySpecForProviderDomainNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainPolicySpecForProviderDomainNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecForProviderDomainNameRefPolicy(obj: DomainPolicySpecForProviderDomainNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainPolicySpecForProviderDomainNameSelectorPolicy
 */
export interface DomainPolicySpecForProviderDomainNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainPolicySpecForProviderDomainNameSelectorPolicy#resolution
   */
  readonly resolution?: DomainPolicySpecForProviderDomainNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainPolicySpecForProviderDomainNameSelectorPolicy#resolve
   */
  readonly resolve?: DomainPolicySpecForProviderDomainNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainPolicySpecForProviderDomainNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecForProviderDomainNameSelectorPolicy(obj: DomainPolicySpecForProviderDomainNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainPolicySpecProviderConfigRefPolicyResolution
 */
export enum DomainPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainPolicySpecProviderConfigRefPolicyResolve
 */
export enum DomainPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainPolicySpecProviderRefPolicyResolution
 */
export enum DomainPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainPolicySpecProviderRefPolicyResolve
 */
export enum DomainPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainPolicySpecForProviderDomainNameRefPolicyResolution
 */
export enum DomainPolicySpecForProviderDomainNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainPolicySpecForProviderDomainNameRefPolicyResolve
 */
export enum DomainPolicySpecForProviderDomainNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainPolicySpecForProviderDomainNameSelectorPolicyResolution
 */
export enum DomainPolicySpecForProviderDomainNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainPolicySpecForProviderDomainNameSelectorPolicyResolve
 */
export enum DomainPolicySpecForProviderDomainNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DomainSAMLOptions is the Schema for the DomainSAMLOptionss API.
 *
 * @schema DomainSAMLOptions
 */
export class DomainSamlOptions extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DomainSAMLOptions"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elasticsearch.aws.upbound.io/v1beta1',
    kind: 'DomainSAMLOptions',
  }

  /**
   * Renders a Kubernetes manifest for "DomainSAMLOptions".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainSamlOptionsProps): any {
    return {
      ...DomainSamlOptions.GVK,
      ...toJson_DomainSamlOptionsProps(props),
    };
  }

  /**
   * Defines a "DomainSAMLOptions" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainSamlOptionsProps) {
    super(scope, id, {
      ...DomainSamlOptions.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DomainSamlOptions.GVK,
      ...toJson_DomainSamlOptionsProps(resolved),
    };
  }
}

/**
 * DomainSAMLOptions is the Schema for the DomainSAMLOptionss API.
 *
 * @schema DomainSAMLOptions
 */
export interface DomainSamlOptionsProps {
  /**
   * @schema DomainSAMLOptions#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainSAMLOptionsSpec defines the desired state of DomainSAMLOptions
   *
   * @schema DomainSAMLOptions#spec
   */
  readonly spec: DomainSamlOptionsSpec;

}

/**
 * Converts an object of type 'DomainSamlOptionsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsProps(obj: DomainSamlOptionsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainSamlOptionsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainSAMLOptionsSpec defines the desired state of DomainSAMLOptions
 *
 * @schema DomainSamlOptionsSpec
 */
export interface DomainSamlOptionsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainSamlOptionsSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainSamlOptionsSpecDeletionPolicy;

  /**
   * @schema DomainSamlOptionsSpec#forProvider
   */
  readonly forProvider: DomainSamlOptionsSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainSamlOptionsSpec#managementPolicy
   */
  readonly managementPolicy?: DomainSamlOptionsSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainSamlOptionsSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainSamlOptionsSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DomainSamlOptionsSpec#providerRef
   */
  readonly providerRef?: DomainSamlOptionsSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainSamlOptionsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainSamlOptionsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainSamlOptionsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainSamlOptionsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpec(obj: DomainSamlOptionsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainSamlOptionsSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DomainSamlOptionsSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DomainSamlOptionsSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DomainSamlOptionsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainSamlOptionsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainSamlOptionsSpecDeletionPolicy
 */
export enum DomainSamlOptionsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainSamlOptionsSpecForProvider
 */
export interface DomainSamlOptionsSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DomainSamlOptionsSpecForProvider#region
   */
  readonly region: string;

  /**
   * The SAML authentication options for an AWS Elasticsearch Domain.
   *
   * @schema DomainSamlOptionsSpecForProvider#samlOptions
   */
  readonly samlOptions?: DomainSamlOptionsSpecForProviderSamlOptions[];

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecForProvider(obj: DomainSamlOptionsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'samlOptions': obj.samlOptions?.map(y => toJson_DomainSamlOptionsSpecForProviderSamlOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainSamlOptionsSpecManagementPolicy
 */
export enum DomainSamlOptionsSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainSamlOptionsSpecProviderConfigRef
 */
export interface DomainSamlOptionsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSamlOptionsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSamlOptionsSpecProviderConfigRef#policy
   */
  readonly policy?: DomainSamlOptionsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecProviderConfigRef(obj: DomainSamlOptionsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSamlOptionsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DomainSamlOptionsSpecProviderRef
 */
export interface DomainSamlOptionsSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSamlOptionsSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSamlOptionsSpecProviderRef#policy
   */
  readonly policy?: DomainSamlOptionsSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecProviderRef(obj: DomainSamlOptionsSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSamlOptionsSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainSamlOptionsSpecPublishConnectionDetailsTo
 */
export interface DomainSamlOptionsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainSamlOptionsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainSamlOptionsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainSamlOptionsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainSamlOptionsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainSamlOptionsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecPublishConnectionDetailsTo(obj: DomainSamlOptionsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainSamlOptionsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainSamlOptionsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainSamlOptionsSpecWriteConnectionSecretToRef
 */
export interface DomainSamlOptionsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainSamlOptionsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainSamlOptionsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecWriteConnectionSecretToRef(obj: DomainSamlOptionsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSamlOptionsSpecForProviderSamlOptions
 */
export interface DomainSamlOptionsSpecForProviderSamlOptions {
  /**
   * Whether SAML authentication is enabled.
   *
   * @schema DomainSamlOptionsSpecForProviderSamlOptions#enabled
   */
  readonly enabled?: boolean;

  /**
   * Information from your identity provider.
   *
   * @schema DomainSamlOptionsSpecForProviderSamlOptions#idp
   */
  readonly idp?: DomainSamlOptionsSpecForProviderSamlOptionsIdp[];

  /**
   * This backend role from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
   *
   * @schema DomainSamlOptionsSpecForProviderSamlOptions#masterBackendRole
   */
  readonly masterBackendRole?: string;

  /**
   * This username from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
   *
   * @schema DomainSamlOptionsSpecForProviderSamlOptions#masterUserNameSecretRef
   */
  readonly masterUserNameSecretRef?: DomainSamlOptionsSpecForProviderSamlOptionsMasterUserNameSecretRef;

  /**
   * Element of the SAML assertion to use for backend roles. Default is roles.
   *
   * @default roles.
   * @schema DomainSamlOptionsSpecForProviderSamlOptions#rolesKey
   */
  readonly rolesKey?: string;

  /**
   * Duration of a session in minutes after a user logs in. Default is 60. Maximum value is 1,440.
   *
   * @default 60. Maximum value is 1,440.
   * @schema DomainSamlOptionsSpecForProviderSamlOptions#sessionTimeoutMinutes
   */
  readonly sessionTimeoutMinutes?: number;

  /**
   * Custom SAML attribute to use for user names. Default is an empty string - "". This will cause Elasticsearch to use the NameID element of the Subject, which is the default location for name identifiers in the SAML specification.
   *
   * @default an empty string - "". This will cause Elasticsearch to use the NameID element of the Subject, which is the default location for name identifiers in the SAML specification.
   * @schema DomainSamlOptionsSpecForProviderSamlOptions#subjectKey
   */
  readonly subjectKey?: string;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecForProviderSamlOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecForProviderSamlOptions(obj: DomainSamlOptionsSpecForProviderSamlOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'idp': obj.idp?.map(y => toJson_DomainSamlOptionsSpecForProviderSamlOptionsIdp(y)),
    'masterBackendRole': obj.masterBackendRole,
    'masterUserNameSecretRef': toJson_DomainSamlOptionsSpecForProviderSamlOptionsMasterUserNameSecretRef(obj.masterUserNameSecretRef),
    'rolesKey': obj.rolesKey,
    'sessionTimeoutMinutes': obj.sessionTimeoutMinutes,
    'subjectKey': obj.subjectKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSamlOptionsSpecProviderConfigRefPolicy
 */
export interface DomainSamlOptionsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSamlOptionsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainSamlOptionsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSamlOptionsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainSamlOptionsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecProviderConfigRefPolicy(obj: DomainSamlOptionsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSamlOptionsSpecProviderRefPolicy
 */
export interface DomainSamlOptionsSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSamlOptionsSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DomainSamlOptionsSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSamlOptionsSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DomainSamlOptionsSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecProviderRefPolicy(obj: DomainSamlOptionsSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainSamlOptionsSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainSamlOptionsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSamlOptionsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSamlOptionsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecPublishConnectionDetailsToConfigRef(obj: DomainSamlOptionsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainSamlOptionsSpecPublishConnectionDetailsToMetadata
 */
export interface DomainSamlOptionsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainSamlOptionsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainSamlOptionsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainSamlOptionsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecPublishConnectionDetailsToMetadata(obj: DomainSamlOptionsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSamlOptionsSpecForProviderSamlOptionsIdp
 */
export interface DomainSamlOptionsSpecForProviderSamlOptionsIdp {
  /**
   * The unique Entity ID of the application in SAML Identity Provider.
   *
   * @schema DomainSamlOptionsSpecForProviderSamlOptionsIdp#entityId
   */
  readonly entityId: string;

  /**
   * The Metadata of the SAML application in xml format.
   *
   * @schema DomainSamlOptionsSpecForProviderSamlOptionsIdp#metadataContent
   */
  readonly metadataContent: string;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecForProviderSamlOptionsIdp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecForProviderSamlOptionsIdp(obj: DomainSamlOptionsSpecForProviderSamlOptionsIdp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entityId': obj.entityId,
    'metadataContent': obj.metadataContent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This username from the SAML IdP receives full permissions to the cluster, equivalent to a new master user.
 *
 * @schema DomainSamlOptionsSpecForProviderSamlOptionsMasterUserNameSecretRef
 */
export interface DomainSamlOptionsSpecForProviderSamlOptionsMasterUserNameSecretRef {
  /**
   * The key to select.
   *
   * @schema DomainSamlOptionsSpecForProviderSamlOptionsMasterUserNameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DomainSamlOptionsSpecForProviderSamlOptionsMasterUserNameSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainSamlOptionsSpecForProviderSamlOptionsMasterUserNameSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecForProviderSamlOptionsMasterUserNameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecForProviderSamlOptionsMasterUserNameSecretRef(obj: DomainSamlOptionsSpecForProviderSamlOptionsMasterUserNameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSamlOptionsSpecProviderConfigRefPolicyResolution
 */
export enum DomainSamlOptionsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSamlOptionsSpecProviderConfigRefPolicyResolve
 */
export enum DomainSamlOptionsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSamlOptionsSpecProviderRefPolicyResolution
 */
export enum DomainSamlOptionsSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSamlOptionsSpecProviderRefPolicyResolve
 */
export enum DomainSamlOptionsSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainSamlOptionsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

