// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AutoScalingConfigurationVersion is the Schema for the AutoScalingConfigurationVersions API. Manages an App Runner AutoScaling Configuration Version.
 *
 * @schema AutoScalingConfigurationVersion
 */
export class AutoScalingConfigurationVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AutoScalingConfigurationVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apprunner.aws.upbound.io/v1beta1',
    kind: 'AutoScalingConfigurationVersion',
  }

  /**
   * Renders a Kubernetes manifest for "AutoScalingConfigurationVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AutoScalingConfigurationVersionProps): any {
    return {
      ...AutoScalingConfigurationVersion.GVK,
      ...toJson_AutoScalingConfigurationVersionProps(props),
    };
  }

  /**
   * Defines a "AutoScalingConfigurationVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AutoScalingConfigurationVersionProps) {
    super(scope, id, {
      ...AutoScalingConfigurationVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AutoScalingConfigurationVersion.GVK,
      ...toJson_AutoScalingConfigurationVersionProps(resolved),
    };
  }
}

/**
 * AutoScalingConfigurationVersion is the Schema for the AutoScalingConfigurationVersions API. Manages an App Runner AutoScaling Configuration Version.
 *
 * @schema AutoScalingConfigurationVersion
 */
export interface AutoScalingConfigurationVersionProps {
  /**
   * @schema AutoScalingConfigurationVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AutoScalingConfigurationVersionSpec defines the desired state of AutoScalingConfigurationVersion
   *
   * @schema AutoScalingConfigurationVersion#spec
   */
  readonly spec: AutoScalingConfigurationVersionSpec;

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionProps(obj: AutoScalingConfigurationVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AutoScalingConfigurationVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AutoScalingConfigurationVersionSpec defines the desired state of AutoScalingConfigurationVersion
 *
 * @schema AutoScalingConfigurationVersionSpec
 */
export interface AutoScalingConfigurationVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema AutoScalingConfigurationVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: AutoScalingConfigurationVersionSpecDeletionPolicy;

  /**
   * @schema AutoScalingConfigurationVersionSpec#forProvider
   */
  readonly forProvider: AutoScalingConfigurationVersionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AutoScalingConfigurationVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: AutoScalingConfigurationVersionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AutoScalingConfigurationVersionSpec#providerRef
   */
  readonly providerRef?: AutoScalingConfigurationVersionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AutoScalingConfigurationVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AutoScalingConfigurationVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AutoScalingConfigurationVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AutoScalingConfigurationVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionSpec(obj: AutoScalingConfigurationVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AutoScalingConfigurationVersionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_AutoScalingConfigurationVersionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AutoScalingConfigurationVersionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AutoScalingConfigurationVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AutoScalingConfigurationVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema AutoScalingConfigurationVersionSpecDeletionPolicy
 */
export enum AutoScalingConfigurationVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AutoScalingConfigurationVersionSpecForProvider
 */
export interface AutoScalingConfigurationVersionSpecForProvider {
  /**
   * Name of the auto scaling configuration.
   *
   * @schema AutoScalingConfigurationVersionSpecForProvider#autoScalingConfigurationName
   */
  readonly autoScalingConfigurationName: string;

  /**
   * Maximal number of concurrent requests that you want an instance to process. When the number of concurrent requests goes over this limit, App Runner scales up your service.
   *
   * @schema AutoScalingConfigurationVersionSpecForProvider#maxConcurrency
   */
  readonly maxConcurrency?: number;

  /**
   * Maximal number of instances that App Runner provisions for your service.
   *
   * @schema AutoScalingConfigurationVersionSpecForProvider#maxSize
   */
  readonly maxSize?: number;

  /**
   * Minimal number of instances that App Runner provisions for your service.
   *
   * @schema AutoScalingConfigurationVersionSpecForProvider#minSize
   */
  readonly minSize?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AutoScalingConfigurationVersionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AutoScalingConfigurationVersionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionSpecForProvider(obj: AutoScalingConfigurationVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoScalingConfigurationName': obj.autoScalingConfigurationName,
    'maxConcurrency': obj.maxConcurrency,
    'maxSize': obj.maxSize,
    'minSize': obj.minSize,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AutoScalingConfigurationVersionSpecProviderConfigRef
 */
export interface AutoScalingConfigurationVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AutoScalingConfigurationVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoScalingConfigurationVersionSpecProviderConfigRef#policy
   */
  readonly policy?: AutoScalingConfigurationVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionSpecProviderConfigRef(obj: AutoScalingConfigurationVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoScalingConfigurationVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AutoScalingConfigurationVersionSpecProviderRef
 */
export interface AutoScalingConfigurationVersionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AutoScalingConfigurationVersionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoScalingConfigurationVersionSpecProviderRef#policy
   */
  readonly policy?: AutoScalingConfigurationVersionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionSpecProviderRef(obj: AutoScalingConfigurationVersionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoScalingConfigurationVersionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsTo
 */
export interface AutoScalingConfigurationVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AutoScalingConfigurationVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionSpecPublishConnectionDetailsTo(obj: AutoScalingConfigurationVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AutoScalingConfigurationVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AutoScalingConfigurationVersionSpecWriteConnectionSecretToRef
 */
export interface AutoScalingConfigurationVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AutoScalingConfigurationVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AutoScalingConfigurationVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionSpecWriteConnectionSecretToRef(obj: AutoScalingConfigurationVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AutoScalingConfigurationVersionSpecProviderConfigRefPolicy
 */
export interface AutoScalingConfigurationVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoScalingConfigurationVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AutoScalingConfigurationVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoScalingConfigurationVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AutoScalingConfigurationVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionSpecProviderConfigRefPolicy(obj: AutoScalingConfigurationVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AutoScalingConfigurationVersionSpecProviderRefPolicy
 */
export interface AutoScalingConfigurationVersionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoScalingConfigurationVersionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AutoScalingConfigurationVersionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoScalingConfigurationVersionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AutoScalingConfigurationVersionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionSpecProviderRefPolicy(obj: AutoScalingConfigurationVersionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRef(obj: AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToMetadata
 */
export interface AutoScalingConfigurationVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionSpecPublishConnectionDetailsToMetadata(obj: AutoScalingConfigurationVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoScalingConfigurationVersionSpecProviderConfigRefPolicyResolution
 */
export enum AutoScalingConfigurationVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoScalingConfigurationVersionSpecProviderConfigRefPolicyResolve
 */
export enum AutoScalingConfigurationVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoScalingConfigurationVersionSpecProviderRefPolicyResolution
 */
export enum AutoScalingConfigurationVersionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoScalingConfigurationVersionSpecProviderRefPolicyResolve
 */
export enum AutoScalingConfigurationVersionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AutoScalingConfigurationVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Connection is the Schema for the Connections API. Manages an App Runner Connection.
 *
 * @schema Connection
 */
export class Connection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Connection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apprunner.aws.upbound.io/v1beta1',
    kind: 'Connection',
  }

  /**
   * Renders a Kubernetes manifest for "Connection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConnectionProps): any {
    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(props),
    };
  }

  /**
   * Defines a "Connection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConnectionProps) {
    super(scope, id, {
      ...Connection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(resolved),
    };
  }
}

/**
 * Connection is the Schema for the Connections API. Manages an App Runner Connection.
 *
 * @schema Connection
 */
export interface ConnectionProps {
  /**
   * @schema Connection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConnectionSpec defines the desired state of Connection
   *
   * @schema Connection#spec
   */
  readonly spec: ConnectionSpec;

}

/**
 * Converts an object of type 'ConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProps(obj: ConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionSpec defines the desired state of Connection
 *
 * @schema ConnectionSpec
 */
export interface ConnectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ConnectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConnectionSpecDeletionPolicy;

  /**
   * @schema ConnectionSpec#forProvider
   */
  readonly forProvider: ConnectionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConnectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConnectionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConnectionSpec#providerRef
   */
  readonly providerRef?: ConnectionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConnectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConnectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConnectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConnectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpec(obj: ConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConnectionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ConnectionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConnectionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConnectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConnectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ConnectionSpecDeletionPolicy
 */
export enum ConnectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConnectionSpecForProvider
 */
export interface ConnectionSpecForProvider {
  /**
   * Source repository provider. Valid values: GITHUB.
   *
   * @schema ConnectionSpecForProvider#providerType
   */
  readonly providerType: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConnectionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ConnectionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConnectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProvider(obj: ConnectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'providerType': obj.providerType,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConnectionSpecProviderConfigRef
 */
export interface ConnectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecProviderConfigRef#policy
   */
  readonly policy?: ConnectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRef(obj: ConnectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConnectionSpecProviderRef
 */
export interface ConnectionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecProviderRef#policy
   */
  readonly policy?: ConnectionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderRef(obj: ConnectionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConnectionSpecPublishConnectionDetailsTo
 */
export interface ConnectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConnectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConnectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsTo(obj: ConnectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConnectionSpecWriteConnectionSecretToRef
 */
export interface ConnectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecWriteConnectionSecretToRef(obj: ConnectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecProviderConfigRefPolicy
 */
export interface ConnectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRefPolicy(obj: ConnectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecProviderRefPolicy
 */
export interface ConnectionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderRefPolicy(obj: ConnectionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRef
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj: ConnectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToMetadata
 */
export interface ConnectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj: ConnectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolution
 */
export enum ConnectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolve
 */
export enum ConnectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecProviderRefPolicyResolution
 */
export enum ConnectionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecProviderRefPolicyResolve
 */
export enum ConnectionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ObservabilityConfiguration is the Schema for the ObservabilityConfigurations API. Manages an App Runner Observability Configuration.
 *
 * @schema ObservabilityConfiguration
 */
export class ObservabilityConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ObservabilityConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apprunner.aws.upbound.io/v1beta1',
    kind: 'ObservabilityConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "ObservabilityConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ObservabilityConfigurationProps): any {
    return {
      ...ObservabilityConfiguration.GVK,
      ...toJson_ObservabilityConfigurationProps(props),
    };
  }

  /**
   * Defines a "ObservabilityConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ObservabilityConfigurationProps) {
    super(scope, id, {
      ...ObservabilityConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ObservabilityConfiguration.GVK,
      ...toJson_ObservabilityConfigurationProps(resolved),
    };
  }
}

/**
 * ObservabilityConfiguration is the Schema for the ObservabilityConfigurations API. Manages an App Runner Observability Configuration.
 *
 * @schema ObservabilityConfiguration
 */
export interface ObservabilityConfigurationProps {
  /**
   * @schema ObservabilityConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ObservabilityConfigurationSpec defines the desired state of ObservabilityConfiguration
   *
   * @schema ObservabilityConfiguration#spec
   */
  readonly spec: ObservabilityConfigurationSpec;

}

/**
 * Converts an object of type 'ObservabilityConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationProps(obj: ObservabilityConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ObservabilityConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObservabilityConfigurationSpec defines the desired state of ObservabilityConfiguration
 *
 * @schema ObservabilityConfigurationSpec
 */
export interface ObservabilityConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ObservabilityConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ObservabilityConfigurationSpecDeletionPolicy;

  /**
   * @schema ObservabilityConfigurationSpec#forProvider
   */
  readonly forProvider: ObservabilityConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ObservabilityConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ObservabilityConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ObservabilityConfigurationSpec#providerRef
   */
  readonly providerRef?: ObservabilityConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ObservabilityConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ObservabilityConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ObservabilityConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ObservabilityConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpec(obj: ObservabilityConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ObservabilityConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ObservabilityConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ObservabilityConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ObservabilityConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ObservabilityConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ObservabilityConfigurationSpecDeletionPolicy
 */
export enum ObservabilityConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ObservabilityConfigurationSpecForProvider
 */
export interface ObservabilityConfigurationSpecForProvider {
  /**
   * Name of the observability configuration.
   *
   * @schema ObservabilityConfigurationSpecForProvider#observabilityConfigurationName
   */
  readonly observabilityConfigurationName: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ObservabilityConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ObservabilityConfigurationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration of the tracing feature within this observability configuration. If you don't specify it, App Runner doesn't enable tracing. See Trace Configuration below for more details.
   *
   * @schema ObservabilityConfigurationSpecForProvider#traceConfiguration
   */
  readonly traceConfiguration?: ObservabilityConfigurationSpecForProviderTraceConfiguration[];

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpecForProvider(obj: ObservabilityConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'observabilityConfigurationName': obj.observabilityConfigurationName,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'traceConfiguration': obj.traceConfiguration?.map(y => toJson_ObservabilityConfigurationSpecForProviderTraceConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ObservabilityConfigurationSpecProviderConfigRef
 */
export interface ObservabilityConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObservabilityConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObservabilityConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: ObservabilityConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpecProviderConfigRef(obj: ObservabilityConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObservabilityConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ObservabilityConfigurationSpecProviderRef
 */
export interface ObservabilityConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObservabilityConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObservabilityConfigurationSpecProviderRef#policy
   */
  readonly policy?: ObservabilityConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpecProviderRef(obj: ObservabilityConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObservabilityConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ObservabilityConfigurationSpecPublishConnectionDetailsTo
 */
export interface ObservabilityConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ObservabilityConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ObservabilityConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ObservabilityConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ObservabilityConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpecPublishConnectionDetailsTo(obj: ObservabilityConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ObservabilityConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ObservabilityConfigurationSpecWriteConnectionSecretToRef
 */
export interface ObservabilityConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ObservabilityConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObservabilityConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpecWriteConnectionSecretToRef(obj: ObservabilityConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ObservabilityConfigurationSpecForProviderTraceConfiguration
 */
export interface ObservabilityConfigurationSpecForProviderTraceConfiguration {
  /**
   * Implementation provider chosen for tracing App Runner services. Valid values: AWSXRAY.
   *
   * @schema ObservabilityConfigurationSpecForProviderTraceConfiguration#vendor
   */
  readonly vendor?: string;

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpecForProviderTraceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpecForProviderTraceConfiguration(obj: ObservabilityConfigurationSpecForProviderTraceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'vendor': obj.vendor,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObservabilityConfigurationSpecProviderConfigRefPolicy
 */
export interface ObservabilityConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObservabilityConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ObservabilityConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObservabilityConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ObservabilityConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpecProviderConfigRefPolicy(obj: ObservabilityConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObservabilityConfigurationSpecProviderRefPolicy
 */
export interface ObservabilityConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObservabilityConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ObservabilityConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObservabilityConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ObservabilityConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpecProviderRefPolicy(obj: ObservabilityConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRef(obj: ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface ObservabilityConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpecPublishConnectionDetailsToMetadata(obj: ObservabilityConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObservabilityConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum ObservabilityConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObservabilityConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum ObservabilityConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObservabilityConfigurationSpecProviderRefPolicyResolution
 */
export enum ObservabilityConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObservabilityConfigurationSpecProviderRefPolicyResolve
 */
export enum ObservabilityConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ObservabilityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Service is the Schema for the Services API. Manages an App Runner Service.
 *
 * @schema Service
 */
export class Service extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Service"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apprunner.aws.upbound.io/v1beta1',
    kind: 'Service',
  }

  /**
   * Renders a Kubernetes manifest for "Service".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceProps): any {
    return {
      ...Service.GVK,
      ...toJson_ServiceProps(props),
    };
  }

  /**
   * Defines a "Service" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceProps) {
    super(scope, id, {
      ...Service.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Service.GVK,
      ...toJson_ServiceProps(resolved),
    };
  }
}

/**
 * Service is the Schema for the Services API. Manages an App Runner Service.
 *
 * @schema Service
 */
export interface ServiceProps {
  /**
   * @schema Service#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceSpec defines the desired state of Service
   *
   * @schema Service#spec
   */
  readonly spec: ServiceSpec;

}

/**
 * Converts an object of type 'ServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceProps(obj: ServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSpec defines the desired state of Service
 *
 * @schema ServiceSpec
 */
export interface ServiceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ServiceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceSpecDeletionPolicy;

  /**
   * @schema ServiceSpec#forProvider
   */
  readonly forProvider: ServiceSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ServiceSpec#providerRef
   */
  readonly providerRef?: ServiceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpec(obj: ServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ServiceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ServiceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ServiceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ServiceSpecDeletionPolicy
 */
export enum ServiceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceSpecForProvider
 */
export interface ServiceSpecForProvider {
  /**
   * ARN of an App Runner automatic scaling configuration resource that you want to associate with your service. If not provided, App Runner associates the latest revision of a default auto scaling configuration.
   *
   * @schema ServiceSpecForProvider#autoScalingConfigurationArn
   */
  readonly autoScalingConfigurationArn?: string;

  /**
   * (Forces new resource) An optional custom encryption key that App Runner uses to encrypt the copy of your source repository that it maintains and your service logs. By default, App Runner uses an AWS managed CMK. See Encryption Configuration below for more details.
   *
   * @schema ServiceSpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: ServiceSpecForProviderEncryptionConfiguration[];

  /**
   * (Forces new resource) Settings of the health check that AWS App Runner performs to monitor the health of your service. See Health Check Configuration below for more details.
   *
   * @schema ServiceSpecForProvider#healthCheckConfiguration
   */
  readonly healthCheckConfiguration?: ServiceSpecForProviderHealthCheckConfiguration[];

  /**
   * The runtime configuration of instances (scaling units) of the App Runner service. See Instance Configuration below for more details.
   *
   * @schema ServiceSpecForProvider#instanceConfiguration
   */
  readonly instanceConfiguration?: ServiceSpecForProviderInstanceConfiguration[];

  /**
   * Configuration settings related to network traffic of the web application that the App Runner service runs. See Network Configuration below for more details.
   *
   * @schema ServiceSpecForProvider#networkConfiguration
   */
  readonly networkConfiguration?: ServiceSpecForProviderNetworkConfiguration[];

  /**
   * The observability configuration of your service. See Observability Configuration below for more details.
   *
   * @schema ServiceSpecForProvider#observabilityConfiguration
   */
  readonly observabilityConfiguration?: ServiceSpecForProviderObservabilityConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ServiceSpecForProvider#region
   */
  readonly region: string;

  /**
   * (Forces new resource) Name of the service.
   *
   * @schema ServiceSpecForProvider#serviceName
   */
  readonly serviceName: string;

  /**
   * The source to deploy to the App Runner service. Can be a code or an image repository. See Source Configuration below for more details.
   *
   * @schema ServiceSpecForProvider#sourceConfiguration
   */
  readonly sourceConfiguration: ServiceSpecForProviderSourceConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ServiceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ServiceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProvider(obj: ServiceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoScalingConfigurationArn': obj.autoScalingConfigurationArn,
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_ServiceSpecForProviderEncryptionConfiguration(y)),
    'healthCheckConfiguration': obj.healthCheckConfiguration?.map(y => toJson_ServiceSpecForProviderHealthCheckConfiguration(y)),
    'instanceConfiguration': obj.instanceConfiguration?.map(y => toJson_ServiceSpecForProviderInstanceConfiguration(y)),
    'networkConfiguration': obj.networkConfiguration?.map(y => toJson_ServiceSpecForProviderNetworkConfiguration(y)),
    'observabilityConfiguration': obj.observabilityConfiguration?.map(y => toJson_ServiceSpecForProviderObservabilityConfiguration(y)),
    'region': obj.region,
    'serviceName': obj.serviceName,
    'sourceConfiguration': obj.sourceConfiguration?.map(y => toJson_ServiceSpecForProviderSourceConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceSpecProviderConfigRef
 */
export interface ServiceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRef(obj: ServiceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ServiceSpecProviderRef
 */
export interface ServiceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecProviderRef#policy
   */
  readonly policy?: ServiceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderRef(obj: ServiceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceSpecPublishConnectionDetailsTo
 */
export interface ServiceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsTo(obj: ServiceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceSpecWriteConnectionSecretToRef
 */
export interface ServiceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecWriteConnectionSecretToRef(obj: ServiceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderEncryptionConfiguration
 */
export interface ServiceSpecForProviderEncryptionConfiguration {
  /**
   * ARN of the KMS key used for encryption.
   *
   * @schema ServiceSpecForProviderEncryptionConfiguration#kmsKey
   */
  readonly kmsKey: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderEncryptionConfiguration(obj: ServiceSpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKey': obj.kmsKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderHealthCheckConfiguration
 */
export interface ServiceSpecForProviderHealthCheckConfiguration {
  /**
   * Number of consecutive checks that must succeed before App Runner decides that the service is healthy. Defaults to 1. Minimum value of 1. Maximum value of 20.
   *
   * @default 1. Minimum value of 1. Maximum value of 20.
   * @schema ServiceSpecForProviderHealthCheckConfiguration#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * Time interval, in seconds, between health checks. Defaults to 5. Minimum value of 1. Maximum value of 20.
   *
   * @default 5. Minimum value of 1. Maximum value of 20.
   * @schema ServiceSpecForProviderHealthCheckConfiguration#interval
   */
  readonly interval?: number;

  /**
   * URL to send requests to for health checks. Defaults to /. Minimum length of 0. Maximum length of 51200.
   *
   * @default Minimum length of 0. Maximum length of 51200.
   * @schema ServiceSpecForProviderHealthCheckConfiguration#path
   */
  readonly path?: string;

  /**
   * IP protocol that App Runner uses to perform health checks for your service. Valid values: TCP, HTTP. Defaults to TCP. If you set protocol to HTTP, App Runner sends health check requests to the HTTP path specified by path.
   *
   * @default TCP. If you set protocol to HTTP, App Runner sends health check requests to the HTTP path specified by path.
   * @schema ServiceSpecForProviderHealthCheckConfiguration#protocol
   */
  readonly protocol?: string;

  /**
   * Time, in seconds, to wait for a health check response before deciding it failed. Defaults to 2. Minimum value of  1. Maximum value of 20.
   *
   * @default 2. Minimum value of  1. Maximum value of 20.
   * @schema ServiceSpecForProviderHealthCheckConfiguration#timeout
   */
  readonly timeout?: number;

  /**
   * Number of consecutive checks that must fail before App Runner decides that the service is unhealthy. Defaults to 5. Minimum value of  1. Maximum value of 20.
   *
   * @default 5. Minimum value of  1. Maximum value of 20.
   * @schema ServiceSpecForProviderHealthCheckConfiguration#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderHealthCheckConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderHealthCheckConfiguration(obj: ServiceSpecForProviderHealthCheckConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthyThreshold': obj.healthyThreshold,
    'interval': obj.interval,
    'path': obj.path,
    'protocol': obj.protocol,
    'timeout': obj.timeout,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderInstanceConfiguration
 */
export interface ServiceSpecForProviderInstanceConfiguration {
  /**
   * Number of CPU units reserved for each instance of your App Runner service represented as a String. Defaults to 1024. Valid values: 1024|2048|(1|2) vCPU.
   *
   * @default 1024. Valid values: 1024|2048|(1|2) vCPU.
   * @schema ServiceSpecForProviderInstanceConfiguration#cpu
   */
  readonly cpu?: string;

  /**
   * ARN of an IAM role that provides permissions to your App Runner service. These are permissions that your code needs when it calls any AWS APIs.
   *
   * @schema ServiceSpecForProviderInstanceConfiguration#instanceRoleArn
   */
  readonly instanceRoleArn?: string;

  /**
   * Amount of memory, in MB or GB, reserved for each instance of your App Runner service. Defaults to 2048. Valid values: 2048|3072|4096|(2|3|4) GB.
   *
   * @default 2048. Valid values: 2048|3072|4096|(2|3|4) GB.
   * @schema ServiceSpecForProviderInstanceConfiguration#memory
   */
  readonly memory?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderInstanceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderInstanceConfiguration(obj: ServiceSpecForProviderInstanceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpu': obj.cpu,
    'instanceRoleArn': obj.instanceRoleArn,
    'memory': obj.memory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderNetworkConfiguration
 */
export interface ServiceSpecForProviderNetworkConfiguration {
  /**
   * Network configuration settings for outbound message traffic. See Egress Configuration below for more details.
   *
   * @schema ServiceSpecForProviderNetworkConfiguration#egressConfiguration
   */
  readonly egressConfiguration?: ServiceSpecForProviderNetworkConfigurationEgressConfiguration[];

  /**
   * Network configuration settings for inbound network traffic. See Ingress Configuration below for more details.
   *
   * @schema ServiceSpecForProviderNetworkConfiguration#ingressConfiguration
   */
  readonly ingressConfiguration?: ServiceSpecForProviderNetworkConfigurationIngressConfiguration[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfiguration(obj: ServiceSpecForProviderNetworkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressConfiguration': obj.egressConfiguration?.map(y => toJson_ServiceSpecForProviderNetworkConfigurationEgressConfiguration(y)),
    'ingressConfiguration': obj.ingressConfiguration?.map(y => toJson_ServiceSpecForProviderNetworkConfigurationIngressConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderObservabilityConfiguration
 */
export interface ServiceSpecForProviderObservabilityConfiguration {
  /**
   * ARN of the observability configuration that is associated with the service. Specified only when observability_enabled is true.
   *
   * @schema ServiceSpecForProviderObservabilityConfiguration#observabilityConfigurationArn
   */
  readonly observabilityConfigurationArn?: string;

  /**
   * Reference to a ObservabilityConfiguration in apprunner to populate observabilityConfigurationArn.
   *
   * @schema ServiceSpecForProviderObservabilityConfiguration#observabilityConfigurationArnRef
   */
  readonly observabilityConfigurationArnRef?: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRef;

  /**
   * Selector for a ObservabilityConfiguration in apprunner to populate observabilityConfigurationArn.
   *
   * @schema ServiceSpecForProviderObservabilityConfiguration#observabilityConfigurationArnSelector
   */
  readonly observabilityConfigurationArnSelector?: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelector;

  /**
   * When true, an observability configuration resource is associated with the service.
   *
   * @schema ServiceSpecForProviderObservabilityConfiguration#observabilityEnabled
   */
  readonly observabilityEnabled: boolean;

}

/**
 * Converts an object of type 'ServiceSpecForProviderObservabilityConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderObservabilityConfiguration(obj: ServiceSpecForProviderObservabilityConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'observabilityConfigurationArn': obj.observabilityConfigurationArn,
    'observabilityConfigurationArnRef': toJson_ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRef(obj.observabilityConfigurationArnRef),
    'observabilityConfigurationArnSelector': toJson_ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelector(obj.observabilityConfigurationArnSelector),
    'observabilityEnabled': obj.observabilityEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderSourceConfiguration
 */
export interface ServiceSpecForProviderSourceConfiguration {
  /**
   * Describes resources needed to authenticate access to some source repositories. See Authentication Configuration below for more details.
   *
   * @schema ServiceSpecForProviderSourceConfiguration#authenticationConfiguration
   */
  readonly authenticationConfiguration?: ServiceSpecForProviderSourceConfigurationAuthenticationConfiguration[];

  /**
   * Whether continuous integration from the source repository is enabled for the App Runner service. If set to true, each repository change (source code commit or new image version) starts a deployment. Defaults to true.
   *
   * @default true.
   * @schema ServiceSpecForProviderSourceConfiguration#autoDeploymentsEnabled
   */
  readonly autoDeploymentsEnabled?: boolean;

  /**
   * Description of a source code repository. See Code Repository below for more details.
   *
   * @schema ServiceSpecForProviderSourceConfiguration#codeRepository
   */
  readonly codeRepository?: ServiceSpecForProviderSourceConfigurationCodeRepository[];

  /**
   * Description of a source image repository. See Image Repository below for more details.
   *
   * @schema ServiceSpecForProviderSourceConfiguration#imageRepository
   */
  readonly imageRepository?: ServiceSpecForProviderSourceConfigurationImageRepository[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfiguration(obj: ServiceSpecForProviderSourceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationConfiguration': obj.authenticationConfiguration?.map(y => toJson_ServiceSpecForProviderSourceConfigurationAuthenticationConfiguration(y)),
    'autoDeploymentsEnabled': obj.autoDeploymentsEnabled,
    'codeRepository': obj.codeRepository?.map(y => toJson_ServiceSpecForProviderSourceConfigurationCodeRepository(y)),
    'imageRepository': obj.imageRepository?.map(y => toJson_ServiceSpecForProviderSourceConfigurationImageRepository(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecProviderConfigRefPolicy
 */
export interface ServiceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRefPolicy(obj: ServiceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecProviderRefPolicy
 */
export interface ServiceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderRefPolicy(obj: ServiceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj: ServiceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj: ServiceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderNetworkConfigurationEgressConfiguration
 */
export interface ServiceSpecForProviderNetworkConfigurationEgressConfiguration {
  /**
   * Type of egress configuration.Set to DEFAULT for access to resources hosted on public networks.Set to VPC to associate your service to a custom VPC specified by VpcConnectorArn.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfiguration#egressType
   */
  readonly egressType?: string;

  /**
   * ARN of the App Runner VPC connector that you want to associate with your App Runner service. Only valid when EgressType = VPC.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfiguration#vpcConnectorArn
   */
  readonly vpcConnectorArn?: string;

  /**
   * Reference to a VPCConnector in apprunner to populate vpcConnectorArn.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfiguration#vpcConnectorArnRef
   */
  readonly vpcConnectorArnRef?: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRef;

  /**
   * Selector for a VPCConnector in apprunner to populate vpcConnectorArn.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfiguration#vpcConnectorArnSelector
   */
  readonly vpcConnectorArnSelector?: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelector;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationEgressConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationEgressConfiguration(obj: ServiceSpecForProviderNetworkConfigurationEgressConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressType': obj.egressType,
    'vpcConnectorArn': obj.vpcConnectorArn,
    'vpcConnectorArnRef': toJson_ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRef(obj.vpcConnectorArnRef),
    'vpcConnectorArnSelector': toJson_ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelector(obj.vpcConnectorArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderNetworkConfigurationIngressConfiguration
 */
export interface ServiceSpecForProviderNetworkConfigurationIngressConfiguration {
  /**
   * Specifies whether your App Runner service is publicly accessible. To make the service publicly accessible set it to True. To make the service privately accessible, from only within an Amazon VPC set it to False.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationIngressConfiguration#isPubliclyAccessible
   */
  readonly isPubliclyAccessible?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationIngressConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationIngressConfiguration(obj: ServiceSpecForProviderNetworkConfigurationIngressConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'isPubliclyAccessible': obj.isPubliclyAccessible,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ObservabilityConfiguration in apprunner to populate observabilityConfigurationArn.
 *
 * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRef
 */
export interface ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRef#policy
   */
  readonly policy?: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRef(obj: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ObservabilityConfiguration in apprunner to populate observabilityConfigurationArn.
 *
 * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelector
 */
export interface ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelector#policy
   */
  readonly policy?: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelector(obj: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfiguration
 */
export interface ServiceSpecForProviderSourceConfigurationAuthenticationConfiguration {
  /**
   * ARN of the IAM role that grants the App Runner service access to a source repository. Required for ECR image repositories (but not for ECR Public)
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfiguration#accessRoleArn
   */
  readonly accessRoleArn?: string;

  /**
   * ARN of the App Runner connection that enables the App Runner service to connect to a source repository. Required for GitHub code repositories.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfiguration#connectionArn
   */
  readonly connectionArn?: string;

  /**
   * Reference to a Connection in apprunner to populate connectionArn.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfiguration#connectionArnRef
   */
  readonly connectionArnRef?: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRef;

  /**
   * Selector for a Connection in apprunner to populate connectionArn.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfiguration#connectionArnSelector
   */
  readonly connectionArnSelector?: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelector;

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfigurationAuthenticationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfigurationAuthenticationConfiguration(obj: ServiceSpecForProviderSourceConfigurationAuthenticationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessRoleArn': obj.accessRoleArn,
    'connectionArn': obj.connectionArn,
    'connectionArnRef': toJson_ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRef(obj.connectionArnRef),
    'connectionArnSelector': toJson_ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelector(obj.connectionArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderSourceConfigurationCodeRepository
 */
export interface ServiceSpecForProviderSourceConfigurationCodeRepository {
  /**
   * Configuration for building and running the service from a source code repository. See Code Configuration below for more details.
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepository#codeConfiguration
   */
  readonly codeConfiguration?: ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfiguration[];

  /**
   * Location of the repository that contains the source code.
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepository#repositoryUrl
   */
  readonly repositoryUrl: string;

  /**
   * Version that should be used within the source code repository. See Source Code Version below for more details.
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepository#sourceCodeVersion
   */
  readonly sourceCodeVersion: ServiceSpecForProviderSourceConfigurationCodeRepositorySourceCodeVersion[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfigurationCodeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfigurationCodeRepository(obj: ServiceSpecForProviderSourceConfigurationCodeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeConfiguration': obj.codeConfiguration?.map(y => toJson_ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfiguration(y)),
    'repositoryUrl': obj.repositoryUrl,
    'sourceCodeVersion': obj.sourceCodeVersion?.map(y => toJson_ServiceSpecForProviderSourceConfigurationCodeRepositorySourceCodeVersion(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderSourceConfigurationImageRepository
 */
export interface ServiceSpecForProviderSourceConfigurationImageRepository {
  /**
   * Configuration for running the identified image. See Image Configuration below for more details.
   *
   * @schema ServiceSpecForProviderSourceConfigurationImageRepository#imageConfiguration
   */
  readonly imageConfiguration?: ServiceSpecForProviderSourceConfigurationImageRepositoryImageConfiguration[];

  /**
   * Identifier of an image. For an image in Amazon Elastic Container Registry (Amazon ECR), this is an image name. For the image name format, see Pulling an image in the Amazon ECR User Guide.
   *
   * @schema ServiceSpecForProviderSourceConfigurationImageRepository#imageIdentifier
   */
  readonly imageIdentifier: string;

  /**
   * Type of the image repository. This reflects the repository provider and whether the repository is private or public. Valid values: ECR , ECR_PUBLIC.
   *
   * @schema ServiceSpecForProviderSourceConfigurationImageRepository#imageRepositoryType
   */
  readonly imageRepositoryType: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfigurationImageRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfigurationImageRepository(obj: ServiceSpecForProviderSourceConfigurationImageRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageConfiguration': obj.imageConfiguration?.map(y => toJson_ServiceSpecForProviderSourceConfigurationImageRepositoryImageConfiguration(y)),
    'imageIdentifier': obj.imageIdentifier,
    'imageRepositoryType': obj.imageRepositoryType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolution
 */
export enum ServiceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolve
 */
export enum ServiceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecProviderRefPolicyResolution
 */
export enum ServiceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecProviderRefPolicyResolve
 */
export enum ServiceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPCConnector in apprunner to populate vpcConnectorArn.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRef
 */
export interface ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRef#policy
   */
  readonly policy?: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRef(obj: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPCConnector in apprunner to populate vpcConnectorArn.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelector
 */
export interface ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelector#policy
   */
  readonly policy?: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelector(obj: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicy
 */
export interface ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicy(obj: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicy
 */
export interface ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicy(obj: ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection in apprunner to populate connectionArn.
 *
 * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRef
 */
export interface ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRef#policy
   */
  readonly policy?: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRef(obj: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection in apprunner to populate connectionArn.
 *
 * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelector
 */
export interface ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelector#policy
   */
  readonly policy?: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelector(obj: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfiguration
 */
export interface ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfiguration {
  /**
   * Basic configuration for building and running the App Runner service. Use this parameter to quickly launch an App Runner service without providing an apprunner.yaml file in the source code repository (or ignoring the file if it exists). See Code Configuration Values below for more details.
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfiguration#codeConfigurationValues
   */
  readonly codeConfigurationValues?: ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues[];

  /**
   * Source of the App Runner configuration. Valid values: REPOSITORY, API. Values are interpreted as follows:
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfiguration#configurationSource
   */
  readonly configurationSource: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfiguration(obj: ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codeConfigurationValues': obj.codeConfigurationValues?.map(y => toJson_ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues(y)),
    'configurationSource': obj.configurationSource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderSourceConfigurationCodeRepositorySourceCodeVersion
 */
export interface ServiceSpecForProviderSourceConfigurationCodeRepositorySourceCodeVersion {
  /**
   * Type of version identifier. For a git-based repository, branches represent versions. Valid values: BRANCH.
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepositorySourceCodeVersion#type
   */
  readonly type: string;

  /**
   * Source code version. For a git-based repository, a branch name maps to a specific version. App Runner uses the most recent commit to the branch.
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepositorySourceCodeVersion#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfigurationCodeRepositorySourceCodeVersion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfigurationCodeRepositorySourceCodeVersion(obj: ServiceSpecForProviderSourceConfigurationCodeRepositorySourceCodeVersion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderSourceConfigurationImageRepositoryImageConfiguration
 */
export interface ServiceSpecForProviderSourceConfigurationImageRepositoryImageConfiguration {
  /**
   * Port that your application listens to in the container. Defaults to "8080".
   *
   * @default 8080".
   * @schema ServiceSpecForProviderSourceConfigurationImageRepositoryImageConfiguration#port
   */
  readonly port?: string;

  /**
   * Secrets and parameters available to your service as environment variables. A map of key/value pairs.
   *
   * @schema ServiceSpecForProviderSourceConfigurationImageRepositoryImageConfiguration#runtimeEnvironmentSecrets
   */
  readonly runtimeEnvironmentSecrets?: { [key: string]: string };

  /**
   * Environment variables available to your running App Runner service. A map of key/value pairs. Keys with a prefix of AWSAPPRUNNER are reserved for system use and aren't valid.
   *
   * @schema ServiceSpecForProviderSourceConfigurationImageRepositoryImageConfiguration#runtimeEnvironmentVariables
   */
  readonly runtimeEnvironmentVariables?: { [key: string]: string };

  /**
   * Command App Runner runs to start the application in the source image. If specified, this command overrides the Docker image’s default start command.
   *
   * @schema ServiceSpecForProviderSourceConfigurationImageRepositoryImageConfiguration#startCommand
   */
  readonly startCommand?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfigurationImageRepositoryImageConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfigurationImageRepositoryImageConfiguration(obj: ServiceSpecForProviderSourceConfigurationImageRepositoryImageConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'runtimeEnvironmentSecrets': ((obj.runtimeEnvironmentSecrets) === undefined) ? undefined : (Object.entries(obj.runtimeEnvironmentSecrets).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'runtimeEnvironmentVariables': ((obj.runtimeEnvironmentVariables) === undefined) ? undefined : (Object.entries(obj.runtimeEnvironmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'startCommand': obj.startCommand,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicy
 */
export interface ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicy(obj: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicy
 */
export interface ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicy(obj: ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicyResolution
 */
export enum ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicyResolve
 */
export enum ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicyResolution
 */
export enum ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicyResolve
 */
export enum ServiceSpecForProviderObservabilityConfigurationObservabilityConfigurationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicy
 */
export interface ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicy(obj: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicy
 */
export interface ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicy(obj: ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues
 */
export interface ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues {
  /**
   * Command App Runner runs to build your application.
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues#buildCommand
   */
  readonly buildCommand?: string;

  /**
   * Port that your application listens to in the container. Defaults to "8080".
   *
   * @default 8080".
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues#port
   */
  readonly port?: string;

  /**
   * Runtime environment type for building and running an App Runner service. Represents a programming language runtime. Valid values: PYTHON_3, NODEJS_12, NODEJS_14, NODEJS_16, CORRETTO_8, CORRETTO_11, GO_1, DOTNET_6, PHP_81, RUBY_31.
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues#runtime
   */
  readonly runtime: string;

  /**
   * Secrets and parameters available to your service as environment variables. A map of key/value pairs.
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues#runtimeEnvironmentSecrets
   */
  readonly runtimeEnvironmentSecrets?: { [key: string]: string };

  /**
   * Environment variables available to your running App Runner service. A map of key/value pairs. Keys with a prefix of AWSAPPRUNNER are reserved for system use and aren't valid.
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues#runtimeEnvironmentVariables
   */
  readonly runtimeEnvironmentVariables?: { [key: string]: string };

  /**
   * Command App Runner runs to start the application in the source image. If specified, this command overrides the Docker image’s default start command.
   *
   * @schema ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues#startCommand
   */
  readonly startCommand?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues(obj: ServiceSpecForProviderSourceConfigurationCodeRepositoryCodeConfigurationCodeConfigurationValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buildCommand': obj.buildCommand,
    'port': obj.port,
    'runtime': obj.runtime,
    'runtimeEnvironmentSecrets': ((obj.runtimeEnvironmentSecrets) === undefined) ? undefined : (Object.entries(obj.runtimeEnvironmentSecrets).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'runtimeEnvironmentVariables': ((obj.runtimeEnvironmentVariables) === undefined) ? undefined : (Object.entries(obj.runtimeEnvironmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'startCommand': obj.startCommand,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicyResolution
 */
export enum ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicyResolve
 */
export enum ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicyResolution
 */
export enum ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicyResolve
 */
export enum ServiceSpecForProviderNetworkConfigurationEgressConfigurationVpcConnectorArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicyResolution
 */
export enum ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicyResolve
 */
export enum ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicyResolution
 */
export enum ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicyResolve
 */
export enum ServiceSpecForProviderSourceConfigurationAuthenticationConfigurationConnectionArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCConnector is the Schema for the VPCConnectors API. Manages an App Runner VPC Connector.
 *
 * @schema VPCConnector
 */
export class VpcConnector extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCConnector"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'apprunner.aws.upbound.io/v1beta1',
    kind: 'VPCConnector',
  }

  /**
   * Renders a Kubernetes manifest for "VPCConnector".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcConnectorProps): any {
    return {
      ...VpcConnector.GVK,
      ...toJson_VpcConnectorProps(props),
    };
  }

  /**
   * Defines a "VPCConnector" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcConnectorProps) {
    super(scope, id, {
      ...VpcConnector.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpcConnector.GVK,
      ...toJson_VpcConnectorProps(resolved),
    };
  }
}

/**
 * VPCConnector is the Schema for the VPCConnectors API. Manages an App Runner VPC Connector.
 *
 * @schema VPCConnector
 */
export interface VpcConnectorProps {
  /**
   * @schema VPCConnector#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCConnectorSpec defines the desired state of VPCConnector
   *
   * @schema VPCConnector#spec
   */
  readonly spec: VpcConnectorSpec;

}

/**
 * Converts an object of type 'VpcConnectorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorProps(obj: VpcConnectorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcConnectorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCConnectorSpec defines the desired state of VPCConnector
 *
 * @schema VpcConnectorSpec
 */
export interface VpcConnectorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema VpcConnectorSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcConnectorSpecDeletionPolicy;

  /**
   * @schema VpcConnectorSpec#forProvider
   */
  readonly forProvider: VpcConnectorSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcConnectorSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcConnectorSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema VpcConnectorSpec#providerRef
   */
  readonly providerRef?: VpcConnectorSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcConnectorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcConnectorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcConnectorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcConnectorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcConnectorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpec(obj: VpcConnectorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcConnectorSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_VpcConnectorSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_VpcConnectorSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_VpcConnectorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcConnectorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema VpcConnectorSpecDeletionPolicy
 */
export enum VpcConnectorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VpcConnectorSpecForProvider
 */
export interface VpcConnectorSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VpcConnectorSpecForProvider#region
   */
  readonly region: string;

  /**
   * References to SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema VpcConnectorSpecForProvider#securityGroupRefs
   */
  readonly securityGroupRefs?: VpcConnectorSpecForProviderSecurityGroupRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema VpcConnectorSpecForProvider#securityGroupSelector
   */
  readonly securityGroupSelector?: VpcConnectorSpecForProviderSecurityGroupSelector;

  /**
   * List of IDs of security groups that App Runner should use for access to AWS resources under the specified subnets. If not specified, App Runner uses the default security group of the Amazon VPC. The default security group allows all outbound traffic.
   *
   * @schema VpcConnectorSpecForProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * References to Subnet in ec2 to populate subnets.
   *
   * @schema VpcConnectorSpecForProvider#subnetRefs
   */
  readonly subnetRefs?: VpcConnectorSpecForProviderSubnetRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnets.
   *
   * @schema VpcConnectorSpecForProvider#subnetSelector
   */
  readonly subnetSelector?: VpcConnectorSpecForProviderSubnetSelector;

  /**
   * List of IDs of subnets that App Runner should use when it associates your service with a custom Amazon VPC. Specify IDs of subnets of a single Amazon VPC. App Runner determines the Amazon VPC from the subnets you specify.
   *
   * @schema VpcConnectorSpecForProvider#subnets
   */
  readonly subnets?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VpcConnectorSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Name for the VPC connector.
   *
   * @schema VpcConnectorSpecForProvider#vpcConnectorName
   */
  readonly vpcConnectorName: string;

}

/**
 * Converts an object of type 'VpcConnectorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecForProvider(obj: VpcConnectorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'securityGroupRefs': obj.securityGroupRefs?.map(y => toJson_VpcConnectorSpecForProviderSecurityGroupRefs(y)),
    'securityGroupSelector': toJson_VpcConnectorSpecForProviderSecurityGroupSelector(obj.securityGroupSelector),
    'securityGroups': obj.securityGroups?.map(y => y),
    'subnetRefs': obj.subnetRefs?.map(y => toJson_VpcConnectorSpecForProviderSubnetRefs(y)),
    'subnetSelector': toJson_VpcConnectorSpecForProviderSubnetSelector(obj.subnetSelector),
    'subnets': obj.subnets?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcConnectorName': obj.vpcConnectorName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcConnectorSpecProviderConfigRef
 */
export interface VpcConnectorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcConnectorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcConnectorSpecProviderConfigRef#policy
   */
  readonly policy?: VpcConnectorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcConnectorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecProviderConfigRef(obj: VpcConnectorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcConnectorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema VpcConnectorSpecProviderRef
 */
export interface VpcConnectorSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcConnectorSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcConnectorSpecProviderRef#policy
   */
  readonly policy?: VpcConnectorSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'VpcConnectorSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecProviderRef(obj: VpcConnectorSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcConnectorSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcConnectorSpecPublishConnectionDetailsTo
 */
export interface VpcConnectorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcConnectorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcConnectorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcConnectorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcConnectorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcConnectorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcConnectorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecPublishConnectionDetailsTo(obj: VpcConnectorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcConnectorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcConnectorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcConnectorSpecWriteConnectionSecretToRef
 */
export interface VpcConnectorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcConnectorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcConnectorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcConnectorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecWriteConnectionSecretToRef(obj: VpcConnectorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcConnectorSpecForProviderSecurityGroupRefs
 */
export interface VpcConnectorSpecForProviderSecurityGroupRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcConnectorSpecForProviderSecurityGroupRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcConnectorSpecForProviderSecurityGroupRefs#policy
   */
  readonly policy?: VpcConnectorSpecForProviderSecurityGroupRefsPolicy;

}

/**
 * Converts an object of type 'VpcConnectorSpecForProviderSecurityGroupRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecForProviderSecurityGroupRefs(obj: VpcConnectorSpecForProviderSecurityGroupRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcConnectorSpecForProviderSecurityGroupRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
 *
 * @schema VpcConnectorSpecForProviderSecurityGroupSelector
 */
export interface VpcConnectorSpecForProviderSecurityGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcConnectorSpecForProviderSecurityGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcConnectorSpecForProviderSecurityGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcConnectorSpecForProviderSecurityGroupSelector#policy
   */
  readonly policy?: VpcConnectorSpecForProviderSecurityGroupSelectorPolicy;

}

/**
 * Converts an object of type 'VpcConnectorSpecForProviderSecurityGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecForProviderSecurityGroupSelector(obj: VpcConnectorSpecForProviderSecurityGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcConnectorSpecForProviderSecurityGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcConnectorSpecForProviderSubnetRefs
 */
export interface VpcConnectorSpecForProviderSubnetRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcConnectorSpecForProviderSubnetRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcConnectorSpecForProviderSubnetRefs#policy
   */
  readonly policy?: VpcConnectorSpecForProviderSubnetRefsPolicy;

}

/**
 * Converts an object of type 'VpcConnectorSpecForProviderSubnetRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecForProviderSubnetRefs(obj: VpcConnectorSpecForProviderSubnetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcConnectorSpecForProviderSubnetRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnets.
 *
 * @schema VpcConnectorSpecForProviderSubnetSelector
 */
export interface VpcConnectorSpecForProviderSubnetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcConnectorSpecForProviderSubnetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcConnectorSpecForProviderSubnetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcConnectorSpecForProviderSubnetSelector#policy
   */
  readonly policy?: VpcConnectorSpecForProviderSubnetSelectorPolicy;

}

/**
 * Converts an object of type 'VpcConnectorSpecForProviderSubnetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecForProviderSubnetSelector(obj: VpcConnectorSpecForProviderSubnetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcConnectorSpecForProviderSubnetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcConnectorSpecProviderConfigRefPolicy
 */
export interface VpcConnectorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcConnectorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcConnectorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcConnectorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcConnectorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcConnectorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecProviderConfigRefPolicy(obj: VpcConnectorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcConnectorSpecProviderRefPolicy
 */
export interface VpcConnectorSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcConnectorSpecProviderRefPolicy#resolution
   */
  readonly resolution?: VpcConnectorSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcConnectorSpecProviderRefPolicy#resolve
   */
  readonly resolve?: VpcConnectorSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcConnectorSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecProviderRefPolicy(obj: VpcConnectorSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcConnectorSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcConnectorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcConnectorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcConnectorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcConnectorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecPublishConnectionDetailsToConfigRef(obj: VpcConnectorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcConnectorSpecPublishConnectionDetailsToMetadata
 */
export interface VpcConnectorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcConnectorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcConnectorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcConnectorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcConnectorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecPublishConnectionDetailsToMetadata(obj: VpcConnectorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcConnectorSpecForProviderSecurityGroupRefsPolicy
 */
export interface VpcConnectorSpecForProviderSecurityGroupRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcConnectorSpecForProviderSecurityGroupRefsPolicy#resolution
   */
  readonly resolution?: VpcConnectorSpecForProviderSecurityGroupRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcConnectorSpecForProviderSecurityGroupRefsPolicy#resolve
   */
  readonly resolve?: VpcConnectorSpecForProviderSecurityGroupRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcConnectorSpecForProviderSecurityGroupRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecForProviderSecurityGroupRefsPolicy(obj: VpcConnectorSpecForProviderSecurityGroupRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcConnectorSpecForProviderSecurityGroupSelectorPolicy
 */
export interface VpcConnectorSpecForProviderSecurityGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcConnectorSpecForProviderSecurityGroupSelectorPolicy#resolution
   */
  readonly resolution?: VpcConnectorSpecForProviderSecurityGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcConnectorSpecForProviderSecurityGroupSelectorPolicy#resolve
   */
  readonly resolve?: VpcConnectorSpecForProviderSecurityGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcConnectorSpecForProviderSecurityGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecForProviderSecurityGroupSelectorPolicy(obj: VpcConnectorSpecForProviderSecurityGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcConnectorSpecForProviderSubnetRefsPolicy
 */
export interface VpcConnectorSpecForProviderSubnetRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcConnectorSpecForProviderSubnetRefsPolicy#resolution
   */
  readonly resolution?: VpcConnectorSpecForProviderSubnetRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcConnectorSpecForProviderSubnetRefsPolicy#resolve
   */
  readonly resolve?: VpcConnectorSpecForProviderSubnetRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcConnectorSpecForProviderSubnetRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecForProviderSubnetRefsPolicy(obj: VpcConnectorSpecForProviderSubnetRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcConnectorSpecForProviderSubnetSelectorPolicy
 */
export interface VpcConnectorSpecForProviderSubnetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcConnectorSpecForProviderSubnetSelectorPolicy#resolution
   */
  readonly resolution?: VpcConnectorSpecForProviderSubnetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcConnectorSpecForProviderSubnetSelectorPolicy#resolve
   */
  readonly resolve?: VpcConnectorSpecForProviderSubnetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcConnectorSpecForProviderSubnetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecForProviderSubnetSelectorPolicy(obj: VpcConnectorSpecForProviderSubnetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcConnectorSpecProviderConfigRefPolicyResolution
 */
export enum VpcConnectorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcConnectorSpecProviderConfigRefPolicyResolve
 */
export enum VpcConnectorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcConnectorSpecProviderRefPolicyResolution
 */
export enum VpcConnectorSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcConnectorSpecProviderRefPolicyResolve
 */
export enum VpcConnectorSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcConnectorSpecForProviderSecurityGroupRefsPolicyResolution
 */
export enum VpcConnectorSpecForProviderSecurityGroupRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcConnectorSpecForProviderSecurityGroupRefsPolicyResolve
 */
export enum VpcConnectorSpecForProviderSecurityGroupRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcConnectorSpecForProviderSecurityGroupSelectorPolicyResolution
 */
export enum VpcConnectorSpecForProviderSecurityGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcConnectorSpecForProviderSecurityGroupSelectorPolicyResolve
 */
export enum VpcConnectorSpecForProviderSecurityGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcConnectorSpecForProviderSubnetRefsPolicyResolution
 */
export enum VpcConnectorSpecForProviderSubnetRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcConnectorSpecForProviderSubnetRefsPolicyResolve
 */
export enum VpcConnectorSpecForProviderSubnetRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcConnectorSpecForProviderSubnetSelectorPolicyResolution
 */
export enum VpcConnectorSpecForProviderSubnetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcConnectorSpecForProviderSubnetSelectorPolicyResolve
 */
export enum VpcConnectorSpecForProviderSubnetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

