// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AccountAssignment is the Schema for the AccountAssignments API. Manages a Single Sign-On (SSO) Account Assignment
 *
 * @schema AccountAssignment
 */
export class AccountAssignment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccountAssignment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta1',
    kind: 'AccountAssignment',
  }

  /**
   * Renders a Kubernetes manifest for "AccountAssignment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccountAssignmentProps): any {
    return {
      ...AccountAssignment.GVK,
      ...toJson_AccountAssignmentProps(props),
    };
  }

  /**
   * Defines a "AccountAssignment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccountAssignmentProps) {
    super(scope, id, {
      ...AccountAssignment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccountAssignment.GVK,
      ...toJson_AccountAssignmentProps(resolved),
    };
  }
}

/**
 * AccountAssignment is the Schema for the AccountAssignments API. Manages a Single Sign-On (SSO) Account Assignment
 *
 * @schema AccountAssignment
 */
export interface AccountAssignmentProps {
  /**
   * @schema AccountAssignment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccountAssignmentSpec defines the desired state of AccountAssignment
   *
   * @schema AccountAssignment#spec
   */
  readonly spec: AccountAssignmentSpec;

}

/**
 * Converts an object of type 'AccountAssignmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentProps(obj: AccountAssignmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccountAssignmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccountAssignmentSpec defines the desired state of AccountAssignment
 *
 * @schema AccountAssignmentSpec
 */
export interface AccountAssignmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountAssignmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccountAssignmentSpecDeletionPolicy;

  /**
   * @schema AccountAssignmentSpec#forProvider
   */
  readonly forProvider: AccountAssignmentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountAssignmentSpec#managementPolicy
   */
  readonly managementPolicy?: AccountAssignmentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccountAssignmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccountAssignmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AccountAssignmentSpec#providerRef
   */
  readonly providerRef?: AccountAssignmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccountAssignmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccountAssignmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccountAssignmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccountAssignmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccountAssignmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpec(obj: AccountAssignmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccountAssignmentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AccountAssignmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AccountAssignmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AccountAssignmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccountAssignmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountAssignmentSpecDeletionPolicy
 */
export enum AccountAssignmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccountAssignmentSpecForProvider
 */
export interface AccountAssignmentSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the SSO Instance.
   *
   * @schema AccountAssignmentSpecForProvider#instanceArn
   */
  readonly instanceArn: string;

  /**
   * The Amazon Resource Name (ARN) of the Permission Set that the admin wants to grant the principal access to.
   *
   * @schema AccountAssignmentSpecForProvider#permissionSetArn
   */
  readonly permissionSetArn: string;

  /**
   * An identifier for an object in SSO, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6).
   *
   * @schema AccountAssignmentSpecForProvider#principalId
   */
  readonly principalId: string;

  /**
   * The entity type for which the assignment will be created. Valid values: USER, GROUP.
   *
   * @schema AccountAssignmentSpecForProvider#principalType
   */
  readonly principalType: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccountAssignmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * An AWS account identifier, typically a 10-12 digit string.
   *
   * @schema AccountAssignmentSpecForProvider#targetId
   */
  readonly targetId: string;

  /**
   * The entity type for which the assignment will be created. Valid values: AWS_ACCOUNT.
   *
   * @schema AccountAssignmentSpecForProvider#targetType
   */
  readonly targetType?: string;

}

/**
 * Converts an object of type 'AccountAssignmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecForProvider(obj: AccountAssignmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceArn': obj.instanceArn,
    'permissionSetArn': obj.permissionSetArn,
    'principalId': obj.principalId,
    'principalType': obj.principalType,
    'region': obj.region,
    'targetId': obj.targetId,
    'targetType': obj.targetType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountAssignmentSpecManagementPolicy
 */
export enum AccountAssignmentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccountAssignmentSpecProviderConfigRef
 */
export interface AccountAssignmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountAssignmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountAssignmentSpecProviderConfigRef#policy
   */
  readonly policy?: AccountAssignmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountAssignmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecProviderConfigRef(obj: AccountAssignmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountAssignmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AccountAssignmentSpecProviderRef
 */
export interface AccountAssignmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountAssignmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountAssignmentSpecProviderRef#policy
   */
  readonly policy?: AccountAssignmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AccountAssignmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecProviderRef(obj: AccountAssignmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountAssignmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsTo
 */
export interface AccountAssignmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccountAssignmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccountAssignmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccountAssignmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecPublishConnectionDetailsTo(obj: AccountAssignmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccountAssignmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccountAssignmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccountAssignmentSpecWriteConnectionSecretToRef
 */
export interface AccountAssignmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccountAssignmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccountAssignmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccountAssignmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecWriteConnectionSecretToRef(obj: AccountAssignmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountAssignmentSpecProviderConfigRefPolicy
 */
export interface AccountAssignmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountAssignmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccountAssignmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountAssignmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccountAssignmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountAssignmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecProviderConfigRefPolicy(obj: AccountAssignmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountAssignmentSpecProviderRefPolicy
 */
export interface AccountAssignmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountAssignmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AccountAssignmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountAssignmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AccountAssignmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountAssignmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecProviderRefPolicy(obj: AccountAssignmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRef
 */
export interface AccountAssignmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountAssignmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecPublishConnectionDetailsToConfigRef(obj: AccountAssignmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsToMetadata
 */
export interface AccountAssignmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccountAssignmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecPublishConnectionDetailsToMetadata(obj: AccountAssignmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountAssignmentSpecProviderConfigRefPolicyResolution
 */
export enum AccountAssignmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountAssignmentSpecProviderConfigRefPolicyResolve
 */
export enum AccountAssignmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountAssignmentSpecProviderRefPolicyResolution
 */
export enum AccountAssignmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountAssignmentSpecProviderRefPolicyResolve
 */
export enum AccountAssignmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ManagedPolicyAttachment is the Schema for the ManagedPolicyAttachments API. Manages an IAM managed policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema ManagedPolicyAttachment
 */
export class ManagedPolicyAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ManagedPolicyAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta1',
    kind: 'ManagedPolicyAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "ManagedPolicyAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ManagedPolicyAttachmentProps): any {
    return {
      ...ManagedPolicyAttachment.GVK,
      ...toJson_ManagedPolicyAttachmentProps(props),
    };
  }

  /**
   * Defines a "ManagedPolicyAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ManagedPolicyAttachmentProps) {
    super(scope, id, {
      ...ManagedPolicyAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ManagedPolicyAttachment.GVK,
      ...toJson_ManagedPolicyAttachmentProps(resolved),
    };
  }
}

/**
 * ManagedPolicyAttachment is the Schema for the ManagedPolicyAttachments API. Manages an IAM managed policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema ManagedPolicyAttachment
 */
export interface ManagedPolicyAttachmentProps {
  /**
   * @schema ManagedPolicyAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ManagedPolicyAttachmentSpec defines the desired state of ManagedPolicyAttachment
   *
   * @schema ManagedPolicyAttachment#spec
   */
  readonly spec: ManagedPolicyAttachmentSpec;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentProps(obj: ManagedPolicyAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ManagedPolicyAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ManagedPolicyAttachmentSpec defines the desired state of ManagedPolicyAttachment
 *
 * @schema ManagedPolicyAttachmentSpec
 */
export interface ManagedPolicyAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ManagedPolicyAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: ManagedPolicyAttachmentSpecDeletionPolicy;

  /**
   * @schema ManagedPolicyAttachmentSpec#forProvider
   */
  readonly forProvider: ManagedPolicyAttachmentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ManagedPolicyAttachmentSpec#managementPolicy
   */
  readonly managementPolicy?: ManagedPolicyAttachmentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ManagedPolicyAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: ManagedPolicyAttachmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ManagedPolicyAttachmentSpec#providerRef
   */
  readonly providerRef?: ManagedPolicyAttachmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ManagedPolicyAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ManagedPolicyAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ManagedPolicyAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ManagedPolicyAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpec(obj: ManagedPolicyAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ManagedPolicyAttachmentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ManagedPolicyAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ManagedPolicyAttachmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ManagedPolicyAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ManagedPolicyAttachmentSpecDeletionPolicy
 */
export enum ManagedPolicyAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ManagedPolicyAttachmentSpecForProvider
 */
export interface ManagedPolicyAttachmentSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#instanceArn
   */
  readonly instanceArn: string;

  /**
   * The IAM managed policy Amazon Resource Name (ARN) to be attached to the Permission Set.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#managedPolicyArn
   */
  readonly managedPolicyArn: string;

  /**
   * The Amazon Resource Name (ARN) of the Permission Set.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#permissionSetArn
   */
  readonly permissionSetArn?: string;

  /**
   * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#permissionSetArnRef
   */
  readonly permissionSetArnRef?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef;

  /**
   * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#permissionSetArnSelector
   */
  readonly permissionSetArnSelector?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecForProvider(obj: ManagedPolicyAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceArn': obj.instanceArn,
    'managedPolicyArn': obj.managedPolicyArn,
    'permissionSetArn': obj.permissionSetArn,
    'permissionSetArnRef': toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef(obj.permissionSetArnRef),
    'permissionSetArnSelector': toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector(obj.permissionSetArnSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ManagedPolicyAttachmentSpecManagementPolicy
 */
export enum ManagedPolicyAttachmentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ManagedPolicyAttachmentSpecProviderConfigRef
 */
export interface ManagedPolicyAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedPolicyAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedPolicyAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: ManagedPolicyAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecProviderConfigRef(obj: ManagedPolicyAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedPolicyAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ManagedPolicyAttachmentSpecProviderRef
 */
export interface ManagedPolicyAttachmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedPolicyAttachmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedPolicyAttachmentSpecProviderRef#policy
   */
  readonly policy?: ManagedPolicyAttachmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecProviderRef(obj: ManagedPolicyAttachmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedPolicyAttachmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsTo
 */
export interface ManagedPolicyAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsTo(obj: ManagedPolicyAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ManagedPolicyAttachmentSpecWriteConnectionSecretToRef
 */
export interface ManagedPolicyAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ManagedPolicyAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ManagedPolicyAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecWriteConnectionSecretToRef(obj: ManagedPolicyAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef
 */
export interface ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef#policy
   */
  readonly policy?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef(obj: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector
 */
export interface ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector#policy
   */
  readonly policy?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector(obj: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedPolicyAttachmentSpecProviderConfigRefPolicy
 */
export interface ManagedPolicyAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedPolicyAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedPolicyAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecProviderConfigRefPolicy(obj: ManagedPolicyAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedPolicyAttachmentSpecProviderRefPolicy
 */
export interface ManagedPolicyAttachmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedPolicyAttachmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ManagedPolicyAttachmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedPolicyAttachmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ManagedPolicyAttachmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecProviderRefPolicy(obj: ManagedPolicyAttachmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef(obj: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata(obj: ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy
 */
export interface ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy#resolution
   */
  readonly resolution?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy#resolve
   */
  readonly resolve?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy(obj: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy
 */
export interface ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy#resolution
   */
  readonly resolution?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy#resolve
   */
  readonly resolve?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy(obj: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedPolicyAttachmentSpecProviderRefPolicyResolution
 */
export enum ManagedPolicyAttachmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedPolicyAttachmentSpecProviderRefPolicyResolve
 */
export enum ManagedPolicyAttachmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolution
 */
export enum ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolve
 */
export enum ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution
 */
export enum ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve
 */
export enum ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PermissionSet is the Schema for the PermissionSets API. Manages a Single Sign-On (SSO) Permission Set
 *
 * @schema PermissionSet
 */
export class PermissionSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PermissionSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta1',
    kind: 'PermissionSet',
  }

  /**
   * Renders a Kubernetes manifest for "PermissionSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionSetProps): any {
    return {
      ...PermissionSet.GVK,
      ...toJson_PermissionSetProps(props),
    };
  }

  /**
   * Defines a "PermissionSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionSetProps) {
    super(scope, id, {
      ...PermissionSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PermissionSet.GVK,
      ...toJson_PermissionSetProps(resolved),
    };
  }
}

/**
 * PermissionSet is the Schema for the PermissionSets API. Manages a Single Sign-On (SSO) Permission Set
 *
 * @schema PermissionSet
 */
export interface PermissionSetProps {
  /**
   * @schema PermissionSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PermissionSetSpec defines the desired state of PermissionSet
   *
   * @schema PermissionSet#spec
   */
  readonly spec: PermissionSetSpec;

}

/**
 * Converts an object of type 'PermissionSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetProps(obj: PermissionSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionSetSpec defines the desired state of PermissionSet
 *
 * @schema PermissionSetSpec
 */
export interface PermissionSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionSetSpecDeletionPolicy;

  /**
   * @schema PermissionSetSpec#forProvider
   */
  readonly forProvider: PermissionSetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSetSpec#managementPolicy
   */
  readonly managementPolicy?: PermissionSetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PermissionSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PermissionSetSpec#providerRef
   */
  readonly providerRef?: PermissionSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PermissionSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PermissionSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpec(obj: PermissionSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionSetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PermissionSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PermissionSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PermissionSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSetSpecDeletionPolicy
 */
export enum PermissionSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PermissionSetSpecForProvider
 */
export interface PermissionSetSpecForProvider {
  /**
   * The description of the Permission Set.
   *
   * @schema PermissionSetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.
   *
   * @schema PermissionSetSpecForProvider#instanceArn
   */
  readonly instanceArn?: string;

  /**
   * The name of the Permission Set.
   *
   * @schema PermissionSetSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PermissionSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * The relay state URL used to redirect users within the application during the federation authentication process.
   *
   * @schema PermissionSetSpecForProvider#relayState
   */
  readonly relayState?: string;

  /**
   * The length of time that the application user sessions are valid in the ISO-8601 standard. Default: PT1H.
   *
   * @schema PermissionSetSpecForProvider#sessionDuration
   */
  readonly sessionDuration?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PermissionSetSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PermissionSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecForProvider(obj: PermissionSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instanceArn': obj.instanceArn,
    'name': obj.name,
    'region': obj.region,
    'relayState': obj.relayState,
    'sessionDuration': obj.sessionDuration,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSetSpecManagementPolicy
 */
export enum PermissionSetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PermissionSetSpecProviderConfigRef
 */
export interface PermissionSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetSpecProviderConfigRef#policy
   */
  readonly policy?: PermissionSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecProviderConfigRef(obj: PermissionSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PermissionSetSpecProviderRef
 */
export interface PermissionSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetSpecProviderRef#policy
   */
  readonly policy?: PermissionSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecProviderRef(obj: PermissionSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsTo
 */
export interface PermissionSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecPublishConnectionDetailsTo(obj: PermissionSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PermissionSetSpecWriteConnectionSecretToRef
 */
export interface PermissionSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecWriteConnectionSecretToRef(obj: PermissionSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSetSpecProviderConfigRefPolicy
 */
export interface PermissionSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecProviderConfigRefPolicy(obj: PermissionSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSetSpecProviderRefPolicy
 */
export interface PermissionSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PermissionSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PermissionSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecProviderRefPolicy(obj: PermissionSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecPublishConnectionDetailsToConfigRef(obj: PermissionSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsToMetadata
 */
export interface PermissionSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecPublishConnectionDetailsToMetadata(obj: PermissionSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSetSpecProviderConfigRefPolicyResolution
 */
export enum PermissionSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSetSpecProviderConfigRefPolicyResolve
 */
export enum PermissionSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSetSpecProviderRefPolicyResolution
 */
export enum PermissionSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSetSpecProviderRefPolicyResolve
 */
export enum PermissionSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PermissionSetInlinePolicy is the Schema for the PermissionSetInlinePolicys API. Manages an IAM inline policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema PermissionSetInlinePolicy
 */
export class PermissionSetInlinePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PermissionSetInlinePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta1',
    kind: 'PermissionSetInlinePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "PermissionSetInlinePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionSetInlinePolicyProps): any {
    return {
      ...PermissionSetInlinePolicy.GVK,
      ...toJson_PermissionSetInlinePolicyProps(props),
    };
  }

  /**
   * Defines a "PermissionSetInlinePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionSetInlinePolicyProps) {
    super(scope, id, {
      ...PermissionSetInlinePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PermissionSetInlinePolicy.GVK,
      ...toJson_PermissionSetInlinePolicyProps(resolved),
    };
  }
}

/**
 * PermissionSetInlinePolicy is the Schema for the PermissionSetInlinePolicys API. Manages an IAM inline policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema PermissionSetInlinePolicy
 */
export interface PermissionSetInlinePolicyProps {
  /**
   * @schema PermissionSetInlinePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PermissionSetInlinePolicySpec defines the desired state of PermissionSetInlinePolicy
   *
   * @schema PermissionSetInlinePolicy#spec
   */
  readonly spec: PermissionSetInlinePolicySpec;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicyProps(obj: PermissionSetInlinePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionSetInlinePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionSetInlinePolicySpec defines the desired state of PermissionSetInlinePolicy
 *
 * @schema PermissionSetInlinePolicySpec
 */
export interface PermissionSetInlinePolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSetInlinePolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionSetInlinePolicySpecDeletionPolicy;

  /**
   * @schema PermissionSetInlinePolicySpec#forProvider
   */
  readonly forProvider: PermissionSetInlinePolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSetInlinePolicySpec#managementPolicy
   */
  readonly managementPolicy?: PermissionSetInlinePolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PermissionSetInlinePolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionSetInlinePolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PermissionSetInlinePolicySpec#providerRef
   */
  readonly providerRef?: PermissionSetInlinePolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PermissionSetInlinePolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionSetInlinePolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PermissionSetInlinePolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionSetInlinePolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpec(obj: PermissionSetInlinePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionSetInlinePolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PermissionSetInlinePolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PermissionSetInlinePolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionSetInlinePolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSetInlinePolicySpecDeletionPolicy
 */
export enum PermissionSetInlinePolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PermissionSetInlinePolicySpecForProvider
 */
export interface PermissionSetInlinePolicySpecForProvider {
  /**
   * The IAM inline policy to attach to a Permission Set.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#inlinePolicy
   */
  readonly inlinePolicy?: string;

  /**
   * The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#instanceArn
   */
  readonly instanceArn: string;

  /**
   * The Amazon Resource Name (ARN) of the Permission Set.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#permissionSetArn
   */
  readonly permissionSetArn?: string;

  /**
   * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#permissionSetArnRef
   */
  readonly permissionSetArnRef?: PermissionSetInlinePolicySpecForProviderPermissionSetArnRef;

  /**
   * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#permissionSetArnSelector
   */
  readonly permissionSetArnSelector?: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecForProvider(obj: PermissionSetInlinePolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inlinePolicy': obj.inlinePolicy,
    'instanceArn': obj.instanceArn,
    'permissionSetArn': obj.permissionSetArn,
    'permissionSetArnRef': toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnRef(obj.permissionSetArnRef),
    'permissionSetArnSelector': toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector(obj.permissionSetArnSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSetInlinePolicySpecManagementPolicy
 */
export enum PermissionSetInlinePolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PermissionSetInlinePolicySpecProviderConfigRef
 */
export interface PermissionSetInlinePolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetInlinePolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetInlinePolicySpecProviderConfigRef#policy
   */
  readonly policy?: PermissionSetInlinePolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecProviderConfigRef(obj: PermissionSetInlinePolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetInlinePolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PermissionSetInlinePolicySpecProviderRef
 */
export interface PermissionSetInlinePolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetInlinePolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetInlinePolicySpecProviderRef#policy
   */
  readonly policy?: PermissionSetInlinePolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecProviderRef(obj: PermissionSetInlinePolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetInlinePolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsTo
 */
export interface PermissionSetInlinePolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsTo(obj: PermissionSetInlinePolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PermissionSetInlinePolicySpecWriteConnectionSecretToRef
 */
export interface PermissionSetInlinePolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionSetInlinePolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionSetInlinePolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecWriteConnectionSecretToRef(obj: PermissionSetInlinePolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRef
 */
export interface PermissionSetInlinePolicySpecForProviderPermissionSetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRef#policy
   */
  readonly policy?: PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecForProviderPermissionSetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnRef(obj: PermissionSetInlinePolicySpecForProviderPermissionSetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector
 */
export interface PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector#policy
   */
  readonly policy?: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector(obj: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSetInlinePolicySpecProviderConfigRefPolicy
 */
export interface PermissionSetInlinePolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSetInlinePolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSetInlinePolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSetInlinePolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSetInlinePolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecProviderConfigRefPolicy(obj: PermissionSetInlinePolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSetInlinePolicySpecProviderRefPolicy
 */
export interface PermissionSetInlinePolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSetInlinePolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: PermissionSetInlinePolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSetInlinePolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: PermissionSetInlinePolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecProviderRefPolicy(obj: PermissionSetInlinePolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef(obj: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata
 */
export interface PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata(obj: PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy
 */
export interface PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy#resolution
   */
  readonly resolution?: PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy#resolve
   */
  readonly resolve?: PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy(obj: PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy
 */
export interface PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy#resolution
   */
  readonly resolution?: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy#resolve
   */
  readonly resolve?: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy(obj: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSetInlinePolicySpecProviderConfigRefPolicyResolution
 */
export enum PermissionSetInlinePolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSetInlinePolicySpecProviderConfigRefPolicyResolve
 */
export enum PermissionSetInlinePolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSetInlinePolicySpecProviderRefPolicyResolution
 */
export enum PermissionSetInlinePolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSetInlinePolicySpecProviderRefPolicyResolve
 */
export enum PermissionSetInlinePolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolution
 */
export enum PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolve
 */
export enum PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolution
 */
export enum PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolve
 */
export enum PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

