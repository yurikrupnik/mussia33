// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * LiteReservation is the Schema for the LiteReservations API. A named resource representing a shared pool of capacity.
 *
 * @schema LiteReservation
 */
export class LiteReservation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LiteReservation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pubsub.gcp.upbound.io/v1beta1',
    kind: 'LiteReservation',
  }

  /**
   * Renders a Kubernetes manifest for "LiteReservation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LiteReservationProps): any {
    return {
      ...LiteReservation.GVK,
      ...toJson_LiteReservationProps(props),
    };
  }

  /**
   * Defines a "LiteReservation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LiteReservationProps) {
    super(scope, id, {
      ...LiteReservation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LiteReservation.GVK,
      ...toJson_LiteReservationProps(resolved),
    };
  }
}

/**
 * LiteReservation is the Schema for the LiteReservations API. A named resource representing a shared pool of capacity.
 *
 * @schema LiteReservation
 */
export interface LiteReservationProps {
  /**
   * @schema LiteReservation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LiteReservationSpec defines the desired state of LiteReservation
   *
   * @schema LiteReservation#spec
   */
  readonly spec: LiteReservationSpec;

}

/**
 * Converts an object of type 'LiteReservationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationProps(obj: LiteReservationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LiteReservationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LiteReservationSpec defines the desired state of LiteReservation
 *
 * @schema LiteReservationSpec
 */
export interface LiteReservationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema LiteReservationSpec#deletionPolicy
   */
  readonly deletionPolicy?: LiteReservationSpecDeletionPolicy;

  /**
   * @schema LiteReservationSpec#forProvider
   */
  readonly forProvider: LiteReservationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LiteReservationSpec#providerConfigRef
   */
  readonly providerConfigRef?: LiteReservationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LiteReservationSpec#providerRef
   */
  readonly providerRef?: LiteReservationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LiteReservationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LiteReservationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LiteReservationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LiteReservationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LiteReservationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationSpec(obj: LiteReservationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LiteReservationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_LiteReservationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LiteReservationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LiteReservationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LiteReservationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema LiteReservationSpecDeletionPolicy
 */
export enum LiteReservationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LiteReservationSpecForProvider
 */
export interface LiteReservationSpecForProvider {
  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema LiteReservationSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region of the pubsub lite reservation.
   *
   * @schema LiteReservationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The reserved throughput capacity. Every unit of throughput capacity is equivalent to 1 MiB/s of published messages or 2 MiB/s of subscribed messages.
   *
   * @schema LiteReservationSpecForProvider#throughputCapacity
   */
  readonly throughputCapacity: number;

}

/**
 * Converts an object of type 'LiteReservationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationSpecForProvider(obj: LiteReservationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'project': obj.project,
    'region': obj.region,
    'throughputCapacity': obj.throughputCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LiteReservationSpecProviderConfigRef
 */
export interface LiteReservationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LiteReservationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LiteReservationSpecProviderConfigRef#policy
   */
  readonly policy?: LiteReservationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LiteReservationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationSpecProviderConfigRef(obj: LiteReservationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LiteReservationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LiteReservationSpecProviderRef
 */
export interface LiteReservationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LiteReservationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LiteReservationSpecProviderRef#policy
   */
  readonly policy?: LiteReservationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LiteReservationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationSpecProviderRef(obj: LiteReservationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LiteReservationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LiteReservationSpecPublishConnectionDetailsTo
 */
export interface LiteReservationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LiteReservationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LiteReservationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LiteReservationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LiteReservationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LiteReservationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LiteReservationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationSpecPublishConnectionDetailsTo(obj: LiteReservationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LiteReservationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LiteReservationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LiteReservationSpecWriteConnectionSecretToRef
 */
export interface LiteReservationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LiteReservationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LiteReservationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LiteReservationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationSpecWriteConnectionSecretToRef(obj: LiteReservationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LiteReservationSpecProviderConfigRefPolicy
 */
export interface LiteReservationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteReservationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LiteReservationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteReservationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LiteReservationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LiteReservationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationSpecProviderConfigRefPolicy(obj: LiteReservationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LiteReservationSpecProviderRefPolicy
 */
export interface LiteReservationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteReservationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LiteReservationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteReservationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LiteReservationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LiteReservationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationSpecProviderRefPolicy(obj: LiteReservationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LiteReservationSpecPublishConnectionDetailsToConfigRef
 */
export interface LiteReservationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LiteReservationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LiteReservationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LiteReservationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LiteReservationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationSpecPublishConnectionDetailsToConfigRef(obj: LiteReservationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LiteReservationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LiteReservationSpecPublishConnectionDetailsToMetadata
 */
export interface LiteReservationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LiteReservationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LiteReservationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LiteReservationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LiteReservationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationSpecPublishConnectionDetailsToMetadata(obj: LiteReservationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteReservationSpecProviderConfigRefPolicyResolution
 */
export enum LiteReservationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteReservationSpecProviderConfigRefPolicyResolve
 */
export enum LiteReservationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteReservationSpecProviderRefPolicyResolution
 */
export enum LiteReservationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteReservationSpecProviderRefPolicyResolve
 */
export enum LiteReservationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LiteReservationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LiteReservationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteReservationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LiteReservationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteReservationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LiteReservationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LiteReservationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteReservationSpecPublishConnectionDetailsToConfigRefPolicy(obj: LiteReservationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteReservationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LiteReservationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteReservationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LiteReservationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LiteSubscription is the Schema for the LiteSubscriptions API. A named resource representing the stream of messages from a single, specific topic, to be delivered to the subscribing application.
 *
 * @schema LiteSubscription
 */
export class LiteSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LiteSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pubsub.gcp.upbound.io/v1beta1',
    kind: 'LiteSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "LiteSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LiteSubscriptionProps): any {
    return {
      ...LiteSubscription.GVK,
      ...toJson_LiteSubscriptionProps(props),
    };
  }

  /**
   * Defines a "LiteSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LiteSubscriptionProps) {
    super(scope, id, {
      ...LiteSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LiteSubscription.GVK,
      ...toJson_LiteSubscriptionProps(resolved),
    };
  }
}

/**
 * LiteSubscription is the Schema for the LiteSubscriptions API. A named resource representing the stream of messages from a single, specific topic, to be delivered to the subscribing application.
 *
 * @schema LiteSubscription
 */
export interface LiteSubscriptionProps {
  /**
   * @schema LiteSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LiteSubscriptionSpec defines the desired state of LiteSubscription
   *
   * @schema LiteSubscription#spec
   */
  readonly spec: LiteSubscriptionSpec;

}

/**
 * Converts an object of type 'LiteSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionProps(obj: LiteSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LiteSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LiteSubscriptionSpec defines the desired state of LiteSubscription
 *
 * @schema LiteSubscriptionSpec
 */
export interface LiteSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema LiteSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: LiteSubscriptionSpecDeletionPolicy;

  /**
   * @schema LiteSubscriptionSpec#forProvider
   */
  readonly forProvider: LiteSubscriptionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LiteSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: LiteSubscriptionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LiteSubscriptionSpec#providerRef
   */
  readonly providerRef?: LiteSubscriptionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LiteSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LiteSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LiteSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LiteSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LiteSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpec(obj: LiteSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LiteSubscriptionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_LiteSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LiteSubscriptionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LiteSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LiteSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema LiteSubscriptionSpecDeletionPolicy
 */
export enum LiteSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LiteSubscriptionSpecForProvider
 */
export interface LiteSubscriptionSpecForProvider {
  /**
   * The settings for this subscription's message delivery. Structure is documented below.
   *
   * @schema LiteSubscriptionSpecForProvider#deliveryConfig
   */
  readonly deliveryConfig?: LiteSubscriptionSpecForProviderDeliveryConfig[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema LiteSubscriptionSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region of the pubsub lite topic.
   *
   * @schema LiteSubscriptionSpecForProvider#region
   */
  readonly region?: string;

  /**
   * A reference to a Topic resource.
   *
   * @schema LiteSubscriptionSpecForProvider#topic
   */
  readonly topic?: string;

  /**
   * Reference to a LiteTopic to populate topic.
   *
   * @schema LiteSubscriptionSpecForProvider#topicRef
   */
  readonly topicRef?: LiteSubscriptionSpecForProviderTopicRef;

  /**
   * Selector for a LiteTopic to populate topic.
   *
   * @schema LiteSubscriptionSpecForProvider#topicSelector
   */
  readonly topicSelector?: LiteSubscriptionSpecForProviderTopicSelector;

  /**
   * The zone of the pubsub lite topic.
   *
   * @schema LiteSubscriptionSpecForProvider#zone
   */
  readonly zone: string;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecForProvider(obj: LiteSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryConfig': obj.deliveryConfig?.map(y => toJson_LiteSubscriptionSpecForProviderDeliveryConfig(y)),
    'project': obj.project,
    'region': obj.region,
    'topic': obj.topic,
    'topicRef': toJson_LiteSubscriptionSpecForProviderTopicRef(obj.topicRef),
    'topicSelector': toJson_LiteSubscriptionSpecForProviderTopicSelector(obj.topicSelector),
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LiteSubscriptionSpecProviderConfigRef
 */
export interface LiteSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LiteSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LiteSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: LiteSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecProviderConfigRef(obj: LiteSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LiteSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LiteSubscriptionSpecProviderRef
 */
export interface LiteSubscriptionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LiteSubscriptionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LiteSubscriptionSpecProviderRef#policy
   */
  readonly policy?: LiteSubscriptionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecProviderRef(obj: LiteSubscriptionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LiteSubscriptionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LiteSubscriptionSpecPublishConnectionDetailsTo
 */
export interface LiteSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LiteSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LiteSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LiteSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LiteSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LiteSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecPublishConnectionDetailsTo(obj: LiteSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LiteSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LiteSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LiteSubscriptionSpecWriteConnectionSecretToRef
 */
export interface LiteSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LiteSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LiteSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecWriteConnectionSecretToRef(obj: LiteSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LiteSubscriptionSpecForProviderDeliveryConfig
 */
export interface LiteSubscriptionSpecForProviderDeliveryConfig {
  /**
   * When this subscription should send messages to subscribers relative to messages persistence in storage. Possible values are DELIVER_IMMEDIATELY, DELIVER_AFTER_STORED, and DELIVERY_REQUIREMENT_UNSPECIFIED.
   *
   * @schema LiteSubscriptionSpecForProviderDeliveryConfig#deliveryRequirement
   */
  readonly deliveryRequirement: string;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecForProviderDeliveryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecForProviderDeliveryConfig(obj: LiteSubscriptionSpecForProviderDeliveryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryRequirement': obj.deliveryRequirement,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LiteTopic to populate topic.
 *
 * @schema LiteSubscriptionSpecForProviderTopicRef
 */
export interface LiteSubscriptionSpecForProviderTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema LiteSubscriptionSpecForProviderTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LiteSubscriptionSpecForProviderTopicRef#policy
   */
  readonly policy?: LiteSubscriptionSpecForProviderTopicRefPolicy;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecForProviderTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecForProviderTopicRef(obj: LiteSubscriptionSpecForProviderTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LiteSubscriptionSpecForProviderTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LiteTopic to populate topic.
 *
 * @schema LiteSubscriptionSpecForProviderTopicSelector
 */
export interface LiteSubscriptionSpecForProviderTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LiteSubscriptionSpecForProviderTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LiteSubscriptionSpecForProviderTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LiteSubscriptionSpecForProviderTopicSelector#policy
   */
  readonly policy?: LiteSubscriptionSpecForProviderTopicSelectorPolicy;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecForProviderTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecForProviderTopicSelector(obj: LiteSubscriptionSpecForProviderTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LiteSubscriptionSpecForProviderTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LiteSubscriptionSpecProviderConfigRefPolicy
 */
export interface LiteSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LiteSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LiteSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecProviderConfigRefPolicy(obj: LiteSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LiteSubscriptionSpecProviderRefPolicy
 */
export interface LiteSubscriptionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteSubscriptionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LiteSubscriptionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteSubscriptionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LiteSubscriptionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecProviderRefPolicy(obj: LiteSubscriptionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LiteSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface LiteSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LiteSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LiteSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: LiteSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LiteSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface LiteSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LiteSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LiteSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LiteSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecPublishConnectionDetailsToMetadata(obj: LiteSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LiteSubscriptionSpecForProviderTopicRefPolicy
 */
export interface LiteSubscriptionSpecForProviderTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteSubscriptionSpecForProviderTopicRefPolicy#resolution
   */
  readonly resolution?: LiteSubscriptionSpecForProviderTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteSubscriptionSpecForProviderTopicRefPolicy#resolve
   */
  readonly resolve?: LiteSubscriptionSpecForProviderTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecForProviderTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecForProviderTopicRefPolicy(obj: LiteSubscriptionSpecForProviderTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LiteSubscriptionSpecForProviderTopicSelectorPolicy
 */
export interface LiteSubscriptionSpecForProviderTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteSubscriptionSpecForProviderTopicSelectorPolicy#resolution
   */
  readonly resolution?: LiteSubscriptionSpecForProviderTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteSubscriptionSpecForProviderTopicSelectorPolicy#resolve
   */
  readonly resolve?: LiteSubscriptionSpecForProviderTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecForProviderTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecForProviderTopicSelectorPolicy(obj: LiteSubscriptionSpecForProviderTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum LiteSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum LiteSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteSubscriptionSpecProviderRefPolicyResolution
 */
export enum LiteSubscriptionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteSubscriptionSpecProviderRefPolicyResolve
 */
export enum LiteSubscriptionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteSubscriptionSpecForProviderTopicRefPolicyResolution
 */
export enum LiteSubscriptionSpecForProviderTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteSubscriptionSpecForProviderTopicRefPolicyResolve
 */
export enum LiteSubscriptionSpecForProviderTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteSubscriptionSpecForProviderTopicSelectorPolicyResolution
 */
export enum LiteSubscriptionSpecForProviderTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteSubscriptionSpecForProviderTopicSelectorPolicyResolve
 */
export enum LiteSubscriptionSpecForProviderTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LiteSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LiteTopic is the Schema for the LiteTopics API. A named resource to which messages are sent by publishers.
 *
 * @schema LiteTopic
 */
export class LiteTopic extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LiteTopic"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pubsub.gcp.upbound.io/v1beta1',
    kind: 'LiteTopic',
  }

  /**
   * Renders a Kubernetes manifest for "LiteTopic".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LiteTopicProps): any {
    return {
      ...LiteTopic.GVK,
      ...toJson_LiteTopicProps(props),
    };
  }

  /**
   * Defines a "LiteTopic" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LiteTopicProps) {
    super(scope, id, {
      ...LiteTopic.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LiteTopic.GVK,
      ...toJson_LiteTopicProps(resolved),
    };
  }
}

/**
 * LiteTopic is the Schema for the LiteTopics API. A named resource to which messages are sent by publishers.
 *
 * @schema LiteTopic
 */
export interface LiteTopicProps {
  /**
   * @schema LiteTopic#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LiteTopicSpec defines the desired state of LiteTopic
   *
   * @schema LiteTopic#spec
   */
  readonly spec: LiteTopicSpec;

}

/**
 * Converts an object of type 'LiteTopicProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicProps(obj: LiteTopicProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LiteTopicSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LiteTopicSpec defines the desired state of LiteTopic
 *
 * @schema LiteTopicSpec
 */
export interface LiteTopicSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema LiteTopicSpec#deletionPolicy
   */
  readonly deletionPolicy?: LiteTopicSpecDeletionPolicy;

  /**
   * @schema LiteTopicSpec#forProvider
   */
  readonly forProvider: LiteTopicSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LiteTopicSpec#providerConfigRef
   */
  readonly providerConfigRef?: LiteTopicSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LiteTopicSpec#providerRef
   */
  readonly providerRef?: LiteTopicSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LiteTopicSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LiteTopicSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LiteTopicSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LiteTopicSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LiteTopicSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpec(obj: LiteTopicSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LiteTopicSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_LiteTopicSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LiteTopicSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LiteTopicSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LiteTopicSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema LiteTopicSpecDeletionPolicy
 */
export enum LiteTopicSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LiteTopicSpecForProvider
 */
export interface LiteTopicSpecForProvider {
  /**
   * The settings for this topic's partitions. Structure is documented below.
   *
   * @schema LiteTopicSpecForProvider#partitionConfig
   */
  readonly partitionConfig: LiteTopicSpecForProviderPartitionConfig[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema LiteTopicSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region of the pubsub lite topic.
   *
   * @schema LiteTopicSpecForProvider#region
   */
  readonly region?: string;

  /**
   * The settings for this topic's Reservation usage. Structure is documented below.
   *
   * @schema LiteTopicSpecForProvider#reservationConfig
   */
  readonly reservationConfig?: LiteTopicSpecForProviderReservationConfig[];

  /**
   * The settings for a topic's message retention. Structure is documented below.
   *
   * @schema LiteTopicSpecForProvider#retentionConfig
   */
  readonly retentionConfig: LiteTopicSpecForProviderRetentionConfig[];

  /**
   * The zone of the pubsub lite topic.
   *
   * @schema LiteTopicSpecForProvider#zone
   */
  readonly zone: string;

}

/**
 * Converts an object of type 'LiteTopicSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecForProvider(obj: LiteTopicSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'partitionConfig': obj.partitionConfig?.map(y => toJson_LiteTopicSpecForProviderPartitionConfig(y)),
    'project': obj.project,
    'region': obj.region,
    'reservationConfig': obj.reservationConfig?.map(y => toJson_LiteTopicSpecForProviderReservationConfig(y)),
    'retentionConfig': obj.retentionConfig?.map(y => toJson_LiteTopicSpecForProviderRetentionConfig(y)),
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LiteTopicSpecProviderConfigRef
 */
export interface LiteTopicSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LiteTopicSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LiteTopicSpecProviderConfigRef#policy
   */
  readonly policy?: LiteTopicSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LiteTopicSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecProviderConfigRef(obj: LiteTopicSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LiteTopicSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LiteTopicSpecProviderRef
 */
export interface LiteTopicSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LiteTopicSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LiteTopicSpecProviderRef#policy
   */
  readonly policy?: LiteTopicSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LiteTopicSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecProviderRef(obj: LiteTopicSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LiteTopicSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LiteTopicSpecPublishConnectionDetailsTo
 */
export interface LiteTopicSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LiteTopicSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LiteTopicSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LiteTopicSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LiteTopicSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LiteTopicSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LiteTopicSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecPublishConnectionDetailsTo(obj: LiteTopicSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LiteTopicSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LiteTopicSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LiteTopicSpecWriteConnectionSecretToRef
 */
export interface LiteTopicSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LiteTopicSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LiteTopicSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LiteTopicSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecWriteConnectionSecretToRef(obj: LiteTopicSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LiteTopicSpecForProviderPartitionConfig
 */
export interface LiteTopicSpecForProviderPartitionConfig {
  /**
   * The capacity configuration. Structure is documented below.
   *
   * @schema LiteTopicSpecForProviderPartitionConfig#capacity
   */
  readonly capacity?: LiteTopicSpecForProviderPartitionConfigCapacity[];

  /**
   * The number of partitions in the topic. Must be at least 1.
   *
   * @schema LiteTopicSpecForProviderPartitionConfig#count
   */
  readonly count: number;

}

/**
 * Converts an object of type 'LiteTopicSpecForProviderPartitionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecForProviderPartitionConfig(obj: LiteTopicSpecForProviderPartitionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacity': obj.capacity?.map(y => toJson_LiteTopicSpecForProviderPartitionConfigCapacity(y)),
    'count': obj.count,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LiteTopicSpecForProviderReservationConfig
 */
export interface LiteTopicSpecForProviderReservationConfig {
  /**
   * The Reservation to use for this topic's throughput capacity.
   *
   * @schema LiteTopicSpecForProviderReservationConfig#throughputReservation
   */
  readonly throughputReservation?: string;

  /**
   * Reference to a LiteReservation to populate throughputReservation.
   *
   * @schema LiteTopicSpecForProviderReservationConfig#throughputReservationRef
   */
  readonly throughputReservationRef?: LiteTopicSpecForProviderReservationConfigThroughputReservationRef;

  /**
   * Selector for a LiteReservation to populate throughputReservation.
   *
   * @schema LiteTopicSpecForProviderReservationConfig#throughputReservationSelector
   */
  readonly throughputReservationSelector?: LiteTopicSpecForProviderReservationConfigThroughputReservationSelector;

}

/**
 * Converts an object of type 'LiteTopicSpecForProviderReservationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecForProviderReservationConfig(obj: LiteTopicSpecForProviderReservationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'throughputReservation': obj.throughputReservation,
    'throughputReservationRef': toJson_LiteTopicSpecForProviderReservationConfigThroughputReservationRef(obj.throughputReservationRef),
    'throughputReservationSelector': toJson_LiteTopicSpecForProviderReservationConfigThroughputReservationSelector(obj.throughputReservationSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LiteTopicSpecForProviderRetentionConfig
 */
export interface LiteTopicSpecForProviderRetentionConfig {
  /**
   * The provisioned storage, in bytes, per partition. If the number of bytes stored in any of the topic's partitions grows beyond this value, older messages will be dropped to make room for newer ones, regardless of the value of period.
   *
   * @schema LiteTopicSpecForProviderRetentionConfig#perPartitionBytes
   */
  readonly perPartitionBytes: string;

  /**
   * How long a published message is retained. If unset, messages will be retained as long as the bytes retained for each partition is below perPartitionBytes. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema LiteTopicSpecForProviderRetentionConfig#period
   */
  readonly period?: string;

}

/**
 * Converts an object of type 'LiteTopicSpecForProviderRetentionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecForProviderRetentionConfig(obj: LiteTopicSpecForProviderRetentionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perPartitionBytes': obj.perPartitionBytes,
    'period': obj.period,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LiteTopicSpecProviderConfigRefPolicy
 */
export interface LiteTopicSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteTopicSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LiteTopicSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteTopicSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LiteTopicSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LiteTopicSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecProviderConfigRefPolicy(obj: LiteTopicSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LiteTopicSpecProviderRefPolicy
 */
export interface LiteTopicSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteTopicSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LiteTopicSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteTopicSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LiteTopicSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LiteTopicSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecProviderRefPolicy(obj: LiteTopicSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LiteTopicSpecPublishConnectionDetailsToConfigRef
 */
export interface LiteTopicSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LiteTopicSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LiteTopicSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LiteTopicSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LiteTopicSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecPublishConnectionDetailsToConfigRef(obj: LiteTopicSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LiteTopicSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LiteTopicSpecPublishConnectionDetailsToMetadata
 */
export interface LiteTopicSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LiteTopicSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LiteTopicSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LiteTopicSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LiteTopicSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecPublishConnectionDetailsToMetadata(obj: LiteTopicSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LiteTopicSpecForProviderPartitionConfigCapacity
 */
export interface LiteTopicSpecForProviderPartitionConfigCapacity {
  /**
   * Subscribe throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
   *
   * @schema LiteTopicSpecForProviderPartitionConfigCapacity#publishMibPerSec
   */
  readonly publishMibPerSec: number;

  /**
   * Publish throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
   *
   * @schema LiteTopicSpecForProviderPartitionConfigCapacity#subscribeMibPerSec
   */
  readonly subscribeMibPerSec: number;

}

/**
 * Converts an object of type 'LiteTopicSpecForProviderPartitionConfigCapacity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecForProviderPartitionConfigCapacity(obj: LiteTopicSpecForProviderPartitionConfigCapacity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publishMibPerSec': obj.publishMibPerSec,
    'subscribeMibPerSec': obj.subscribeMibPerSec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LiteReservation to populate throughputReservation.
 *
 * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationRef
 */
export interface LiteTopicSpecForProviderReservationConfigThroughputReservationRef {
  /**
   * Name of the referenced object.
   *
   * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationRef#policy
   */
  readonly policy?: LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicy;

}

/**
 * Converts an object of type 'LiteTopicSpecForProviderReservationConfigThroughputReservationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecForProviderReservationConfigThroughputReservationRef(obj: LiteTopicSpecForProviderReservationConfigThroughputReservationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LiteReservation to populate throughputReservation.
 *
 * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationSelector
 */
export interface LiteTopicSpecForProviderReservationConfigThroughputReservationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationSelector#policy
   */
  readonly policy?: LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicy;

}

/**
 * Converts an object of type 'LiteTopicSpecForProviderReservationConfigThroughputReservationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecForProviderReservationConfigThroughputReservationSelector(obj: LiteTopicSpecForProviderReservationConfigThroughputReservationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteTopicSpecProviderConfigRefPolicyResolution
 */
export enum LiteTopicSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteTopicSpecProviderConfigRefPolicyResolve
 */
export enum LiteTopicSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteTopicSpecProviderRefPolicyResolution
 */
export enum LiteTopicSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteTopicSpecProviderRefPolicyResolve
 */
export enum LiteTopicSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LiteTopicSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LiteTopicSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteTopicSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LiteTopicSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteTopicSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LiteTopicSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LiteTopicSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecPublishConnectionDetailsToConfigRefPolicy(obj: LiteTopicSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicy
 */
export interface LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicy#resolution
   */
  readonly resolution?: LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicy#resolve
   */
  readonly resolve?: LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicyResolve;

}

/**
 * Converts an object of type 'LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicy(obj: LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicy
 */
export interface LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicy#resolution
   */
  readonly resolution?: LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicy#resolve
   */
  readonly resolve?: LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicy(obj: LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteTopicSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LiteTopicSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteTopicSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LiteTopicSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicyResolution
 */
export enum LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicyResolve
 */
export enum LiteTopicSpecForProviderReservationConfigThroughputReservationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicyResolution
 */
export enum LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicyResolve
 */
export enum LiteTopicSpecForProviderReservationConfigThroughputReservationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Schema is the Schema for the Schemas API. A schema is a format that messages must follow, creating a contract between publisher and subscriber that Pub/Sub will enforce.
 *
 * @schema Schema
 */
export class Schema extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Schema"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pubsub.gcp.upbound.io/v1beta1',
    kind: 'Schema',
  }

  /**
   * Renders a Kubernetes manifest for "Schema".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SchemaProps): any {
    return {
      ...Schema.GVK,
      ...toJson_SchemaProps(props),
    };
  }

  /**
   * Defines a "Schema" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SchemaProps) {
    super(scope, id, {
      ...Schema.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Schema.GVK,
      ...toJson_SchemaProps(resolved),
    };
  }
}

/**
 * Schema is the Schema for the Schemas API. A schema is a format that messages must follow, creating a contract between publisher and subscriber that Pub/Sub will enforce.
 *
 * @schema Schema
 */
export interface SchemaProps {
  /**
   * @schema Schema#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SchemaSpec defines the desired state of Schema
   *
   * @schema Schema#spec
   */
  readonly spec: SchemaSpec;

}

/**
 * Converts an object of type 'SchemaProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaProps(obj: SchemaProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SchemaSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SchemaSpec defines the desired state of Schema
 *
 * @schema SchemaSpec
 */
export interface SchemaSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema SchemaSpec#deletionPolicy
   */
  readonly deletionPolicy?: SchemaSpecDeletionPolicy;

  /**
   * @schema SchemaSpec#forProvider
   */
  readonly forProvider: SchemaSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SchemaSpec#providerConfigRef
   */
  readonly providerConfigRef?: SchemaSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SchemaSpec#providerRef
   */
  readonly providerRef?: SchemaSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SchemaSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SchemaSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SchemaSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SchemaSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SchemaSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpec(obj: SchemaSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SchemaSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_SchemaSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SchemaSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SchemaSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SchemaSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema SchemaSpecDeletionPolicy
 */
export enum SchemaSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SchemaSpecForProvider
 */
export interface SchemaSpecForProvider {
  /**
   * The definition of the schema. This should contain a string representing the full definition of the schema that is a valid schema definition of the type specified in type.
   *
   * @schema SchemaSpecForProvider#definition
   */
  readonly definition?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema SchemaSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The type of the schema definition Default value is TYPE_UNSPECIFIED. Possible values are TYPE_UNSPECIFIED, PROTOCOL_BUFFER, and AVRO.
   *
   * @schema SchemaSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SchemaSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecForProvider(obj: SchemaSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'definition': obj.definition,
    'project': obj.project,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SchemaSpecProviderConfigRef
 */
export interface SchemaSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SchemaSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SchemaSpecProviderConfigRef#policy
   */
  readonly policy?: SchemaSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SchemaSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecProviderConfigRef(obj: SchemaSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SchemaSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SchemaSpecProviderRef
 */
export interface SchemaSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SchemaSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SchemaSpecProviderRef#policy
   */
  readonly policy?: SchemaSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SchemaSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecProviderRef(obj: SchemaSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SchemaSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SchemaSpecPublishConnectionDetailsTo
 */
export interface SchemaSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SchemaSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SchemaSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SchemaSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SchemaSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SchemaSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsTo(obj: SchemaSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SchemaSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SchemaSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SchemaSpecWriteConnectionSecretToRef
 */
export interface SchemaSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SchemaSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SchemaSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SchemaSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecWriteConnectionSecretToRef(obj: SchemaSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SchemaSpecProviderConfigRefPolicy
 */
export interface SchemaSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SchemaSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SchemaSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SchemaSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SchemaSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SchemaSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecProviderConfigRefPolicy(obj: SchemaSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SchemaSpecProviderRefPolicy
 */
export interface SchemaSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SchemaSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SchemaSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SchemaSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SchemaSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SchemaSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecProviderRefPolicy(obj: SchemaSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRef
 */
export interface SchemaSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SchemaSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsToConfigRef(obj: SchemaSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SchemaSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SchemaSpecPublishConnectionDetailsToMetadata
 */
export interface SchemaSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SchemaSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SchemaSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SchemaSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsToMetadata(obj: SchemaSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SchemaSpecProviderConfigRefPolicyResolution
 */
export enum SchemaSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SchemaSpecProviderConfigRefPolicyResolve
 */
export enum SchemaSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SchemaSpecProviderRefPolicyResolution
 */
export enum SchemaSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SchemaSpecProviderRefPolicyResolve
 */
export enum SchemaSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SchemaSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsToConfigRefPolicy(obj: SchemaSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Subscription is the Schema for the Subscriptions API. A named resource representing the stream of messages from a single, specific topic, to be delivered to the subscribing application.
 *
 * @schema Subscription
 */
export class Subscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Subscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pubsub.gcp.upbound.io/v1beta1',
    kind: 'Subscription',
  }

  /**
   * Renders a Kubernetes manifest for "Subscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubscriptionProps): any {
    return {
      ...Subscription.GVK,
      ...toJson_SubscriptionProps(props),
    };
  }

  /**
   * Defines a "Subscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubscriptionProps) {
    super(scope, id, {
      ...Subscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Subscription.GVK,
      ...toJson_SubscriptionProps(resolved),
    };
  }
}

/**
 * Subscription is the Schema for the Subscriptions API. A named resource representing the stream of messages from a single, specific topic, to be delivered to the subscribing application.
 *
 * @schema Subscription
 */
export interface SubscriptionProps {
  /**
   * @schema Subscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SubscriptionSpec defines the desired state of Subscription
   *
   * @schema Subscription#spec
   */
  readonly spec: SubscriptionSpec;

}

/**
 * Converts an object of type 'SubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionProps(obj: SubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubscriptionSpec defines the desired state of Subscription
 *
 * @schema SubscriptionSpec
 */
export interface SubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema SubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: SubscriptionSpecDeletionPolicy;

  /**
   * @schema SubscriptionSpec#forProvider
   */
  readonly forProvider: SubscriptionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: SubscriptionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SubscriptionSpec#providerRef
   */
  readonly providerRef?: SubscriptionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpec(obj: SubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubscriptionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_SubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SubscriptionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema SubscriptionSpecDeletionPolicy
 */
export enum SubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SubscriptionSpecForProvider
 */
export interface SubscriptionSpecForProvider {
  /**
   * This value is the maximum time after a subscriber receives a message before the subscriber should acknowledge the message. After message delivery but before the ack deadline expires and before the message is acknowledged, it is an outstanding message and will not be delivered again during that time (on a best-effort basis). For pull subscriptions, this value is used as the initial value for the ack deadline. To override this value for a given message, call subscriptions.modifyAckDeadline with the corresponding ackId if using pull. The minimum custom deadline you can specify is 10 seconds. The maximum custom deadline you can specify is 600 seconds (10 minutes). If this parameter is 0, a default value of 10 seconds is used. For push delivery, this value is also used to set the request timeout for the call to the push endpoint. If the subscriber never acknowledges the message, the Pub/Sub system will eventually redeliver the message.
   *
   * @schema SubscriptionSpecForProvider#ackDeadlineSeconds
   */
  readonly ackDeadlineSeconds?: number;

  /**
   * If delivery to BigQuery is used with this subscription, this field is used to configure it. Either pushConfig or bigQueryConfig can be set, but not both. If both are empty, then the subscriber will pull and ack messages using API methods. Structure is documented below.
   *
   * @schema SubscriptionSpecForProvider#bigqueryConfig
   */
  readonly bigqueryConfig?: SubscriptionSpecForProviderBigqueryConfig[];

  /**
   * A policy that specifies the conditions for dead lettering messages in this subscription. If dead_letter_policy is not set, dead lettering is disabled. The Cloud Pub/Sub service account associated with this subscription's parent project (i.e., service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have permission to Acknowledge() messages on this subscription. Structure is documented below.
   *
   * @schema SubscriptionSpecForProvider#deadLetterPolicy
   */
  readonly deadLetterPolicy?: SubscriptionSpecForProviderDeadLetterPolicy[];

  /**
   * If true, Pub/Sub provides the following guarantees for the delivery of a message with a given value of messageId on this Subscriptions':
   *
   * @schema SubscriptionSpecForProvider#enableExactlyOnceDelivery
   */
  readonly enableExactlyOnceDelivery?: boolean;

  /**
   * If true, messages published with the same orderingKey in PubsubMessage will be delivered to the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they may be delivered in any order.
   *
   * @schema SubscriptionSpecForProvider#enableMessageOrdering
   */
  readonly enableMessageOrdering?: boolean;

  /**
   * A policy that specifies the conditions for this subscription's expiration. A subscription is considered active as long as any connected subscriber is successfully consuming messages from the subscription or is issuing operations on the subscription. If expirationPolicy is not set, a default policy with ttl of 31 days will be used.  If it is set but ttl is "", the resource never expires.  The minimum allowed value for expirationPolicy.ttl is 1 day. Structure is documented below.
   *
   * @schema SubscriptionSpecForProvider#expirationPolicy
   */
  readonly expirationPolicy?: SubscriptionSpecForProviderExpirationPolicy[];

  /**
   * The subscription only delivers the messages that match the filter. Pub/Sub automatically acknowledges the messages that don't match the filter. You can filter messages by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription, you can't modify the filter.
   *
   * @schema SubscriptionSpecForProvider#filter
   */
  readonly filter?: string;

  /**
   * A set of key/value label pairs to assign to this Subscription.
   *
   * @schema SubscriptionSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * How long to retain unacknowledged messages in the subscription's backlog, from the moment a message is published. If retain_acked_messages is true, then this also configures the retention of acknowledged messages, and thus configures how far back in time a subscriptions.seek can be done. Defaults to 7 days. Cannot be more than 7 days ("604800s") or less than 10 minutes ("600s"). A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "600.5s".
   *
   * @default 7 days. Cannot be more than 7 days ("604800s") or less than 10 minutes ("600s"). A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "600.5s".
   * @schema SubscriptionSpecForProvider#messageRetentionDuration
   */
  readonly messageRetentionDuration?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema SubscriptionSpecForProvider#project
   */
  readonly project?: string;

  /**
   * If push delivery is used with this subscription, this field is used to configure it. An empty pushConfig signifies that the subscriber will pull and ack messages using API methods. Structure is documented below.
   *
   * @schema SubscriptionSpecForProvider#pushConfig
   */
  readonly pushConfig?: SubscriptionSpecForProviderPushConfig[];

  /**
   * Indicates whether to retain acknowledged messages. If true, then messages are not expunged from the subscription's backlog, even if they are acknowledged, until they fall out of the messageRetentionDuration window.
   *
   * @schema SubscriptionSpecForProvider#retainAckedMessages
   */
  readonly retainAckedMessages?: boolean;

  /**
   * A policy that specifies how Pub/Sub retries message delivery for this subscription. If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers. RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message Structure is documented below.
   *
   * @schema SubscriptionSpecForProvider#retryPolicy
   */
  readonly retryPolicy?: SubscriptionSpecForProviderRetryPolicy[];

  /**
   * A reference to a Topic resource.
   *
   * @schema SubscriptionSpecForProvider#topic
   */
  readonly topic?: string;

  /**
   * Reference to a Topic to populate topic.
   *
   * @schema SubscriptionSpecForProvider#topicRef
   */
  readonly topicRef?: SubscriptionSpecForProviderTopicRef;

  /**
   * Selector for a Topic to populate topic.
   *
   * @schema SubscriptionSpecForProvider#topicSelector
   */
  readonly topicSelector?: SubscriptionSpecForProviderTopicSelector;

}

/**
 * Converts an object of type 'SubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProvider(obj: SubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ackDeadlineSeconds': obj.ackDeadlineSeconds,
    'bigqueryConfig': obj.bigqueryConfig?.map(y => toJson_SubscriptionSpecForProviderBigqueryConfig(y)),
    'deadLetterPolicy': obj.deadLetterPolicy?.map(y => toJson_SubscriptionSpecForProviderDeadLetterPolicy(y)),
    'enableExactlyOnceDelivery': obj.enableExactlyOnceDelivery,
    'enableMessageOrdering': obj.enableMessageOrdering,
    'expirationPolicy': obj.expirationPolicy?.map(y => toJson_SubscriptionSpecForProviderExpirationPolicy(y)),
    'filter': obj.filter,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'messageRetentionDuration': obj.messageRetentionDuration,
    'project': obj.project,
    'pushConfig': obj.pushConfig?.map(y => toJson_SubscriptionSpecForProviderPushConfig(y)),
    'retainAckedMessages': obj.retainAckedMessages,
    'retryPolicy': obj.retryPolicy?.map(y => toJson_SubscriptionSpecForProviderRetryPolicy(y)),
    'topic': obj.topic,
    'topicRef': toJson_SubscriptionSpecForProviderTopicRef(obj.topicRef),
    'topicSelector': toJson_SubscriptionSpecForProviderTopicSelector(obj.topicSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SubscriptionSpecProviderConfigRef
 */
export interface SubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: SubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecProviderConfigRef(obj: SubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SubscriptionSpecProviderRef
 */
export interface SubscriptionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionSpecProviderRef#policy
   */
  readonly policy?: SubscriptionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecProviderRef(obj: SubscriptionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsTo
 */
export interface SubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecPublishConnectionDetailsTo(obj: SubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SubscriptionSpecWriteConnectionSecretToRef
 */
export interface SubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecWriteConnectionSecretToRef(obj: SubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SubscriptionSpecForProviderBigqueryConfig
 */
export interface SubscriptionSpecForProviderBigqueryConfig {
  /**
   * When true and useTopicSchema is true, any fields that are a part of the topic schema that are not part of the BigQuery table schema are dropped when writing to BigQuery. Otherwise, the schemas must be kept in sync and any messages with extra fields are not written and remain in the subscription's backlog.
   *
   * @schema SubscriptionSpecForProviderBigqueryConfig#dropUnknownFields
   */
  readonly dropUnknownFields?: boolean;

  /**
   * The name of the table to which to write data, of the form {projectId}:{datasetId}.{tableId}
   *
   * @schema SubscriptionSpecForProviderBigqueryConfig#table
   */
  readonly table: string;

  /**
   * When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
   *
   * @schema SubscriptionSpecForProviderBigqueryConfig#useTopicSchema
   */
  readonly useTopicSchema?: boolean;

  /**
   * When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table. The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
   *
   * @schema SubscriptionSpecForProviderBigqueryConfig#writeMetadata
   */
  readonly writeMetadata?: boolean;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderBigqueryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderBigqueryConfig(obj: SubscriptionSpecForProviderBigqueryConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dropUnknownFields': obj.dropUnknownFields,
    'table': obj.table,
    'useTopicSchema': obj.useTopicSchema,
    'writeMetadata': obj.writeMetadata,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SubscriptionSpecForProviderDeadLetterPolicy
 */
export interface SubscriptionSpecForProviderDeadLetterPolicy {
  /**
   * The name of the topic to which dead letter messages should be published. Format is projects/{project}/topics/{topic}. The Cloud Pub/Sub service account associated with the enclosing subscription's parent project (i.e., service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have permission to Publish() to this topic. The operation will fail if the topic does not exist. Users should ensure that there is a subscription attached to this topic since messages published to a topic with no subscriptions are lost.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicy#deadLetterTopic
   */
  readonly deadLetterTopic?: string;

  /**
   * Reference to a Topic in pubsub to populate deadLetterTopic.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicy#deadLetterTopicRef
   */
  readonly deadLetterTopicRef?: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRef;

  /**
   * Selector for a Topic in pubsub to populate deadLetterTopic.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicy#deadLetterTopicSelector
   */
  readonly deadLetterTopicSelector?: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelector;

  /**
   * The maximum number of delivery attempts for any message. The value must be between 5 and 100. The number of delivery attempts is defined as 1 + (the sum of number of NACKs and number of times the acknowledgement deadline has been exceeded for the message). A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that client libraries may automatically extend ack_deadlines. This field will be honored on a best effort basis. If this parameter is 0, a default value of 5 is used.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicy#maxDeliveryAttempts
   */
  readonly maxDeliveryAttempts?: number;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderDeadLetterPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderDeadLetterPolicy(obj: SubscriptionSpecForProviderDeadLetterPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deadLetterTopic': obj.deadLetterTopic,
    'deadLetterTopicRef': toJson_SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRef(obj.deadLetterTopicRef),
    'deadLetterTopicSelector': toJson_SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelector(obj.deadLetterTopicSelector),
    'maxDeliveryAttempts': obj.maxDeliveryAttempts,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SubscriptionSpecForProviderExpirationPolicy
 */
export interface SubscriptionSpecForProviderExpirationPolicy {
  /**
   * Specifies the "time-to-live" duration for an associated resource. The resource expires if it is not active for a period of ttl. If ttl is not set, the associated resource never expires. A duration in seconds with up to nine fractional digits, terminated by 's'. Example - "3.5s".
   *
   * @schema SubscriptionSpecForProviderExpirationPolicy#ttl
   */
  readonly ttl: string;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderExpirationPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderExpirationPolicy(obj: SubscriptionSpecForProviderExpirationPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SubscriptionSpecForProviderPushConfig
 */
export interface SubscriptionSpecForProviderPushConfig {
  /**
   * Endpoint configuration attributes. Every endpoint has a set of API supported attributes that can be used to control different aspects of the message delivery. The currently supported attribute is x-goog-version, which you can use to change the format of the pushed message. This attribute indicates the version of the data expected by the endpoint. This controls the shape of the pushed message (i.e., its fields and metadata). The endpoint version is based on the version of the Pub/Sub API. If not present during the subscriptions.create call, it will default to the version of the API used to make such call. If not present during a subscriptions.modifyPushConfig call, its value will not be changed. subscriptions.get calls will always return a valid version, even if the subscription was created without this attribute. The possible values for this attribute are:
   *
   * @schema SubscriptionSpecForProviderPushConfig#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * If specified, Pub/Sub will generate and attach an OIDC JWT token as an Authorization header in the HTTP request for every pushed message. Structure is documented below.
   *
   * @schema SubscriptionSpecForProviderPushConfig#oidcToken
   */
  readonly oidcToken?: SubscriptionSpecForProviderPushConfigOidcToken[];

  /**
   * A URL locating the endpoint to which messages should be pushed. For example, a Webhook endpoint might use "https://example.com/push".
   *
   * @schema SubscriptionSpecForProviderPushConfig#pushEndpoint
   */
  readonly pushEndpoint: string;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderPushConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderPushConfig(obj: SubscriptionSpecForProviderPushConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'oidcToken': obj.oidcToken?.map(y => toJson_SubscriptionSpecForProviderPushConfigOidcToken(y)),
    'pushEndpoint': obj.pushEndpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SubscriptionSpecForProviderRetryPolicy
 */
export interface SubscriptionSpecForProviderRetryPolicy {
  /**
   * The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @default 600 seconds. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   * @schema SubscriptionSpecForProviderRetryPolicy#maximumBackoff
   */
  readonly maximumBackoff?: string;

  /**
   * The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @default 10 seconds. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   * @schema SubscriptionSpecForProviderRetryPolicy#minimumBackoff
   */
  readonly minimumBackoff?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderRetryPolicy(obj: SubscriptionSpecForProviderRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maximumBackoff': obj.maximumBackoff,
    'minimumBackoff': obj.minimumBackoff,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic to populate topic.
 *
 * @schema SubscriptionSpecForProviderTopicRef
 */
export interface SubscriptionSpecForProviderTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionSpecForProviderTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionSpecForProviderTopicRef#policy
   */
  readonly policy?: SubscriptionSpecForProviderTopicRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderTopicRef(obj: SubscriptionSpecForProviderTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionSpecForProviderTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic to populate topic.
 *
 * @schema SubscriptionSpecForProviderTopicSelector
 */
export interface SubscriptionSpecForProviderTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SubscriptionSpecForProviderTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubscriptionSpecForProviderTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubscriptionSpecForProviderTopicSelector#policy
   */
  readonly policy?: SubscriptionSpecForProviderTopicSelectorPolicy;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderTopicSelector(obj: SubscriptionSpecForProviderTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubscriptionSpecForProviderTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubscriptionSpecProviderConfigRefPolicy
 */
export interface SubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecProviderConfigRefPolicy(obj: SubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubscriptionSpecProviderRefPolicy
 */
export interface SubscriptionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SubscriptionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SubscriptionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecProviderRefPolicy(obj: SubscriptionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface SubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecPublishConnectionDetailsToConfigRef(obj: SubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface SubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecPublishConnectionDetailsToMetadata(obj: SubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in pubsub to populate deadLetterTopic.
 *
 * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRef
 */
export interface SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRef#policy
   */
  readonly policy?: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRef(obj: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in pubsub to populate deadLetterTopic.
 *
 * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelector
 */
export interface SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelector#policy
   */
  readonly policy?: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelector(obj: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SubscriptionSpecForProviderPushConfigOidcToken
 */
export interface SubscriptionSpecForProviderPushConfigOidcToken {
  /**
   * Audience to be used when generating OIDC token. The audience claim identifies the recipients that the JWT is intended for. The audience value is a single case-sensitive string. Having multiple values (array) for the audience field is not supported. More info about the OIDC JWT token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3 Note: if not specified, the Push endpoint URL will be used.
   *
   * @schema SubscriptionSpecForProviderPushConfigOidcToken#audience
   */
  readonly audience?: string;

  /**
   * Service account email to be used for generating the OIDC token. The caller (for subscriptions.create, subscriptions.patch, and subscriptions.modifyPushConfig RPCs) must have the iam.serviceAccounts.actAs permission for the service account.
   *
   * @schema SubscriptionSpecForProviderPushConfigOidcToken#serviceAccountEmail
   */
  readonly serviceAccountEmail: string;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderPushConfigOidcToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderPushConfigOidcToken(obj: SubscriptionSpecForProviderPushConfigOidcToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'serviceAccountEmail': obj.serviceAccountEmail,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubscriptionSpecForProviderTopicRefPolicy
 */
export interface SubscriptionSpecForProviderTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionSpecForProviderTopicRefPolicy#resolution
   */
  readonly resolution?: SubscriptionSpecForProviderTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionSpecForProviderTopicRefPolicy#resolve
   */
  readonly resolve?: SubscriptionSpecForProviderTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderTopicRefPolicy(obj: SubscriptionSpecForProviderTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SubscriptionSpecForProviderTopicSelectorPolicy
 */
export interface SubscriptionSpecForProviderTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionSpecForProviderTopicSelectorPolicy#resolution
   */
  readonly resolution?: SubscriptionSpecForProviderTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionSpecForProviderTopicSelectorPolicy#resolve
   */
  readonly resolve?: SubscriptionSpecForProviderTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderTopicSelectorPolicy(obj: SubscriptionSpecForProviderTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum SubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum SubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionSpecProviderRefPolicyResolution
 */
export enum SubscriptionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionSpecProviderRefPolicyResolve
 */
export enum SubscriptionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: SubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicy
 */
export interface SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicy#resolution
   */
  readonly resolution?: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicy#resolve
   */
  readonly resolve?: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicy(obj: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy
 */
export interface SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy#resolution
   */
  readonly resolution?: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy#resolve
   */
  readonly resolve?: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy(obj: SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionSpecForProviderTopicRefPolicyResolution
 */
export enum SubscriptionSpecForProviderTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionSpecForProviderTopicRefPolicyResolve
 */
export enum SubscriptionSpecForProviderTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionSpecForProviderTopicSelectorPolicyResolution
 */
export enum SubscriptionSpecForProviderTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionSpecForProviderTopicSelectorPolicyResolve
 */
export enum SubscriptionSpecForProviderTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolution
 */
export enum SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolve
 */
export enum SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolution
 */
export enum SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolve
 */
export enum SubscriptionSpecForProviderDeadLetterPolicyDeadLetterTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SubscriptionIAMMember is the Schema for the SubscriptionIAMMembers API. <no value>
 *
 * @schema SubscriptionIAMMember
 */
export class SubscriptionIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SubscriptionIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pubsub.gcp.upbound.io/v1beta1',
    kind: 'SubscriptionIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "SubscriptionIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubscriptionIamMemberProps): any {
    return {
      ...SubscriptionIamMember.GVK,
      ...toJson_SubscriptionIamMemberProps(props),
    };
  }

  /**
   * Defines a "SubscriptionIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubscriptionIamMemberProps) {
    super(scope, id, {
      ...SubscriptionIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SubscriptionIamMember.GVK,
      ...toJson_SubscriptionIamMemberProps(resolved),
    };
  }
}

/**
 * SubscriptionIAMMember is the Schema for the SubscriptionIAMMembers API. <no value>
 *
 * @schema SubscriptionIAMMember
 */
export interface SubscriptionIamMemberProps {
  /**
   * @schema SubscriptionIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SubscriptionIAMMemberSpec defines the desired state of SubscriptionIAMMember
   *
   * @schema SubscriptionIAMMember#spec
   */
  readonly spec: SubscriptionIamMemberSpec;

}

/**
 * Converts an object of type 'SubscriptionIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberProps(obj: SubscriptionIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubscriptionIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubscriptionIAMMemberSpec defines the desired state of SubscriptionIAMMember
 *
 * @schema SubscriptionIamMemberSpec
 */
export interface SubscriptionIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema SubscriptionIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: SubscriptionIamMemberSpecDeletionPolicy;

  /**
   * @schema SubscriptionIamMemberSpec#forProvider
   */
  readonly forProvider: SubscriptionIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SubscriptionIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: SubscriptionIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SubscriptionIamMemberSpec#providerRef
   */
  readonly providerRef?: SubscriptionIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SubscriptionIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SubscriptionIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SubscriptionIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubscriptionIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpec(obj: SubscriptionIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubscriptionIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_SubscriptionIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SubscriptionIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SubscriptionIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SubscriptionIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema SubscriptionIamMemberSpecDeletionPolicy
 */
export enum SubscriptionIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SubscriptionIamMemberSpecForProvider
 */
export interface SubscriptionIamMemberSpecForProvider {
  /**
   * @schema SubscriptionIamMemberSpecForProvider#condition
   */
  readonly condition?: SubscriptionIamMemberSpecForProviderCondition[];

  /**
   * @schema SubscriptionIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema SubscriptionIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema SubscriptionIamMemberSpecForProvider#role
   */
  readonly role: string;

  /**
   * @schema SubscriptionIamMemberSpecForProvider#subscription
   */
  readonly subscription?: string;

  /**
   * Reference to a Subscription to populate subscription.
   *
   * @schema SubscriptionIamMemberSpecForProvider#subscriptionRef
   */
  readonly subscriptionRef?: SubscriptionIamMemberSpecForProviderSubscriptionRef;

  /**
   * Selector for a Subscription to populate subscription.
   *
   * @schema SubscriptionIamMemberSpecForProvider#subscriptionSelector
   */
  readonly subscriptionSelector?: SubscriptionIamMemberSpecForProviderSubscriptionSelector;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecForProvider(obj: SubscriptionIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_SubscriptionIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
    'subscription': obj.subscription,
    'subscriptionRef': toJson_SubscriptionIamMemberSpecForProviderSubscriptionRef(obj.subscriptionRef),
    'subscriptionSelector': toJson_SubscriptionIamMemberSpecForProviderSubscriptionSelector(obj.subscriptionSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SubscriptionIamMemberSpecProviderConfigRef
 */
export interface SubscriptionIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: SubscriptionIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecProviderConfigRef(obj: SubscriptionIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SubscriptionIamMemberSpecProviderRef
 */
export interface SubscriptionIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionIamMemberSpecProviderRef#policy
   */
  readonly policy?: SubscriptionIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecProviderRef(obj: SubscriptionIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SubscriptionIamMemberSpecPublishConnectionDetailsTo
 */
export interface SubscriptionIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SubscriptionIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SubscriptionIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SubscriptionIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SubscriptionIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecPublishConnectionDetailsTo(obj: SubscriptionIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SubscriptionIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SubscriptionIamMemberSpecWriteConnectionSecretToRef
 */
export interface SubscriptionIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubscriptionIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubscriptionIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecWriteConnectionSecretToRef(obj: SubscriptionIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SubscriptionIamMemberSpecForProviderCondition
 */
export interface SubscriptionIamMemberSpecForProviderCondition {
  /**
   * @schema SubscriptionIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema SubscriptionIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema SubscriptionIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecForProviderCondition(obj: SubscriptionIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subscription to populate subscription.
 *
 * @schema SubscriptionIamMemberSpecForProviderSubscriptionRef
 */
export interface SubscriptionIamMemberSpecForProviderSubscriptionRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionIamMemberSpecForProviderSubscriptionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionIamMemberSpecForProviderSubscriptionRef#policy
   */
  readonly policy?: SubscriptionIamMemberSpecForProviderSubscriptionRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecForProviderSubscriptionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecForProviderSubscriptionRef(obj: SubscriptionIamMemberSpecForProviderSubscriptionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionIamMemberSpecForProviderSubscriptionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subscription to populate subscription.
 *
 * @schema SubscriptionIamMemberSpecForProviderSubscriptionSelector
 */
export interface SubscriptionIamMemberSpecForProviderSubscriptionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SubscriptionIamMemberSpecForProviderSubscriptionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubscriptionIamMemberSpecForProviderSubscriptionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubscriptionIamMemberSpecForProviderSubscriptionSelector#policy
   */
  readonly policy?: SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicy;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecForProviderSubscriptionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecForProviderSubscriptionSelector(obj: SubscriptionIamMemberSpecForProviderSubscriptionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubscriptionIamMemberSpecProviderConfigRefPolicy
 */
export interface SubscriptionIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubscriptionIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubscriptionIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecProviderConfigRefPolicy(obj: SubscriptionIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubscriptionIamMemberSpecProviderRefPolicy
 */
export interface SubscriptionIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SubscriptionIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SubscriptionIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecProviderRefPolicy(obj: SubscriptionIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRef(obj: SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface SubscriptionIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecPublishConnectionDetailsToMetadata(obj: SubscriptionIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubscriptionIamMemberSpecForProviderSubscriptionRefPolicy
 */
export interface SubscriptionIamMemberSpecForProviderSubscriptionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionIamMemberSpecForProviderSubscriptionRefPolicy#resolution
   */
  readonly resolution?: SubscriptionIamMemberSpecForProviderSubscriptionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionIamMemberSpecForProviderSubscriptionRefPolicy#resolve
   */
  readonly resolve?: SubscriptionIamMemberSpecForProviderSubscriptionRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecForProviderSubscriptionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecForProviderSubscriptionRefPolicy(obj: SubscriptionIamMemberSpecForProviderSubscriptionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicy
 */
export interface SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicy#resolution
   */
  readonly resolution?: SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicy#resolve
   */
  readonly resolve?: SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicy(obj: SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum SubscriptionIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum SubscriptionIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionIamMemberSpecProviderRefPolicyResolution
 */
export enum SubscriptionIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionIamMemberSpecProviderRefPolicyResolve
 */
export enum SubscriptionIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionIamMemberSpecForProviderSubscriptionRefPolicyResolution
 */
export enum SubscriptionIamMemberSpecForProviderSubscriptionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionIamMemberSpecForProviderSubscriptionRefPolicyResolve
 */
export enum SubscriptionIamMemberSpecForProviderSubscriptionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicyResolution
 */
export enum SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicyResolve
 */
export enum SubscriptionIamMemberSpecForProviderSubscriptionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SubscriptionIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Topic is the Schema for the Topics API. A named resource to which messages are sent by publishers.
 *
 * @schema Topic
 */
export class Topic extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Topic"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pubsub.gcp.upbound.io/v1beta1',
    kind: 'Topic',
  }

  /**
   * Renders a Kubernetes manifest for "Topic".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TopicProps): any {
    return {
      ...Topic.GVK,
      ...toJson_TopicProps(props),
    };
  }

  /**
   * Defines a "Topic" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TopicProps) {
    super(scope, id, {
      ...Topic.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Topic.GVK,
      ...toJson_TopicProps(resolved),
    };
  }
}

/**
 * Topic is the Schema for the Topics API. A named resource to which messages are sent by publishers.
 *
 * @schema Topic
 */
export interface TopicProps {
  /**
   * @schema Topic#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TopicSpec defines the desired state of Topic
   *
   * @schema Topic#spec
   */
  readonly spec: TopicSpec;

}

/**
 * Converts an object of type 'TopicProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicProps(obj: TopicProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TopicSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicSpec defines the desired state of Topic
 *
 * @schema TopicSpec
 */
export interface TopicSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TopicSpec#deletionPolicy
   */
  readonly deletionPolicy?: TopicSpecDeletionPolicy;

  /**
   * @schema TopicSpec#forProvider
   */
  readonly forProvider: TopicSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TopicSpec#providerConfigRef
   */
  readonly providerConfigRef?: TopicSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TopicSpec#providerRef
   */
  readonly providerRef?: TopicSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TopicSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TopicSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TopicSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TopicSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TopicSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpec(obj: TopicSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TopicSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TopicSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TopicSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TopicSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TopicSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TopicSpecDeletionPolicy
 */
export enum TopicSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TopicSpecForProvider
 */
export interface TopicSpecForProvider {
  /**
   * The resource name of the Cloud KMS CryptoKey to be used to protect access to messages published on this topic. Your project's PubSub service account (service-{{PROJECT_NUMBER}}@gcp-sa-pubsub.iam.gserviceaccount.com) must have roles/cloudkms.cryptoKeyEncrypterDecrypter to use this feature. The expected format is projects/_/locations/_/keyRings/_/cryptoKeys/*
   *
   * @schema TopicSpecForProvider#kmsKeyName
   */
  readonly kmsKeyName?: string;

  /**
   * Reference to a CryptoKey in kms to populate kmsKeyName.
   *
   * @schema TopicSpecForProvider#kmsKeyNameRef
   */
  readonly kmsKeyNameRef?: TopicSpecForProviderKmsKeyNameRef;

  /**
   * Selector for a CryptoKey in kms to populate kmsKeyName.
   *
   * @schema TopicSpecForProvider#kmsKeyNameSelector
   */
  readonly kmsKeyNameSelector?: TopicSpecForProviderKmsKeyNameSelector;

  /**
   * A set of key/value label pairs to assign to this Topic.
   *
   * @schema TopicSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Indicates the minimum duration to retain a message after it is published to the topic. If this field is set, messages published to the topic in the last messageRetentionDuration are always available to subscribers. For instance, it allows any attached subscription to seek to a timestamp that is up to messageRetentionDuration in the past. If this field is not set, message retention is controlled by settings on individual subscriptions. Cannot be more than 31 days or less than 10 minutes.
   *
   * @schema TopicSpecForProvider#messageRetentionDuration
   */
  readonly messageRetentionDuration?: string;

  /**
   * Policy constraining the set of Google Cloud Platform regions where messages published to the topic may be stored. If not present, then no constraints are in effect. Structure is documented below.
   *
   * @schema TopicSpecForProvider#messageStoragePolicy
   */
  readonly messageStoragePolicy?: TopicSpecForProviderMessageStoragePolicy[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema TopicSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Settings for validating messages published against a schema. Structure is documented below.
   *
   * @schema TopicSpecForProvider#schemaSettings
   */
  readonly schemaSettings?: TopicSpecForProviderSchemaSettings[];

}

/**
 * Converts an object of type 'TopicSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProvider(obj: TopicSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
    'kmsKeyNameRef': toJson_TopicSpecForProviderKmsKeyNameRef(obj.kmsKeyNameRef),
    'kmsKeyNameSelector': toJson_TopicSpecForProviderKmsKeyNameSelector(obj.kmsKeyNameSelector),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'messageRetentionDuration': obj.messageRetentionDuration,
    'messageStoragePolicy': obj.messageStoragePolicy?.map(y => toJson_TopicSpecForProviderMessageStoragePolicy(y)),
    'project': obj.project,
    'schemaSettings': obj.schemaSettings?.map(y => toJson_TopicSpecForProviderSchemaSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TopicSpecProviderConfigRef
 */
export interface TopicSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecProviderConfigRef#policy
   */
  readonly policy?: TopicSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecProviderConfigRef(obj: TopicSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TopicSpecProviderRef
 */
export interface TopicSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecProviderRef#policy
   */
  readonly policy?: TopicSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecProviderRef(obj: TopicSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TopicSpecPublishConnectionDetailsTo
 */
export interface TopicSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TopicSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TopicSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TopicSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TopicSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TopicSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsTo(obj: TopicSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TopicSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TopicSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TopicSpecWriteConnectionSecretToRef
 */
export interface TopicSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TopicSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TopicSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TopicSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecWriteConnectionSecretToRef(obj: TopicSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate kmsKeyName.
 *
 * @schema TopicSpecForProviderKmsKeyNameRef
 */
export interface TopicSpecForProviderKmsKeyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecForProviderKmsKeyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecForProviderKmsKeyNameRef#policy
   */
  readonly policy?: TopicSpecForProviderKmsKeyNameRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderKmsKeyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderKmsKeyNameRef(obj: TopicSpecForProviderKmsKeyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecForProviderKmsKeyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate kmsKeyName.
 *
 * @schema TopicSpecForProviderKmsKeyNameSelector
 */
export interface TopicSpecForProviderKmsKeyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSpecForProviderKmsKeyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSpecForProviderKmsKeyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSpecForProviderKmsKeyNameSelector#policy
   */
  readonly policy?: TopicSpecForProviderKmsKeyNameSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderKmsKeyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderKmsKeyNameSelector(obj: TopicSpecForProviderKmsKeyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSpecForProviderKmsKeyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicSpecForProviderMessageStoragePolicy
 */
export interface TopicSpecForProviderMessageStoragePolicy {
  /**
   * A list of IDs of GCP regions where messages that are published to the topic may be persisted in storage. Messages published by publishers running in non-allowed GCP regions (or running outside of GCP altogether) will be routed for storage in one of the allowed regions. An empty list means that no regions are allowed, and is not a valid configuration.
   *
   * @schema TopicSpecForProviderMessageStoragePolicy#allowedPersistenceRegions
   */
  readonly allowedPersistenceRegions: string[];

}

/**
 * Converts an object of type 'TopicSpecForProviderMessageStoragePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderMessageStoragePolicy(obj: TopicSpecForProviderMessageStoragePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedPersistenceRegions': obj.allowedPersistenceRegions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicSpecForProviderSchemaSettings
 */
export interface TopicSpecForProviderSchemaSettings {
  /**
   * The encoding of messages validated against schema. Default value is ENCODING_UNSPECIFIED. Possible values are ENCODING_UNSPECIFIED, JSON, and BINARY.
   *
   * @schema TopicSpecForProviderSchemaSettings#encoding
   */
  readonly encoding?: string;

  /**
   * The name of the schema that messages published should be validated against. Format is projects/{project}/schemas/{schema}. The value of this field will be deleted-schema if the schema has been deleted.
   *
   * @schema TopicSpecForProviderSchemaSettings#schema
   */
  readonly schema: string;

}

/**
 * Converts an object of type 'TopicSpecForProviderSchemaSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderSchemaSettings(obj: TopicSpecForProviderSchemaSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encoding': obj.encoding,
    'schema': obj.schema,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecProviderConfigRefPolicy
 */
export interface TopicSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TopicSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TopicSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecProviderConfigRefPolicy(obj: TopicSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecProviderRefPolicy
 */
export interface TopicSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TopicSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TopicSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecProviderRefPolicy(obj: TopicSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRef
 */
export interface TopicSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TopicSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsToConfigRef(obj: TopicSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TopicSpecPublishConnectionDetailsToMetadata
 */
export interface TopicSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TopicSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsToMetadata(obj: TopicSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecForProviderKmsKeyNameRefPolicy
 */
export interface TopicSpecForProviderKmsKeyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderKmsKeyNameRefPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderKmsKeyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderKmsKeyNameRefPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderKmsKeyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderKmsKeyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderKmsKeyNameRefPolicy(obj: TopicSpecForProviderKmsKeyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSpecForProviderKmsKeyNameSelectorPolicy
 */
export interface TopicSpecForProviderKmsKeyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderKmsKeyNameSelectorPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderKmsKeyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderKmsKeyNameSelectorPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderKmsKeyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderKmsKeyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderKmsKeyNameSelectorPolicy(obj: TopicSpecForProviderKmsKeyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecProviderConfigRefPolicyResolution
 */
export enum TopicSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecProviderConfigRefPolicyResolve
 */
export enum TopicSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecProviderRefPolicyResolution
 */
export enum TopicSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecProviderRefPolicyResolve
 */
export enum TopicSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TopicSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TopicSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TopicSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsToConfigRefPolicy(obj: TopicSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderKmsKeyNameRefPolicyResolution
 */
export enum TopicSpecForProviderKmsKeyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderKmsKeyNameRefPolicyResolve
 */
export enum TopicSpecForProviderKmsKeyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderKmsKeyNameSelectorPolicyResolution
 */
export enum TopicSpecForProviderKmsKeyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderKmsKeyNameSelectorPolicyResolve
 */
export enum TopicSpecForProviderKmsKeyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TopicSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TopicSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TopicIAMMember is the Schema for the TopicIAMMembers API. <no value>
 *
 * @schema TopicIAMMember
 */
export class TopicIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TopicIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'pubsub.gcp.upbound.io/v1beta1',
    kind: 'TopicIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "TopicIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TopicIamMemberProps): any {
    return {
      ...TopicIamMember.GVK,
      ...toJson_TopicIamMemberProps(props),
    };
  }

  /**
   * Defines a "TopicIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TopicIamMemberProps) {
    super(scope, id, {
      ...TopicIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TopicIamMember.GVK,
      ...toJson_TopicIamMemberProps(resolved),
    };
  }
}

/**
 * TopicIAMMember is the Schema for the TopicIAMMembers API. <no value>
 *
 * @schema TopicIAMMember
 */
export interface TopicIamMemberProps {
  /**
   * @schema TopicIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TopicIAMMemberSpec defines the desired state of TopicIAMMember
   *
   * @schema TopicIAMMember#spec
   */
  readonly spec: TopicIamMemberSpec;

}

/**
 * Converts an object of type 'TopicIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberProps(obj: TopicIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TopicIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicIAMMemberSpec defines the desired state of TopicIAMMember
 *
 * @schema TopicIamMemberSpec
 */
export interface TopicIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TopicIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: TopicIamMemberSpecDeletionPolicy;

  /**
   * @schema TopicIamMemberSpec#forProvider
   */
  readonly forProvider: TopicIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TopicIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: TopicIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TopicIamMemberSpec#providerRef
   */
  readonly providerRef?: TopicIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TopicIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TopicIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TopicIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TopicIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TopicIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpec(obj: TopicIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TopicIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TopicIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TopicIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TopicIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TopicIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TopicIamMemberSpecDeletionPolicy
 */
export enum TopicIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TopicIamMemberSpecForProvider
 */
export interface TopicIamMemberSpecForProvider {
  /**
   * @schema TopicIamMemberSpecForProvider#condition
   */
  readonly condition?: TopicIamMemberSpecForProviderCondition[];

  /**
   * @schema TopicIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema TopicIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema TopicIamMemberSpecForProvider#role
   */
  readonly role: string;

  /**
   * @schema TopicIamMemberSpecForProvider#topic
   */
  readonly topic?: string;

  /**
   * Reference to a Topic to populate topic.
   *
   * @schema TopicIamMemberSpecForProvider#topicRef
   */
  readonly topicRef?: TopicIamMemberSpecForProviderTopicRef;

  /**
   * Selector for a Topic to populate topic.
   *
   * @schema TopicIamMemberSpecForProvider#topicSelector
   */
  readonly topicSelector?: TopicIamMemberSpecForProviderTopicSelector;

}

/**
 * Converts an object of type 'TopicIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecForProvider(obj: TopicIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_TopicIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
    'topic': obj.topic,
    'topicRef': toJson_TopicIamMemberSpecForProviderTopicRef(obj.topicRef),
    'topicSelector': toJson_TopicIamMemberSpecForProviderTopicSelector(obj.topicSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TopicIamMemberSpecProviderConfigRef
 */
export interface TopicIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: TopicIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecProviderConfigRef(obj: TopicIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TopicIamMemberSpecProviderRef
 */
export interface TopicIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicIamMemberSpecProviderRef#policy
   */
  readonly policy?: TopicIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TopicIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecProviderRef(obj: TopicIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TopicIamMemberSpecPublishConnectionDetailsTo
 */
export interface TopicIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TopicIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TopicIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TopicIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TopicIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TopicIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TopicIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecPublishConnectionDetailsTo(obj: TopicIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TopicIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TopicIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TopicIamMemberSpecWriteConnectionSecretToRef
 */
export interface TopicIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TopicIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TopicIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TopicIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecWriteConnectionSecretToRef(obj: TopicIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TopicIamMemberSpecForProviderCondition
 */
export interface TopicIamMemberSpecForProviderCondition {
  /**
   * @schema TopicIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema TopicIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema TopicIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'TopicIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecForProviderCondition(obj: TopicIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic to populate topic.
 *
 * @schema TopicIamMemberSpecForProviderTopicRef
 */
export interface TopicIamMemberSpecForProviderTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicIamMemberSpecForProviderTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicIamMemberSpecForProviderTopicRef#policy
   */
  readonly policy?: TopicIamMemberSpecForProviderTopicRefPolicy;

}

/**
 * Converts an object of type 'TopicIamMemberSpecForProviderTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecForProviderTopicRef(obj: TopicIamMemberSpecForProviderTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicIamMemberSpecForProviderTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic to populate topic.
 *
 * @schema TopicIamMemberSpecForProviderTopicSelector
 */
export interface TopicIamMemberSpecForProviderTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicIamMemberSpecForProviderTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicIamMemberSpecForProviderTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicIamMemberSpecForProviderTopicSelector#policy
   */
  readonly policy?: TopicIamMemberSpecForProviderTopicSelectorPolicy;

}

/**
 * Converts an object of type 'TopicIamMemberSpecForProviderTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecForProviderTopicSelector(obj: TopicIamMemberSpecForProviderTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicIamMemberSpecForProviderTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicIamMemberSpecProviderConfigRefPolicy
 */
export interface TopicIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TopicIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TopicIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecProviderConfigRefPolicy(obj: TopicIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicIamMemberSpecProviderRefPolicy
 */
export interface TopicIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TopicIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TopicIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecProviderRefPolicy(obj: TopicIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TopicIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface TopicIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecPublishConnectionDetailsToConfigRef(obj: TopicIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TopicIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface TopicIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TopicIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TopicIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecPublishConnectionDetailsToMetadata(obj: TopicIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicIamMemberSpecForProviderTopicRefPolicy
 */
export interface TopicIamMemberSpecForProviderTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicIamMemberSpecForProviderTopicRefPolicy#resolution
   */
  readonly resolution?: TopicIamMemberSpecForProviderTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicIamMemberSpecForProviderTopicRefPolicy#resolve
   */
  readonly resolve?: TopicIamMemberSpecForProviderTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicIamMemberSpecForProviderTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecForProviderTopicRefPolicy(obj: TopicIamMemberSpecForProviderTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicIamMemberSpecForProviderTopicSelectorPolicy
 */
export interface TopicIamMemberSpecForProviderTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicIamMemberSpecForProviderTopicSelectorPolicy#resolution
   */
  readonly resolution?: TopicIamMemberSpecForProviderTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicIamMemberSpecForProviderTopicSelectorPolicy#resolve
   */
  readonly resolve?: TopicIamMemberSpecForProviderTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicIamMemberSpecForProviderTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecForProviderTopicSelectorPolicy(obj: TopicIamMemberSpecForProviderTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum TopicIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum TopicIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicIamMemberSpecProviderRefPolicyResolution
 */
export enum TopicIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicIamMemberSpecProviderRefPolicyResolve
 */
export enum TopicIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicIamMemberSpecForProviderTopicRefPolicyResolution
 */
export enum TopicIamMemberSpecForProviderTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicIamMemberSpecForProviderTopicRefPolicyResolve
 */
export enum TopicIamMemberSpecForProviderTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicIamMemberSpecForProviderTopicSelectorPolicyResolution
 */
export enum TopicIamMemberSpecForProviderTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicIamMemberSpecForProviderTopicSelectorPolicyResolve
 */
export enum TopicIamMemberSpecForProviderTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TopicIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

