// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * LogView is the Schema for the LogViews API. Describes a view over log entries in a bucket.
 *
 * @schema LogView
 */
export class LogView extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LogView"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'logging.gcp.upbound.io/v1beta1',
    kind: 'LogView',
  }

  /**
   * Renders a Kubernetes manifest for "LogView".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LogViewProps): any {
    return {
      ...LogView.GVK,
      ...toJson_LogViewProps(props),
    };
  }

  /**
   * Defines a "LogView" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LogViewProps) {
    super(scope, id, {
      ...LogView.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LogView.GVK,
      ...toJson_LogViewProps(resolved),
    };
  }
}

/**
 * LogView is the Schema for the LogViews API. Describes a view over log entries in a bucket.
 *
 * @schema LogView
 */
export interface LogViewProps {
  /**
   * @schema LogView#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LogViewSpec defines the desired state of LogView
   *
   * @schema LogView#spec
   */
  readonly spec: LogViewSpec;

}

/**
 * Converts an object of type 'LogViewProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewProps(obj: LogViewProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LogViewSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LogViewSpec defines the desired state of LogView
 *
 * @schema LogViewSpec
 */
export interface LogViewSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LogViewSpec#deletionPolicy
   */
  readonly deletionPolicy?: LogViewSpecDeletionPolicy;

  /**
   * @schema LogViewSpec#forProvider
   */
  readonly forProvider: LogViewSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema LogViewSpec#initProvider
   */
  readonly initProvider?: LogViewSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LogViewSpec#managementPolicies
   */
  readonly managementPolicies?: LogViewSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LogViewSpec#providerConfigRef
   */
  readonly providerConfigRef?: LogViewSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LogViewSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LogViewSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LogViewSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LogViewSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LogViewSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpec(obj: LogViewSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LogViewSpecForProvider(obj.forProvider),
    'initProvider': toJson_LogViewSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LogViewSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LogViewSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LogViewSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LogViewSpecDeletionPolicy
 */
export enum LogViewSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LogViewSpecForProvider
 */
export interface LogViewSpecForProvider {
  /**
   * The bucket of the resource
   *
   * @schema LogViewSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a ProjectBucketConfig in logging to populate bucket.
   *
   * @schema LogViewSpecForProvider#bucketRef
   */
  readonly bucketRef?: LogViewSpecForProviderBucketRef;

  /**
   * Selector for a ProjectBucketConfig in logging to populate bucket.
   *
   * @schema LogViewSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: LogViewSpecForProviderBucketSelector;

  /**
   * Describes this view.
   *
   * @schema LogViewSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Filter that restricts which log entries in a bucket are visible in this view. Filters are restricted to be a logical AND of ==/!= of any of the following: - originating project/folder/organization/billing account. - resource type - log id For example: SOURCE("projects/myproject") AND resource.type = "gce_instance" AND LOG_ID("stdout")
   *
   * @schema LogViewSpecForProvider#filter
   */
  readonly filter?: string;

  /**
   * The location of the resource. The supported locations are: global, us-central1, us-east1, us-west1, asia-east1, europe-west1.
   *
   * @schema LogViewSpecForProvider#location
   */
  readonly location?: string;

  /**
   * The parent of the resource.
   *
   * @schema LogViewSpecForProvider#parent
   */
  readonly parent?: string;

}

/**
 * Converts an object of type 'LogViewSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecForProvider(obj: LogViewSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_LogViewSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_LogViewSpecForProviderBucketSelector(obj.bucketSelector),
    'description': obj.description,
    'filter': obj.filter,
    'location': obj.location,
    'parent': obj.parent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema LogViewSpecInitProvider
 */
export interface LogViewSpecInitProvider {
  /**
   * Describes this view.
   *
   * @schema LogViewSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Filter that restricts which log entries in a bucket are visible in this view. Filters are restricted to be a logical AND of ==/!= of any of the following: - originating project/folder/organization/billing account. - resource type - log id For example: SOURCE("projects/myproject") AND resource.type = "gce_instance" AND LOG_ID("stdout")
   *
   * @schema LogViewSpecInitProvider#filter
   */
  readonly filter?: string;

}

/**
 * Converts an object of type 'LogViewSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecInitProvider(obj: LogViewSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'filter': obj.filter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LogViewSpecManagementPolicies
 */
export enum LogViewSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LogViewSpecProviderConfigRef
 */
export interface LogViewSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LogViewSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LogViewSpecProviderConfigRef#policy
   */
  readonly policy?: LogViewSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LogViewSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecProviderConfigRef(obj: LogViewSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LogViewSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LogViewSpecPublishConnectionDetailsTo
 */
export interface LogViewSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LogViewSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LogViewSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LogViewSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LogViewSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LogViewSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LogViewSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecPublishConnectionDetailsTo(obj: LogViewSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LogViewSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LogViewSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LogViewSpecWriteConnectionSecretToRef
 */
export interface LogViewSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LogViewSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LogViewSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LogViewSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecWriteConnectionSecretToRef(obj: LogViewSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ProjectBucketConfig in logging to populate bucket.
 *
 * @schema LogViewSpecForProviderBucketRef
 */
export interface LogViewSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema LogViewSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LogViewSpecForProviderBucketRef#policy
   */
  readonly policy?: LogViewSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'LogViewSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecForProviderBucketRef(obj: LogViewSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LogViewSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ProjectBucketConfig in logging to populate bucket.
 *
 * @schema LogViewSpecForProviderBucketSelector
 */
export interface LogViewSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LogViewSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LogViewSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LogViewSpecForProviderBucketSelector#policy
   */
  readonly policy?: LogViewSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'LogViewSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecForProviderBucketSelector(obj: LogViewSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LogViewSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LogViewSpecProviderConfigRefPolicy
 */
export interface LogViewSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LogViewSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LogViewSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LogViewSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LogViewSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LogViewSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecProviderConfigRefPolicy(obj: LogViewSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LogViewSpecPublishConnectionDetailsToConfigRef
 */
export interface LogViewSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LogViewSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LogViewSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LogViewSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LogViewSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecPublishConnectionDetailsToConfigRef(obj: LogViewSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LogViewSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LogViewSpecPublishConnectionDetailsToMetadata
 */
export interface LogViewSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LogViewSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LogViewSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LogViewSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LogViewSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecPublishConnectionDetailsToMetadata(obj: LogViewSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LogViewSpecForProviderBucketRefPolicy
 */
export interface LogViewSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LogViewSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: LogViewSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LogViewSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: LogViewSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'LogViewSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecForProviderBucketRefPolicy(obj: LogViewSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LogViewSpecForProviderBucketSelectorPolicy
 */
export interface LogViewSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LogViewSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: LogViewSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LogViewSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: LogViewSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LogViewSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecForProviderBucketSelectorPolicy(obj: LogViewSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LogViewSpecProviderConfigRefPolicyResolution
 */
export enum LogViewSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LogViewSpecProviderConfigRefPolicyResolve
 */
export enum LogViewSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LogViewSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LogViewSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LogViewSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LogViewSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LogViewSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LogViewSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LogViewSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LogViewSpecPublishConnectionDetailsToConfigRefPolicy(obj: LogViewSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LogViewSpecForProviderBucketRefPolicyResolution
 */
export enum LogViewSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LogViewSpecForProviderBucketRefPolicyResolve
 */
export enum LogViewSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LogViewSpecForProviderBucketSelectorPolicyResolution
 */
export enum LogViewSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LogViewSpecForProviderBucketSelectorPolicyResolve
 */
export enum LogViewSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LogViewSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LogViewSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LogViewSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LogViewSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Metric is the Schema for the Metrics API. Logs-based metric can also be used to extract values from logs and create a a distribution of the values.
 *
 * @schema Metric
 */
export class Metric extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Metric"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'logging.gcp.upbound.io/v1beta1',
    kind: 'Metric',
  }

  /**
   * Renders a Kubernetes manifest for "Metric".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MetricProps): any {
    return {
      ...Metric.GVK,
      ...toJson_MetricProps(props),
    };
  }

  /**
   * Defines a "Metric" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MetricProps) {
    super(scope, id, {
      ...Metric.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Metric.GVK,
      ...toJson_MetricProps(resolved),
    };
  }
}

/**
 * Metric is the Schema for the Metrics API. Logs-based metric can also be used to extract values from logs and create a a distribution of the values.
 *
 * @schema Metric
 */
export interface MetricProps {
  /**
   * @schema Metric#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MetricSpec defines the desired state of Metric
   *
   * @schema Metric#spec
   */
  readonly spec: MetricSpec;

}

/**
 * Converts an object of type 'MetricProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricProps(obj: MetricProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MetricSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MetricSpec defines the desired state of Metric
 *
 * @schema MetricSpec
 */
export interface MetricSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MetricSpec#deletionPolicy
   */
  readonly deletionPolicy?: MetricSpecDeletionPolicy;

  /**
   * @schema MetricSpec#forProvider
   */
  readonly forProvider: MetricSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema MetricSpec#initProvider
   */
  readonly initProvider?: MetricSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema MetricSpec#managementPolicies
   */
  readonly managementPolicies?: MetricSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MetricSpec#providerConfigRef
   */
  readonly providerConfigRef?: MetricSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MetricSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MetricSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MetricSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MetricSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MetricSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpec(obj: MetricSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MetricSpecForProvider(obj.forProvider),
    'initProvider': toJson_MetricSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_MetricSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_MetricSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MetricSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MetricSpecDeletionPolicy
 */
export enum MetricSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MetricSpecForProvider
 */
export interface MetricSpecForProvider {
  /**
   * The resource name of the Log Bucket that owns the Log Metric. Only Log Buckets in projects are supported. The bucket has to be in the same project as the metric.
   *
   * @schema MetricSpecForProvider#bucketName
   */
  readonly bucketName?: string;

  /**
   * Reference to a ProjectBucketConfig in logging to populate bucketName.
   *
   * @schema MetricSpecForProvider#bucketNameRef
   */
  readonly bucketNameRef?: MetricSpecForProviderBucketNameRef;

  /**
   * Selector for a ProjectBucketConfig in logging to populate bucketName.
   *
   * @schema MetricSpecForProvider#bucketNameSelector
   */
  readonly bucketNameSelector?: MetricSpecForProviderBucketNameSelector;

  /**
   * The bucketOptions are required when the logs-based metric is using a DISTRIBUTION value type and it describes the bucket boundaries used to create a histogram of the extracted values. Structure is documented below.
   *
   * @schema MetricSpecForProvider#bucketOptions
   */
  readonly bucketOptions?: MetricSpecForProviderBucketOptions[];

  /**
   * A description of this metric, which is used in documentation. The maximum length of the description is 8000 characters.
   *
   * @schema MetricSpecForProvider#description
   */
  readonly description?: string;

  /**
   * If set to True, then this metric is disabled and it does not generate any points.
   *
   * @schema MetricSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * An advanced logs filter (https://cloud.google.com/logging/docs/view/advanced-filters) which is used to match log entries.
   *
   * @schema MetricSpecForProvider#filter
   */
  readonly filter?: string;

  /**
   * A map from a label key string to an extractor expression which is used to extract data from a log entry field and assign as the label value. Each label key specified in the LabelDescriptor must have an associated extractor expression in this map. The syntax of the extractor expression is the same as for the valueExtractor field.
   *
   * @schema MetricSpecForProvider#labelExtractors
   */
  readonly labelExtractors?: { [key: string]: string };

  /**
   * The optional metric descriptor associated with the logs-based metric. If unspecified, it uses a default metric descriptor with a DELTA metric kind, INT64 value type, with no labels and a unit of "1". Such a metric counts the number of log entries matching the filter expression. Structure is documented below.
   *
   * @schema MetricSpecForProvider#metricDescriptor
   */
  readonly metricDescriptor?: MetricSpecForProviderMetricDescriptor[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema MetricSpecForProvider#project
   */
  readonly project?: string;

  /**
   * A valueExtractor is required when using a distribution logs-based metric to extract the values to record from a log entry. Two functions are supported for value extraction - EXTRACT(field) or REGEXP_EXTRACT(field, regex). The argument are 1. field - The name of the log entry field from which the value is to be extracted. 2. regex - A regular expression using the Google RE2 syntax (https://github.com/google/re2/wiki/Syntax) with a single capture group to extract data from the specified log entry field. The value of the field is converted to a string before applying the regex. It is an error to specify a regex that does not include exactly one capture group.
   *
   * @schema MetricSpecForProvider#valueExtractor
   */
  readonly valueExtractor?: string;

}

/**
 * Converts an object of type 'MetricSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecForProvider(obj: MetricSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketNameRef': toJson_MetricSpecForProviderBucketNameRef(obj.bucketNameRef),
    'bucketNameSelector': toJson_MetricSpecForProviderBucketNameSelector(obj.bucketNameSelector),
    'bucketOptions': obj.bucketOptions?.map(y => toJson_MetricSpecForProviderBucketOptions(y)),
    'description': obj.description,
    'disabled': obj.disabled,
    'filter': obj.filter,
    'labelExtractors': ((obj.labelExtractors) === undefined) ? undefined : (Object.entries(obj.labelExtractors).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metricDescriptor': obj.metricDescriptor?.map(y => toJson_MetricSpecForProviderMetricDescriptor(y)),
    'project': obj.project,
    'valueExtractor': obj.valueExtractor,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema MetricSpecInitProvider
 */
export interface MetricSpecInitProvider {
  /**
   * The bucketOptions are required when the logs-based metric is using a DISTRIBUTION value type and it describes the bucket boundaries used to create a histogram of the extracted values. Structure is documented below.
   *
   * @schema MetricSpecInitProvider#bucketOptions
   */
  readonly bucketOptions?: MetricSpecInitProviderBucketOptions[];

  /**
   * A description of this metric, which is used in documentation. The maximum length of the description is 8000 characters.
   *
   * @schema MetricSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * If set to True, then this metric is disabled and it does not generate any points.
   *
   * @schema MetricSpecInitProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * An advanced logs filter (https://cloud.google.com/logging/docs/view/advanced-filters) which is used to match log entries.
   *
   * @schema MetricSpecInitProvider#filter
   */
  readonly filter?: string;

  /**
   * A map from a label key string to an extractor expression which is used to extract data from a log entry field and assign as the label value. Each label key specified in the LabelDescriptor must have an associated extractor expression in this map. The syntax of the extractor expression is the same as for the valueExtractor field.
   *
   * @schema MetricSpecInitProvider#labelExtractors
   */
  readonly labelExtractors?: { [key: string]: string };

  /**
   * The optional metric descriptor associated with the logs-based metric. If unspecified, it uses a default metric descriptor with a DELTA metric kind, INT64 value type, with no labels and a unit of "1". Such a metric counts the number of log entries matching the filter expression. Structure is documented below.
   *
   * @schema MetricSpecInitProvider#metricDescriptor
   */
  readonly metricDescriptor?: MetricSpecInitProviderMetricDescriptor[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema MetricSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * A valueExtractor is required when using a distribution logs-based metric to extract the values to record from a log entry. Two functions are supported for value extraction - EXTRACT(field) or REGEXP_EXTRACT(field, regex). The argument are 1. field - The name of the log entry field from which the value is to be extracted. 2. regex - A regular expression using the Google RE2 syntax (https://github.com/google/re2/wiki/Syntax) with a single capture group to extract data from the specified log entry field. The value of the field is converted to a string before applying the regex. It is an error to specify a regex that does not include exactly one capture group.
   *
   * @schema MetricSpecInitProvider#valueExtractor
   */
  readonly valueExtractor?: string;

}

/**
 * Converts an object of type 'MetricSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecInitProvider(obj: MetricSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketOptions': obj.bucketOptions?.map(y => toJson_MetricSpecInitProviderBucketOptions(y)),
    'description': obj.description,
    'disabled': obj.disabled,
    'filter': obj.filter,
    'labelExtractors': ((obj.labelExtractors) === undefined) ? undefined : (Object.entries(obj.labelExtractors).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metricDescriptor': obj.metricDescriptor?.map(y => toJson_MetricSpecInitProviderMetricDescriptor(y)),
    'project': obj.project,
    'valueExtractor': obj.valueExtractor,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema MetricSpecManagementPolicies
 */
export enum MetricSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MetricSpecProviderConfigRef
 */
export interface MetricSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricSpecProviderConfigRef#policy
   */
  readonly policy?: MetricSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MetricSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecProviderConfigRef(obj: MetricSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MetricSpecPublishConnectionDetailsTo
 */
export interface MetricSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MetricSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MetricSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MetricSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MetricSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MetricSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MetricSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecPublishConnectionDetailsTo(obj: MetricSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MetricSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MetricSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MetricSpecWriteConnectionSecretToRef
 */
export interface MetricSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MetricSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MetricSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MetricSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecWriteConnectionSecretToRef(obj: MetricSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ProjectBucketConfig in logging to populate bucketName.
 *
 * @schema MetricSpecForProviderBucketNameRef
 */
export interface MetricSpecForProviderBucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricSpecForProviderBucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricSpecForProviderBucketNameRef#policy
   */
  readonly policy?: MetricSpecForProviderBucketNameRefPolicy;

}

/**
 * Converts an object of type 'MetricSpecForProviderBucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecForProviderBucketNameRef(obj: MetricSpecForProviderBucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricSpecForProviderBucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ProjectBucketConfig in logging to populate bucketName.
 *
 * @schema MetricSpecForProviderBucketNameSelector
 */
export interface MetricSpecForProviderBucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MetricSpecForProviderBucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MetricSpecForProviderBucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MetricSpecForProviderBucketNameSelector#policy
   */
  readonly policy?: MetricSpecForProviderBucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'MetricSpecForProviderBucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecForProviderBucketNameSelector(obj: MetricSpecForProviderBucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MetricSpecForProviderBucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecForProviderBucketOptions
 */
export interface MetricSpecForProviderBucketOptions {
  /**
   * Specifies a set of buckets with arbitrary widths. Structure is documented below.
   *
   * @schema MetricSpecForProviderBucketOptions#explicitBuckets
   */
  readonly explicitBuckets?: MetricSpecForProviderBucketOptionsExplicitBuckets[];

  /**
   * Specifies an exponential sequence of buckets that have a width that is proportional to the value of the lower bound. Each bucket represents a constant relative uncertainty on a specific value in the bucket. Structure is documented below.
   *
   * @schema MetricSpecForProviderBucketOptions#exponentialBuckets
   */
  readonly exponentialBuckets?: MetricSpecForProviderBucketOptionsExponentialBuckets[];

  /**
   * Specifies a linear sequence of buckets that all have the same width (except overflow and underflow). Each bucket represents a constant absolute uncertainty on the specific value in the bucket. Structure is documented below.
   *
   * @schema MetricSpecForProviderBucketOptions#linearBuckets
   */
  readonly linearBuckets?: MetricSpecForProviderBucketOptionsLinearBuckets[];

}

/**
 * Converts an object of type 'MetricSpecForProviderBucketOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecForProviderBucketOptions(obj: MetricSpecForProviderBucketOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'explicitBuckets': obj.explicitBuckets?.map(y => toJson_MetricSpecForProviderBucketOptionsExplicitBuckets(y)),
    'exponentialBuckets': obj.exponentialBuckets?.map(y => toJson_MetricSpecForProviderBucketOptionsExponentialBuckets(y)),
    'linearBuckets': obj.linearBuckets?.map(y => toJson_MetricSpecForProviderBucketOptionsLinearBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecForProviderMetricDescriptor
 */
export interface MetricSpecForProviderMetricDescriptor {
  /**
   * A concise name for the metric, which can be displayed in user interfaces. Use sentence case without an ending period, for example "Request count". This field is optional but it is recommended to be set for any metrics associated with user-visible concepts, such as Quota.
   *
   * @schema MetricSpecForProviderMetricDescriptor#displayName
   */
  readonly displayName?: string;

  /**
   * The set of labels that can be used to describe a specific instance of this metric type. For example, the appengine.googleapis.com/http/server/response_latencies metric type has a label for the HTTP response code, response_code, so you can look at latencies for successful responses or just for responses that failed. Structure is documented below.
   *
   * @schema MetricSpecForProviderMetricDescriptor#labels
   */
  readonly labels?: MetricSpecForProviderMetricDescriptorLabels[];

  /**
   * Whether the metric records instantaneous values, changes to a value, etc. Some combinations of metricKind and valueType might not be supported. For counter metrics, set this to DELTA. Possible values are: DELTA, GAUGE, CUMULATIVE.
   *
   * @schema MetricSpecForProviderMetricDescriptor#metricKind
   */
  readonly metricKind?: string;

  /**
   * The unit in which the metric value is reported. It is only applicable if the valueType is INT64, DOUBLE, or DISTRIBUTION. The supported units are a subset of The Unified Code for Units of Measure standard
   *
   * @schema MetricSpecForProviderMetricDescriptor#unit
   */
  readonly unit?: string;

  /**
   * Whether the measurement is an integer, a floating-point number, etc. Some combinations of metricKind and valueType might not be supported. For counter metrics, set this to INT64. Possible values are: BOOL, INT64, DOUBLE, STRING, DISTRIBUTION, MONEY.
   *
   * @schema MetricSpecForProviderMetricDescriptor#valueType
   */
  readonly valueType?: string;

}

/**
 * Converts an object of type 'MetricSpecForProviderMetricDescriptor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecForProviderMetricDescriptor(obj: MetricSpecForProviderMetricDescriptor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'labels': obj.labels?.map(y => toJson_MetricSpecForProviderMetricDescriptorLabels(y)),
    'metricKind': obj.metricKind,
    'unit': obj.unit,
    'valueType': obj.valueType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecInitProviderBucketOptions
 */
export interface MetricSpecInitProviderBucketOptions {
  /**
   * Specifies a set of buckets with arbitrary widths. Structure is documented below.
   *
   * @schema MetricSpecInitProviderBucketOptions#explicitBuckets
   */
  readonly explicitBuckets?: MetricSpecInitProviderBucketOptionsExplicitBuckets[];

  /**
   * Specifies an exponential sequence of buckets that have a width that is proportional to the value of the lower bound. Each bucket represents a constant relative uncertainty on a specific value in the bucket. Structure is documented below.
   *
   * @schema MetricSpecInitProviderBucketOptions#exponentialBuckets
   */
  readonly exponentialBuckets?: MetricSpecInitProviderBucketOptionsExponentialBuckets[];

  /**
   * Specifies a linear sequence of buckets that all have the same width (except overflow and underflow). Each bucket represents a constant absolute uncertainty on the specific value in the bucket. Structure is documented below.
   *
   * @schema MetricSpecInitProviderBucketOptions#linearBuckets
   */
  readonly linearBuckets?: MetricSpecInitProviderBucketOptionsLinearBuckets[];

}

/**
 * Converts an object of type 'MetricSpecInitProviderBucketOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecInitProviderBucketOptions(obj: MetricSpecInitProviderBucketOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'explicitBuckets': obj.explicitBuckets?.map(y => toJson_MetricSpecInitProviderBucketOptionsExplicitBuckets(y)),
    'exponentialBuckets': obj.exponentialBuckets?.map(y => toJson_MetricSpecInitProviderBucketOptionsExponentialBuckets(y)),
    'linearBuckets': obj.linearBuckets?.map(y => toJson_MetricSpecInitProviderBucketOptionsLinearBuckets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecInitProviderMetricDescriptor
 */
export interface MetricSpecInitProviderMetricDescriptor {
  /**
   * A concise name for the metric, which can be displayed in user interfaces. Use sentence case without an ending period, for example "Request count". This field is optional but it is recommended to be set for any metrics associated with user-visible concepts, such as Quota.
   *
   * @schema MetricSpecInitProviderMetricDescriptor#displayName
   */
  readonly displayName?: string;

  /**
   * The set of labels that can be used to describe a specific instance of this metric type. For example, the appengine.googleapis.com/http/server/response_latencies metric type has a label for the HTTP response code, response_code, so you can look at latencies for successful responses or just for responses that failed. Structure is documented below.
   *
   * @schema MetricSpecInitProviderMetricDescriptor#labels
   */
  readonly labels?: MetricSpecInitProviderMetricDescriptorLabels[];

  /**
   * Whether the metric records instantaneous values, changes to a value, etc. Some combinations of metricKind and valueType might not be supported. For counter metrics, set this to DELTA. Possible values are: DELTA, GAUGE, CUMULATIVE.
   *
   * @schema MetricSpecInitProviderMetricDescriptor#metricKind
   */
  readonly metricKind?: string;

  /**
   * The unit in which the metric value is reported. It is only applicable if the valueType is INT64, DOUBLE, or DISTRIBUTION. The supported units are a subset of The Unified Code for Units of Measure standard
   *
   * @schema MetricSpecInitProviderMetricDescriptor#unit
   */
  readonly unit?: string;

  /**
   * Whether the measurement is an integer, a floating-point number, etc. Some combinations of metricKind and valueType might not be supported. For counter metrics, set this to INT64. Possible values are: BOOL, INT64, DOUBLE, STRING, DISTRIBUTION, MONEY.
   *
   * @schema MetricSpecInitProviderMetricDescriptor#valueType
   */
  readonly valueType?: string;

}

/**
 * Converts an object of type 'MetricSpecInitProviderMetricDescriptor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecInitProviderMetricDescriptor(obj: MetricSpecInitProviderMetricDescriptor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'labels': obj.labels?.map(y => toJson_MetricSpecInitProviderMetricDescriptorLabels(y)),
    'metricKind': obj.metricKind,
    'unit': obj.unit,
    'valueType': obj.valueType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricSpecProviderConfigRefPolicy
 */
export interface MetricSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MetricSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MetricSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecProviderConfigRefPolicy(obj: MetricSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MetricSpecPublishConnectionDetailsToConfigRef
 */
export interface MetricSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MetricSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MetricSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecPublishConnectionDetailsToConfigRef(obj: MetricSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MetricSpecPublishConnectionDetailsToMetadata
 */
export interface MetricSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MetricSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MetricSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MetricSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MetricSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecPublishConnectionDetailsToMetadata(obj: MetricSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricSpecForProviderBucketNameRefPolicy
 */
export interface MetricSpecForProviderBucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricSpecForProviderBucketNameRefPolicy#resolution
   */
  readonly resolution?: MetricSpecForProviderBucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricSpecForProviderBucketNameRefPolicy#resolve
   */
  readonly resolve?: MetricSpecForProviderBucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricSpecForProviderBucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecForProviderBucketNameRefPolicy(obj: MetricSpecForProviderBucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MetricSpecForProviderBucketNameSelectorPolicy
 */
export interface MetricSpecForProviderBucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricSpecForProviderBucketNameSelectorPolicy#resolution
   */
  readonly resolution?: MetricSpecForProviderBucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricSpecForProviderBucketNameSelectorPolicy#resolve
   */
  readonly resolve?: MetricSpecForProviderBucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MetricSpecForProviderBucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecForProviderBucketNameSelectorPolicy(obj: MetricSpecForProviderBucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecForProviderBucketOptionsExplicitBuckets
 */
export interface MetricSpecForProviderBucketOptionsExplicitBuckets {
  /**
   * The values must be monotonically increasing.
   *
   * @schema MetricSpecForProviderBucketOptionsExplicitBuckets#bounds
   */
  readonly bounds?: number[];

}

/**
 * Converts an object of type 'MetricSpecForProviderBucketOptionsExplicitBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecForProviderBucketOptionsExplicitBuckets(obj: MetricSpecForProviderBucketOptionsExplicitBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bounds': obj.bounds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecForProviderBucketOptionsExponentialBuckets
 */
export interface MetricSpecForProviderBucketOptionsExponentialBuckets {
  /**
   * Must be greater than 1.
   *
   * @schema MetricSpecForProviderBucketOptionsExponentialBuckets#growthFactor
   */
  readonly growthFactor?: number;

  /**
   * Must be greater than 0.
   *
   * @schema MetricSpecForProviderBucketOptionsExponentialBuckets#numFiniteBuckets
   */
  readonly numFiniteBuckets?: number;

  /**
   * Must be greater than 0.
   *
   * @schema MetricSpecForProviderBucketOptionsExponentialBuckets#scale
   */
  readonly scale?: number;

}

/**
 * Converts an object of type 'MetricSpecForProviderBucketOptionsExponentialBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecForProviderBucketOptionsExponentialBuckets(obj: MetricSpecForProviderBucketOptionsExponentialBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'growthFactor': obj.growthFactor,
    'numFiniteBuckets': obj.numFiniteBuckets,
    'scale': obj.scale,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecForProviderBucketOptionsLinearBuckets
 */
export interface MetricSpecForProviderBucketOptionsLinearBuckets {
  /**
   * Must be greater than 0.
   *
   * @schema MetricSpecForProviderBucketOptionsLinearBuckets#numFiniteBuckets
   */
  readonly numFiniteBuckets?: number;

  /**
   * Lower bound of the first bucket.
   *
   * @schema MetricSpecForProviderBucketOptionsLinearBuckets#offset
   */
  readonly offset?: number;

  /**
   * Must be greater than 0.
   *
   * @schema MetricSpecForProviderBucketOptionsLinearBuckets#width
   */
  readonly width?: number;

}

/**
 * Converts an object of type 'MetricSpecForProviderBucketOptionsLinearBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecForProviderBucketOptionsLinearBuckets(obj: MetricSpecForProviderBucketOptionsLinearBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numFiniteBuckets': obj.numFiniteBuckets,
    'offset': obj.offset,
    'width': obj.width,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecForProviderMetricDescriptorLabels
 */
export interface MetricSpecForProviderMetricDescriptorLabels {
  /**
   * A human-readable description for the label.
   *
   * @schema MetricSpecForProviderMetricDescriptorLabels#description
   */
  readonly description?: string;

  /**
   * The label key.
   *
   * @schema MetricSpecForProviderMetricDescriptorLabels#key
   */
  readonly key?: string;

  /**
   * Whether the measurement is an integer, a floating-point number, etc. Some combinations of metricKind and valueType might not be supported. For counter metrics, set this to INT64. Possible values are: BOOL, INT64, DOUBLE, STRING, DISTRIBUTION, MONEY.
   *
   * @schema MetricSpecForProviderMetricDescriptorLabels#valueType
   */
  readonly valueType?: string;

}

/**
 * Converts an object of type 'MetricSpecForProviderMetricDescriptorLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecForProviderMetricDescriptorLabels(obj: MetricSpecForProviderMetricDescriptorLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'key': obj.key,
    'valueType': obj.valueType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecInitProviderBucketOptionsExplicitBuckets
 */
export interface MetricSpecInitProviderBucketOptionsExplicitBuckets {
  /**
   * The values must be monotonically increasing.
   *
   * @schema MetricSpecInitProviderBucketOptionsExplicitBuckets#bounds
   */
  readonly bounds?: number[];

}

/**
 * Converts an object of type 'MetricSpecInitProviderBucketOptionsExplicitBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecInitProviderBucketOptionsExplicitBuckets(obj: MetricSpecInitProviderBucketOptionsExplicitBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bounds': obj.bounds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecInitProviderBucketOptionsExponentialBuckets
 */
export interface MetricSpecInitProviderBucketOptionsExponentialBuckets {
  /**
   * Must be greater than 1.
   *
   * @schema MetricSpecInitProviderBucketOptionsExponentialBuckets#growthFactor
   */
  readonly growthFactor?: number;

  /**
   * Must be greater than 0.
   *
   * @schema MetricSpecInitProviderBucketOptionsExponentialBuckets#numFiniteBuckets
   */
  readonly numFiniteBuckets?: number;

  /**
   * Must be greater than 0.
   *
   * @schema MetricSpecInitProviderBucketOptionsExponentialBuckets#scale
   */
  readonly scale?: number;

}

/**
 * Converts an object of type 'MetricSpecInitProviderBucketOptionsExponentialBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecInitProviderBucketOptionsExponentialBuckets(obj: MetricSpecInitProviderBucketOptionsExponentialBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'growthFactor': obj.growthFactor,
    'numFiniteBuckets': obj.numFiniteBuckets,
    'scale': obj.scale,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecInitProviderBucketOptionsLinearBuckets
 */
export interface MetricSpecInitProviderBucketOptionsLinearBuckets {
  /**
   * Must be greater than 0.
   *
   * @schema MetricSpecInitProviderBucketOptionsLinearBuckets#numFiniteBuckets
   */
  readonly numFiniteBuckets?: number;

  /**
   * Lower bound of the first bucket.
   *
   * @schema MetricSpecInitProviderBucketOptionsLinearBuckets#offset
   */
  readonly offset?: number;

  /**
   * Must be greater than 0.
   *
   * @schema MetricSpecInitProviderBucketOptionsLinearBuckets#width
   */
  readonly width?: number;

}

/**
 * Converts an object of type 'MetricSpecInitProviderBucketOptionsLinearBuckets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecInitProviderBucketOptionsLinearBuckets(obj: MetricSpecInitProviderBucketOptionsLinearBuckets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'numFiniteBuckets': obj.numFiniteBuckets,
    'offset': obj.offset,
    'width': obj.width,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricSpecInitProviderMetricDescriptorLabels
 */
export interface MetricSpecInitProviderMetricDescriptorLabels {
  /**
   * A human-readable description for the label.
   *
   * @schema MetricSpecInitProviderMetricDescriptorLabels#description
   */
  readonly description?: string;

  /**
   * The label key.
   *
   * @schema MetricSpecInitProviderMetricDescriptorLabels#key
   */
  readonly key?: string;

  /**
   * Whether the measurement is an integer, a floating-point number, etc. Some combinations of metricKind and valueType might not be supported. For counter metrics, set this to INT64. Possible values are: BOOL, INT64, DOUBLE, STRING, DISTRIBUTION, MONEY.
   *
   * @schema MetricSpecInitProviderMetricDescriptorLabels#valueType
   */
  readonly valueType?: string;

}

/**
 * Converts an object of type 'MetricSpecInitProviderMetricDescriptorLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecInitProviderMetricDescriptorLabels(obj: MetricSpecInitProviderMetricDescriptorLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'key': obj.key,
    'valueType': obj.valueType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricSpecProviderConfigRefPolicyResolution
 */
export enum MetricSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricSpecProviderConfigRefPolicyResolve
 */
export enum MetricSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MetricSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MetricSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MetricSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MetricSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricSpecPublishConnectionDetailsToConfigRefPolicy(obj: MetricSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricSpecForProviderBucketNameRefPolicyResolution
 */
export enum MetricSpecForProviderBucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricSpecForProviderBucketNameRefPolicyResolve
 */
export enum MetricSpecForProviderBucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricSpecForProviderBucketNameSelectorPolicyResolution
 */
export enum MetricSpecForProviderBucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricSpecForProviderBucketNameSelectorPolicyResolve
 */
export enum MetricSpecForProviderBucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MetricSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MetricSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectBucketConfig is the Schema for the ProjectBucketConfigs API. Manages a project-level logging bucket config.
 *
 * @schema ProjectBucketConfig
 */
export class ProjectBucketConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectBucketConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'logging.gcp.upbound.io/v1beta1',
    kind: 'ProjectBucketConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectBucketConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectBucketConfigProps): any {
    return {
      ...ProjectBucketConfig.GVK,
      ...toJson_ProjectBucketConfigProps(props),
    };
  }

  /**
   * Defines a "ProjectBucketConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectBucketConfigProps) {
    super(scope, id, {
      ...ProjectBucketConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectBucketConfig.GVK,
      ...toJson_ProjectBucketConfigProps(resolved),
    };
  }
}

/**
 * ProjectBucketConfig is the Schema for the ProjectBucketConfigs API. Manages a project-level logging bucket config.
 *
 * @schema ProjectBucketConfig
 */
export interface ProjectBucketConfigProps {
  /**
   * @schema ProjectBucketConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectBucketConfigSpec defines the desired state of ProjectBucketConfig
   *
   * @schema ProjectBucketConfig#spec
   */
  readonly spec: ProjectBucketConfigSpec;

}

/**
 * Converts an object of type 'ProjectBucketConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigProps(obj: ProjectBucketConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectBucketConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectBucketConfigSpec defines the desired state of ProjectBucketConfig
 *
 * @schema ProjectBucketConfigSpec
 */
export interface ProjectBucketConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectBucketConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectBucketConfigSpecDeletionPolicy;

  /**
   * @schema ProjectBucketConfigSpec#forProvider
   */
  readonly forProvider: ProjectBucketConfigSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProjectBucketConfigSpec#initProvider
   */
  readonly initProvider?: ProjectBucketConfigSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectBucketConfigSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectBucketConfigSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectBucketConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectBucketConfigSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectBucketConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectBucketConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectBucketConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectBucketConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpec(obj: ProjectBucketConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectBucketConfigSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectBucketConfigSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectBucketConfigSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectBucketConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectBucketConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectBucketConfigSpecDeletionPolicy
 */
export enum ProjectBucketConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectBucketConfigSpecForProvider
 */
export interface ProjectBucketConfigSpecForProvider {
  /**
   * The name of the logging bucket. Logging automatically creates two log buckets: _Required and _Default.
   *
   * @schema ProjectBucketConfigSpecForProvider#bucketId
   */
  readonly bucketId: string;

  /**
   * The CMEK settings of the log bucket. If present, new log entries written to this log bucket are encrypted using the CMEK key provided in this configuration. If a log bucket has CMEK settings, the CMEK settings cannot be disabled later by updating the log bucket. Changing the KMS key is allowed. Structure is documented below.
   *
   * @schema ProjectBucketConfigSpecForProvider#cmekSettings
   */
  readonly cmekSettings?: ProjectBucketConfigSpecForProviderCmekSettings[];

  /**
   * Describes this bucket.
   *
   * @schema ProjectBucketConfigSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether or not Log Analytics is enabled. Logs for buckets with Log Analytics enabled can be queried in the Log Analytics page using SQL queries. Cannot be disabled once enabled.
   *
   * @schema ProjectBucketConfigSpecForProvider#enableAnalytics
   */
  readonly enableAnalytics?: boolean;

  /**
   * The location of the bucket.
   *
   * @schema ProjectBucketConfigSpecForProvider#location
   */
  readonly location: string;

  /**
   * Whether the bucket is locked. The retention period on a locked bucket cannot be changed. Locked buckets may only be deleted if they are empty.
   *
   * @schema ProjectBucketConfigSpecForProvider#locked
   */
  readonly locked?: boolean;

  /**
   * The parent resource that contains the logging bucket.
   *
   * @schema ProjectBucketConfigSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema ProjectBucketConfigSpecForProvider#projectRef
   */
  readonly projectRef?: ProjectBucketConfigSpecForProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema ProjectBucketConfigSpecForProvider#projectSelector
   */
  readonly projectSelector?: ProjectBucketConfigSpecForProviderProjectSelector;

  /**
   * Logs will be retained by default for this amount of time, after which they will automatically be deleted. The minimum retention period is 1 day. If this value is set to zero at bucket creation time, the default time of 30 days will be used.
   *
   * @schema ProjectBucketConfigSpecForProvider#retentionDays
   */
  readonly retentionDays?: number;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecForProvider(obj: ProjectBucketConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketId': obj.bucketId,
    'cmekSettings': obj.cmekSettings?.map(y => toJson_ProjectBucketConfigSpecForProviderCmekSettings(y)),
    'description': obj.description,
    'enableAnalytics': obj.enableAnalytics,
    'location': obj.location,
    'locked': obj.locked,
    'project': obj.project,
    'projectRef': toJson_ProjectBucketConfigSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ProjectBucketConfigSpecForProviderProjectSelector(obj.projectSelector),
    'retentionDays': obj.retentionDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProjectBucketConfigSpecInitProvider
 */
export interface ProjectBucketConfigSpecInitProvider {
  /**
   * The CMEK settings of the log bucket. If present, new log entries written to this log bucket are encrypted using the CMEK key provided in this configuration. If a log bucket has CMEK settings, the CMEK settings cannot be disabled later by updating the log bucket. Changing the KMS key is allowed. Structure is documented below.
   *
   * @schema ProjectBucketConfigSpecInitProvider#cmekSettings
   */
  readonly cmekSettings?: any[];

  /**
   * Describes this bucket.
   *
   * @schema ProjectBucketConfigSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Whether or not Log Analytics is enabled. Logs for buckets with Log Analytics enabled can be queried in the Log Analytics page using SQL queries. Cannot be disabled once enabled.
   *
   * @schema ProjectBucketConfigSpecInitProvider#enableAnalytics
   */
  readonly enableAnalytics?: boolean;

  /**
   * Whether the bucket is locked. The retention period on a locked bucket cannot be changed. Locked buckets may only be deleted if they are empty.
   *
   * @schema ProjectBucketConfigSpecInitProvider#locked
   */
  readonly locked?: boolean;

  /**
   * Logs will be retained by default for this amount of time, after which they will automatically be deleted. The minimum retention period is 1 day. If this value is set to zero at bucket creation time, the default time of 30 days will be used.
   *
   * @schema ProjectBucketConfigSpecInitProvider#retentionDays
   */
  readonly retentionDays?: number;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecInitProvider(obj: ProjectBucketConfigSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cmekSettings': obj.cmekSettings?.map(y => y),
    'description': obj.description,
    'enableAnalytics': obj.enableAnalytics,
    'locked': obj.locked,
    'retentionDays': obj.retentionDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProjectBucketConfigSpecManagementPolicies
 */
export enum ProjectBucketConfigSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectBucketConfigSpecProviderConfigRef
 */
export interface ProjectBucketConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectBucketConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectBucketConfigSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectBucketConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecProviderConfigRef(obj: ProjectBucketConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectBucketConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectBucketConfigSpecPublishConnectionDetailsTo
 */
export interface ProjectBucketConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectBucketConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectBucketConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectBucketConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectBucketConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectBucketConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecPublishConnectionDetailsTo(obj: ProjectBucketConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectBucketConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectBucketConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectBucketConfigSpecWriteConnectionSecretToRef
 */
export interface ProjectBucketConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectBucketConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectBucketConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecWriteConnectionSecretToRef(obj: ProjectBucketConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectBucketConfigSpecForProviderCmekSettings
 */
export interface ProjectBucketConfigSpecForProviderCmekSettings {
  /**
   * The resource name for the configured Cloud KMS key. KMS key name format: 'projects/[PROJECT_ID]/locations/[LOCATION]/keyRings/[KEYRING]/cryptoKeys/[KEY]' To enable CMEK for the bucket, set this field to a valid kmsKeyName for which the associated service account has the required cloudkms.cryptoKeyEncrypterDecrypter roles assigned for the key. The Cloud KMS key used by the bucket can be updated by changing the kmsKeyName to a new valid key name. Encryption operations that are in progress will be completed with the key that was in use when they started. Decryption operations will be completed using the key that was used at the time of encryption unless access to that key has been revoked. See Enabling CMEK for Logging Buckets for more information.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettings#kmsKeyName
   */
  readonly kmsKeyName?: string;

  /**
   * Reference to a CryptoKey in kms to populate kmsKeyName.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettings#kmsKeyNameRef
   */
  readonly kmsKeyNameRef?: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRef;

  /**
   * Selector for a CryptoKey in kms to populate kmsKeyName.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettings#kmsKeyNameSelector
   */
  readonly kmsKeyNameSelector?: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelector;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecForProviderCmekSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecForProviderCmekSettings(obj: ProjectBucketConfigSpecForProviderCmekSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
    'kmsKeyNameRef': toJson_ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRef(obj.kmsKeyNameRef),
    'kmsKeyNameSelector': toJson_ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelector(obj.kmsKeyNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema ProjectBucketConfigSpecForProviderProjectRef
 */
export interface ProjectBucketConfigSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectBucketConfigSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectBucketConfigSpecForProviderProjectRef#policy
   */
  readonly policy?: ProjectBucketConfigSpecForProviderProjectRefPolicy;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecForProviderProjectRef(obj: ProjectBucketConfigSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectBucketConfigSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema ProjectBucketConfigSpecForProviderProjectSelector
 */
export interface ProjectBucketConfigSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProjectBucketConfigSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectBucketConfigSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectBucketConfigSpecForProviderProjectSelector#policy
   */
  readonly policy?: ProjectBucketConfigSpecForProviderProjectSelectorPolicy;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecForProviderProjectSelector(obj: ProjectBucketConfigSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectBucketConfigSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectBucketConfigSpecProviderConfigRefPolicy
 */
export interface ProjectBucketConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectBucketConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectBucketConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectBucketConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectBucketConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecProviderConfigRefPolicy(obj: ProjectBucketConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectBucketConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectBucketConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectBucketConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectBucketConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecPublishConnectionDetailsToConfigRef(obj: ProjectBucketConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectBucketConfigSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectBucketConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectBucketConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectBucketConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectBucketConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecPublishConnectionDetailsToMetadata(obj: ProjectBucketConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CryptoKey in kms to populate kmsKeyName.
 *
 * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRef
 */
export interface ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRef#policy
   */
  readonly policy?: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicy;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRef(obj: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CryptoKey in kms to populate kmsKeyName.
 *
 * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelector
 */
export interface ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelector#policy
   */
  readonly policy?: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicy;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelector(obj: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectBucketConfigSpecForProviderProjectRefPolicy
 */
export interface ProjectBucketConfigSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectBucketConfigSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ProjectBucketConfigSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectBucketConfigSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ProjectBucketConfigSpecForProviderProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecForProviderProjectRefPolicy(obj: ProjectBucketConfigSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectBucketConfigSpecForProviderProjectSelectorPolicy
 */
export interface ProjectBucketConfigSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectBucketConfigSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ProjectBucketConfigSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectBucketConfigSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ProjectBucketConfigSpecForProviderProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecForProviderProjectSelectorPolicy(obj: ProjectBucketConfigSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectBucketConfigSpecProviderConfigRefPolicyResolution
 */
export enum ProjectBucketConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectBucketConfigSpecProviderConfigRefPolicyResolve
 */
export enum ProjectBucketConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicy
 */
export interface ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicy#resolution
   */
  readonly resolution?: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicy#resolve
   */
  readonly resolve?: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicy(obj: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicy
 */
export interface ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicy#resolution
   */
  readonly resolution?: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicy#resolve
   */
  readonly resolve?: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicy(obj: ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectBucketConfigSpecForProviderProjectRefPolicyResolution
 */
export enum ProjectBucketConfigSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectBucketConfigSpecForProviderProjectRefPolicyResolve
 */
export enum ProjectBucketConfigSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectBucketConfigSpecForProviderProjectSelectorPolicyResolution
 */
export enum ProjectBucketConfigSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectBucketConfigSpecForProviderProjectSelectorPolicyResolve
 */
export enum ProjectBucketConfigSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectBucketConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicyResolution
 */
export enum ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicyResolve
 */
export enum ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicyResolution
 */
export enum ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicyResolve
 */
export enum ProjectBucketConfigSpecForProviderCmekSettingsKmsKeyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectExclusion is the Schema for the ProjectExclusions API. Manages a project-level logging exclusion.
 *
 * @schema ProjectExclusion
 */
export class ProjectExclusion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectExclusion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'logging.gcp.upbound.io/v1beta1',
    kind: 'ProjectExclusion',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectExclusion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectExclusionProps): any {
    return {
      ...ProjectExclusion.GVK,
      ...toJson_ProjectExclusionProps(props),
    };
  }

  /**
   * Defines a "ProjectExclusion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectExclusionProps) {
    super(scope, id, {
      ...ProjectExclusion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectExclusion.GVK,
      ...toJson_ProjectExclusionProps(resolved),
    };
  }
}

/**
 * ProjectExclusion is the Schema for the ProjectExclusions API. Manages a project-level logging exclusion.
 *
 * @schema ProjectExclusion
 */
export interface ProjectExclusionProps {
  /**
   * @schema ProjectExclusion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectExclusionSpec defines the desired state of ProjectExclusion
   *
   * @schema ProjectExclusion#spec
   */
  readonly spec: ProjectExclusionSpec;

}

/**
 * Converts an object of type 'ProjectExclusionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectExclusionProps(obj: ProjectExclusionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectExclusionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectExclusionSpec defines the desired state of ProjectExclusion
 *
 * @schema ProjectExclusionSpec
 */
export interface ProjectExclusionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectExclusionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectExclusionSpecDeletionPolicy;

  /**
   * @schema ProjectExclusionSpec#forProvider
   */
  readonly forProvider: ProjectExclusionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProjectExclusionSpec#initProvider
   */
  readonly initProvider?: ProjectExclusionSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectExclusionSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectExclusionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectExclusionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectExclusionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectExclusionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectExclusionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectExclusionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectExclusionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectExclusionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectExclusionSpec(obj: ProjectExclusionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectExclusionSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectExclusionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectExclusionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectExclusionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectExclusionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectExclusionSpecDeletionPolicy
 */
export enum ProjectExclusionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectExclusionSpecForProvider
 */
export interface ProjectExclusionSpecForProvider {
  /**
   * A human-readable description.
   *
   * @schema ProjectExclusionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether this exclusion rule should be disabled or not. This defaults to false.
   *
   * @schema ProjectExclusionSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * The filter to apply when excluding logs. Only log entries that match the filter are excluded. See Advanced Log Filters for information on how to write a filter.
   *
   * @schema ProjectExclusionSpecForProvider#filter
   */
  readonly filter?: string;

  /**
   * The project to create the exclusion in. If omitted, the project associated with the provider is used.
   *
   * @schema ProjectExclusionSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ProjectExclusionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectExclusionSpecForProvider(obj: ProjectExclusionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'disabled': obj.disabled,
    'filter': obj.filter,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProjectExclusionSpecInitProvider
 */
export interface ProjectExclusionSpecInitProvider {
  /**
   * A human-readable description.
   *
   * @schema ProjectExclusionSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Whether this exclusion rule should be disabled or not. This defaults to false.
   *
   * @schema ProjectExclusionSpecInitProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * The filter to apply when excluding logs. Only log entries that match the filter are excluded. See Advanced Log Filters for information on how to write a filter.
   *
   * @schema ProjectExclusionSpecInitProvider#filter
   */
  readonly filter?: string;

  /**
   * The project to create the exclusion in. If omitted, the project associated with the provider is used.
   *
   * @schema ProjectExclusionSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ProjectExclusionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectExclusionSpecInitProvider(obj: ProjectExclusionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'disabled': obj.disabled,
    'filter': obj.filter,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProjectExclusionSpecManagementPolicies
 */
export enum ProjectExclusionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectExclusionSpecProviderConfigRef
 */
export interface ProjectExclusionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectExclusionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectExclusionSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectExclusionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectExclusionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectExclusionSpecProviderConfigRef(obj: ProjectExclusionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectExclusionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectExclusionSpecPublishConnectionDetailsTo
 */
export interface ProjectExclusionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectExclusionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectExclusionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectExclusionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectExclusionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectExclusionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectExclusionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectExclusionSpecPublishConnectionDetailsTo(obj: ProjectExclusionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectExclusionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectExclusionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectExclusionSpecWriteConnectionSecretToRef
 */
export interface ProjectExclusionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectExclusionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectExclusionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectExclusionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectExclusionSpecWriteConnectionSecretToRef(obj: ProjectExclusionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectExclusionSpecProviderConfigRefPolicy
 */
export interface ProjectExclusionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectExclusionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectExclusionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectExclusionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectExclusionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectExclusionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectExclusionSpecProviderConfigRefPolicy(obj: ProjectExclusionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectExclusionSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectExclusionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectExclusionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectExclusionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectExclusionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectExclusionSpecPublishConnectionDetailsToConfigRef(obj: ProjectExclusionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectExclusionSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectExclusionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectExclusionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectExclusionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectExclusionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectExclusionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectExclusionSpecPublishConnectionDetailsToMetadata(obj: ProjectExclusionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectExclusionSpecProviderConfigRefPolicyResolution
 */
export enum ProjectExclusionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectExclusionSpecProviderConfigRefPolicyResolve
 */
export enum ProjectExclusionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectExclusionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectSink is the Schema for the ProjectSinks API. Manages a project-level logging sink.
 *
 * @schema ProjectSink
 */
export class ProjectSink extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectSink"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'logging.gcp.upbound.io/v1beta1',
    kind: 'ProjectSink',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectSink".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectSinkProps): any {
    return {
      ...ProjectSink.GVK,
      ...toJson_ProjectSinkProps(props),
    };
  }

  /**
   * Defines a "ProjectSink" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectSinkProps) {
    super(scope, id, {
      ...ProjectSink.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectSink.GVK,
      ...toJson_ProjectSinkProps(resolved),
    };
  }
}

/**
 * ProjectSink is the Schema for the ProjectSinks API. Manages a project-level logging sink.
 *
 * @schema ProjectSink
 */
export interface ProjectSinkProps {
  /**
   * @schema ProjectSink#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectSinkSpec defines the desired state of ProjectSink
   *
   * @schema ProjectSink#spec
   */
  readonly spec: ProjectSinkSpec;

}

/**
 * Converts an object of type 'ProjectSinkProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkProps(obj: ProjectSinkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectSinkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectSinkSpec defines the desired state of ProjectSink
 *
 * @schema ProjectSinkSpec
 */
export interface ProjectSinkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectSinkSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectSinkSpecDeletionPolicy;

  /**
   * @schema ProjectSinkSpec#forProvider
   */
  readonly forProvider: ProjectSinkSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProjectSinkSpec#initProvider
   */
  readonly initProvider?: ProjectSinkSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectSinkSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectSinkSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectSinkSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectSinkSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectSinkSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectSinkSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectSinkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectSinkSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectSinkSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpec(obj: ProjectSinkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectSinkSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectSinkSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectSinkSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectSinkSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectSinkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectSinkSpecDeletionPolicy
 */
export enum ProjectSinkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectSinkSpecForProvider
 */
export interface ProjectSinkSpecForProvider {
  /**
   * Options that affect sinks exporting data to BigQuery. Structure documented below.
   *
   * @schema ProjectSinkSpecForProvider#bigqueryOptions
   */
  readonly bigqueryOptions?: ProjectSinkSpecForProviderBigqueryOptions[];

  /**
   * A description of this sink. The maximum length of the description is 8000 characters.
   *
   * @schema ProjectSinkSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The destination of the sink (or, in other words, where logs are written to). Can be a Cloud Storage bucket, a PubSub topic, a BigQuery dataset or a Cloud Logging bucket . Examples:
   *
   * @schema ProjectSinkSpecForProvider#destination
   */
  readonly destination?: string;

  /**
   * If set to True, then this sink is disabled and it does not export any log entries.
   *
   * @schema ProjectSinkSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * Log entries that match any of the exclusion filters will not be exported. If a log entry is matched by both filter and one of exclusions.filter, it will not be exported.  Can be repeated multiple times for multiple exclusions. Structure is documented below.
   *
   * @schema ProjectSinkSpecForProvider#exclusions
   */
  readonly exclusions?: ProjectSinkSpecForProviderExclusions[];

  /**
   * The filter to apply when exporting logs. Only log entries that match the filter are exported. See Advanced Log Filters for information on how to write a filter.
   *
   * @schema ProjectSinkSpecForProvider#filter
   */
  readonly filter?: string;

  /**
   * The ID of the project to create the sink in. If omitted, the project associated with the provider is used.
   *
   * @schema ProjectSinkSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Whether or not to create a unique identity associated with this sink. If false (the default), then the writer_identity used is serviceAccount:cloud-logs@system.gserviceaccount.com. If true, then a unique service account is created and used for this sink. If you wish to publish logs across projects or utilize bigquery_options, you must set unique_writer_identity to true.
   *
   * @schema ProjectSinkSpecForProvider#uniqueWriterIdentity
   */
  readonly uniqueWriterIdentity?: boolean;

}

/**
 * Converts an object of type 'ProjectSinkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecForProvider(obj: ProjectSinkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigqueryOptions': obj.bigqueryOptions?.map(y => toJson_ProjectSinkSpecForProviderBigqueryOptions(y)),
    'description': obj.description,
    'destination': obj.destination,
    'disabled': obj.disabled,
    'exclusions': obj.exclusions?.map(y => toJson_ProjectSinkSpecForProviderExclusions(y)),
    'filter': obj.filter,
    'project': obj.project,
    'uniqueWriterIdentity': obj.uniqueWriterIdentity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProjectSinkSpecInitProvider
 */
export interface ProjectSinkSpecInitProvider {
  /**
   * Options that affect sinks exporting data to BigQuery. Structure documented below.
   *
   * @schema ProjectSinkSpecInitProvider#bigqueryOptions
   */
  readonly bigqueryOptions?: ProjectSinkSpecInitProviderBigqueryOptions[];

  /**
   * A description of this sink. The maximum length of the description is 8000 characters.
   *
   * @schema ProjectSinkSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The destination of the sink (or, in other words, where logs are written to). Can be a Cloud Storage bucket, a PubSub topic, a BigQuery dataset or a Cloud Logging bucket . Examples:
   *
   * @schema ProjectSinkSpecInitProvider#destination
   */
  readonly destination?: string;

  /**
   * If set to True, then this sink is disabled and it does not export any log entries.
   *
   * @schema ProjectSinkSpecInitProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * Log entries that match any of the exclusion filters will not be exported. If a log entry is matched by both filter and one of exclusions.filter, it will not be exported.  Can be repeated multiple times for multiple exclusions. Structure is documented below.
   *
   * @schema ProjectSinkSpecInitProvider#exclusions
   */
  readonly exclusions?: ProjectSinkSpecInitProviderExclusions[];

  /**
   * The filter to apply when exporting logs. Only log entries that match the filter are exported. See Advanced Log Filters for information on how to write a filter.
   *
   * @schema ProjectSinkSpecInitProvider#filter
   */
  readonly filter?: string;

  /**
   * The ID of the project to create the sink in. If omitted, the project associated with the provider is used.
   *
   * @schema ProjectSinkSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * Whether or not to create a unique identity associated with this sink. If false (the default), then the writer_identity used is serviceAccount:cloud-logs@system.gserviceaccount.com. If true, then a unique service account is created and used for this sink. If you wish to publish logs across projects or utilize bigquery_options, you must set unique_writer_identity to true.
   *
   * @schema ProjectSinkSpecInitProvider#uniqueWriterIdentity
   */
  readonly uniqueWriterIdentity?: boolean;

}

/**
 * Converts an object of type 'ProjectSinkSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecInitProvider(obj: ProjectSinkSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bigqueryOptions': obj.bigqueryOptions?.map(y => toJson_ProjectSinkSpecInitProviderBigqueryOptions(y)),
    'description': obj.description,
    'destination': obj.destination,
    'disabled': obj.disabled,
    'exclusions': obj.exclusions?.map(y => toJson_ProjectSinkSpecInitProviderExclusions(y)),
    'filter': obj.filter,
    'project': obj.project,
    'uniqueWriterIdentity': obj.uniqueWriterIdentity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProjectSinkSpecManagementPolicies
 */
export enum ProjectSinkSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectSinkSpecProviderConfigRef
 */
export interface ProjectSinkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSinkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSinkSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectSinkSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectSinkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecProviderConfigRef(obj: ProjectSinkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSinkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectSinkSpecPublishConnectionDetailsTo
 */
export interface ProjectSinkSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectSinkSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectSinkSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectSinkSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectSinkSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectSinkSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectSinkSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecPublishConnectionDetailsTo(obj: ProjectSinkSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectSinkSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectSinkSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectSinkSpecWriteConnectionSecretToRef
 */
export interface ProjectSinkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectSinkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectSinkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectSinkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecWriteConnectionSecretToRef(obj: ProjectSinkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectSinkSpecForProviderBigqueryOptions
 */
export interface ProjectSinkSpecForProviderBigqueryOptions {
  /**
   * Whether to use BigQuery's partition tables. By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned tables the date suffix is no longer present and special query syntax has to be used instead. In both cases, tables are sharded based on UTC timezone.
   *
   * @schema ProjectSinkSpecForProviderBigqueryOptions#usePartitionedTables
   */
  readonly usePartitionedTables?: boolean;

}

/**
 * Converts an object of type 'ProjectSinkSpecForProviderBigqueryOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecForProviderBigqueryOptions(obj: ProjectSinkSpecForProviderBigqueryOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'usePartitionedTables': obj.usePartitionedTables,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectSinkSpecForProviderExclusions
 */
export interface ProjectSinkSpecForProviderExclusions {
  /**
   * A description of this exclusion.
   *
   * @schema ProjectSinkSpecForProviderExclusions#description
   */
  readonly description?: string;

  /**
   * If set to True, then this exclusion is disabled and it does not exclude any log entries.
   *
   * @schema ProjectSinkSpecForProviderExclusions#disabled
   */
  readonly disabled?: boolean;

  /**
   * An advanced logs filter that matches the log entries to be excluded. By using the sample function, you can exclude less than 100% of the matching log entries. See Advanced Log Filters for information on how to write a filter.
   *
   * @schema ProjectSinkSpecForProviderExclusions#filter
   */
  readonly filter?: string;

  /**
   * A client-assigned identifier, such as load-balancer-exclusion. Identifiers are limited to 100 characters and can include only letters, digits, underscores, hyphens, and periods. First character has to be alphanumeric.
   *
   * @schema ProjectSinkSpecForProviderExclusions#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectSinkSpecForProviderExclusions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecForProviderExclusions(obj: ProjectSinkSpecForProviderExclusions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'disabled': obj.disabled,
    'filter': obj.filter,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectSinkSpecInitProviderBigqueryOptions
 */
export interface ProjectSinkSpecInitProviderBigqueryOptions {
  /**
   * Whether to use BigQuery's partition tables. By default, Logging creates dated tables based on the log entries' timestamps, e.g. syslog_20170523. With partitioned tables the date suffix is no longer present and special query syntax has to be used instead. In both cases, tables are sharded based on UTC timezone.
   *
   * @schema ProjectSinkSpecInitProviderBigqueryOptions#usePartitionedTables
   */
  readonly usePartitionedTables?: boolean;

}

/**
 * Converts an object of type 'ProjectSinkSpecInitProviderBigqueryOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecInitProviderBigqueryOptions(obj: ProjectSinkSpecInitProviderBigqueryOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'usePartitionedTables': obj.usePartitionedTables,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectSinkSpecInitProviderExclusions
 */
export interface ProjectSinkSpecInitProviderExclusions {
  /**
   * A description of this exclusion.
   *
   * @schema ProjectSinkSpecInitProviderExclusions#description
   */
  readonly description?: string;

  /**
   * If set to True, then this exclusion is disabled and it does not exclude any log entries.
   *
   * @schema ProjectSinkSpecInitProviderExclusions#disabled
   */
  readonly disabled?: boolean;

  /**
   * An advanced logs filter that matches the log entries to be excluded. By using the sample function, you can exclude less than 100% of the matching log entries. See Advanced Log Filters for information on how to write a filter.
   *
   * @schema ProjectSinkSpecInitProviderExclusions#filter
   */
  readonly filter?: string;

  /**
   * A client-assigned identifier, such as load-balancer-exclusion. Identifiers are limited to 100 characters and can include only letters, digits, underscores, hyphens, and periods. First character has to be alphanumeric.
   *
   * @schema ProjectSinkSpecInitProviderExclusions#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectSinkSpecInitProviderExclusions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecInitProviderExclusions(obj: ProjectSinkSpecInitProviderExclusions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'disabled': obj.disabled,
    'filter': obj.filter,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectSinkSpecProviderConfigRefPolicy
 */
export interface ProjectSinkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSinkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectSinkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSinkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectSinkSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSinkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecProviderConfigRefPolicy(obj: ProjectSinkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectSinkSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectSinkSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSinkSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSinkSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectSinkSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecPublishConnectionDetailsToConfigRef(obj: ProjectSinkSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectSinkSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectSinkSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectSinkSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectSinkSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectSinkSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectSinkSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecPublishConnectionDetailsToMetadata(obj: ProjectSinkSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSinkSpecProviderConfigRefPolicyResolution
 */
export enum ProjectSinkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSinkSpecProviderConfigRefPolicyResolve
 */
export enum ProjectSinkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectSinkSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

