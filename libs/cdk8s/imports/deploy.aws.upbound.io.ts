// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * App is the Schema for the Apps API. Provides a CodeDeploy application.
 *
 * @schema App
 */
export class App extends ApiObject {
  /**
   * Returns the apiVersion and kind for "App"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'deploy.aws.upbound.io/v1beta1',
    kind: 'App',
  }

  /**
   * Renders a Kubernetes manifest for "App".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppProps): any {
    return {
      ...App.GVK,
      ...toJson_AppProps(props),
    };
  }

  /**
   * Defines a "App" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppProps) {
    super(scope, id, {
      ...App.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...App.GVK,
      ...toJson_AppProps(resolved),
    };
  }
}

/**
 * App is the Schema for the Apps API. Provides a CodeDeploy application.
 *
 * @schema App
 */
export interface AppProps {
  /**
   * @schema App#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppSpec defines the desired state of App
   *
   * @schema App#spec
   */
  readonly spec: AppSpec;

}

/**
 * Converts an object of type 'AppProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppProps(obj: AppProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppSpec defines the desired state of App
 *
 * @schema AppSpec
 */
export interface AppSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppSpec#deletionPolicy
   */
  readonly deletionPolicy?: AppSpecDeletionPolicy;

  /**
   * @schema AppSpec#forProvider
   */
  readonly forProvider: AppSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppSpec#managementPolicy
   */
  readonly managementPolicy?: AppSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppSpec#providerConfigRef
   */
  readonly providerConfigRef?: AppSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AppSpec#providerRef
   */
  readonly providerRef?: AppSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpec(obj: AppSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AppSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AppSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AppSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppSpecDeletionPolicy
 */
export enum AppSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppSpecForProvider
 */
export interface AppSpecForProvider {
  /**
   * The compute platform can either be ECS, Lambda, or Server. Default is Server.
   *
   * @default Server.
   * @schema AppSpecForProvider#computePlatform
   */
  readonly computePlatform?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AppSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AppSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AppSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecForProvider(obj: AppSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'computePlatform': obj.computePlatform,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppSpecManagementPolicy
 */
export enum AppSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppSpecProviderConfigRef
 */
export interface AppSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecProviderConfigRef#policy
   */
  readonly policy?: AppSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderConfigRef(obj: AppSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AppSpecProviderRef
 */
export interface AppSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecProviderRef#policy
   */
  readonly policy?: AppSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AppSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderRef(obj: AppSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppSpecPublishConnectionDetailsTo
 */
export interface AppSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsTo(obj: AppSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppSpecWriteConnectionSecretToRef
 */
export interface AppSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecWriteConnectionSecretToRef(obj: AppSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppSpecProviderConfigRefPolicy
 */
export interface AppSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderConfigRefPolicy(obj: AppSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppSpecProviderRefPolicy
 */
export interface AppSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AppSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AppSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecProviderRefPolicy(obj: AppSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRef
 */
export interface AppSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToConfigRef(obj: AppSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppSpecPublishConnectionDetailsToMetadata
 */
export interface AppSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToMetadata(obj: AppSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecProviderConfigRefPolicyResolution
 */
export enum AppSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecProviderConfigRefPolicyResolve
 */
export enum AppSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecProviderRefPolicyResolution
 */
export enum AppSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecProviderRefPolicyResolve
 */
export enum AppSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppSpecPublishConnectionDetailsToConfigRefPolicy(obj: AppSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DeploymentConfig is the Schema for the DeploymentConfigs API. Provides a CodeDeploy deployment config.
 *
 * @schema DeploymentConfig
 */
export class DeploymentConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DeploymentConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'deploy.aws.upbound.io/v1beta1',
    kind: 'DeploymentConfig',
  }

  /**
   * Renders a Kubernetes manifest for "DeploymentConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeploymentConfigProps): any {
    return {
      ...DeploymentConfig.GVK,
      ...toJson_DeploymentConfigProps(props),
    };
  }

  /**
   * Defines a "DeploymentConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeploymentConfigProps) {
    super(scope, id, {
      ...DeploymentConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DeploymentConfig.GVK,
      ...toJson_DeploymentConfigProps(resolved),
    };
  }
}

/**
 * DeploymentConfig is the Schema for the DeploymentConfigs API. Provides a CodeDeploy deployment config.
 *
 * @schema DeploymentConfig
 */
export interface DeploymentConfigProps {
  /**
   * @schema DeploymentConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeploymentConfigSpec defines the desired state of DeploymentConfig
   *
   * @schema DeploymentConfig#spec
   */
  readonly spec: DeploymentConfigSpec;

}

/**
 * Converts an object of type 'DeploymentConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigProps(obj: DeploymentConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeploymentConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentConfigSpec defines the desired state of DeploymentConfig
 *
 * @schema DeploymentConfigSpec
 */
export interface DeploymentConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeploymentConfigSpecDeletionPolicy;

  /**
   * @schema DeploymentConfigSpec#forProvider
   */
  readonly forProvider: DeploymentConfigSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentConfigSpec#managementPolicy
   */
  readonly managementPolicy?: DeploymentConfigSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeploymentConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeploymentConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DeploymentConfigSpec#providerRef
   */
  readonly providerRef?: DeploymentConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeploymentConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeploymentConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeploymentConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeploymentConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeploymentConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpec(obj: DeploymentConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeploymentConfigSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DeploymentConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DeploymentConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DeploymentConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeploymentConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentConfigSpecDeletionPolicy
 */
export enum DeploymentConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeploymentConfigSpecForProvider
 */
export interface DeploymentConfigSpecForProvider {
  /**
   * The compute platform can be Server, Lambda, or ECS. Default is Server.
   *
   * @default Server.
   * @schema DeploymentConfigSpecForProvider#computePlatform
   */
  readonly computePlatform?: string;

  /**
   * A minimum_healthy_hosts block. Required for Server compute platform. Minimum Healthy Hosts are documented below.
   *
   * @schema DeploymentConfigSpecForProvider#minimumHealthyHosts
   */
  readonly minimumHealthyHosts?: DeploymentConfigSpecForProviderMinimumHealthyHosts[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DeploymentConfigSpecForProvider#region
   */
  readonly region: string;

  /**
   * A traffic_routing_config block. Traffic Routing Config is documented below.
   *
   * @schema DeploymentConfigSpecForProvider#trafficRoutingConfig
   */
  readonly trafficRoutingConfig?: DeploymentConfigSpecForProviderTrafficRoutingConfig[];

}

/**
 * Converts an object of type 'DeploymentConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecForProvider(obj: DeploymentConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'computePlatform': obj.computePlatform,
    'minimumHealthyHosts': obj.minimumHealthyHosts?.map(y => toJson_DeploymentConfigSpecForProviderMinimumHealthyHosts(y)),
    'region': obj.region,
    'trafficRoutingConfig': obj.trafficRoutingConfig?.map(y => toJson_DeploymentConfigSpecForProviderTrafficRoutingConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentConfigSpecManagementPolicy
 */
export enum DeploymentConfigSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeploymentConfigSpecProviderConfigRef
 */
export interface DeploymentConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentConfigSpecProviderConfigRef#policy
   */
  readonly policy?: DeploymentConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecProviderConfigRef(obj: DeploymentConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DeploymentConfigSpecProviderRef
 */
export interface DeploymentConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentConfigSpecProviderRef#policy
   */
  readonly policy?: DeploymentConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DeploymentConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecProviderRef(obj: DeploymentConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeploymentConfigSpecPublishConnectionDetailsTo
 */
export interface DeploymentConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeploymentConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeploymentConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeploymentConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeploymentConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeploymentConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeploymentConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecPublishConnectionDetailsTo(obj: DeploymentConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeploymentConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeploymentConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeploymentConfigSpecWriteConnectionSecretToRef
 */
export interface DeploymentConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeploymentConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeploymentConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeploymentConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecWriteConnectionSecretToRef(obj: DeploymentConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentConfigSpecForProviderMinimumHealthyHosts
 */
export interface DeploymentConfigSpecForProviderMinimumHealthyHosts {
  /**
   * The type can either be FLEET_PERCENT or HOST_COUNT.
   *
   * @schema DeploymentConfigSpecForProviderMinimumHealthyHosts#type
   */
  readonly type?: string;

  /**
   * The value when the type is FLEET_PERCENT represents the minimum number of healthy instances as a percentage of the total number of instances in the deployment. If you specify FLEET_PERCENT, at the start of the deployment, AWS CodeDeploy converts the percentage to the equivalent number of instance and rounds up fractional instances. When the type is HOST_COUNT, the value represents the minimum number of healthy instances as an absolute value.
   *
   * @schema DeploymentConfigSpecForProviderMinimumHealthyHosts#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'DeploymentConfigSpecForProviderMinimumHealthyHosts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecForProviderMinimumHealthyHosts(obj: DeploymentConfigSpecForProviderMinimumHealthyHosts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentConfigSpecForProviderTrafficRoutingConfig
 */
export interface DeploymentConfigSpecForProviderTrafficRoutingConfig {
  /**
   * The time based canary configuration information. If type is TimeBasedLinear, use time_based_linear instead.
   *
   * @schema DeploymentConfigSpecForProviderTrafficRoutingConfig#timeBasedCanary
   */
  readonly timeBasedCanary?: DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedCanary[];

  /**
   * The time based linear configuration information. If type is TimeBasedCanary, use time_based_canary instead.
   *
   * @schema DeploymentConfigSpecForProviderTrafficRoutingConfig#timeBasedLinear
   */
  readonly timeBasedLinear?: DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedLinear[];

  /**
   * Type of traffic routing config. One of TimeBasedCanary, TimeBasedLinear, AllAtOnce.
   *
   * @schema DeploymentConfigSpecForProviderTrafficRoutingConfig#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeploymentConfigSpecForProviderTrafficRoutingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecForProviderTrafficRoutingConfig(obj: DeploymentConfigSpecForProviderTrafficRoutingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeBasedCanary': obj.timeBasedCanary?.map(y => toJson_DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedCanary(y)),
    'timeBasedLinear': obj.timeBasedLinear?.map(y => toJson_DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedLinear(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentConfigSpecProviderConfigRefPolicy
 */
export interface DeploymentConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecProviderConfigRefPolicy(obj: DeploymentConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentConfigSpecProviderRefPolicy
 */
export interface DeploymentConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DeploymentConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DeploymentConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecProviderRefPolicy(obj: DeploymentConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeploymentConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface DeploymentConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecPublishConnectionDetailsToConfigRef(obj: DeploymentConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeploymentConfigSpecPublishConnectionDetailsToMetadata
 */
export interface DeploymentConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeploymentConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeploymentConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecPublishConnectionDetailsToMetadata(obj: DeploymentConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedCanary
 */
export interface DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedCanary {
  /**
   * The number of minutes between the first and second traffic shifts of a TimeBasedCanary deployment.
   *
   * @schema DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedCanary#interval
   */
  readonly interval?: number;

  /**
   * The percentage of traffic to shift in the first increment of a TimeBasedCanary deployment.
   *
   * @schema DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedCanary#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedCanary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedCanary(obj: DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedCanary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedLinear
 */
export interface DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedLinear {
  /**
   * The number of minutes between the first and second traffic shifts of a TimeBasedCanary deployment.
   *
   * @schema DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedLinear#interval
   */
  readonly interval?: number;

  /**
   * The percentage of traffic to shift in the first increment of a TimeBasedCanary deployment.
   *
   * @schema DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedLinear#percentage
   */
  readonly percentage?: number;

}

/**
 * Converts an object of type 'DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedLinear' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedLinear(obj: DeploymentConfigSpecForProviderTrafficRoutingConfigTimeBasedLinear | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'percentage': obj.percentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentConfigSpecProviderConfigRefPolicyResolution
 */
export enum DeploymentConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentConfigSpecProviderConfigRefPolicyResolve
 */
export enum DeploymentConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentConfigSpecProviderRefPolicyResolution
 */
export enum DeploymentConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentConfigSpecProviderRefPolicyResolve
 */
export enum DeploymentConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeploymentConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DeploymentGroup is the Schema for the DeploymentGroups API. Provides a CodeDeploy deployment group.
 *
 * @schema DeploymentGroup
 */
export class DeploymentGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DeploymentGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'deploy.aws.upbound.io/v1beta1',
    kind: 'DeploymentGroup',
  }

  /**
   * Renders a Kubernetes manifest for "DeploymentGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeploymentGroupProps): any {
    return {
      ...DeploymentGroup.GVK,
      ...toJson_DeploymentGroupProps(props),
    };
  }

  /**
   * Defines a "DeploymentGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeploymentGroupProps) {
    super(scope, id, {
      ...DeploymentGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DeploymentGroup.GVK,
      ...toJson_DeploymentGroupProps(resolved),
    };
  }
}

/**
 * DeploymentGroup is the Schema for the DeploymentGroups API. Provides a CodeDeploy deployment group.
 *
 * @schema DeploymentGroup
 */
export interface DeploymentGroupProps {
  /**
   * @schema DeploymentGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeploymentGroupSpec defines the desired state of DeploymentGroup
   *
   * @schema DeploymentGroup#spec
   */
  readonly spec: DeploymentGroupSpec;

}

/**
 * Converts an object of type 'DeploymentGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupProps(obj: DeploymentGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeploymentGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeploymentGroupSpec defines the desired state of DeploymentGroup
 *
 * @schema DeploymentGroupSpec
 */
export interface DeploymentGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeploymentGroupSpecDeletionPolicy;

  /**
   * @schema DeploymentGroupSpec#forProvider
   */
  readonly forProvider: DeploymentGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeploymentGroupSpec#managementPolicy
   */
  readonly managementPolicy?: DeploymentGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeploymentGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeploymentGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DeploymentGroupSpec#providerRef
   */
  readonly providerRef?: DeploymentGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeploymentGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeploymentGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeploymentGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeploymentGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeploymentGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpec(obj: DeploymentGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeploymentGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DeploymentGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DeploymentGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DeploymentGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeploymentGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentGroupSpecDeletionPolicy
 */
export enum DeploymentGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeploymentGroupSpecForProvider
 */
export interface DeploymentGroupSpecForProvider {
  /**
   * Configuration block of alarms associated with the deployment group (documented below).
   *
   * @schema DeploymentGroupSpecForProvider#alarmConfiguration
   */
  readonly alarmConfiguration?: DeploymentGroupSpecForProviderAlarmConfiguration[];

  /**
   * The name of the application.
   *
   * @schema DeploymentGroupSpecForProvider#appName
   */
  readonly appName?: string;

  /**
   * Reference to a App in deploy to populate appName.
   *
   * @schema DeploymentGroupSpecForProvider#appNameRef
   */
  readonly appNameRef?: DeploymentGroupSpecForProviderAppNameRef;

  /**
   * Selector for a App in deploy to populate appName.
   *
   * @schema DeploymentGroupSpecForProvider#appNameSelector
   */
  readonly appNameSelector?: DeploymentGroupSpecForProviderAppNameSelector;

  /**
   * Configuration block of the automatic rollback configuration associated with the deployment group (documented below).
   *
   * @schema DeploymentGroupSpecForProvider#autoRollbackConfiguration
   */
  readonly autoRollbackConfiguration?: DeploymentGroupSpecForProviderAutoRollbackConfiguration[];

  /**
   * Autoscaling groups associated with the deployment group.
   *
   * @schema DeploymentGroupSpecForProvider#autoscalingGroups
   */
  readonly autoscalingGroups?: string[];

  /**
   * Configuration block of the blue/green deployment options for a deployment group (documented below).
   *
   * @schema DeploymentGroupSpecForProvider#blueGreenDeploymentConfig
   */
  readonly blueGreenDeploymentConfig?: DeploymentGroupSpecForProviderBlueGreenDeploymentConfig[];

  /**
   * The name of the group's deployment config. The default is "CodeDeployDefault.OneAtATime".
   *
   * @schema DeploymentGroupSpecForProvider#deploymentConfigName
   */
  readonly deploymentConfigName?: string;

  /**
   * Configuration block of the type of deployment, either in-place or blue/green, you want to run and whether to route deployment traffic behind a load balancer (documented below).
   *
   * @schema DeploymentGroupSpecForProvider#deploymentStyle
   */
  readonly deploymentStyle?: DeploymentGroupSpecForProviderDeploymentStyle[];

  /**
   * Tag filters associated with the deployment group. See the AWS docs for details.
   *
   * @schema DeploymentGroupSpecForProvider#ec2TagFilter
   */
  readonly ec2TagFilter?: DeploymentGroupSpecForProviderEc2TagFilter[];

  /**
   * Configuration block(s) of Tag filters associated with the deployment group, which are also referred to as tag groups (documented below). See the AWS docs for details.
   *
   * @schema DeploymentGroupSpecForProvider#ec2TagSet
   */
  readonly ec2TagSet?: DeploymentGroupSpecForProviderEc2TagSet[];

  /**
   * Configuration block(s) of the ECS services for a deployment group (documented below).
   *
   * @schema DeploymentGroupSpecForProvider#ecsService
   */
  readonly ecsService?: DeploymentGroupSpecForProviderEcsService[];

  /**
   * Single configuration block of the load balancer to use in a blue/green deployment (documented below).
   *
   * @schema DeploymentGroupSpecForProvider#loadBalancerInfo
   */
  readonly loadBalancerInfo?: DeploymentGroupSpecForProviderLoadBalancerInfo[];

  /**
   * On premise tag filters associated with the group. See the AWS docs for details.
   *
   * @schema DeploymentGroupSpecForProvider#onPremisesInstanceTagFilter
   */
  readonly onPremisesInstanceTagFilter?: DeploymentGroupSpecForProviderOnPremisesInstanceTagFilter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DeploymentGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * The service role ARN that allows deployments.
   *
   * @schema DeploymentGroupSpecForProvider#serviceRoleArn
   */
  readonly serviceRoleArn?: string;

  /**
   * Reference to a Role in iam to populate serviceRoleArn.
   *
   * @schema DeploymentGroupSpecForProvider#serviceRoleArnRef
   */
  readonly serviceRoleArnRef?: DeploymentGroupSpecForProviderServiceRoleArnRef;

  /**
   * Selector for a Role in iam to populate serviceRoleArn.
   *
   * @schema DeploymentGroupSpecForProvider#serviceRoleArnSelector
   */
  readonly serviceRoleArnSelector?: DeploymentGroupSpecForProviderServiceRoleArnSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema DeploymentGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block(s) of the triggers for the deployment group (documented below).
   *
   * @schema DeploymentGroupSpecForProvider#triggerConfiguration
   */
  readonly triggerConfiguration?: DeploymentGroupSpecForProviderTriggerConfiguration[];

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProvider(obj: DeploymentGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarmConfiguration': obj.alarmConfiguration?.map(y => toJson_DeploymentGroupSpecForProviderAlarmConfiguration(y)),
    'appName': obj.appName,
    'appNameRef': toJson_DeploymentGroupSpecForProviderAppNameRef(obj.appNameRef),
    'appNameSelector': toJson_DeploymentGroupSpecForProviderAppNameSelector(obj.appNameSelector),
    'autoRollbackConfiguration': obj.autoRollbackConfiguration?.map(y => toJson_DeploymentGroupSpecForProviderAutoRollbackConfiguration(y)),
    'autoscalingGroups': obj.autoscalingGroups?.map(y => y),
    'blueGreenDeploymentConfig': obj.blueGreenDeploymentConfig?.map(y => toJson_DeploymentGroupSpecForProviderBlueGreenDeploymentConfig(y)),
    'deploymentConfigName': obj.deploymentConfigName,
    'deploymentStyle': obj.deploymentStyle?.map(y => toJson_DeploymentGroupSpecForProviderDeploymentStyle(y)),
    'ec2TagFilter': obj.ec2TagFilter?.map(y => toJson_DeploymentGroupSpecForProviderEc2TagFilter(y)),
    'ec2TagSet': obj.ec2TagSet?.map(y => toJson_DeploymentGroupSpecForProviderEc2TagSet(y)),
    'ecsService': obj.ecsService?.map(y => toJson_DeploymentGroupSpecForProviderEcsService(y)),
    'loadBalancerInfo': obj.loadBalancerInfo?.map(y => toJson_DeploymentGroupSpecForProviderLoadBalancerInfo(y)),
    'onPremisesInstanceTagFilter': obj.onPremisesInstanceTagFilter?.map(y => toJson_DeploymentGroupSpecForProviderOnPremisesInstanceTagFilter(y)),
    'region': obj.region,
    'serviceRoleArn': obj.serviceRoleArn,
    'serviceRoleArnRef': toJson_DeploymentGroupSpecForProviderServiceRoleArnRef(obj.serviceRoleArnRef),
    'serviceRoleArnSelector': toJson_DeploymentGroupSpecForProviderServiceRoleArnSelector(obj.serviceRoleArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'triggerConfiguration': obj.triggerConfiguration?.map(y => toJson_DeploymentGroupSpecForProviderTriggerConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeploymentGroupSpecManagementPolicy
 */
export enum DeploymentGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeploymentGroupSpecProviderConfigRef
 */
export interface DeploymentGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentGroupSpecProviderConfigRef#policy
   */
  readonly policy?: DeploymentGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecProviderConfigRef(obj: DeploymentGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DeploymentGroupSpecProviderRef
 */
export interface DeploymentGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentGroupSpecProviderRef#policy
   */
  readonly policy?: DeploymentGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecProviderRef(obj: DeploymentGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeploymentGroupSpecPublishConnectionDetailsTo
 */
export interface DeploymentGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeploymentGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeploymentGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeploymentGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeploymentGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeploymentGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeploymentGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecPublishConnectionDetailsTo(obj: DeploymentGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeploymentGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeploymentGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeploymentGroupSpecWriteConnectionSecretToRef
 */
export interface DeploymentGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeploymentGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeploymentGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeploymentGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecWriteConnectionSecretToRef(obj: DeploymentGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderAlarmConfiguration
 */
export interface DeploymentGroupSpecForProviderAlarmConfiguration {
  /**
   * A list of alarms configured for the deployment group. A maximum of 10 alarms can be added to a deployment group.
   *
   * @schema DeploymentGroupSpecForProviderAlarmConfiguration#alarms
   */
  readonly alarms?: string[];

  /**
   * Indicates whether the alarm configuration is enabled. This option is useful when you want to temporarily deactivate alarm monitoring for a deployment group without having to add the same alarms again later.
   *
   * @schema DeploymentGroupSpecForProviderAlarmConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * Indicates whether a deployment should continue if information about the current state of alarms cannot be retrieved from CloudWatch. The default value is false.
   *
   * @schema DeploymentGroupSpecForProviderAlarmConfiguration#ignorePollAlarmFailure
   */
  readonly ignorePollAlarmFailure?: boolean;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderAlarmConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderAlarmConfiguration(obj: DeploymentGroupSpecForProviderAlarmConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => y),
    'enabled': obj.enabled,
    'ignorePollAlarmFailure': obj.ignorePollAlarmFailure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a App in deploy to populate appName.
 *
 * @schema DeploymentGroupSpecForProviderAppNameRef
 */
export interface DeploymentGroupSpecForProviderAppNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentGroupSpecForProviderAppNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentGroupSpecForProviderAppNameRef#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderAppNameRefPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderAppNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderAppNameRef(obj: DeploymentGroupSpecForProviderAppNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentGroupSpecForProviderAppNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a App in deploy to populate appName.
 *
 * @schema DeploymentGroupSpecForProviderAppNameSelector
 */
export interface DeploymentGroupSpecForProviderAppNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentGroupSpecForProviderAppNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentGroupSpecForProviderAppNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentGroupSpecForProviderAppNameSelector#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderAppNameSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderAppNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderAppNameSelector(obj: DeploymentGroupSpecForProviderAppNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentGroupSpecForProviderAppNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderAutoRollbackConfiguration
 */
export interface DeploymentGroupSpecForProviderAutoRollbackConfiguration {
  /**
   * Indicates whether the alarm configuration is enabled. This option is useful when you want to temporarily deactivate alarm monitoring for a deployment group without having to add the same alarms again later.
   *
   * @schema DeploymentGroupSpecForProviderAutoRollbackConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * The event type or types that trigger a rollback. Supported types are DEPLOYMENT_FAILURE and DEPLOYMENT_STOP_ON_ALARM.
   *
   * @schema DeploymentGroupSpecForProviderAutoRollbackConfiguration#events
   */
  readonly events?: string[];

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderAutoRollbackConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderAutoRollbackConfiguration(obj: DeploymentGroupSpecForProviderAutoRollbackConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'events': obj.events?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfig
 */
export interface DeploymentGroupSpecForProviderBlueGreenDeploymentConfig {
  /**
   * Information about the action to take when newly provisioned instances are ready to receive traffic in a blue/green deployment (documented below).
   *
   * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfig#deploymentReadyOption
   */
  readonly deploymentReadyOption?: DeploymentGroupSpecForProviderBlueGreenDeploymentConfigDeploymentReadyOption[];

  /**
   * Information about how instances are provisioned for a replacement environment in a blue/green deployment (documented below).
   *
   * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfig#greenFleetProvisioningOption
   */
  readonly greenFleetProvisioningOption?: DeploymentGroupSpecForProviderBlueGreenDeploymentConfigGreenFleetProvisioningOption[];

  /**
   * Information about whether to terminate instances in the original fleet during a blue/green deployment (documented below).
   *
   * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfig#terminateBlueInstancesOnDeploymentSuccess
   */
  readonly terminateBlueInstancesOnDeploymentSuccess?: DeploymentGroupSpecForProviderBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess[];

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderBlueGreenDeploymentConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderBlueGreenDeploymentConfig(obj: DeploymentGroupSpecForProviderBlueGreenDeploymentConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deploymentReadyOption': obj.deploymentReadyOption?.map(y => toJson_DeploymentGroupSpecForProviderBlueGreenDeploymentConfigDeploymentReadyOption(y)),
    'greenFleetProvisioningOption': obj.greenFleetProvisioningOption?.map(y => toJson_DeploymentGroupSpecForProviderBlueGreenDeploymentConfigGreenFleetProvisioningOption(y)),
    'terminateBlueInstancesOnDeploymentSuccess': obj.terminateBlueInstancesOnDeploymentSuccess?.map(y => toJson_DeploymentGroupSpecForProviderBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderDeploymentStyle
 */
export interface DeploymentGroupSpecForProviderDeploymentStyle {
  /**
   * Indicates whether to route deployment traffic behind a load balancer. Valid Values are WITH_TRAFFIC_CONTROL or WITHOUT_TRAFFIC_CONTROL. Default is WITHOUT_TRAFFIC_CONTROL.
   *
   * @default WITHOUT_TRAFFIC_CONTROL.
   * @schema DeploymentGroupSpecForProviderDeploymentStyle#deploymentOption
   */
  readonly deploymentOption?: string;

  /**
   * Indicates whether to run an in-place deployment or a blue/green deployment. Valid Values are IN_PLACE or BLUE_GREEN. Default is IN_PLACE.
   *
   * @default IN_PLACE.
   * @schema DeploymentGroupSpecForProviderDeploymentStyle#deploymentType
   */
  readonly deploymentType?: string;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderDeploymentStyle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderDeploymentStyle(obj: DeploymentGroupSpecForProviderDeploymentStyle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deploymentOption': obj.deploymentOption,
    'deploymentType': obj.deploymentType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderEc2TagFilter
 */
export interface DeploymentGroupSpecForProviderEc2TagFilter {
  /**
   * The key of the tag filter.
   *
   * @schema DeploymentGroupSpecForProviderEc2TagFilter#key
   */
  readonly key?: string;

  /**
   * The type of the tag filter, either KEY_ONLY, VALUE_ONLY, or KEY_AND_VALUE.
   *
   * @schema DeploymentGroupSpecForProviderEc2TagFilter#type
   */
  readonly type?: string;

  /**
   * The value of the tag filter.
   *
   * @schema DeploymentGroupSpecForProviderEc2TagFilter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEc2TagFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEc2TagFilter(obj: DeploymentGroupSpecForProviderEc2TagFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderEc2TagSet
 */
export interface DeploymentGroupSpecForProviderEc2TagSet {
  /**
   * Tag filters associated with the deployment group. See the AWS docs for details.
   *
   * @schema DeploymentGroupSpecForProviderEc2TagSet#ec2TagFilter
   */
  readonly ec2TagFilter?: DeploymentGroupSpecForProviderEc2TagSetEc2TagFilter[];

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEc2TagSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEc2TagSet(obj: DeploymentGroupSpecForProviderEc2TagSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ec2TagFilter': obj.ec2TagFilter?.map(y => toJson_DeploymentGroupSpecForProviderEc2TagSetEc2TagFilter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderEcsService
 */
export interface DeploymentGroupSpecForProviderEcsService {
  /**
   * The name of the ECS cluster.
   *
   * @schema DeploymentGroupSpecForProviderEcsService#clusterName
   */
  readonly clusterName?: string;

  /**
   * Reference to a Cluster in ecs to populate clusterName.
   *
   * @schema DeploymentGroupSpecForProviderEcsService#clusterNameRef
   */
  readonly clusterNameRef?: DeploymentGroupSpecForProviderEcsServiceClusterNameRef;

  /**
   * Selector for a Cluster in ecs to populate clusterName.
   *
   * @schema DeploymentGroupSpecForProviderEcsService#clusterNameSelector
   */
  readonly clusterNameSelector?: DeploymentGroupSpecForProviderEcsServiceClusterNameSelector;

  /**
   * The name of the ECS service.
   *
   * @schema DeploymentGroupSpecForProviderEcsService#serviceName
   */
  readonly serviceName?: string;

  /**
   * Reference to a Service in ecs to populate serviceName.
   *
   * @schema DeploymentGroupSpecForProviderEcsService#serviceNameRef
   */
  readonly serviceNameRef?: DeploymentGroupSpecForProviderEcsServiceServiceNameRef;

  /**
   * Selector for a Service in ecs to populate serviceName.
   *
   * @schema DeploymentGroupSpecForProviderEcsService#serviceNameSelector
   */
  readonly serviceNameSelector?: DeploymentGroupSpecForProviderEcsServiceServiceNameSelector;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEcsService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEcsService(obj: DeploymentGroupSpecForProviderEcsService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_DeploymentGroupSpecForProviderEcsServiceClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_DeploymentGroupSpecForProviderEcsServiceClusterNameSelector(obj.clusterNameSelector),
    'serviceName': obj.serviceName,
    'serviceNameRef': toJson_DeploymentGroupSpecForProviderEcsServiceServiceNameRef(obj.serviceNameRef),
    'serviceNameSelector': toJson_DeploymentGroupSpecForProviderEcsServiceServiceNameSelector(obj.serviceNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfo
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfo {
  /**
   * The Classic Elastic Load Balancer to use in a deployment. Conflicts with target_group_info and target_group_pair_info.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfo#elbInfo
   */
  readonly elbInfo?: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfo[];

  /**
   * The (Application/Network Load Balancer) target group to use in a deployment. Conflicts with elb_info and target_group_pair_info.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfo#targetGroupInfo
   */
  readonly targetGroupInfo?: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupInfo[];

  /**
   * The (Application/Network Load Balancer) target group pair to use in a deployment. Conflicts with elb_info and target_group_info.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfo#targetGroupPairInfo
   */
  readonly targetGroupPairInfo?: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfo[];

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfo(obj: DeploymentGroupSpecForProviderLoadBalancerInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'elbInfo': obj.elbInfo?.map(y => toJson_DeploymentGroupSpecForProviderLoadBalancerInfoElbInfo(y)),
    'targetGroupInfo': obj.targetGroupInfo?.map(y => toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupInfo(y)),
    'targetGroupPairInfo': obj.targetGroupPairInfo?.map(y => toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfo(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderOnPremisesInstanceTagFilter
 */
export interface DeploymentGroupSpecForProviderOnPremisesInstanceTagFilter {
  /**
   * The key of the tag filter.
   *
   * @schema DeploymentGroupSpecForProviderOnPremisesInstanceTagFilter#key
   */
  readonly key?: string;

  /**
   * The type of the tag filter, either KEY_ONLY, VALUE_ONLY, or KEY_AND_VALUE.
   *
   * @schema DeploymentGroupSpecForProviderOnPremisesInstanceTagFilter#type
   */
  readonly type?: string;

  /**
   * The value of the tag filter.
   *
   * @schema DeploymentGroupSpecForProviderOnPremisesInstanceTagFilter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderOnPremisesInstanceTagFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderOnPremisesInstanceTagFilter(obj: DeploymentGroupSpecForProviderOnPremisesInstanceTagFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate serviceRoleArn.
 *
 * @schema DeploymentGroupSpecForProviderServiceRoleArnRef
 */
export interface DeploymentGroupSpecForProviderServiceRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentGroupSpecForProviderServiceRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentGroupSpecForProviderServiceRoleArnRef#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderServiceRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderServiceRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderServiceRoleArnRef(obj: DeploymentGroupSpecForProviderServiceRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentGroupSpecForProviderServiceRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate serviceRoleArn.
 *
 * @schema DeploymentGroupSpecForProviderServiceRoleArnSelector
 */
export interface DeploymentGroupSpecForProviderServiceRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentGroupSpecForProviderServiceRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentGroupSpecForProviderServiceRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentGroupSpecForProviderServiceRoleArnSelector#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderServiceRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderServiceRoleArnSelector(obj: DeploymentGroupSpecForProviderServiceRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderTriggerConfiguration
 */
export interface DeploymentGroupSpecForProviderTriggerConfiguration {
  /**
   * The event type or types for which notifications are triggered. Some values that are supported: DeploymentStart, DeploymentSuccess, DeploymentFailure, DeploymentStop, DeploymentRollback, InstanceStart, InstanceSuccess, InstanceFailure.  See the CodeDeploy documentation for all possible values.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfiguration#triggerEvents
   */
  readonly triggerEvents: string[];

  /**
   * The name of the notification trigger.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfiguration#triggerName
   */
  readonly triggerName: string;

  /**
   * The ARN of the SNS topic through which notifications are sent.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfiguration#triggerTargetArn
   */
  readonly triggerTargetArn?: string;

  /**
   * Reference to a Topic in sns to populate triggerTargetArn.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfiguration#triggerTargetArnRef
   */
  readonly triggerTargetArnRef?: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRef;

  /**
   * Selector for a Topic in sns to populate triggerTargetArn.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfiguration#triggerTargetArnSelector
   */
  readonly triggerTargetArnSelector?: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelector;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderTriggerConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderTriggerConfiguration(obj: DeploymentGroupSpecForProviderTriggerConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'triggerEvents': obj.triggerEvents?.map(y => y),
    'triggerName': obj.triggerName,
    'triggerTargetArn': obj.triggerTargetArn,
    'triggerTargetArnRef': toJson_DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRef(obj.triggerTargetArnRef),
    'triggerTargetArnSelector': toJson_DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelector(obj.triggerTargetArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentGroupSpecProviderConfigRefPolicy
 */
export interface DeploymentGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecProviderConfigRefPolicy(obj: DeploymentGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentGroupSpecProviderRefPolicy
 */
export interface DeploymentGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecProviderRefPolicy(obj: DeploymentGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeploymentGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface DeploymentGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecPublishConnectionDetailsToConfigRef(obj: DeploymentGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeploymentGroupSpecPublishConnectionDetailsToMetadata
 */
export interface DeploymentGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeploymentGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeploymentGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeploymentGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecPublishConnectionDetailsToMetadata(obj: DeploymentGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentGroupSpecForProviderAppNameRefPolicy
 */
export interface DeploymentGroupSpecForProviderAppNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderAppNameRefPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderAppNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderAppNameRefPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderAppNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderAppNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderAppNameRefPolicy(obj: DeploymentGroupSpecForProviderAppNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentGroupSpecForProviderAppNameSelectorPolicy
 */
export interface DeploymentGroupSpecForProviderAppNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderAppNameSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderAppNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderAppNameSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderAppNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderAppNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderAppNameSelectorPolicy(obj: DeploymentGroupSpecForProviderAppNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfigDeploymentReadyOption
 */
export interface DeploymentGroupSpecForProviderBlueGreenDeploymentConfigDeploymentReadyOption {
  /**
   * When to reroute traffic from an original environment to a replacement environment in a blue/green deployment.
   *
   * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfigDeploymentReadyOption#actionOnTimeout
   */
  readonly actionOnTimeout?: string;

  /**
   * The number of minutes to wait before the status of a blue/green deployment changed to Stopped if rerouting is not started manually. Applies only to the STOP_DEPLOYMENT option for action_on_timeout.
   *
   * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfigDeploymentReadyOption#waitTimeInMinutes
   */
  readonly waitTimeInMinutes?: number;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderBlueGreenDeploymentConfigDeploymentReadyOption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderBlueGreenDeploymentConfigDeploymentReadyOption(obj: DeploymentGroupSpecForProviderBlueGreenDeploymentConfigDeploymentReadyOption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actionOnTimeout': obj.actionOnTimeout,
    'waitTimeInMinutes': obj.waitTimeInMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfigGreenFleetProvisioningOption
 */
export interface DeploymentGroupSpecForProviderBlueGreenDeploymentConfigGreenFleetProvisioningOption {
  /**
   * The method used to add instances to a replacement environment.
   *
   * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfigGreenFleetProvisioningOption#action
   */
  readonly action?: string;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderBlueGreenDeploymentConfigGreenFleetProvisioningOption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderBlueGreenDeploymentConfigGreenFleetProvisioningOption(obj: DeploymentGroupSpecForProviderBlueGreenDeploymentConfigGreenFleetProvisioningOption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess
 */
export interface DeploymentGroupSpecForProviderBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess {
  /**
   * The method used to add instances to a replacement environment.
   *
   * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess#action
   */
  readonly action?: string;

  /**
   * The number of minutes to wait after a successful blue/green deployment before terminating instances from the original environment.
   *
   * @schema DeploymentGroupSpecForProviderBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess#terminationWaitTimeInMinutes
   */
  readonly terminationWaitTimeInMinutes?: number;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess(obj: DeploymentGroupSpecForProviderBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'terminationWaitTimeInMinutes': obj.terminationWaitTimeInMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderEc2TagSetEc2TagFilter
 */
export interface DeploymentGroupSpecForProviderEc2TagSetEc2TagFilter {
  /**
   * The key of the tag filter.
   *
   * @schema DeploymentGroupSpecForProviderEc2TagSetEc2TagFilter#key
   */
  readonly key?: string;

  /**
   * The type of the tag filter, either KEY_ONLY, VALUE_ONLY, or KEY_AND_VALUE.
   *
   * @schema DeploymentGroupSpecForProviderEc2TagSetEc2TagFilter#type
   */
  readonly type?: string;

  /**
   * The value of the tag filter.
   *
   * @schema DeploymentGroupSpecForProviderEc2TagSetEc2TagFilter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEc2TagSetEc2TagFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEc2TagSetEc2TagFilter(obj: DeploymentGroupSpecForProviderEc2TagSetEc2TagFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in ecs to populate clusterName.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameRef
 */
export interface DeploymentGroupSpecForProviderEcsServiceClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameRef#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEcsServiceClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEcsServiceClusterNameRef(obj: DeploymentGroupSpecForProviderEcsServiceClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in ecs to populate clusterName.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameSelector
 */
export interface DeploymentGroupSpecForProviderEcsServiceClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameSelector#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEcsServiceClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEcsServiceClusterNameSelector(obj: DeploymentGroupSpecForProviderEcsServiceClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Service in ecs to populate serviceName.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameRef
 */
export interface DeploymentGroupSpecForProviderEcsServiceServiceNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameRef#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEcsServiceServiceNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEcsServiceServiceNameRef(obj: DeploymentGroupSpecForProviderEcsServiceServiceNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Service in ecs to populate serviceName.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameSelector
 */
export interface DeploymentGroupSpecForProviderEcsServiceServiceNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameSelector#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEcsServiceServiceNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEcsServiceServiceNameSelector(obj: DeploymentGroupSpecForProviderEcsServiceServiceNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfo
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoElbInfo {
  /**
   * The name of the target group that instances in the original environment are deregistered from, and instances in the replacement environment registered with. For in-place deployments, the name of the target group that instances are deregistered from, so they are not serving traffic during a deployment, and then re-registered with after the deployment completes.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfo#name
   */
  readonly name?: string;

  /**
   * Reference to a ELB in elb to populate name.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfo#nameRef
   */
  readonly nameRef?: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRef;

  /**
   * Selector for a ELB in elb to populate name.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfo#nameSelector
   */
  readonly nameSelector?: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelector;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoElbInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoElbInfo(obj: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'nameRef': toJson_DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRef(obj.nameRef),
    'nameSelector': toJson_DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelector(obj.nameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupInfo
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupInfo {
  /**
   * The name of the target group that instances in the original environment are deregistered from, and instances in the replacement environment registered with. For in-place deployments, the name of the target group that instances are deregistered from, so they are not serving traffic during a deployment, and then re-registered with after the deployment completes.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupInfo#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupInfo(obj: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfo
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfo {
  /**
   * Configuration block for the production traffic route (documented below).
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfo#prodTrafficRoute
   */
  readonly prodTrafficRoute: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute[];

  /**
   * Configuration blocks for a target group within a target group pair (documented below).
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfo#targetGroup
   */
  readonly targetGroup: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroup[];

  /**
   * Configuration block for the test traffic route (documented below).
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfo#testTrafficRoute
   */
  readonly testTrafficRoute?: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute[];

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfo(obj: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prodTrafficRoute': obj.prodTrafficRoute?.map(y => toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute(y)),
    'targetGroup': obj.targetGroup?.map(y => toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroup(y)),
    'testTrafficRoute': obj.testTrafficRoute?.map(y => toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentGroupSpecForProviderServiceRoleArnRefPolicy
 */
export interface DeploymentGroupSpecForProviderServiceRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderServiceRoleArnRefPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderServiceRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderServiceRoleArnRefPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderServiceRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderServiceRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderServiceRoleArnRefPolicy(obj: DeploymentGroupSpecForProviderServiceRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicy
 */
export interface DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicy(obj: DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate triggerTargetArn.
 *
 * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRef
 */
export interface DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRef#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRef(obj: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate triggerTargetArn.
 *
 * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelector
 */
export interface DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelector#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelector(obj: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecProviderConfigRefPolicyResolution
 */
export enum DeploymentGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecProviderConfigRefPolicyResolve
 */
export enum DeploymentGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecProviderRefPolicyResolution
 */
export enum DeploymentGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecProviderRefPolicyResolve
 */
export enum DeploymentGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderAppNameRefPolicyResolution
 */
export enum DeploymentGroupSpecForProviderAppNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderAppNameRefPolicyResolve
 */
export enum DeploymentGroupSpecForProviderAppNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderAppNameSelectorPolicyResolution
 */
export enum DeploymentGroupSpecForProviderAppNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderAppNameSelectorPolicyResolve
 */
export enum DeploymentGroupSpecForProviderAppNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicy
 */
export interface DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicy(obj: DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicy
 */
export interface DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicy(obj: DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicy
 */
export interface DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicy(obj: DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicy
 */
export interface DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicy(obj: DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ELB in elb to populate name.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRef
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRef#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRef(obj: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ELB in elb to populate name.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelector
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelector#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelector(obj: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute {
  /**
   * List of Amazon Resource Names (ARNs) of the load balancer listeners.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute#listenerArns
   */
  readonly listenerArns: string[];

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute(obj: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listenerArns': obj.listenerArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroup
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroup {
  /**
   * The name of the target group that instances in the original environment are deregistered from, and instances in the replacement environment registered with. For in-place deployments, the name of the target group that instances are deregistered from, so they are not serving traffic during a deployment, and then re-registered with after the deployment completes.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroup#name
   */
  readonly name?: string;

  /**
   * Reference to a LBTargetGroup in elbv2 to populate name.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroup#nameRef
   */
  readonly nameRef?: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRef;

  /**
   * Selector for a LBTargetGroup in elbv2 to populate name.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroup#nameSelector
   */
  readonly nameSelector?: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelector;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroup(obj: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'nameRef': toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRef(obj.nameRef),
    'nameSelector': toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelector(obj.nameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute {
  /**
   * List of Amazon Resource Names (ARNs) of the load balancer listeners.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute#listenerArns
   */
  readonly listenerArns: string[];

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute(obj: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'listenerArns': obj.listenerArns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderServiceRoleArnRefPolicyResolution
 */
export enum DeploymentGroupSpecForProviderServiceRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderServiceRoleArnRefPolicyResolve
 */
export enum DeploymentGroupSpecForProviderServiceRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicyResolution
 */
export enum DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicyResolve
 */
export enum DeploymentGroupSpecForProviderServiceRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicy
 */
export interface DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicy(obj: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicy
 */
export interface DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicy(obj: DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeploymentGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicyResolution
 */
export enum DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicyResolve
 */
export enum DeploymentGroupSpecForProviderEcsServiceClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicyResolution
 */
export enum DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicyResolve
 */
export enum DeploymentGroupSpecForProviderEcsServiceClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicyResolution
 */
export enum DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicyResolve
 */
export enum DeploymentGroupSpecForProviderEcsServiceServiceNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicyResolution
 */
export enum DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicyResolve
 */
export enum DeploymentGroupSpecForProviderEcsServiceServiceNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicy
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicy(obj: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicy
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicy(obj: DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LBTargetGroup in elbv2 to populate name.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRef
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRef#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRef(obj: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LBTargetGroup in elbv2 to populate name.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelector
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelector#policy
   */
  readonly policy?: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelector(obj: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicyResolution
 */
export enum DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicyResolve
 */
export enum DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicyResolution
 */
export enum DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicyResolve
 */
export enum DeploymentGroupSpecForProviderTriggerConfigurationTriggerTargetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicyResolution
 */
export enum DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicyResolve
 */
export enum DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicyResolution
 */
export enum DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicyResolve
 */
export enum DeploymentGroupSpecForProviderLoadBalancerInfoElbInfoNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicy
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicy(obj: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicy
 */
export interface DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicy(obj: DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicyResolution
 */
export enum DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicyResolve
 */
export enum DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicyResolution
 */
export enum DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicyResolve
 */
export enum DeploymentGroupSpecForProviderLoadBalancerInfoTargetGroupPairInfoTargetGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

