// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Flow is the Schema for the Flows API. Provides an AppFlow Flow resource.
 *
 * @schema Flow
 */
export class Flow extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Flow"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appflow.aws.upbound.io/v1beta1',
    kind: 'Flow',
  }

  /**
   * Renders a Kubernetes manifest for "Flow".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FlowProps): any {
    return {
      ...Flow.GVK,
      ...toJson_FlowProps(props),
    };
  }

  /**
   * Defines a "Flow" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FlowProps) {
    super(scope, id, {
      ...Flow.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Flow.GVK,
      ...toJson_FlowProps(resolved),
    };
  }
}

/**
 * Flow is the Schema for the Flows API. Provides an AppFlow Flow resource.
 *
 * @schema Flow
 */
export interface FlowProps {
  /**
   * @schema Flow#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FlowSpec defines the desired state of Flow
   *
   * @schema Flow#spec
   */
  readonly spec: FlowSpec;

}

/**
 * Converts an object of type 'FlowProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowProps(obj: FlowProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FlowSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FlowSpec defines the desired state of Flow
 *
 * @schema FlowSpec
 */
export interface FlowSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FlowSpec#deletionPolicy
   */
  readonly deletionPolicy?: FlowSpecDeletionPolicy;

  /**
   * @schema FlowSpec#forProvider
   */
  readonly forProvider: FlowSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FlowSpec#managementPolicy
   */
  readonly managementPolicy?: FlowSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FlowSpec#providerConfigRef
   */
  readonly providerConfigRef?: FlowSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FlowSpec#providerRef
   */
  readonly providerRef?: FlowSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FlowSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FlowSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FlowSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FlowSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FlowSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpec(obj: FlowSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FlowSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_FlowSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FlowSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FlowSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FlowSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FlowSpecDeletionPolicy
 */
export enum FlowSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FlowSpecForProvider
 */
export interface FlowSpecForProvider {
  /**
   * Description of the flow you want to create.
   *
   * @schema FlowSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A Destination Flow Config that controls how Amazon AppFlow places data in the destination connector.
   *
   * @schema FlowSpecForProvider#destinationFlowConfig
   */
  readonly destinationFlowConfig?: FlowSpecForProviderDestinationFlowConfig[];

  /**
   * ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
   *
   * @schema FlowSpecForProvider#kmsArn
   */
  readonly kmsArn?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FlowSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Source Flow Config that controls how Amazon AppFlow retrieves data from the source connector.
   *
   * @schema FlowSpecForProvider#sourceFlowConfig
   */
  readonly sourceFlowConfig?: FlowSpecForProviderSourceFlowConfig[];

  /**
   * Key-value map of resource tags.
   *
   * @schema FlowSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * A Task that Amazon AppFlow performs while transferring the data in the flow run.
   *
   * @schema FlowSpecForProvider#task
   */
  readonly task?: FlowSpecForProviderTask[];

  /**
   * A Trigger that determine how and when the flow runs.
   *
   * @schema FlowSpecForProvider#triggerConfig
   */
  readonly triggerConfig?: FlowSpecForProviderTriggerConfig[];

}

/**
 * Converts an object of type 'FlowSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProvider(obj: FlowSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'destinationFlowConfig': obj.destinationFlowConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfig(y)),
    'kmsArn': obj.kmsArn,
    'region': obj.region,
    'sourceFlowConfig': obj.sourceFlowConfig?.map(y => toJson_FlowSpecForProviderSourceFlowConfig(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'task': obj.task?.map(y => toJson_FlowSpecForProviderTask(y)),
    'triggerConfig': obj.triggerConfig?.map(y => toJson_FlowSpecForProviderTriggerConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FlowSpecManagementPolicy
 */
export enum FlowSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FlowSpecProviderConfigRef
 */
export interface FlowSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowSpecProviderConfigRef#policy
   */
  readonly policy?: FlowSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FlowSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecProviderConfigRef(obj: FlowSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FlowSpecProviderRef
 */
export interface FlowSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowSpecProviderRef#policy
   */
  readonly policy?: FlowSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FlowSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecProviderRef(obj: FlowSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FlowSpecPublishConnectionDetailsTo
 */
export interface FlowSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FlowSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FlowSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FlowSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FlowSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FlowSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FlowSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecPublishConnectionDetailsTo(obj: FlowSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FlowSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FlowSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FlowSpecWriteConnectionSecretToRef
 */
export interface FlowSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FlowSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FlowSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FlowSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecWriteConnectionSecretToRef(obj: FlowSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfig
 */
export interface FlowSpecForProviderDestinationFlowConfig {
  /**
   * API version that the destination connector uses.
   *
   * @schema FlowSpecForProviderDestinationFlowConfig#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Name of the connector profile. This name must be unique for each connector profile in the AWS account.
   *
   * @schema FlowSpecForProviderDestinationFlowConfig#connectorProfileName
   */
  readonly connectorProfileName?: string;

  /**
   * Type of connector, such as Salesforce, Amplitude, and so on. Valid values are Salesforce, Singular, Slack, Redshift, S3, Marketo, Googleanalytics, Zendesk, Servicenow, Datadog, Trendmicro, Snowflake, Dynatrace, Infornexus, Amplitude, Veeva, EventBridge, LookoutMetrics, Upsolver, Honeycode, CustomerProfiles, SAPOData, and CustomConnector.
   *
   * @schema FlowSpecForProviderDestinationFlowConfig#connectorType
   */
  readonly connectorType: string;

  /**
   * This stores the information that is required to query a particular connector. See Destination Connector Properties for more information.
   *
   * @schema FlowSpecForProviderDestinationFlowConfig#destinationConnectorProperties
   */
  readonly destinationConnectorProperties: FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties[];

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfig(obj: FlowSpecForProviderDestinationFlowConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'connectorProfileName': obj.connectorProfileName,
    'connectorType': obj.connectorType,
    'destinationConnectorProperties': obj.destinationConnectorProperties?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfig
 */
export interface FlowSpecForProviderSourceFlowConfig {
  /**
   * API version that the destination connector uses.
   *
   * @schema FlowSpecForProviderSourceFlowConfig#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Name of the connector profile. This name must be unique for each connector profile in the AWS account.
   *
   * @schema FlowSpecForProviderSourceFlowConfig#connectorProfileName
   */
  readonly connectorProfileName?: string;

  /**
   * Type of connector, such as Salesforce, Amplitude, and so on. Valid values are Salesforce, Singular, Slack, Redshift, S3, Marketo, Googleanalytics, Zendesk, Servicenow, Datadog, Trendmicro, Snowflake, Dynatrace, Infornexus, Amplitude, Veeva, EventBridge, LookoutMetrics, Upsolver, Honeycode, CustomerProfiles, SAPOData, and CustomConnector.
   *
   * @schema FlowSpecForProviderSourceFlowConfig#connectorType
   */
  readonly connectorType: string;

  /**
   * Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull. See Incremental Pull Config for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfig#incrementalPullConfig
   */
  readonly incrementalPullConfig?: FlowSpecForProviderSourceFlowConfigIncrementalPullConfig[];

  /**
   * Information that is required to query a particular source connector. See Source Connector Properties for details.
   *
   * @schema FlowSpecForProviderSourceFlowConfig#sourceConnectorProperties
   */
  readonly sourceConnectorProperties: FlowSpecForProviderSourceFlowConfigSourceConnectorProperties[];

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfig(obj: FlowSpecForProviderSourceFlowConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'connectorProfileName': obj.connectorProfileName,
    'connectorType': obj.connectorType,
    'incrementalPullConfig': obj.incrementalPullConfig?.map(y => toJson_FlowSpecForProviderSourceFlowConfigIncrementalPullConfig(y)),
    'sourceConnectorProperties': obj.sourceConnectorProperties?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderTask
 */
export interface FlowSpecForProviderTask {
  /**
   * Operation to be performed on the provided source fields. See Connector Operator for details.
   *
   * @schema FlowSpecForProviderTask#connectorOperator
   */
  readonly connectorOperator?: FlowSpecForProviderTaskConnectorOperator[];

  /**
   * Field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
   *
   * @schema FlowSpecForProviderTask#destinationField
   */
  readonly destinationField?: string;

  /**
   * Source fields to which a particular task is applied.
   *
   * @schema FlowSpecForProviderTask#sourceFields
   */
  readonly sourceFields: string[];

  /**
   * Map used to store task-related information. The execution service looks for particular information based on the TaskType. Valid keys are VALUE, VALUES, DATA_TYPE, UPPER_BOUND, LOWER_BOUND, SOURCE_DATA_TYPE, DESTINATION_DATA_TYPE, VALIDATION_ACTION, MASK_VALUE, MASK_LENGTH, TRUNCATE_LENGTH, MATH_OPERATION_FIELDS_ORDER, CONCAT_FORMAT, SUBFIELD_CATEGORY_MAP, and EXCLUDE_SOURCE_FIELDS_LIST.
   *
   * @schema FlowSpecForProviderTask#taskProperties
   */
  readonly taskProperties?: { [key: string]: string };

  /**
   * Particular task implementation that Amazon AppFlow performs. Valid values are Arithmetic, Filter, Map, Map_all, Mask, Merge, Passthrough, Truncate, and Validate.
   *
   * @schema FlowSpecForProviderTask#taskType
   */
  readonly taskType: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderTask' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderTask(obj: FlowSpecForProviderTask | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectorOperator': obj.connectorOperator?.map(y => toJson_FlowSpecForProviderTaskConnectorOperator(y)),
    'destinationField': obj.destinationField,
    'sourceFields': obj.sourceFields?.map(y => y),
    'taskProperties': ((obj.taskProperties) === undefined) ? undefined : (Object.entries(obj.taskProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taskType': obj.taskType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderTriggerConfig
 */
export interface FlowSpecForProviderTriggerConfig {
  /**
   * Configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the Scheduled trigger type. See Scheduled Trigger Properties for details.
   *
   * @schema FlowSpecForProviderTriggerConfig#triggerProperties
   */
  readonly triggerProperties?: FlowSpecForProviderTriggerConfigTriggerProperties[];

  /**
   * Type of flow trigger. Valid values are Scheduled, Event, and OnDemand.
   *
   * @schema FlowSpecForProviderTriggerConfig#triggerType
   */
  readonly triggerType: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderTriggerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderTriggerConfig(obj: FlowSpecForProviderTriggerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'triggerProperties': obj.triggerProperties?.map(y => toJson_FlowSpecForProviderTriggerConfigTriggerProperties(y)),
    'triggerType': obj.triggerType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowSpecProviderConfigRefPolicy
 */
export interface FlowSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FlowSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FlowSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecProviderConfigRefPolicy(obj: FlowSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowSpecProviderRefPolicy
 */
export interface FlowSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FlowSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FlowSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecProviderRefPolicy(obj: FlowSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FlowSpecPublishConnectionDetailsToConfigRef
 */
export interface FlowSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FlowSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FlowSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecPublishConnectionDetailsToConfigRef(obj: FlowSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FlowSpecPublishConnectionDetailsToMetadata
 */
export interface FlowSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FlowSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FlowSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FlowSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FlowSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecPublishConnectionDetailsToMetadata(obj: FlowSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties {
  /**
   * Properties that are required to query the custom Connector. See Custom Connector Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#customConnector
   */
  readonly customConnector?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector[];

  /**
   * Properties that are required to query Amazon Connect Customer Profiles. See Customer Profiles Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#customerProfiles
   */
  readonly customerProfiles?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles[];

  /**
   * Properties that are required to query Amazon EventBridge. See Generic Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#eventBridge
   */
  readonly eventBridge?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridge[];

  /**
   * Properties that are required to query Amazon Honeycode. See Generic Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#honeycode
   */
  readonly honeycode?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycode[];

  /**
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#lookoutMetrics
   */
  readonly lookoutMetrics?: any[];

  /**
   * Properties that are required to query Marketo. See Generic Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#marketo
   */
  readonly marketo?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketo[];

  /**
   * Properties that are required to query Amazon Redshift. See Redshift Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#redshift
   */
  readonly redshift?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshift[];

  /**
   * Properties that are required to query Amazon S3. See S3 Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#s3
   */
  readonly s3?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3[];

  /**
   * Properties that are required to query Salesforce. See Salesforce Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#salesforce
   */
  readonly salesforce?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforce[];

  /**
   * Properties that are required to query SAPOData. See SAPOData Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#sapoData
   */
  readonly sapoData?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData[];

  /**
   * Properties that are required to query Snowflake. See Snowflake Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#snowflake
   */
  readonly snowflake?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflake[];

  /**
   * Properties that are required to query Upsolver. See Upsolver Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#upsolver
   */
  readonly upsolver?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolver[];

  /**
   * Properties that are required to query Zendesk. See Zendesk Destination Properties for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties#zendesk
   */
  readonly zendesk?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendesk[];

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customConnector': obj.customConnector?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector(y)),
    'customerProfiles': obj.customerProfiles?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles(y)),
    'eventBridge': obj.eventBridge?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridge(y)),
    'honeycode': obj.honeycode?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycode(y)),
    'lookoutMetrics': obj.lookoutMetrics?.map(y => y),
    'marketo': obj.marketo?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketo(y)),
    'redshift': obj.redshift?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshift(y)),
    's3': obj.s3?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3(y)),
    'salesforce': obj.salesforce?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforce(y)),
    'sapoData': obj.sapoData?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData(y)),
    'snowflake': obj.snowflake?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflake(y)),
    'upsolver': obj.upsolver?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolver(y)),
    'zendesk': obj.zendesk?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendesk(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigIncrementalPullConfig
 */
export interface FlowSpecForProviderSourceFlowConfigIncrementalPullConfig {
  /**
   * Field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
   *
   * @schema FlowSpecForProviderSourceFlowConfigIncrementalPullConfig#datetimeTypeFieldName
   */
  readonly datetimeTypeFieldName?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigIncrementalPullConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigIncrementalPullConfig(obj: FlowSpecForProviderSourceFlowConfigIncrementalPullConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datetimeTypeFieldName': obj.datetimeTypeFieldName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorProperties {
  /**
   * Information that is required for querying Amplitude. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#amplitude
   */
  readonly amplitude?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesAmplitude[];

  /**
   * Properties that are required to query the custom Connector. See Custom Connector Destination Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#customConnector
   */
  readonly customConnector?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesCustomConnector[];

  /**
   * Information that is required for querying Datadog. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#datadog
   */
  readonly datadog?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDatadog[];

  /**
   * Operation to be performed on the provided Dynatrace source fields. Valid values are PROJECTION, BETWEEN, EQUAL_TO, ADDITION, MULTIPLICATION, DIVISION, SUBTRACTION, MASK_ALL, MASK_FIRST_N, MASK_LAST_N, VALIDATE_NON_NULL, VALIDATE_NON_ZERO, VALIDATE_NON_NEGATIVE, VALIDATE_NUMERIC, and NO_OP.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#dynatrace
   */
  readonly dynatrace?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDynatrace[];

  /**
   * Operation to be performed on the provided Google Analytics source fields. Valid values are PROJECTION and BETWEEN.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#googleAnalytics
   */
  readonly googleAnalytics?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics[];

  /**
   * Information that is required for querying Infor Nexus. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#inforNexus
   */
  readonly inforNexus?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesInforNexus[];

  /**
   * Properties that are required to query Marketo. See Generic Destination Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#marketo
   */
  readonly marketo?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesMarketo[];

  /**
   * Properties that are required to query Amazon S3. See S3 Destination Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#s3
   */
  readonly s3?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3[];

  /**
   * Properties that are required to query Salesforce. See Salesforce Destination Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#salesforce
   */
  readonly salesforce?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSalesforce[];

  /**
   * Properties that are required to query SAPOData. See SAPOData Destination Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#sapoData
   */
  readonly sapoData?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSapoData[];

  /**
   * Information that is required for querying ServiceNow. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#serviceNow
   */
  readonly serviceNow?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesServiceNow[];

  /**
   * Information that is required for querying Singular. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#singular
   */
  readonly singular?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSingular[];

  /**
   * Information that is required for querying Slack. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#slack
   */
  readonly slack?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSlack[];

  /**
   * Operation to be performed on the provided Trend Micro source fields. Valid values are PROJECTION, EQUAL_TO, ADDITION, MULTIPLICATION, DIVISION, SUBTRACTION, MASK_ALL, MASK_FIRST_N, MASK_LAST_N, VALIDATE_NON_NULL, VALIDATE_NON_ZERO, VALIDATE_NON_NEGATIVE, VALIDATE_NUMERIC, and NO_OP.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#trendmicro
   */
  readonly trendmicro?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesTrendmicro[];

  /**
   * Information that is required for querying Veeva. See Veeva Source Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#veeva
   */
  readonly veeva?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva[];

  /**
   * Properties that are required to query Zendesk. See Zendesk Destination Properties for more details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorProperties#zendesk
   */
  readonly zendesk?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesZendesk[];

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorProperties(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amplitude': obj.amplitude?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesAmplitude(y)),
    'customConnector': obj.customConnector?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesCustomConnector(y)),
    'datadog': obj.datadog?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDatadog(y)),
    'dynatrace': obj.dynatrace?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDynatrace(y)),
    'googleAnalytics': obj.googleAnalytics?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics(y)),
    'inforNexus': obj.inforNexus?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesInforNexus(y)),
    'marketo': obj.marketo?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesMarketo(y)),
    's3': obj.s3?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3(y)),
    'salesforce': obj.salesforce?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSalesforce(y)),
    'sapoData': obj.sapoData?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSapoData(y)),
    'serviceNow': obj.serviceNow?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesServiceNow(y)),
    'singular': obj.singular?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSingular(y)),
    'slack': obj.slack?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSlack(y)),
    'trendmicro': obj.trendmicro?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesTrendmicro(y)),
    'veeva': obj.veeva?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva(y)),
    'zendesk': obj.zendesk?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesZendesk(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderTaskConnectorOperator
 */
export interface FlowSpecForProviderTaskConnectorOperator {
  /**
   * Information that is required for querying Amplitude. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#amplitude
   */
  readonly amplitude?: string;

  /**
   * Properties that are required to query the custom Connector. See Custom Connector Destination Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#customConnector
   */
  readonly customConnector?: string;

  /**
   * Information that is required for querying Datadog. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#datadog
   */
  readonly datadog?: string;

  /**
   * Operation to be performed on the provided Dynatrace source fields. Valid values are PROJECTION, BETWEEN, EQUAL_TO, ADDITION, MULTIPLICATION, DIVISION, SUBTRACTION, MASK_ALL, MASK_FIRST_N, MASK_LAST_N, VALIDATE_NON_NULL, VALIDATE_NON_ZERO, VALIDATE_NON_NEGATIVE, VALIDATE_NUMERIC, and NO_OP.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#dynatrace
   */
  readonly dynatrace?: string;

  /**
   * Operation to be performed on the provided Google Analytics source fields. Valid values are PROJECTION and BETWEEN.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#googleAnalytics
   */
  readonly googleAnalytics?: string;

  /**
   * Information that is required for querying Infor Nexus. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#inforNexus
   */
  readonly inforNexus?: string;

  /**
   * Properties that are required to query Marketo. See Generic Destination Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#marketo
   */
  readonly marketo?: string;

  /**
   * Properties that are required to query Amazon S3. See S3 Destination Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#s3
   */
  readonly s3?: string;

  /**
   * Properties that are required to query Salesforce. See Salesforce Destination Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#salesforce
   */
  readonly salesforce?: string;

  /**
   * Properties that are required to query SAPOData. See SAPOData Destination Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#sapoData
   */
  readonly sapoData?: string;

  /**
   * Information that is required for querying ServiceNow. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#serviceNow
   */
  readonly serviceNow?: string;

  /**
   * Information that is required for querying Singular. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#singular
   */
  readonly singular?: string;

  /**
   * Information that is required for querying Slack. See Generic Source Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#slack
   */
  readonly slack?: string;

  /**
   * Operation to be performed on the provided Trend Micro source fields. Valid values are PROJECTION, EQUAL_TO, ADDITION, MULTIPLICATION, DIVISION, SUBTRACTION, MASK_ALL, MASK_FIRST_N, MASK_LAST_N, VALIDATE_NON_NULL, VALIDATE_NON_ZERO, VALIDATE_NON_NEGATIVE, VALIDATE_NUMERIC, and NO_OP.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#trendmicro
   */
  readonly trendmicro?: string;

  /**
   * Information that is required for querying Veeva. See Veeva Source Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#veeva
   */
  readonly veeva?: string;

  /**
   * Properties that are required to query Zendesk. See Zendesk Destination Properties for more details.
   *
   * @schema FlowSpecForProviderTaskConnectorOperator#zendesk
   */
  readonly zendesk?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderTaskConnectorOperator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderTaskConnectorOperator(obj: FlowSpecForProviderTaskConnectorOperator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amplitude': obj.amplitude,
    'customConnector': obj.customConnector,
    'datadog': obj.datadog,
    'dynatrace': obj.dynatrace,
    'googleAnalytics': obj.googleAnalytics,
    'inforNexus': obj.inforNexus,
    'marketo': obj.marketo,
    's3': obj.s3,
    'salesforce': obj.salesforce,
    'sapoData': obj.sapoData,
    'serviceNow': obj.serviceNow,
    'singular': obj.singular,
    'slack': obj.slack,
    'trendmicro': obj.trendmicro,
    'veeva': obj.veeva,
    'zendesk': obj.zendesk,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderTriggerConfigTriggerProperties
 */
export interface FlowSpecForProviderTriggerConfigTriggerProperties {
  /**
   * @schema FlowSpecForProviderTriggerConfigTriggerProperties#scheduled
   */
  readonly scheduled?: FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled[];

}

/**
 * Converts an object of type 'FlowSpecForProviderTriggerConfigTriggerProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderTriggerConfigTriggerProperties(obj: FlowSpecForProviderTriggerConfigTriggerProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scheduled': obj.scheduled?.map(y => toJson_FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecProviderConfigRefPolicyResolution
 */
export enum FlowSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecProviderConfigRefPolicyResolve
 */
export enum FlowSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecProviderRefPolicyResolution
 */
export enum FlowSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecProviderRefPolicyResolve
 */
export enum FlowSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FlowSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FlowSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FlowSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FlowSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecPublishConnectionDetailsToConfigRefPolicy(obj: FlowSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector {
  /**
   * Custom properties that are specific to the connector when it's used as a destination in the flow. Maximum of 50 items.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector#customProperties
   */
  readonly customProperties?: { [key: string]: string };

  /**
   * Entity specified in the custom connector as a destination in the flow.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector#entityName
   */
  readonly entityName: string;

  /**
   * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector#errorHandlingConfig
   */
  readonly errorHandlingConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig[];

  /**
   * Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector#idFieldNames
   */
  readonly idFieldNames?: string[];

  /**
   * Type of write operation to be performed in the custom connector when it's used as destination. Valid values are INSERT, UPSERT, UPDATE, and DELETE.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector#writeOperationType
   */
  readonly writeOperationType?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customProperties': ((obj.customProperties) === undefined) ? undefined : (Object.entries(obj.customProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'entityName': obj.entityName,
    'errorHandlingConfig': obj.errorHandlingConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig(y)),
    'idFieldNames': obj.idFieldNames?.map(y => y),
    'writeOperationType': obj.writeOperationType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles {
  /**
   * Unique name of the Amazon Connect Customer Profiles domain.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles#domainName
   */
  readonly domainName: string;

  /**
   * Object specified in the Amazon Connect Customer Profiles flow destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles#objectTypeName
   */
  readonly objectTypeName?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomerProfiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainName': obj.domainName,
    'objectTypeName': obj.objectTypeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridge
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridge {
  /**
   * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridge#errorHandlingConfig
   */
  readonly errorHandlingConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig[];

  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridge#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridge' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridge(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridge | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorHandlingConfig': obj.errorHandlingConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig(y)),
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycode
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycode {
  /**
   * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycode#errorHandlingConfig
   */
  readonly errorHandlingConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig[];

  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycode#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycode' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycode(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycode | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorHandlingConfig': obj.errorHandlingConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig(y)),
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketo
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketo {
  /**
   * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketo#errorHandlingConfig
   */
  readonly errorHandlingConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig[];

  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketo#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketo(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorHandlingConfig': obj.errorHandlingConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig(y)),
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshift
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshift {
  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshift#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshift#errorHandlingConfig
   */
  readonly errorHandlingConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig[];

  /**
   * Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshift#intermediateBucketName
   */
  readonly intermediateBucketName: string;

  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshift#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshift' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshift(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshift | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketPrefix': obj.bucketPrefix,
    'errorHandlingConfig': obj.errorHandlingConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig(y)),
    'intermediateBucketName': obj.intermediateBucketName,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3 {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3#bucketName
   */
  readonly bucketName?: string;

  /**
   * Reference to a BucketPolicy in s3 to populate bucketName.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3#bucketNameRef
   */
  readonly bucketNameRef?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRef;

  /**
   * Selector for a BucketPolicy in s3 to populate bucketName.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3#bucketNameSelector
   */
  readonly bucketNameSelector?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelector;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * Configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination. See S3 Output Format Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3#s3OutputFormatConfig
   */
  readonly s3OutputFormatConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig[];

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketNameRef': toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRef(obj.bucketNameRef),
    'bucketNameSelector': toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelector(obj.bucketNameSelector),
    'bucketPrefix': obj.bucketPrefix,
    's3OutputFormatConfig': obj.s3OutputFormatConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforce
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforce {
  /**
   * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforce#errorHandlingConfig
   */
  readonly errorHandlingConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig[];

  /**
   * Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforce#idFieldNames
   */
  readonly idFieldNames?: string[];

  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforce#object
   */
  readonly object: string;

  /**
   * Type of write operation to be performed in the custom connector when it's used as destination. Valid values are INSERT, UPSERT, UPDATE, and DELETE.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforce#writeOperationType
   */
  readonly writeOperationType?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforce' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforce(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorHandlingConfig': obj.errorHandlingConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig(y)),
    'idFieldNames': obj.idFieldNames?.map(y => y),
    'object': obj.object,
    'writeOperationType': obj.writeOperationType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData {
  /**
   * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData#errorHandlingConfig
   */
  readonly errorHandlingConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig[];

  /**
   * Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData#idFieldNames
   */
  readonly idFieldNames?: string[];

  /**
   * Object path specified in the SAPOData flow destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData#objectPath
   */
  readonly objectPath: string;

  /**
   * Determines how Amazon AppFlow handles the success response that it gets from the connector after placing data. See Success Response Handling Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData#successResponseHandlingConfig
   */
  readonly successResponseHandlingConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig[];

  /**
   * Type of write operation to be performed in the custom connector when it's used as destination. Valid values are INSERT, UPSERT, UPDATE, and DELETE.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData#writeOperationType
   */
  readonly writeOperationType?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorHandlingConfig': obj.errorHandlingConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig(y)),
    'idFieldNames': obj.idFieldNames?.map(y => y),
    'objectPath': obj.objectPath,
    'successResponseHandlingConfig': obj.successResponseHandlingConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig(y)),
    'writeOperationType': obj.writeOperationType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflake
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflake {
  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflake#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflake#errorHandlingConfig
   */
  readonly errorHandlingConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig[];

  /**
   * Intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflake#intermediateBucketName
   */
  readonly intermediateBucketName: string;

  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflake#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflake' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflake(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflake | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketPrefix': obj.bucketPrefix,
    'errorHandlingConfig': obj.errorHandlingConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig(y)),
    'intermediateBucketName': obj.intermediateBucketName,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolver
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolver {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolver#bucketName
   */
  readonly bucketName: string;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolver#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * Configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination. See S3 Output Format Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolver#s3OutputFormatConfig
   */
  readonly s3OutputFormatConfig: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig[];

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolver' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolver(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolver | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    's3OutputFormatConfig': obj.s3OutputFormatConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendesk
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendesk {
  /**
   * Settings that determine how Amazon AppFlow handles an error when placing data in the destination. See Error Handling Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendesk#errorHandlingConfig
   */
  readonly errorHandlingConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig[];

  /**
   * Name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendesk#idFieldNames
   */
  readonly idFieldNames?: string[];

  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendesk#object
   */
  readonly object: string;

  /**
   * Type of write operation to be performed in the custom connector when it's used as destination. Valid values are INSERT, UPSERT, UPDATE, and DELETE.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendesk#writeOperationType
   */
  readonly writeOperationType?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendesk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendesk(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendesk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorHandlingConfig': obj.errorHandlingConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig(y)),
    'idFieldNames': obj.idFieldNames?.map(y => y),
    'object': obj.object,
    'writeOperationType': obj.writeOperationType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesAmplitude
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesAmplitude {
  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesAmplitude#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesAmplitude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesAmplitude(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesAmplitude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesCustomConnector
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesCustomConnector {
  /**
   * Custom properties that are specific to the connector when it's used as a destination in the flow. Maximum of 50 items.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesCustomConnector#customProperties
   */
  readonly customProperties?: { [key: string]: string };

  /**
   * Entity specified in the custom connector as a destination in the flow.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesCustomConnector#entityName
   */
  readonly entityName: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesCustomConnector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesCustomConnector(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesCustomConnector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customProperties': ((obj.customProperties) === undefined) ? undefined : (Object.entries(obj.customProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'entityName': obj.entityName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDatadog
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDatadog {
  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDatadog#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDatadog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDatadog(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDatadog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDynatrace
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDynatrace {
  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDynatrace#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDynatrace' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDynatrace(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesDynatrace | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics {
  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesGoogleAnalytics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesInforNexus
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesInforNexus {
  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesInforNexus#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesInforNexus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesInforNexus(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesInforNexus | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesMarketo
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesMarketo {
  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesMarketo#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesMarketo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesMarketo(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesMarketo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3 {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3#bucketName
   */
  readonly bucketName?: string;

  /**
   * Reference to a BucketPolicy in s3 to populate bucketName.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3#bucketNameRef
   */
  readonly bucketNameRef?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRef;

  /**
   * Selector for a BucketPolicy in s3 to populate bucketName.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3#bucketNameSelector
   */
  readonly bucketNameSelector?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelector;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * When you use Amazon S3 as the source, the configuration format that you provide the flow input data. See S3 Input Format Config for details.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3#s3InputFormatConfig
   */
  readonly s3InputFormatConfig?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig[];

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketNameRef': toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRef(obj.bucketNameRef),
    'bucketNameSelector': toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelector(obj.bucketNameSelector),
    'bucketPrefix': obj.bucketPrefix,
    's3InputFormatConfig': obj.s3InputFormatConfig?.map(y => toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSalesforce
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSalesforce {
  /**
   * Flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSalesforce#enableDynamicFieldUpdate
   */
  readonly enableDynamicFieldUpdate?: boolean;

  /**
   * Whether Amazon AppFlow includes deleted files in the flow run.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSalesforce#includeDeletedRecords
   */
  readonly includeDeletedRecords?: boolean;

  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSalesforce#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSalesforce' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSalesforce(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSalesforce | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableDynamicFieldUpdate': obj.enableDynamicFieldUpdate,
    'includeDeletedRecords': obj.includeDeletedRecords,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSapoData
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSapoData {
  /**
   * Object path specified in the SAPOData flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSapoData#objectPath
   */
  readonly objectPath: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSapoData' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSapoData(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSapoData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectPath': obj.objectPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesServiceNow
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesServiceNow {
  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesServiceNow#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesServiceNow' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesServiceNow(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesServiceNow | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSingular
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSingular {
  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSingular#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSingular' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSingular(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSingular | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSlack
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSlack {
  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSlack#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSlack' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSlack(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesSlack | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesTrendmicro
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesTrendmicro {
  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesTrendmicro#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesTrendmicro' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesTrendmicro(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesTrendmicro | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva {
  /**
   * Document type specified in the Veeva document extract flow.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva#documentType
   */
  readonly documentType?: string;

  /**
   * Boolean value to include All Versions of files in Veeva document extract flow.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva#includeAllVersions
   */
  readonly includeAllVersions?: boolean;

  /**
   * Boolean value to include file renditions in Veeva document extract flow.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva#includeRenditions
   */
  readonly includeRenditions?: boolean;

  /**
   * Boolean value to include source files in Veeva document extract flow.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva#includeSourceFiles
   */
  readonly includeSourceFiles?: boolean;

  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesVeeva | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'documentType': obj.documentType,
    'includeAllVersions': obj.includeAllVersions,
    'includeRenditions': obj.includeRenditions,
    'includeSourceFiles': obj.includeSourceFiles,
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesZendesk
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesZendesk {
  /**
   * Object specified in the flow destination.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesZendesk#object
   */
  readonly object: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesZendesk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesZendesk(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesZendesk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'object': obj.object,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled
 */
export interface FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled {
  /**
   * Whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run. Valid values are Incremental and Complete.
   *
   * @schema FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled#dataPullMode
   */
  readonly dataPullMode?: string;

  /**
   * Date range for the records to import from the connector in the first flow run. Must be a valid RFC3339 timestamp.
   *
   * @schema FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled#firstExecutionFrom
   */
  readonly firstExecutionFrom?: string;

  /**
   * Scheduled end time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
   *
   * @schema FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled#scheduleEndTime
   */
  readonly scheduleEndTime?: string;

  /**
   * Scheduling expression that determines the rate at which the schedule will run, for example rate(5minutes).
   *
   * @schema FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled#scheduleExpression
   */
  readonly scheduleExpression: string;

  /**
   * Optional offset that is added to the time interval for a schedule-triggered flow. Maximum value of 36000.
   *
   * @schema FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled#scheduleOffset
   */
  readonly scheduleOffset?: number;

  /**
   * Scheduled start time for a schedule-triggered flow. Must be a valid RFC3339 timestamp.
   *
   * @schema FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled#scheduleStartTime
   */
  readonly scheduleStartTime?: string;

  /**
   * Time zone used when referring to the date and time of a scheduled-triggered flow, such as America/New_York.
   *
   * @schema FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled#timezone
   */
  readonly timezone?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled(obj: FlowSpecForProviderTriggerConfigTriggerPropertiesScheduled | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataPullMode': obj.dataPullMode,
    'firstExecutionFrom': obj.firstExecutionFrom,
    'scheduleEndTime': obj.scheduleEndTime,
    'scheduleExpression': obj.scheduleExpression,
    'scheduleOffset': obj.scheduleOffset,
    'scheduleStartTime': obj.scheduleStartTime,
    'timezone': obj.timezone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FlowSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FlowSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig#bucketName
   */
  readonly bucketName?: string;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig#failOnFirstDestinationError
   */
  readonly failOnFirstDestinationError?: boolean;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesCustomConnectorErrorHandlingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    'failOnFirstDestinationError': obj.failOnFirstDestinationError,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig#bucketName
   */
  readonly bucketName?: string;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig#failOnFirstDestinationError
   */
  readonly failOnFirstDestinationError?: boolean;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesEventBridgeErrorHandlingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    'failOnFirstDestinationError': obj.failOnFirstDestinationError,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig#bucketName
   */
  readonly bucketName?: string;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig#failOnFirstDestinationError
   */
  readonly failOnFirstDestinationError?: boolean;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesHoneycodeErrorHandlingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    'failOnFirstDestinationError': obj.failOnFirstDestinationError,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig#bucketName
   */
  readonly bucketName?: string;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig#failOnFirstDestinationError
   */
  readonly failOnFirstDestinationError?: boolean;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesMarketoErrorHandlingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    'failOnFirstDestinationError': obj.failOnFirstDestinationError,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig#bucketName
   */
  readonly bucketName?: string;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig#failOnFirstDestinationError
   */
  readonly failOnFirstDestinationError?: boolean;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesRedshiftErrorHandlingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    'failOnFirstDestinationError': obj.failOnFirstDestinationError,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a BucketPolicy in s3 to populate bucketName.
 *
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRef
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRef#policy
   */
  readonly policy?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicy;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRef(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a BucketPolicy in s3 to populate bucketName.
 *
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelector
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelector#policy
   */
  readonly policy?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelector(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig {
  /**
   * Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig#aggregationConfig
   */
  readonly aggregationConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig[];

  /**
   * File type that Amazon AppFlow places in the Amazon S3 bucket. Valid values are CSV, JSON, and PARQUET.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig#fileType
   */
  readonly fileType?: string;

  /**
   * Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig#prefixConfig
   */
  readonly prefixConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig[];

  /**
   * Whether the data types from the source system need to be preserved (Only valid for Parquet file type)
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig#preserveSourceDataTyping
   */
  readonly preserveSourceDataTyping?: boolean;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationConfig': obj.aggregationConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig(y)),
    'fileType': obj.fileType,
    'prefixConfig': obj.prefixConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig(y)),
    'preserveSourceDataTyping': obj.preserveSourceDataTyping,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig#bucketName
   */
  readonly bucketName?: string;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig#failOnFirstDestinationError
   */
  readonly failOnFirstDestinationError?: boolean;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSalesforceErrorHandlingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    'failOnFirstDestinationError': obj.failOnFirstDestinationError,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig#bucketName
   */
  readonly bucketName?: string;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig#failOnFirstDestinationError
   */
  readonly failOnFirstDestinationError?: boolean;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataErrorHandlingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    'failOnFirstDestinationError': obj.failOnFirstDestinationError,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig#bucketName
   */
  readonly bucketName?: string;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig#bucketPrefix
   */
  readonly bucketPrefix?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSapoDataSuccessResponseHandlingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig#bucketName
   */
  readonly bucketName?: string;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig#failOnFirstDestinationError
   */
  readonly failOnFirstDestinationError?: boolean;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesSnowflakeErrorHandlingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    'failOnFirstDestinationError': obj.failOnFirstDestinationError,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig {
  /**
   * Aggregation settings that you can use to customize the output format of your flow data. See Aggregation Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig#aggregationConfig
   */
  readonly aggregationConfig?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig[];

  /**
   * File type that Amazon AppFlow places in the Amazon S3 bucket. Valid values are CSV, JSON, and PARQUET.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig#fileType
   */
  readonly fileType?: string;

  /**
   * Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. See Prefix Config for more details.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig#prefixConfig
   */
  readonly prefixConfig: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig[];

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationConfig': obj.aggregationConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig(y)),
    'fileType': obj.fileType,
    'prefixConfig': obj.prefixConfig?.map(y => toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig {
  /**
   * Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig#bucketName
   */
  readonly bucketName?: string;

  /**
   * Object key for the bucket in which Amazon AppFlow places the destination files.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * If the flow should fail after the first instance of a failure when attempting to place data in the destination.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig#failOnFirstDestinationError
   */
  readonly failOnFirstDestinationError?: boolean;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesZendeskErrorHandlingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    'failOnFirstDestinationError': obj.failOnFirstDestinationError,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a BucketPolicy in s3 to populate bucketName.
 *
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRef
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRef#policy
   */
  readonly policy?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicy;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRef(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a BucketPolicy in s3 to populate bucketName.
 *
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelector
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelector#policy
   */
  readonly policy?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelector(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig {
  /**
   * File type that Amazon AppFlow gets from your Amazon S3 bucket. Valid values are CSV and JSON.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig#s3InputFileType
   */
  readonly s3InputFileType?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3S3InputFormatConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3InputFileType': obj.s3InputFileType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicy
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicy#resolution
   */
  readonly resolution?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicy#resolve
   */
  readonly resolve?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicy(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicy
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicy#resolution
   */
  readonly resolution?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicy#resolve
   */
  readonly resolve?: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicy(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig {
  /**
   * Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are None and SingleFile.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig#aggregationType
   */
  readonly aggregationType?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigAggregationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationType': obj.aggregationType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig {
  /**
   * Determines the level of granularity that's included in the prefix. Valid values are YEAR, MONTH, DAY, HOUR, and MINUTE.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig#prefixFormat
   */
  readonly prefixFormat?: string;

  /**
   * Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are FILENAME, PATH, and PATH_AND_FILENAME.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig#prefixType
   */
  readonly prefixType?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3S3OutputFormatConfigPrefixConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefixFormat': obj.prefixFormat,
    'prefixType': obj.prefixType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig {
  /**
   * Whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. Valid values are None and SingleFile.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig#aggregationType
   */
  readonly aggregationType?: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigAggregationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregationType': obj.aggregationType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig
 */
export interface FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig {
  /**
   * Determines the level of granularity that's included in the prefix. Valid values are YEAR, MONTH, DAY, HOUR, and MINUTE.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig#prefixFormat
   */
  readonly prefixFormat?: string;

  /**
   * Determines the format of the prefix, and whether it applies to the file name, file path, or both. Valid values are FILENAME, PATH, and PATH_AND_FILENAME.
   *
   * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig#prefixType
   */
  readonly prefixType: string;

}

/**
 * Converts an object of type 'FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig(obj: FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesUpsolverS3OutputFormatConfigPrefixConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefixFormat': obj.prefixFormat,
    'prefixType': obj.prefixType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicy
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicy#resolution
   */
  readonly resolution?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicy#resolve
   */
  readonly resolve?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicy(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicy
 */
export interface FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicy#resolution
   */
  readonly resolution?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicy#resolve
   */
  readonly resolve?: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicy(obj: FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicyResolution
 */
export enum FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicyResolve
 */
export enum FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicyResolution
 */
export enum FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicyResolve
 */
export enum FlowSpecForProviderDestinationFlowConfigDestinationConnectorPropertiesS3BucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicyResolution
 */
export enum FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicyResolve
 */
export enum FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicyResolution
 */
export enum FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicyResolve
 */
export enum FlowSpecForProviderSourceFlowConfigSourceConnectorPropertiesS3BucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

