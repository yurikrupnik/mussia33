// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * SigningJob is the Schema for the SigningJobs API. Creates a Signer Signing Job.
 *
 * @schema SigningJob
 */
export class SigningJob extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SigningJob"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'signer.aws.upbound.io/v1beta1',
    kind: 'SigningJob',
  }

  /**
   * Renders a Kubernetes manifest for "SigningJob".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SigningJobProps): any {
    return {
      ...SigningJob.GVK,
      ...toJson_SigningJobProps(props),
    };
  }

  /**
   * Defines a "SigningJob" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SigningJobProps) {
    super(scope, id, {
      ...SigningJob.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SigningJob.GVK,
      ...toJson_SigningJobProps(resolved),
    };
  }
}

/**
 * SigningJob is the Schema for the SigningJobs API. Creates a Signer Signing Job.
 *
 * @schema SigningJob
 */
export interface SigningJobProps {
  /**
   * @schema SigningJob#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SigningJobSpec defines the desired state of SigningJob
   *
   * @schema SigningJob#spec
   */
  readonly spec: SigningJobSpec;

}

/**
 * Converts an object of type 'SigningJobProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobProps(obj: SigningJobProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SigningJobSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SigningJobSpec defines the desired state of SigningJob
 *
 * @schema SigningJobSpec
 */
export interface SigningJobSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SigningJobSpec#deletionPolicy
   */
  readonly deletionPolicy?: SigningJobSpecDeletionPolicy;

  /**
   * @schema SigningJobSpec#forProvider
   */
  readonly forProvider: SigningJobSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SigningJobSpec#managementPolicy
   */
  readonly managementPolicy?: SigningJobSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SigningJobSpec#providerConfigRef
   */
  readonly providerConfigRef?: SigningJobSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SigningJobSpec#providerRef
   */
  readonly providerRef?: SigningJobSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SigningJobSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SigningJobSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SigningJobSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SigningJobSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SigningJobSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpec(obj: SigningJobSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SigningJobSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SigningJobSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SigningJobSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SigningJobSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SigningJobSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SigningJobSpecDeletionPolicy
 */
export enum SigningJobSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SigningJobSpecForProvider
 */
export interface SigningJobSpecForProvider {
  /**
   * The S3 bucket in which to save your signed object. See Destination below for details.
   *
   * @schema SigningJobSpecForProvider#destination
   */
  readonly destination?: SigningJobSpecForProviderDestination[];

  /**
   * Set this argument to true to ignore signing job failures and retrieve failed status and reason. Default false.
   *
   * @schema SigningJobSpecForProvider#ignoreSigningJobFailure
   */
  readonly ignoreSigningJobFailure?: boolean;

  /**
   * The name of the profile to initiate the signing operation.
   *
   * @schema SigningJobSpecForProvider#profileName
   */
  readonly profileName?: string;

  /**
   * Reference to a SigningProfile in signer to populate profileName.
   *
   * @schema SigningJobSpecForProvider#profileNameRef
   */
  readonly profileNameRef?: SigningJobSpecForProviderProfileNameRef;

  /**
   * Selector for a SigningProfile in signer to populate profileName.
   *
   * @schema SigningJobSpecForProvider#profileNameSelector
   */
  readonly profileNameSelector?: SigningJobSpecForProviderProfileNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SigningJobSpecForProvider#region
   */
  readonly region: string;

  /**
   * The S3 bucket that contains the object to sign. See Source below for details.
   *
   * @schema SigningJobSpecForProvider#source
   */
  readonly source?: SigningJobSpecForProviderSource[];

}

/**
 * Converts an object of type 'SigningJobSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecForProvider(obj: SigningJobSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination?.map(y => toJson_SigningJobSpecForProviderDestination(y)),
    'ignoreSigningJobFailure': obj.ignoreSigningJobFailure,
    'profileName': obj.profileName,
    'profileNameRef': toJson_SigningJobSpecForProviderProfileNameRef(obj.profileNameRef),
    'profileNameSelector': toJson_SigningJobSpecForProviderProfileNameSelector(obj.profileNameSelector),
    'region': obj.region,
    'source': obj.source?.map(y => toJson_SigningJobSpecForProviderSource(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SigningJobSpecManagementPolicy
 */
export enum SigningJobSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SigningJobSpecProviderConfigRef
 */
export interface SigningJobSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningJobSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningJobSpecProviderConfigRef#policy
   */
  readonly policy?: SigningJobSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SigningJobSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecProviderConfigRef(obj: SigningJobSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningJobSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SigningJobSpecProviderRef
 */
export interface SigningJobSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningJobSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningJobSpecProviderRef#policy
   */
  readonly policy?: SigningJobSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SigningJobSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecProviderRef(obj: SigningJobSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningJobSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SigningJobSpecPublishConnectionDetailsTo
 */
export interface SigningJobSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SigningJobSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SigningJobSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SigningJobSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SigningJobSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SigningJobSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SigningJobSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecPublishConnectionDetailsTo(obj: SigningJobSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SigningJobSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SigningJobSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SigningJobSpecWriteConnectionSecretToRef
 */
export interface SigningJobSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SigningJobSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SigningJobSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SigningJobSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecWriteConnectionSecretToRef(obj: SigningJobSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SigningJobSpecForProviderDestination
 */
export interface SigningJobSpecForProviderDestination {
  /**
   * A configuration block describing the S3 Source object: See S3 Source below for details.
   *
   * @schema SigningJobSpecForProviderDestination#s3
   */
  readonly s3: SigningJobSpecForProviderDestinationS3[];

}

/**
 * Converts an object of type 'SigningJobSpecForProviderDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecForProviderDestination(obj: SigningJobSpecForProviderDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3': obj.s3?.map(y => toJson_SigningJobSpecForProviderDestinationS3(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a SigningProfile in signer to populate profileName.
 *
 * @schema SigningJobSpecForProviderProfileNameRef
 */
export interface SigningJobSpecForProviderProfileNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningJobSpecForProviderProfileNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningJobSpecForProviderProfileNameRef#policy
   */
  readonly policy?: SigningJobSpecForProviderProfileNameRefPolicy;

}

/**
 * Converts an object of type 'SigningJobSpecForProviderProfileNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecForProviderProfileNameRef(obj: SigningJobSpecForProviderProfileNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningJobSpecForProviderProfileNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a SigningProfile in signer to populate profileName.
 *
 * @schema SigningJobSpecForProviderProfileNameSelector
 */
export interface SigningJobSpecForProviderProfileNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SigningJobSpecForProviderProfileNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SigningJobSpecForProviderProfileNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SigningJobSpecForProviderProfileNameSelector#policy
   */
  readonly policy?: SigningJobSpecForProviderProfileNameSelectorPolicy;

}

/**
 * Converts an object of type 'SigningJobSpecForProviderProfileNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecForProviderProfileNameSelector(obj: SigningJobSpecForProviderProfileNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SigningJobSpecForProviderProfileNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SigningJobSpecForProviderSource
 */
export interface SigningJobSpecForProviderSource {
  /**
   * A configuration block describing the S3 Source object: See S3 Source below for details.
   *
   * @schema SigningJobSpecForProviderSource#s3
   */
  readonly s3: SigningJobSpecForProviderSourceS3[];

}

/**
 * Converts an object of type 'SigningJobSpecForProviderSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecForProviderSource(obj: SigningJobSpecForProviderSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3': obj.s3?.map(y => toJson_SigningJobSpecForProviderSourceS3(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SigningJobSpecProviderConfigRefPolicy
 */
export interface SigningJobSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningJobSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SigningJobSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningJobSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SigningJobSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningJobSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecProviderConfigRefPolicy(obj: SigningJobSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SigningJobSpecProviderRefPolicy
 */
export interface SigningJobSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningJobSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SigningJobSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningJobSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SigningJobSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningJobSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecProviderRefPolicy(obj: SigningJobSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SigningJobSpecPublishConnectionDetailsToConfigRef
 */
export interface SigningJobSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningJobSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningJobSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SigningJobSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SigningJobSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecPublishConnectionDetailsToConfigRef(obj: SigningJobSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningJobSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SigningJobSpecPublishConnectionDetailsToMetadata
 */
export interface SigningJobSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SigningJobSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SigningJobSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SigningJobSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SigningJobSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecPublishConnectionDetailsToMetadata(obj: SigningJobSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SigningJobSpecForProviderDestinationS3
 */
export interface SigningJobSpecForProviderDestinationS3 {
  /**
   * Name of the S3 bucket.
   *
   * @schema SigningJobSpecForProviderDestinationS3#bucket
   */
  readonly bucket: string;

  /**
   * An Amazon S3 object key prefix that you can use to limit signed objects keys to begin with the specified prefix.
   *
   * @schema SigningJobSpecForProviderDestinationS3#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'SigningJobSpecForProviderDestinationS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecForProviderDestinationS3(obj: SigningJobSpecForProviderDestinationS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SigningJobSpecForProviderProfileNameRefPolicy
 */
export interface SigningJobSpecForProviderProfileNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningJobSpecForProviderProfileNameRefPolicy#resolution
   */
  readonly resolution?: SigningJobSpecForProviderProfileNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningJobSpecForProviderProfileNameRefPolicy#resolve
   */
  readonly resolve?: SigningJobSpecForProviderProfileNameRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningJobSpecForProviderProfileNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecForProviderProfileNameRefPolicy(obj: SigningJobSpecForProviderProfileNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SigningJobSpecForProviderProfileNameSelectorPolicy
 */
export interface SigningJobSpecForProviderProfileNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningJobSpecForProviderProfileNameSelectorPolicy#resolution
   */
  readonly resolution?: SigningJobSpecForProviderProfileNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningJobSpecForProviderProfileNameSelectorPolicy#resolve
   */
  readonly resolve?: SigningJobSpecForProviderProfileNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SigningJobSpecForProviderProfileNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecForProviderProfileNameSelectorPolicy(obj: SigningJobSpecForProviderProfileNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SigningJobSpecForProviderSourceS3
 */
export interface SigningJobSpecForProviderSourceS3 {
  /**
   * Name of the S3 bucket.
   *
   * @schema SigningJobSpecForProviderSourceS3#bucket
   */
  readonly bucket: string;

  /**
   * Key name of the object that contains your unsigned code.
   *
   * @schema SigningJobSpecForProviderSourceS3#key
   */
  readonly key: string;

  /**
   * Version of your source image in your version enabled S3 bucket.
   *
   * @schema SigningJobSpecForProviderSourceS3#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'SigningJobSpecForProviderSourceS3' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecForProviderSourceS3(obj: SigningJobSpecForProviderSourceS3 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'key': obj.key,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningJobSpecProviderConfigRefPolicyResolution
 */
export enum SigningJobSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningJobSpecProviderConfigRefPolicyResolve
 */
export enum SigningJobSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningJobSpecProviderRefPolicyResolution
 */
export enum SigningJobSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningJobSpecProviderRefPolicyResolve
 */
export enum SigningJobSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SigningJobSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SigningJobSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningJobSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SigningJobSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningJobSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SigningJobSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningJobSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningJobSpecPublishConnectionDetailsToConfigRefPolicy(obj: SigningJobSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningJobSpecForProviderProfileNameRefPolicyResolution
 */
export enum SigningJobSpecForProviderProfileNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningJobSpecForProviderProfileNameRefPolicyResolve
 */
export enum SigningJobSpecForProviderProfileNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningJobSpecForProviderProfileNameSelectorPolicyResolution
 */
export enum SigningJobSpecForProviderProfileNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningJobSpecForProviderProfileNameSelectorPolicyResolve
 */
export enum SigningJobSpecForProviderProfileNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningJobSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SigningJobSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningJobSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SigningJobSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SigningProfile is the Schema for the SigningProfiles API. Creates a Signer Signing Profile.
 *
 * @schema SigningProfile
 */
export class SigningProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SigningProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'signer.aws.upbound.io/v1beta1',
    kind: 'SigningProfile',
  }

  /**
   * Renders a Kubernetes manifest for "SigningProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SigningProfileProps): any {
    return {
      ...SigningProfile.GVK,
      ...toJson_SigningProfileProps(props),
    };
  }

  /**
   * Defines a "SigningProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SigningProfileProps) {
    super(scope, id, {
      ...SigningProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SigningProfile.GVK,
      ...toJson_SigningProfileProps(resolved),
    };
  }
}

/**
 * SigningProfile is the Schema for the SigningProfiles API. Creates a Signer Signing Profile.
 *
 * @schema SigningProfile
 */
export interface SigningProfileProps {
  /**
   * @schema SigningProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SigningProfileSpec defines the desired state of SigningProfile
   *
   * @schema SigningProfile#spec
   */
  readonly spec: SigningProfileSpec;

}

/**
 * Converts an object of type 'SigningProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileProps(obj: SigningProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SigningProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SigningProfileSpec defines the desired state of SigningProfile
 *
 * @schema SigningProfileSpec
 */
export interface SigningProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SigningProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: SigningProfileSpecDeletionPolicy;

  /**
   * @schema SigningProfileSpec#forProvider
   */
  readonly forProvider: SigningProfileSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SigningProfileSpec#managementPolicy
   */
  readonly managementPolicy?: SigningProfileSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SigningProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: SigningProfileSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SigningProfileSpec#providerRef
   */
  readonly providerRef?: SigningProfileSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SigningProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SigningProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SigningProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SigningProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SigningProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpec(obj: SigningProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SigningProfileSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SigningProfileSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SigningProfileSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SigningProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SigningProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SigningProfileSpecDeletionPolicy
 */
export enum SigningProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SigningProfileSpecForProvider
 */
export interface SigningProfileSpecForProvider {
  /**
   * The ID of the platform that is used by the target signing profile.
   *
   * @schema SigningProfileSpecForProvider#platformId
   */
  readonly platformId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SigningProfileSpecForProvider#region
   */
  readonly region: string;

  /**
   * The validity period for a signing job.
   *
   * @schema SigningProfileSpecForProvider#signatureValidityPeriod
   */
  readonly signatureValidityPeriod?: SigningProfileSpecForProviderSignatureValidityPeriod[];

  /**
   * Key-value map of resource tags.
   *
   * @schema SigningProfileSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SigningProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpecForProvider(obj: SigningProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'platformId': obj.platformId,
    'region': obj.region,
    'signatureValidityPeriod': obj.signatureValidityPeriod?.map(y => toJson_SigningProfileSpecForProviderSignatureValidityPeriod(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SigningProfileSpecManagementPolicy
 */
export enum SigningProfileSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SigningProfileSpecProviderConfigRef
 */
export interface SigningProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningProfileSpecProviderConfigRef#policy
   */
  readonly policy?: SigningProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SigningProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpecProviderConfigRef(obj: SigningProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SigningProfileSpecProviderRef
 */
export interface SigningProfileSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningProfileSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningProfileSpecProviderRef#policy
   */
  readonly policy?: SigningProfileSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SigningProfileSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpecProviderRef(obj: SigningProfileSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningProfileSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SigningProfileSpecPublishConnectionDetailsTo
 */
export interface SigningProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SigningProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SigningProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SigningProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SigningProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SigningProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SigningProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpecPublishConnectionDetailsTo(obj: SigningProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SigningProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SigningProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SigningProfileSpecWriteConnectionSecretToRef
 */
export interface SigningProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SigningProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SigningProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SigningProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpecWriteConnectionSecretToRef(obj: SigningProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SigningProfileSpecForProviderSignatureValidityPeriod
 */
export interface SigningProfileSpecForProviderSignatureValidityPeriod {
  /**
   * @schema SigningProfileSpecForProviderSignatureValidityPeriod#type
   */
  readonly type: string;

  /**
   * @schema SigningProfileSpecForProviderSignatureValidityPeriod#value
   */
  readonly value: number;

}

/**
 * Converts an object of type 'SigningProfileSpecForProviderSignatureValidityPeriod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpecForProviderSignatureValidityPeriod(obj: SigningProfileSpecForProviderSignatureValidityPeriod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SigningProfileSpecProviderConfigRefPolicy
 */
export interface SigningProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SigningProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SigningProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpecProviderConfigRefPolicy(obj: SigningProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SigningProfileSpecProviderRefPolicy
 */
export interface SigningProfileSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningProfileSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SigningProfileSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningProfileSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SigningProfileSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningProfileSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpecProviderRefPolicy(obj: SigningProfileSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SigningProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface SigningProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SigningProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SigningProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpecPublishConnectionDetailsToConfigRef(obj: SigningProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SigningProfileSpecPublishConnectionDetailsToMetadata
 */
export interface SigningProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SigningProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SigningProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SigningProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SigningProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpecPublishConnectionDetailsToMetadata(obj: SigningProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningProfileSpecProviderConfigRefPolicyResolution
 */
export enum SigningProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningProfileSpecProviderConfigRefPolicyResolve
 */
export enum SigningProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningProfileSpecProviderRefPolicyResolution
 */
export enum SigningProfileSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningProfileSpecProviderRefPolicyResolve
 */
export enum SigningProfileSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SigningProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SigningProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SigningProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SigningProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: SigningProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SigningProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SigningProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SigningProfilePermission is the Schema for the SigningProfilePermissions API. Creates a Signer Signing Profile Permission.
 *
 * @schema SigningProfilePermission
 */
export class SigningProfilePermission extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SigningProfilePermission"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'signer.aws.upbound.io/v1beta1',
    kind: 'SigningProfilePermission',
  }

  /**
   * Renders a Kubernetes manifest for "SigningProfilePermission".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SigningProfilePermissionProps): any {
    return {
      ...SigningProfilePermission.GVK,
      ...toJson_SigningProfilePermissionProps(props),
    };
  }

  /**
   * Defines a "SigningProfilePermission" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SigningProfilePermissionProps) {
    super(scope, id, {
      ...SigningProfilePermission.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SigningProfilePermission.GVK,
      ...toJson_SigningProfilePermissionProps(resolved),
    };
  }
}

/**
 * SigningProfilePermission is the Schema for the SigningProfilePermissions API. Creates a Signer Signing Profile Permission.
 *
 * @schema SigningProfilePermission
 */
export interface SigningProfilePermissionProps {
  /**
   * @schema SigningProfilePermission#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SigningProfilePermissionSpec defines the desired state of SigningProfilePermission
   *
   * @schema SigningProfilePermission#spec
   */
  readonly spec: SigningProfilePermissionSpec;

}

/**
 * Converts an object of type 'SigningProfilePermissionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionProps(obj: SigningProfilePermissionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SigningProfilePermissionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SigningProfilePermissionSpec defines the desired state of SigningProfilePermission
 *
 * @schema SigningProfilePermissionSpec
 */
export interface SigningProfilePermissionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SigningProfilePermissionSpec#deletionPolicy
   */
  readonly deletionPolicy?: SigningProfilePermissionSpecDeletionPolicy;

  /**
   * @schema SigningProfilePermissionSpec#forProvider
   */
  readonly forProvider: SigningProfilePermissionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SigningProfilePermissionSpec#managementPolicy
   */
  readonly managementPolicy?: SigningProfilePermissionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SigningProfilePermissionSpec#providerConfigRef
   */
  readonly providerConfigRef?: SigningProfilePermissionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SigningProfilePermissionSpec#providerRef
   */
  readonly providerRef?: SigningProfilePermissionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SigningProfilePermissionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SigningProfilePermissionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SigningProfilePermissionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SigningProfilePermissionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpec(obj: SigningProfilePermissionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SigningProfilePermissionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SigningProfilePermissionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SigningProfilePermissionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SigningProfilePermissionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SigningProfilePermissionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SigningProfilePermissionSpecDeletionPolicy
 */
export enum SigningProfilePermissionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SigningProfilePermissionSpecForProvider
 */
export interface SigningProfilePermissionSpecForProvider {
  /**
   * An AWS Signer action permitted as part of cross-account permissions. Valid values: signer:StartSigningJob, signer:GetSigningProfile, or signer:RevokeSignature.
   *
   * @schema SigningProfilePermissionSpecForProvider#action
   */
  readonly action?: string;

  /**
   * The AWS principal to be granted a cross-account permission.
   *
   * @schema SigningProfilePermissionSpecForProvider#principal
   */
  readonly principal?: string;

  /**
   * Name of the signing profile to add the cross-account permissions.
   *
   * @schema SigningProfilePermissionSpecForProvider#profileName
   */
  readonly profileName?: string;

  /**
   * Reference to a SigningProfile in signer to populate profileName.
   *
   * @schema SigningProfilePermissionSpecForProvider#profileNameRef
   */
  readonly profileNameRef?: SigningProfilePermissionSpecForProviderProfileNameRef;

  /**
   * Selector for a SigningProfile in signer to populate profileName.
   *
   * @schema SigningProfilePermissionSpecForProvider#profileNameSelector
   */
  readonly profileNameSelector?: SigningProfilePermissionSpecForProviderProfileNameSelector;

  /**
   * The signing profile version that a permission applies to.
   *
   * @schema SigningProfilePermissionSpecForProvider#profileVersion
   */
  readonly profileVersion?: string;

  /**
   * Reference to a SigningProfile in signer to populate profileVersion.
   *
   * @schema SigningProfilePermissionSpecForProvider#profileVersionRef
   */
  readonly profileVersionRef?: SigningProfilePermissionSpecForProviderProfileVersionRef;

  /**
   * Selector for a SigningProfile in signer to populate profileVersion.
   *
   * @schema SigningProfilePermissionSpecForProvider#profileVersionSelector
   */
  readonly profileVersionSelector?: SigningProfilePermissionSpecForProviderProfileVersionSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SigningProfilePermissionSpecForProvider#region
   */
  readonly region: string;

  /**
   * A unique statement identifier.
   *
   * @schema SigningProfilePermissionSpecForProvider#statementId
   */
  readonly statementId?: string;

  /**
   * A statement identifier prefix. Conflicts with statement_id.
   *
   * @schema SigningProfilePermissionSpecForProvider#statementIdPrefix
   */
  readonly statementIdPrefix?: string;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecForProvider(obj: SigningProfilePermissionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'principal': obj.principal,
    'profileName': obj.profileName,
    'profileNameRef': toJson_SigningProfilePermissionSpecForProviderProfileNameRef(obj.profileNameRef),
    'profileNameSelector': toJson_SigningProfilePermissionSpecForProviderProfileNameSelector(obj.profileNameSelector),
    'profileVersion': obj.profileVersion,
    'profileVersionRef': toJson_SigningProfilePermissionSpecForProviderProfileVersionRef(obj.profileVersionRef),
    'profileVersionSelector': toJson_SigningProfilePermissionSpecForProviderProfileVersionSelector(obj.profileVersionSelector),
    'region': obj.region,
    'statementId': obj.statementId,
    'statementIdPrefix': obj.statementIdPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SigningProfilePermissionSpecManagementPolicy
 */
export enum SigningProfilePermissionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SigningProfilePermissionSpecProviderConfigRef
 */
export interface SigningProfilePermissionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningProfilePermissionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningProfilePermissionSpecProviderConfigRef#policy
   */
  readonly policy?: SigningProfilePermissionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecProviderConfigRef(obj: SigningProfilePermissionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningProfilePermissionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SigningProfilePermissionSpecProviderRef
 */
export interface SigningProfilePermissionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningProfilePermissionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningProfilePermissionSpecProviderRef#policy
   */
  readonly policy?: SigningProfilePermissionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecProviderRef(obj: SigningProfilePermissionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningProfilePermissionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SigningProfilePermissionSpecPublishConnectionDetailsTo
 */
export interface SigningProfilePermissionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SigningProfilePermissionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SigningProfilePermissionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SigningProfilePermissionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SigningProfilePermissionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SigningProfilePermissionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecPublishConnectionDetailsTo(obj: SigningProfilePermissionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SigningProfilePermissionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SigningProfilePermissionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SigningProfilePermissionSpecWriteConnectionSecretToRef
 */
export interface SigningProfilePermissionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SigningProfilePermissionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SigningProfilePermissionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecWriteConnectionSecretToRef(obj: SigningProfilePermissionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a SigningProfile in signer to populate profileName.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileNameRef
 */
export interface SigningProfilePermissionSpecForProviderProfileNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileNameRef#policy
   */
  readonly policy?: SigningProfilePermissionSpecForProviderProfileNameRefPolicy;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecForProviderProfileNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecForProviderProfileNameRef(obj: SigningProfilePermissionSpecForProviderProfileNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningProfilePermissionSpecForProviderProfileNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a SigningProfile in signer to populate profileName.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileNameSelector
 */
export interface SigningProfilePermissionSpecForProviderProfileNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileNameSelector#policy
   */
  readonly policy?: SigningProfilePermissionSpecForProviderProfileNameSelectorPolicy;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecForProviderProfileNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecForProviderProfileNameSelector(obj: SigningProfilePermissionSpecForProviderProfileNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SigningProfilePermissionSpecForProviderProfileNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a SigningProfile in signer to populate profileVersion.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileVersionRef
 */
export interface SigningProfilePermissionSpecForProviderProfileVersionRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileVersionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileVersionRef#policy
   */
  readonly policy?: SigningProfilePermissionSpecForProviderProfileVersionRefPolicy;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecForProviderProfileVersionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecForProviderProfileVersionRef(obj: SigningProfilePermissionSpecForProviderProfileVersionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningProfilePermissionSpecForProviderProfileVersionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a SigningProfile in signer to populate profileVersion.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileVersionSelector
 */
export interface SigningProfilePermissionSpecForProviderProfileVersionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileVersionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileVersionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileVersionSelector#policy
   */
  readonly policy?: SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicy;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecForProviderProfileVersionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecForProviderProfileVersionSelector(obj: SigningProfilePermissionSpecForProviderProfileVersionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SigningProfilePermissionSpecProviderConfigRefPolicy
 */
export interface SigningProfilePermissionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningProfilePermissionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SigningProfilePermissionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningProfilePermissionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SigningProfilePermissionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecProviderConfigRefPolicy(obj: SigningProfilePermissionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SigningProfilePermissionSpecProviderRefPolicy
 */
export interface SigningProfilePermissionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningProfilePermissionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SigningProfilePermissionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningProfilePermissionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SigningProfilePermissionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecProviderRefPolicy(obj: SigningProfilePermissionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SigningProfilePermissionSpecPublishConnectionDetailsToConfigRef
 */
export interface SigningProfilePermissionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SigningProfilePermissionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SigningProfilePermissionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecPublishConnectionDetailsToConfigRef(obj: SigningProfilePermissionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SigningProfilePermissionSpecPublishConnectionDetailsToMetadata
 */
export interface SigningProfilePermissionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SigningProfilePermissionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SigningProfilePermissionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SigningProfilePermissionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecPublishConnectionDetailsToMetadata(obj: SigningProfilePermissionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileNameRefPolicy
 */
export interface SigningProfilePermissionSpecForProviderProfileNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileNameRefPolicy#resolution
   */
  readonly resolution?: SigningProfilePermissionSpecForProviderProfileNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileNameRefPolicy#resolve
   */
  readonly resolve?: SigningProfilePermissionSpecForProviderProfileNameRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecForProviderProfileNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecForProviderProfileNameRefPolicy(obj: SigningProfilePermissionSpecForProviderProfileNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileNameSelectorPolicy
 */
export interface SigningProfilePermissionSpecForProviderProfileNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileNameSelectorPolicy#resolution
   */
  readonly resolution?: SigningProfilePermissionSpecForProviderProfileNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileNameSelectorPolicy#resolve
   */
  readonly resolve?: SigningProfilePermissionSpecForProviderProfileNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecForProviderProfileNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecForProviderProfileNameSelectorPolicy(obj: SigningProfilePermissionSpecForProviderProfileNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileVersionRefPolicy
 */
export interface SigningProfilePermissionSpecForProviderProfileVersionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileVersionRefPolicy#resolution
   */
  readonly resolution?: SigningProfilePermissionSpecForProviderProfileVersionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileVersionRefPolicy#resolve
   */
  readonly resolve?: SigningProfilePermissionSpecForProviderProfileVersionRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecForProviderProfileVersionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecForProviderProfileVersionRefPolicy(obj: SigningProfilePermissionSpecForProviderProfileVersionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicy
 */
export interface SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicy#resolution
   */
  readonly resolution?: SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicy#resolve
   */
  readonly resolve?: SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicy(obj: SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningProfilePermissionSpecProviderConfigRefPolicyResolution
 */
export enum SigningProfilePermissionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningProfilePermissionSpecProviderConfigRefPolicyResolve
 */
export enum SigningProfilePermissionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningProfilePermissionSpecProviderRefPolicyResolution
 */
export enum SigningProfilePermissionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningProfilePermissionSpecProviderRefPolicyResolve
 */
export enum SigningProfilePermissionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicy(obj: SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileNameRefPolicyResolution
 */
export enum SigningProfilePermissionSpecForProviderProfileNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileNameRefPolicyResolve
 */
export enum SigningProfilePermissionSpecForProviderProfileNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileNameSelectorPolicyResolution
 */
export enum SigningProfilePermissionSpecForProviderProfileNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileNameSelectorPolicyResolve
 */
export enum SigningProfilePermissionSpecForProviderProfileNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileVersionRefPolicyResolution
 */
export enum SigningProfilePermissionSpecForProviderProfileVersionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileVersionRefPolicyResolve
 */
export enum SigningProfilePermissionSpecForProviderProfileVersionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicyResolution
 */
export enum SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicyResolve
 */
export enum SigningProfilePermissionSpecForProviderProfileVersionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SigningProfilePermissionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

