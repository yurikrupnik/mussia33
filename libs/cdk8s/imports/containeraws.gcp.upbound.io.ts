// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Cluster is the Schema for the Clusters API. An Anthos cluster running on AWS.
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'containeraws.gcp.upbound.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API. An Anthos cluster running on AWS.
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClusterSpec#initProvider
   */
  readonly initProvider?: ClusterSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * Optional. Annotations on the cluster. This field has the same restrictions as Kubernetes annotations. The total size of all keys and values combined is limited to 256k. Key can have 2 segments: prefix  and name , separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between.
   *
   * @schema ClusterSpecForProvider#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Configuration related to the cluster RBAC settings.
   *
   * @schema ClusterSpecForProvider#authorization
   */
  readonly authorization?: ClusterSpecForProviderAuthorization[];

  /**
   * The AWS region where the cluster runs. Each Google Cloud region supports a subset of nearby AWS regions. You can call to list all supported AWS regions within a given Google Cloud region.
   *
   * @schema ClusterSpecForProvider#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * Configuration related to the cluster control plane.
   *
   * @schema ClusterSpecForProvider#controlPlane
   */
  readonly controlPlane?: ClusterSpecForProviderControlPlane[];

  /**
   * Optional. A human readable description of this cluster. Cannot be longer than 255 UTF-8 encoded bytes.
   *
   * @schema ClusterSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Fleet configuration.
   *
   * @schema ClusterSpecForProvider#fleet
   */
  readonly fleet?: ClusterSpecForProviderFleet[];

  /**
   * The location for the resource
   *
   * @schema ClusterSpecForProvider#location
   */
  readonly location: string;

  /**
   * Cluster-wide networking configuration.
   *
   * @schema ClusterSpecForProvider#networking
   */
  readonly networking?: ClusterSpecForProviderNetworking[];

  /**
   * The project for the resource
   *
   * @schema ClusterSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'authorization': obj.authorization?.map(y => toJson_ClusterSpecForProviderAuthorization(y)),
    'awsRegion': obj.awsRegion,
    'controlPlane': obj.controlPlane?.map(y => toJson_ClusterSpecForProviderControlPlane(y)),
    'description': obj.description,
    'fleet': obj.fleet?.map(y => toJson_ClusterSpecForProviderFleet(y)),
    'location': obj.location,
    'networking': obj.networking?.map(y => toJson_ClusterSpecForProviderNetworking(y)),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClusterSpecInitProvider
 */
export interface ClusterSpecInitProvider {
  /**
   * Optional. Annotations on the cluster. This field has the same restrictions as Kubernetes annotations. The total size of all keys and values combined is limited to 256k. Key can have 2 segments: prefix  and name , separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between.
   *
   * @schema ClusterSpecInitProvider#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Configuration related to the cluster RBAC settings.
   *
   * @schema ClusterSpecInitProvider#authorization
   */
  readonly authorization?: ClusterSpecInitProviderAuthorization[];

  /**
   * The AWS region where the cluster runs. Each Google Cloud region supports a subset of nearby AWS regions. You can call to list all supported AWS regions within a given Google Cloud region.
   *
   * @schema ClusterSpecInitProvider#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * Configuration related to the cluster control plane.
   *
   * @schema ClusterSpecInitProvider#controlPlane
   */
  readonly controlPlane?: ClusterSpecInitProviderControlPlane[];

  /**
   * Optional. A human readable description of this cluster. Cannot be longer than 255 UTF-8 encoded bytes.
   *
   * @schema ClusterSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Fleet configuration.
   *
   * @schema ClusterSpecInitProvider#fleet
   */
  readonly fleet?: ClusterSpecInitProviderFleet[];

  /**
   * Cluster-wide networking configuration.
   *
   * @schema ClusterSpecInitProvider#networking
   */
  readonly networking?: ClusterSpecInitProviderNetworking[];

  /**
   * The project for the resource
   *
   * @schema ClusterSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProvider(obj: ClusterSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'authorization': obj.authorization?.map(y => toJson_ClusterSpecInitProviderAuthorization(y)),
    'awsRegion': obj.awsRegion,
    'controlPlane': obj.controlPlane?.map(y => toJson_ClusterSpecInitProviderControlPlane(y)),
    'description': obj.description,
    'fleet': obj.fleet?.map(y => toJson_ClusterSpecInitProviderFleet(y)),
    'networking': obj.networking?.map(y => toJson_ClusterSpecInitProviderNetworking(y)),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterSpecManagementPolicies
 */
export enum ClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderAuthorization
 */
export interface ClusterSpecForProviderAuthorization {
  /**
   * Users to perform operations as a cluster admin. A managed ClusterRoleBinding will be created to grant the cluster-admin ClusterRole to the users. Up to ten admin users can be provided. For more info on RBAC, see https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
   *
   * @schema ClusterSpecForProviderAuthorization#adminUsers
   */
  readonly adminUsers?: ClusterSpecForProviderAuthorizationAdminUsers[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderAuthorization(obj: ClusterSpecForProviderAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminUsers': obj.adminUsers?.map(y => toJson_ClusterSpecForProviderAuthorizationAdminUsers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderControlPlane
 */
export interface ClusterSpecForProviderControlPlane {
  /**
   * Authentication configuration for management of AWS resources.
   *
   * @schema ClusterSpecForProviderControlPlane#awsServicesAuthentication
   */
  readonly awsServicesAuthentication?: ClusterSpecForProviderControlPlaneAwsServicesAuthentication[];

  /**
   * The ARN of the AWS KMS key used to encrypt cluster configuration.
   *
   * @schema ClusterSpecForProviderControlPlane#configEncryption
   */
  readonly configEncryption?: ClusterSpecForProviderControlPlaneConfigEncryption[];

  /**
   * The ARN of the AWS KMS key used to encrypt cluster secrets.
   *
   * @schema ClusterSpecForProviderControlPlane#databaseEncryption
   */
  readonly databaseEncryption?: ClusterSpecForProviderControlPlaneDatabaseEncryption[];

  /**
   * The name of the AWS IAM instance pofile to assign to each control plane replica.
   *
   * @schema ClusterSpecForProviderControlPlane#iamInstanceProfile
   */
  readonly iamInstanceProfile?: string;

  /**
   * Optional. The AWS instance type. When unspecified, it defaults to m5.large.
   *
   * @schema ClusterSpecForProviderControlPlane#instanceType
   */
  readonly instanceType?: string;

  /**
   * Optional. Configuration related to the main volume provisioned for each control plane replica. The main volume is in charge of storing all of the cluster's etcd state. Volumes will be provisioned in the availability zone associated with the corresponding subnet. When unspecified, it defaults to 8 GiB with the GP2 volume type.
   *
   * @schema ClusterSpecForProviderControlPlane#mainVolume
   */
  readonly mainVolume?: ClusterSpecForProviderControlPlaneMainVolume[];

  /**
   * Proxy configuration for outbound HTTP(S) traffic.
   *
   * @schema ClusterSpecForProviderControlPlane#proxyConfig
   */
  readonly proxyConfig?: ClusterSpecForProviderControlPlaneProxyConfig[];

  /**
   * Optional. Configuration related to the root volume provisioned for each control plane replica. Volumes will be provisioned in the availability zone associated with the corresponding subnet. When unspecified, it defaults to 32 GiB with the GP2 volume type.
   *
   * @schema ClusterSpecForProviderControlPlane#rootVolume
   */
  readonly rootVolume?: ClusterSpecForProviderControlPlaneRootVolume[];

  /**
   * Optional. The IDs of additional security groups to add to control plane replicas. The Anthos Multi-Cloud API will automatically create and manage security groups with the minimum rules needed for a functioning cluster.
   *
   * @schema ClusterSpecForProviderControlPlane#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * Optional. SSH configuration for how to access the underlying control plane machines.
   *
   * @schema ClusterSpecForProviderControlPlane#sshConfig
   */
  readonly sshConfig?: ClusterSpecForProviderControlPlaneSshConfig[];

  /**
   * The list of subnets where control plane replicas will run. A replica will be provisioned on each subnet and up to three values can be provided. Each subnet must be in a different AWS Availability Zone (AZ).
   *
   * @schema ClusterSpecForProviderControlPlane#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Optional. A set of AWS resource tags to propagate to all underlying managed AWS resources. Specify at most 50 pairs containing alphanumerics, spaces, and symbols (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to 255 Unicode characters.
   *
   * @schema ClusterSpecForProviderControlPlane#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The Kubernetes version to run on control plane replicas (e.g. 1.19.10-gke.1000). You can list all supported versions on a given Google Cloud region by calling .
   *
   * @schema ClusterSpecForProviderControlPlane#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderControlPlane' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderControlPlane(obj: ClusterSpecForProviderControlPlane | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsServicesAuthentication': obj.awsServicesAuthentication?.map(y => toJson_ClusterSpecForProviderControlPlaneAwsServicesAuthentication(y)),
    'configEncryption': obj.configEncryption?.map(y => toJson_ClusterSpecForProviderControlPlaneConfigEncryption(y)),
    'databaseEncryption': obj.databaseEncryption?.map(y => toJson_ClusterSpecForProviderControlPlaneDatabaseEncryption(y)),
    'iamInstanceProfile': obj.iamInstanceProfile,
    'instanceType': obj.instanceType,
    'mainVolume': obj.mainVolume?.map(y => toJson_ClusterSpecForProviderControlPlaneMainVolume(y)),
    'proxyConfig': obj.proxyConfig?.map(y => toJson_ClusterSpecForProviderControlPlaneProxyConfig(y)),
    'rootVolume': obj.rootVolume?.map(y => toJson_ClusterSpecForProviderControlPlaneRootVolume(y)),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'sshConfig': obj.sshConfig?.map(y => toJson_ClusterSpecForProviderControlPlaneSshConfig(y)),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderFleet
 */
export interface ClusterSpecForProviderFleet {
  /**
   * The number of the Fleet host project where this cluster will be registered.
   *
   * @schema ClusterSpecForProviderFleet#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderFleet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderFleet(obj: ClusterSpecForProviderFleet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderNetworking
 */
export interface ClusterSpecForProviderNetworking {
  /**
   * Disable the per node pool subnet security group rules on the control plane security group. When set to true, you must also provide one or more security groups that ensure node pools are able to send requests to the control plane on TCP/443 and TCP/8132. Failure to do so may result in unavailable node pools.
   *
   * @schema ClusterSpecForProviderNetworking#perNodePoolSgRulesDisabled
   */
  readonly perNodePoolSgRulesDisabled?: boolean;

  /**
   * All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
   *
   * @schema ClusterSpecForProviderNetworking#podAddressCidrBlocks
   */
  readonly podAddressCidrBlocks?: string[];

  /**
   * All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
   *
   * @schema ClusterSpecForProviderNetworking#serviceAddressCidrBlocks
   */
  readonly serviceAddressCidrBlocks?: string[];

  /**
   * The VPC associated with the cluster. All component clusters (i.e. control plane and node pools) run on a single VPC. This field cannot be changed after creation.
   *
   * @schema ClusterSpecForProviderNetworking#vpcId
   */
  readonly vpcId?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderNetworking' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderNetworking(obj: ClusterSpecForProviderNetworking | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perNodePoolSgRulesDisabled': obj.perNodePoolSgRulesDisabled,
    'podAddressCidrBlocks': obj.podAddressCidrBlocks?.map(y => y),
    'serviceAddressCidrBlocks': obj.serviceAddressCidrBlocks?.map(y => y),
    'vpcId': obj.vpcId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderAuthorization
 */
export interface ClusterSpecInitProviderAuthorization {
  /**
   * Users to perform operations as a cluster admin. A managed ClusterRoleBinding will be created to grant the cluster-admin ClusterRole to the users. Up to ten admin users can be provided. For more info on RBAC, see https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
   *
   * @schema ClusterSpecInitProviderAuthorization#adminUsers
   */
  readonly adminUsers?: ClusterSpecInitProviderAuthorizationAdminUsers[];

}

/**
 * Converts an object of type 'ClusterSpecInitProviderAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderAuthorization(obj: ClusterSpecInitProviderAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminUsers': obj.adminUsers?.map(y => toJson_ClusterSpecInitProviderAuthorizationAdminUsers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderControlPlane
 */
export interface ClusterSpecInitProviderControlPlane {
  /**
   * Authentication configuration for management of AWS resources.
   *
   * @schema ClusterSpecInitProviderControlPlane#awsServicesAuthentication
   */
  readonly awsServicesAuthentication?: ClusterSpecInitProviderControlPlaneAwsServicesAuthentication[];

  /**
   * The ARN of the AWS KMS key used to encrypt cluster configuration.
   *
   * @schema ClusterSpecInitProviderControlPlane#configEncryption
   */
  readonly configEncryption?: ClusterSpecInitProviderControlPlaneConfigEncryption[];

  /**
   * The ARN of the AWS KMS key used to encrypt cluster secrets.
   *
   * @schema ClusterSpecInitProviderControlPlane#databaseEncryption
   */
  readonly databaseEncryption?: ClusterSpecInitProviderControlPlaneDatabaseEncryption[];

  /**
   * The name of the AWS IAM instance pofile to assign to each control plane replica.
   *
   * @schema ClusterSpecInitProviderControlPlane#iamInstanceProfile
   */
  readonly iamInstanceProfile?: string;

  /**
   * Optional. The AWS instance type. When unspecified, it defaults to m5.large.
   *
   * @schema ClusterSpecInitProviderControlPlane#instanceType
   */
  readonly instanceType?: string;

  /**
   * Optional. Configuration related to the main volume provisioned for each control plane replica. The main volume is in charge of storing all of the cluster's etcd state. Volumes will be provisioned in the availability zone associated with the corresponding subnet. When unspecified, it defaults to 8 GiB with the GP2 volume type.
   *
   * @schema ClusterSpecInitProviderControlPlane#mainVolume
   */
  readonly mainVolume?: ClusterSpecInitProviderControlPlaneMainVolume[];

  /**
   * Proxy configuration for outbound HTTP(S) traffic.
   *
   * @schema ClusterSpecInitProviderControlPlane#proxyConfig
   */
  readonly proxyConfig?: ClusterSpecInitProviderControlPlaneProxyConfig[];

  /**
   * Optional. Configuration related to the root volume provisioned for each control plane replica. Volumes will be provisioned in the availability zone associated with the corresponding subnet. When unspecified, it defaults to 32 GiB with the GP2 volume type.
   *
   * @schema ClusterSpecInitProviderControlPlane#rootVolume
   */
  readonly rootVolume?: ClusterSpecInitProviderControlPlaneRootVolume[];

  /**
   * Optional. The IDs of additional security groups to add to control plane replicas. The Anthos Multi-Cloud API will automatically create and manage security groups with the minimum rules needed for a functioning cluster.
   *
   * @schema ClusterSpecInitProviderControlPlane#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * Optional. SSH configuration for how to access the underlying control plane machines.
   *
   * @schema ClusterSpecInitProviderControlPlane#sshConfig
   */
  readonly sshConfig?: ClusterSpecInitProviderControlPlaneSshConfig[];

  /**
   * The list of subnets where control plane replicas will run. A replica will be provisioned on each subnet and up to three values can be provided. Each subnet must be in a different AWS Availability Zone (AZ).
   *
   * @schema ClusterSpecInitProviderControlPlane#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Optional. A set of AWS resource tags to propagate to all underlying managed AWS resources. Specify at most 50 pairs containing alphanumerics, spaces, and symbols (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to 255 Unicode characters.
   *
   * @schema ClusterSpecInitProviderControlPlane#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The Kubernetes version to run on control plane replicas (e.g. 1.19.10-gke.1000). You can list all supported versions on a given Google Cloud region by calling .
   *
   * @schema ClusterSpecInitProviderControlPlane#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderControlPlane' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderControlPlane(obj: ClusterSpecInitProviderControlPlane | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsServicesAuthentication': obj.awsServicesAuthentication?.map(y => toJson_ClusterSpecInitProviderControlPlaneAwsServicesAuthentication(y)),
    'configEncryption': obj.configEncryption?.map(y => toJson_ClusterSpecInitProviderControlPlaneConfigEncryption(y)),
    'databaseEncryption': obj.databaseEncryption?.map(y => toJson_ClusterSpecInitProviderControlPlaneDatabaseEncryption(y)),
    'iamInstanceProfile': obj.iamInstanceProfile,
    'instanceType': obj.instanceType,
    'mainVolume': obj.mainVolume?.map(y => toJson_ClusterSpecInitProviderControlPlaneMainVolume(y)),
    'proxyConfig': obj.proxyConfig?.map(y => toJson_ClusterSpecInitProviderControlPlaneProxyConfig(y)),
    'rootVolume': obj.rootVolume?.map(y => toJson_ClusterSpecInitProviderControlPlaneRootVolume(y)),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'sshConfig': obj.sshConfig?.map(y => toJson_ClusterSpecInitProviderControlPlaneSshConfig(y)),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderFleet
 */
export interface ClusterSpecInitProviderFleet {
  /**
   * The number of the Fleet host project where this cluster will be registered.
   *
   * @schema ClusterSpecInitProviderFleet#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderFleet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderFleet(obj: ClusterSpecInitProviderFleet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderNetworking
 */
export interface ClusterSpecInitProviderNetworking {
  /**
   * Disable the per node pool subnet security group rules on the control plane security group. When set to true, you must also provide one or more security groups that ensure node pools are able to send requests to the control plane on TCP/443 and TCP/8132. Failure to do so may result in unavailable node pools.
   *
   * @schema ClusterSpecInitProviderNetworking#perNodePoolSgRulesDisabled
   */
  readonly perNodePoolSgRulesDisabled?: boolean;

  /**
   * All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
   *
   * @schema ClusterSpecInitProviderNetworking#podAddressCidrBlocks
   */
  readonly podAddressCidrBlocks?: string[];

  /**
   * All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
   *
   * @schema ClusterSpecInitProviderNetworking#serviceAddressCidrBlocks
   */
  readonly serviceAddressCidrBlocks?: string[];

  /**
   * The VPC associated with the cluster. All component clusters (i.e. control plane and node pools) run on a single VPC. This field cannot be changed after creation.
   *
   * @schema ClusterSpecInitProviderNetworking#vpcId
   */
  readonly vpcId?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderNetworking' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderNetworking(obj: ClusterSpecInitProviderNetworking | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'perNodePoolSgRulesDisabled': obj.perNodePoolSgRulesDisabled,
    'podAddressCidrBlocks': obj.podAddressCidrBlocks?.map(y => y),
    'serviceAddressCidrBlocks': obj.serviceAddressCidrBlocks?.map(y => y),
    'vpcId': obj.vpcId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderAuthorizationAdminUsers
 */
export interface ClusterSpecForProviderAuthorizationAdminUsers {
  /**
   * The name of the user, e.g. my-gcp-id@gmail.com.
   *
   * @schema ClusterSpecForProviderAuthorizationAdminUsers#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderAuthorizationAdminUsers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderAuthorizationAdminUsers(obj: ClusterSpecForProviderAuthorizationAdminUsers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderControlPlaneAwsServicesAuthentication
 */
export interface ClusterSpecForProviderControlPlaneAwsServicesAuthentication {
  /**
   * The Amazon Resource Name (ARN) of the role that the Anthos Multi-Cloud API will assume when managing AWS resources on your account.
   *
   * @schema ClusterSpecForProviderControlPlaneAwsServicesAuthentication#roleArn
   */
  readonly roleArn?: string;

  /**
   * Optional. An identifier for the assumed role session. When unspecified, it defaults to multicloud-service-agent.
   *
   * @schema ClusterSpecForProviderControlPlaneAwsServicesAuthentication#roleSessionName
   */
  readonly roleSessionName?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderControlPlaneAwsServicesAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderControlPlaneAwsServicesAuthentication(obj: ClusterSpecForProviderControlPlaneAwsServicesAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleArn': obj.roleArn,
    'roleSessionName': obj.roleSessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderControlPlaneConfigEncryption
 */
export interface ClusterSpecForProviderControlPlaneConfigEncryption {
  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema ClusterSpecForProviderControlPlaneConfigEncryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderControlPlaneConfigEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderControlPlaneConfigEncryption(obj: ClusterSpecForProviderControlPlaneConfigEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyArn': obj.kmsKeyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderControlPlaneDatabaseEncryption
 */
export interface ClusterSpecForProviderControlPlaneDatabaseEncryption {
  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema ClusterSpecForProviderControlPlaneDatabaseEncryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderControlPlaneDatabaseEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderControlPlaneDatabaseEncryption(obj: ClusterSpecForProviderControlPlaneDatabaseEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyArn': obj.kmsKeyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderControlPlaneMainVolume
 */
export interface ClusterSpecForProviderControlPlaneMainVolume {
  /**
   * Optional. The number of I/O operations per second (IOPS) to provision for GP3 volume.
   *
   * @schema ClusterSpecForProviderControlPlaneMainVolume#iops
   */
  readonly iops?: number;

  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema ClusterSpecForProviderControlPlaneMainVolume#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Optional. The size of the volume, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
   *
   * @schema ClusterSpecForProviderControlPlaneMainVolume#sizeGib
   */
  readonly sizeGib?: number;

  /**
   * Optional. The throughput to provision for the volume, in MiB/s. Only valid if the volume type is GP3.
   *
   * @schema ClusterSpecForProviderControlPlaneMainVolume#throughput
   */
  readonly throughput?: number;

  /**
   * Optional. Type of the EBS volume. When unspecified, it defaults to GP2 volume. Possible values: VOLUME_TYPE_UNSPECIFIED, GP2, GP3
   *
   * @schema ClusterSpecForProviderControlPlaneMainVolume#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderControlPlaneMainVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderControlPlaneMainVolume(obj: ClusterSpecForProviderControlPlaneMainVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iops': obj.iops,
    'kmsKeyArn': obj.kmsKeyArn,
    'sizeGib': obj.sizeGib,
    'throughput': obj.throughput,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderControlPlaneProxyConfig
 */
export interface ClusterSpecForProviderControlPlaneProxyConfig {
  /**
   * The ARN of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
   *
   * @schema ClusterSpecForProviderControlPlaneProxyConfig#secretArn
   */
  readonly secretArn?: string;

  /**
   * The version string of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
   *
   * @schema ClusterSpecForProviderControlPlaneProxyConfig#secretVersion
   */
  readonly secretVersion?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderControlPlaneProxyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderControlPlaneProxyConfig(obj: ClusterSpecForProviderControlPlaneProxyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretArn': obj.secretArn,
    'secretVersion': obj.secretVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderControlPlaneRootVolume
 */
export interface ClusterSpecForProviderControlPlaneRootVolume {
  /**
   * Optional. The number of I/O operations per second (IOPS) to provision for GP3 volume.
   *
   * @schema ClusterSpecForProviderControlPlaneRootVolume#iops
   */
  readonly iops?: number;

  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema ClusterSpecForProviderControlPlaneRootVolume#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Optional. The size of the volume, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
   *
   * @schema ClusterSpecForProviderControlPlaneRootVolume#sizeGib
   */
  readonly sizeGib?: number;

  /**
   * Optional. The throughput to provision for the volume, in MiB/s. Only valid if the volume type is GP3.
   *
   * @schema ClusterSpecForProviderControlPlaneRootVolume#throughput
   */
  readonly throughput?: number;

  /**
   * Optional. Type of the EBS volume. When unspecified, it defaults to GP2 volume. Possible values: VOLUME_TYPE_UNSPECIFIED, GP2, GP3
   *
   * @schema ClusterSpecForProviderControlPlaneRootVolume#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderControlPlaneRootVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderControlPlaneRootVolume(obj: ClusterSpecForProviderControlPlaneRootVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iops': obj.iops,
    'kmsKeyArn': obj.kmsKeyArn,
    'sizeGib': obj.sizeGib,
    'throughput': obj.throughput,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderControlPlaneSshConfig
 */
export interface ClusterSpecForProviderControlPlaneSshConfig {
  /**
   * The name of the EC2 key pair used to login into cluster machines.
   *
   * @schema ClusterSpecForProviderControlPlaneSshConfig#ec2KeyPair
   */
  readonly ec2KeyPair?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderControlPlaneSshConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderControlPlaneSshConfig(obj: ClusterSpecForProviderControlPlaneSshConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ec2KeyPair': obj.ec2KeyPair,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderAuthorizationAdminUsers
 */
export interface ClusterSpecInitProviderAuthorizationAdminUsers {
  /**
   * The name of the user, e.g. my-gcp-id@gmail.com.
   *
   * @schema ClusterSpecInitProviderAuthorizationAdminUsers#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderAuthorizationAdminUsers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderAuthorizationAdminUsers(obj: ClusterSpecInitProviderAuthorizationAdminUsers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderControlPlaneAwsServicesAuthentication
 */
export interface ClusterSpecInitProviderControlPlaneAwsServicesAuthentication {
  /**
   * The Amazon Resource Name (ARN) of the role that the Anthos Multi-Cloud API will assume when managing AWS resources on your account.
   *
   * @schema ClusterSpecInitProviderControlPlaneAwsServicesAuthentication#roleArn
   */
  readonly roleArn?: string;

  /**
   * Optional. An identifier for the assumed role session. When unspecified, it defaults to multicloud-service-agent.
   *
   * @schema ClusterSpecInitProviderControlPlaneAwsServicesAuthentication#roleSessionName
   */
  readonly roleSessionName?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderControlPlaneAwsServicesAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderControlPlaneAwsServicesAuthentication(obj: ClusterSpecInitProviderControlPlaneAwsServicesAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'roleArn': obj.roleArn,
    'roleSessionName': obj.roleSessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderControlPlaneConfigEncryption
 */
export interface ClusterSpecInitProviderControlPlaneConfigEncryption {
  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema ClusterSpecInitProviderControlPlaneConfigEncryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderControlPlaneConfigEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderControlPlaneConfigEncryption(obj: ClusterSpecInitProviderControlPlaneConfigEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyArn': obj.kmsKeyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderControlPlaneDatabaseEncryption
 */
export interface ClusterSpecInitProviderControlPlaneDatabaseEncryption {
  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema ClusterSpecInitProviderControlPlaneDatabaseEncryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderControlPlaneDatabaseEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderControlPlaneDatabaseEncryption(obj: ClusterSpecInitProviderControlPlaneDatabaseEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyArn': obj.kmsKeyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderControlPlaneMainVolume
 */
export interface ClusterSpecInitProviderControlPlaneMainVolume {
  /**
   * Optional. The number of I/O operations per second (IOPS) to provision for GP3 volume.
   *
   * @schema ClusterSpecInitProviderControlPlaneMainVolume#iops
   */
  readonly iops?: number;

  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema ClusterSpecInitProviderControlPlaneMainVolume#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Optional. The size of the volume, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
   *
   * @schema ClusterSpecInitProviderControlPlaneMainVolume#sizeGib
   */
  readonly sizeGib?: number;

  /**
   * Optional. The throughput to provision for the volume, in MiB/s. Only valid if the volume type is GP3.
   *
   * @schema ClusterSpecInitProviderControlPlaneMainVolume#throughput
   */
  readonly throughput?: number;

  /**
   * Optional. Type of the EBS volume. When unspecified, it defaults to GP2 volume. Possible values: VOLUME_TYPE_UNSPECIFIED, GP2, GP3
   *
   * @schema ClusterSpecInitProviderControlPlaneMainVolume#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderControlPlaneMainVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderControlPlaneMainVolume(obj: ClusterSpecInitProviderControlPlaneMainVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iops': obj.iops,
    'kmsKeyArn': obj.kmsKeyArn,
    'sizeGib': obj.sizeGib,
    'throughput': obj.throughput,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderControlPlaneProxyConfig
 */
export interface ClusterSpecInitProviderControlPlaneProxyConfig {
  /**
   * The ARN of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
   *
   * @schema ClusterSpecInitProviderControlPlaneProxyConfig#secretArn
   */
  readonly secretArn?: string;

  /**
   * The version string of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
   *
   * @schema ClusterSpecInitProviderControlPlaneProxyConfig#secretVersion
   */
  readonly secretVersion?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderControlPlaneProxyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderControlPlaneProxyConfig(obj: ClusterSpecInitProviderControlPlaneProxyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretArn': obj.secretArn,
    'secretVersion': obj.secretVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderControlPlaneRootVolume
 */
export interface ClusterSpecInitProviderControlPlaneRootVolume {
  /**
   * Optional. The number of I/O operations per second (IOPS) to provision for GP3 volume.
   *
   * @schema ClusterSpecInitProviderControlPlaneRootVolume#iops
   */
  readonly iops?: number;

  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema ClusterSpecInitProviderControlPlaneRootVolume#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Optional. The size of the volume, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
   *
   * @schema ClusterSpecInitProviderControlPlaneRootVolume#sizeGib
   */
  readonly sizeGib?: number;

  /**
   * Optional. The throughput to provision for the volume, in MiB/s. Only valid if the volume type is GP3.
   *
   * @schema ClusterSpecInitProviderControlPlaneRootVolume#throughput
   */
  readonly throughput?: number;

  /**
   * Optional. Type of the EBS volume. When unspecified, it defaults to GP2 volume. Possible values: VOLUME_TYPE_UNSPECIFIED, GP2, GP3
   *
   * @schema ClusterSpecInitProviderControlPlaneRootVolume#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderControlPlaneRootVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderControlPlaneRootVolume(obj: ClusterSpecInitProviderControlPlaneRootVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iops': obj.iops,
    'kmsKeyArn': obj.kmsKeyArn,
    'sizeGib': obj.sizeGib,
    'throughput': obj.throughput,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderControlPlaneSshConfig
 */
export interface ClusterSpecInitProviderControlPlaneSshConfig {
  /**
   * The name of the EC2 key pair used to login into cluster machines.
   *
   * @schema ClusterSpecInitProviderControlPlaneSshConfig#ec2KeyPair
   */
  readonly ec2KeyPair?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderControlPlaneSshConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderControlPlaneSshConfig(obj: ClusterSpecInitProviderControlPlaneSshConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ec2KeyPair': obj.ec2KeyPair,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * NodePool is the Schema for the NodePools API. An Anthos node pool running on AWS.
 *
 * @schema NodePool
 */
export class NodePool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodePool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'containeraws.gcp.upbound.io/v1beta1',
    kind: 'NodePool',
  }

  /**
   * Renders a Kubernetes manifest for "NodePool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodePoolProps): any {
    return {
      ...NodePool.GVK,
      ...toJson_NodePoolProps(props),
    };
  }

  /**
   * Defines a "NodePool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodePoolProps) {
    super(scope, id, {
      ...NodePool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodePool.GVK,
      ...toJson_NodePoolProps(resolved),
    };
  }
}

/**
 * NodePool is the Schema for the NodePools API. An Anthos node pool running on AWS.
 *
 * @schema NodePool
 */
export interface NodePoolProps {
  /**
   * @schema NodePool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NodePoolSpec defines the desired state of NodePool
   *
   * @schema NodePool#spec
   */
  readonly spec: NodePoolSpec;

}

/**
 * Converts an object of type 'NodePoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolProps(obj: NodePoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NodePoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePoolSpec defines the desired state of NodePool
 *
 * @schema NodePoolSpec
 */
export interface NodePoolSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NodePoolSpec#deletionPolicy
   */
  readonly deletionPolicy?: NodePoolSpecDeletionPolicy;

  /**
   * @schema NodePoolSpec#forProvider
   */
  readonly forProvider: NodePoolSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema NodePoolSpec#initProvider
   */
  readonly initProvider?: NodePoolSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NodePoolSpec#managementPolicies
   */
  readonly managementPolicies?: NodePoolSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NodePoolSpec#providerConfigRef
   */
  readonly providerConfigRef?: NodePoolSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NodePoolSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NodePoolSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NodePoolSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NodePoolSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NodePoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpec(obj: NodePoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NodePoolSpecForProvider(obj.forProvider),
    'initProvider': toJson_NodePoolSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NodePoolSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_NodePoolSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NodePoolSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NodePoolSpecDeletionPolicy
 */
export enum NodePoolSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NodePoolSpecForProvider
 */
export interface NodePoolSpecForProvider {
  /**
   * Optional. Annotations on the node pool. This field has the same restrictions as Kubernetes annotations. The total size of all keys and values combined is limited to 256k. Key can have 2 segments: prefix  and name , separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between.
   *
   * @schema NodePoolSpecForProvider#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Autoscaler configuration for this node pool.
   *
   * @schema NodePoolSpecForProvider#autoscaling
   */
  readonly autoscaling?: NodePoolSpecForProviderAutoscaling[];

  /**
   * The awsCluster for the resource
   *
   * @schema NodePoolSpecForProvider#cluster
   */
  readonly cluster?: string;

  /**
   * Reference to a Cluster to populate cluster.
   *
   * @schema NodePoolSpecForProvider#clusterRef
   */
  readonly clusterRef?: NodePoolSpecForProviderClusterRef;

  /**
   * Selector for a Cluster to populate cluster.
   *
   * @schema NodePoolSpecForProvider#clusterSelector
   */
  readonly clusterSelector?: NodePoolSpecForProviderClusterSelector;

  /**
   * The configuration of the node pool.
   *
   * @schema NodePoolSpecForProvider#config
   */
  readonly config?: NodePoolSpecForProviderConfig[];

  /**
   * The location for the resource
   *
   * @schema NodePoolSpecForProvider#location
   */
  readonly location: string;

  /**
   * The constraint on the maximum number of pods that can be run simultaneously on a node in the node pool.
   *
   * @schema NodePoolSpecForProvider#maxPodsConstraint
   */
  readonly maxPodsConstraint?: NodePoolSpecForProviderMaxPodsConstraint[];

  /**
   * The project for the resource
   *
   * @schema NodePoolSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The subnet where the node pool node run.
   *
   * @schema NodePoolSpecForProvider#subnetId
   */
  readonly subnetId?: string;

  /**
   * The Kubernetes version to run on this node pool (e.g. 1.19.10-gke.1000). You can list all supported versions on a given Google Cloud region by calling GetAwsServerConfig.
   *
   * @schema NodePoolSpecForProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'NodePoolSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProvider(obj: NodePoolSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'autoscaling': obj.autoscaling?.map(y => toJson_NodePoolSpecForProviderAutoscaling(y)),
    'cluster': obj.cluster,
    'clusterRef': toJson_NodePoolSpecForProviderClusterRef(obj.clusterRef),
    'clusterSelector': toJson_NodePoolSpecForProviderClusterSelector(obj.clusterSelector),
    'config': obj.config?.map(y => toJson_NodePoolSpecForProviderConfig(y)),
    'location': obj.location,
    'maxPodsConstraint': obj.maxPodsConstraint?.map(y => toJson_NodePoolSpecForProviderMaxPodsConstraint(y)),
    'project': obj.project,
    'subnetId': obj.subnetId,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema NodePoolSpecInitProvider
 */
export interface NodePoolSpecInitProvider {
  /**
   * Optional. Annotations on the node pool. This field has the same restrictions as Kubernetes annotations. The total size of all keys and values combined is limited to 256k. Key can have 2 segments: prefix  and name , separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between.
   *
   * @schema NodePoolSpecInitProvider#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Autoscaler configuration for this node pool.
   *
   * @schema NodePoolSpecInitProvider#autoscaling
   */
  readonly autoscaling?: NodePoolSpecInitProviderAutoscaling[];

  /**
   * The configuration of the node pool.
   *
   * @schema NodePoolSpecInitProvider#config
   */
  readonly config?: NodePoolSpecInitProviderConfig[];

  /**
   * The constraint on the maximum number of pods that can be run simultaneously on a node in the node pool.
   *
   * @schema NodePoolSpecInitProvider#maxPodsConstraint
   */
  readonly maxPodsConstraint?: NodePoolSpecInitProviderMaxPodsConstraint[];

  /**
   * The project for the resource
   *
   * @schema NodePoolSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The subnet where the node pool node run.
   *
   * @schema NodePoolSpecInitProvider#subnetId
   */
  readonly subnetId?: string;

  /**
   * The Kubernetes version to run on this node pool (e.g. 1.19.10-gke.1000). You can list all supported versions on a given Google Cloud region by calling GetAwsServerConfig.
   *
   * @schema NodePoolSpecInitProvider#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'NodePoolSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecInitProvider(obj: NodePoolSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'autoscaling': obj.autoscaling?.map(y => toJson_NodePoolSpecInitProviderAutoscaling(y)),
    'config': obj.config?.map(y => toJson_NodePoolSpecInitProviderConfig(y)),
    'maxPodsConstraint': obj.maxPodsConstraint?.map(y => toJson_NodePoolSpecInitProviderMaxPodsConstraint(y)),
    'project': obj.project,
    'subnetId': obj.subnetId,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema NodePoolSpecManagementPolicies
 */
export enum NodePoolSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NodePoolSpecProviderConfigRef
 */
export interface NodePoolSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodePoolSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodePoolSpecProviderConfigRef#policy
   */
  readonly policy?: NodePoolSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NodePoolSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecProviderConfigRef(obj: NodePoolSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodePoolSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NodePoolSpecPublishConnectionDetailsTo
 */
export interface NodePoolSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NodePoolSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NodePoolSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NodePoolSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NodePoolSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NodePoolSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NodePoolSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecPublishConnectionDetailsTo(obj: NodePoolSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NodePoolSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NodePoolSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NodePoolSpecWriteConnectionSecretToRef
 */
export interface NodePoolSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NodePoolSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NodePoolSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NodePoolSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecWriteConnectionSecretToRef(obj: NodePoolSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecForProviderAutoscaling
 */
export interface NodePoolSpecForProviderAutoscaling {
  /**
   * Maximum number of nodes in the NodePool. Must be >= min_node_count.
   *
   * @schema NodePoolSpecForProviderAutoscaling#maxNodeCount
   */
  readonly maxNodeCount?: number;

  /**
   * Minimum number of nodes in the NodePool. Must be >= 1 and <= max_node_count.
   *
   * @schema NodePoolSpecForProviderAutoscaling#minNodeCount
   */
  readonly minNodeCount?: number;

}

/**
 * Converts an object of type 'NodePoolSpecForProviderAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderAutoscaling(obj: NodePoolSpecForProviderAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxNodeCount': obj.maxNodeCount,
    'minNodeCount': obj.minNodeCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate cluster.
 *
 * @schema NodePoolSpecForProviderClusterRef
 */
export interface NodePoolSpecForProviderClusterRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodePoolSpecForProviderClusterRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodePoolSpecForProviderClusterRef#policy
   */
  readonly policy?: NodePoolSpecForProviderClusterRefPolicy;

}

/**
 * Converts an object of type 'NodePoolSpecForProviderClusterRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderClusterRef(obj: NodePoolSpecForProviderClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodePoolSpecForProviderClusterRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate cluster.
 *
 * @schema NodePoolSpecForProviderClusterSelector
 */
export interface NodePoolSpecForProviderClusterSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodePoolSpecForProviderClusterSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodePoolSpecForProviderClusterSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodePoolSpecForProviderClusterSelector#policy
   */
  readonly policy?: NodePoolSpecForProviderClusterSelectorPolicy;

}

/**
 * Converts an object of type 'NodePoolSpecForProviderClusterSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderClusterSelector(obj: NodePoolSpecForProviderClusterSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodePoolSpecForProviderClusterSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecForProviderConfig
 */
export interface NodePoolSpecForProviderConfig {
  /**
   * Optional. Configuration related to CloudWatch metrics collection on the Auto Scaling group of the node pool. When unspecified, metrics collection is disabled.
   *
   * @schema NodePoolSpecForProviderConfig#autoscalingMetricsCollection
   */
  readonly autoscalingMetricsCollection?: NodePoolSpecForProviderConfigAutoscalingMetricsCollection[];

  /**
   * The ARN of the AWS KMS key used to encrypt node pool configuration.
   *
   * @schema NodePoolSpecForProviderConfig#configEncryption
   */
  readonly configEncryption?: NodePoolSpecForProviderConfigConfigEncryption[];

  /**
   * The name of the AWS IAM role assigned to nodes in the pool.
   *
   * @schema NodePoolSpecForProviderConfig#iamInstanceProfile
   */
  readonly iamInstanceProfile?: string;

  /**
   * Optional. The AWS instance type. When unspecified, it defaults to m5.large.
   *
   * @schema NodePoolSpecForProviderConfig#instanceType
   */
  readonly instanceType?: string;

  /**
   * Optional. The initial labels assigned to nodes of this node pool. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema NodePoolSpecForProviderConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Proxy configuration for outbound HTTP(S) traffic.
   *
   * @schema NodePoolSpecForProviderConfig#proxyConfig
   */
  readonly proxyConfig?: NodePoolSpecForProviderConfigProxyConfig[];

  /**
   * Optional. Template for the root volume provisioned for node pool nodes. Volumes will be provisioned in the availability zone assigned to the node pool subnet. When unspecified, it defaults to 32 GiB with the GP2 volume type.
   *
   * @schema NodePoolSpecForProviderConfig#rootVolume
   */
  readonly rootVolume?: NodePoolSpecForProviderConfigRootVolume[];

  /**
   * Optional. The IDs of additional security groups to add to nodes in this pool. The manager will automatically create security groups with minimum rules needed for a functioning cluster.
   *
   * @schema NodePoolSpecForProviderConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * Optional. The SSH configuration.
   *
   * @schema NodePoolSpecForProviderConfig#sshConfig
   */
  readonly sshConfig?: NodePoolSpecForProviderConfigSshConfig[];

  /**
   * Optional. Key/value metadata to assign to each underlying AWS resource. Specify at most 50 pairs containing alphanumerics, spaces, and symbols (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to 255 Unicode characters.
   *
   * @schema NodePoolSpecForProviderConfig#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Optional. The initial taints assigned to nodes of this node pool.
   *
   * @schema NodePoolSpecForProviderConfig#taints
   */
  readonly taints?: NodePoolSpecForProviderConfigTaints[];

}

/**
 * Converts an object of type 'NodePoolSpecForProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderConfig(obj: NodePoolSpecForProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoscalingMetricsCollection': obj.autoscalingMetricsCollection?.map(y => toJson_NodePoolSpecForProviderConfigAutoscalingMetricsCollection(y)),
    'configEncryption': obj.configEncryption?.map(y => toJson_NodePoolSpecForProviderConfigConfigEncryption(y)),
    'iamInstanceProfile': obj.iamInstanceProfile,
    'instanceType': obj.instanceType,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxyConfig': obj.proxyConfig?.map(y => toJson_NodePoolSpecForProviderConfigProxyConfig(y)),
    'rootVolume': obj.rootVolume?.map(y => toJson_NodePoolSpecForProviderConfigRootVolume(y)),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'sshConfig': obj.sshConfig?.map(y => toJson_NodePoolSpecForProviderConfigSshConfig(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taints': obj.taints?.map(y => toJson_NodePoolSpecForProviderConfigTaints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecForProviderMaxPodsConstraint
 */
export interface NodePoolSpecForProviderMaxPodsConstraint {
  /**
   * The maximum number of pods to schedule on a single node.
   *
   * @schema NodePoolSpecForProviderMaxPodsConstraint#maxPodsPerNode
   */
  readonly maxPodsPerNode?: number;

}

/**
 * Converts an object of type 'NodePoolSpecForProviderMaxPodsConstraint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderMaxPodsConstraint(obj: NodePoolSpecForProviderMaxPodsConstraint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxPodsPerNode': obj.maxPodsPerNode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecInitProviderAutoscaling
 */
export interface NodePoolSpecInitProviderAutoscaling {
  /**
   * Maximum number of nodes in the NodePool. Must be >= min_node_count.
   *
   * @schema NodePoolSpecInitProviderAutoscaling#maxNodeCount
   */
  readonly maxNodeCount?: number;

  /**
   * Minimum number of nodes in the NodePool. Must be >= 1 and <= max_node_count.
   *
   * @schema NodePoolSpecInitProviderAutoscaling#minNodeCount
   */
  readonly minNodeCount?: number;

}

/**
 * Converts an object of type 'NodePoolSpecInitProviderAutoscaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecInitProviderAutoscaling(obj: NodePoolSpecInitProviderAutoscaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxNodeCount': obj.maxNodeCount,
    'minNodeCount': obj.minNodeCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecInitProviderConfig
 */
export interface NodePoolSpecInitProviderConfig {
  /**
   * Optional. Configuration related to CloudWatch metrics collection on the Auto Scaling group of the node pool. When unspecified, metrics collection is disabled.
   *
   * @schema NodePoolSpecInitProviderConfig#autoscalingMetricsCollection
   */
  readonly autoscalingMetricsCollection?: NodePoolSpecInitProviderConfigAutoscalingMetricsCollection[];

  /**
   * The ARN of the AWS KMS key used to encrypt node pool configuration.
   *
   * @schema NodePoolSpecInitProviderConfig#configEncryption
   */
  readonly configEncryption?: NodePoolSpecInitProviderConfigConfigEncryption[];

  /**
   * The name of the AWS IAM role assigned to nodes in the pool.
   *
   * @schema NodePoolSpecInitProviderConfig#iamInstanceProfile
   */
  readonly iamInstanceProfile?: string;

  /**
   * Optional. The AWS instance type. When unspecified, it defaults to m5.large.
   *
   * @schema NodePoolSpecInitProviderConfig#instanceType
   */
  readonly instanceType?: string;

  /**
   * Optional. The initial labels assigned to nodes of this node pool. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema NodePoolSpecInitProviderConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Proxy configuration for outbound HTTP(S) traffic.
   *
   * @schema NodePoolSpecInitProviderConfig#proxyConfig
   */
  readonly proxyConfig?: NodePoolSpecInitProviderConfigProxyConfig[];

  /**
   * Optional. Template for the root volume provisioned for node pool nodes. Volumes will be provisioned in the availability zone assigned to the node pool subnet. When unspecified, it defaults to 32 GiB with the GP2 volume type.
   *
   * @schema NodePoolSpecInitProviderConfig#rootVolume
   */
  readonly rootVolume?: NodePoolSpecInitProviderConfigRootVolume[];

  /**
   * Optional. The IDs of additional security groups to add to nodes in this pool. The manager will automatically create security groups with minimum rules needed for a functioning cluster.
   *
   * @schema NodePoolSpecInitProviderConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * Optional. The SSH configuration.
   *
   * @schema NodePoolSpecInitProviderConfig#sshConfig
   */
  readonly sshConfig?: NodePoolSpecInitProviderConfigSshConfig[];

  /**
   * Optional. Key/value metadata to assign to each underlying AWS resource. Specify at most 50 pairs containing alphanumerics, spaces, and symbols (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to 255 Unicode characters.
   *
   * @schema NodePoolSpecInitProviderConfig#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Optional. The initial taints assigned to nodes of this node pool.
   *
   * @schema NodePoolSpecInitProviderConfig#taints
   */
  readonly taints?: NodePoolSpecInitProviderConfigTaints[];

}

/**
 * Converts an object of type 'NodePoolSpecInitProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecInitProviderConfig(obj: NodePoolSpecInitProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoscalingMetricsCollection': obj.autoscalingMetricsCollection?.map(y => toJson_NodePoolSpecInitProviderConfigAutoscalingMetricsCollection(y)),
    'configEncryption': obj.configEncryption?.map(y => toJson_NodePoolSpecInitProviderConfigConfigEncryption(y)),
    'iamInstanceProfile': obj.iamInstanceProfile,
    'instanceType': obj.instanceType,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxyConfig': obj.proxyConfig?.map(y => toJson_NodePoolSpecInitProviderConfigProxyConfig(y)),
    'rootVolume': obj.rootVolume?.map(y => toJson_NodePoolSpecInitProviderConfigRootVolume(y)),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'sshConfig': obj.sshConfig?.map(y => toJson_NodePoolSpecInitProviderConfigSshConfig(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taints': obj.taints?.map(y => toJson_NodePoolSpecInitProviderConfigTaints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecInitProviderMaxPodsConstraint
 */
export interface NodePoolSpecInitProviderMaxPodsConstraint {
  /**
   * The maximum number of pods to schedule on a single node.
   *
   * @schema NodePoolSpecInitProviderMaxPodsConstraint#maxPodsPerNode
   */
  readonly maxPodsPerNode?: number;

}

/**
 * Converts an object of type 'NodePoolSpecInitProviderMaxPodsConstraint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecInitProviderMaxPodsConstraint(obj: NodePoolSpecInitProviderMaxPodsConstraint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxPodsPerNode': obj.maxPodsPerNode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodePoolSpecProviderConfigRefPolicy
 */
export interface NodePoolSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodePoolSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NodePoolSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodePoolSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NodePoolSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NodePoolSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecProviderConfigRefPolicy(obj: NodePoolSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NodePoolSpecPublishConnectionDetailsToConfigRef
 */
export interface NodePoolSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodePoolSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodePoolSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NodePoolSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NodePoolSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecPublishConnectionDetailsToConfigRef(obj: NodePoolSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodePoolSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NodePoolSpecPublishConnectionDetailsToMetadata
 */
export interface NodePoolSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NodePoolSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NodePoolSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NodePoolSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NodePoolSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecPublishConnectionDetailsToMetadata(obj: NodePoolSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodePoolSpecForProviderClusterRefPolicy
 */
export interface NodePoolSpecForProviderClusterRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodePoolSpecForProviderClusterRefPolicy#resolution
   */
  readonly resolution?: NodePoolSpecForProviderClusterRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodePoolSpecForProviderClusterRefPolicy#resolve
   */
  readonly resolve?: NodePoolSpecForProviderClusterRefPolicyResolve;

}

/**
 * Converts an object of type 'NodePoolSpecForProviderClusterRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderClusterRefPolicy(obj: NodePoolSpecForProviderClusterRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodePoolSpecForProviderClusterSelectorPolicy
 */
export interface NodePoolSpecForProviderClusterSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodePoolSpecForProviderClusterSelectorPolicy#resolution
   */
  readonly resolution?: NodePoolSpecForProviderClusterSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodePoolSpecForProviderClusterSelectorPolicy#resolve
   */
  readonly resolve?: NodePoolSpecForProviderClusterSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodePoolSpecForProviderClusterSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderClusterSelectorPolicy(obj: NodePoolSpecForProviderClusterSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecForProviderConfigAutoscalingMetricsCollection
 */
export interface NodePoolSpecForProviderConfigAutoscalingMetricsCollection {
  /**
   * The frequency at which EC2 Auto Scaling sends aggregated data to AWS CloudWatch. The only valid value is "1Minute".
   *
   * @schema NodePoolSpecForProviderConfigAutoscalingMetricsCollection#granularity
   */
  readonly granularity?: string;

  /**
   * The metrics to enable. For a list of valid metrics, see https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_EnableMetricsCollection.html. If you specify granularity and don't specify any metrics, all metrics are enabled.
   *
   * @schema NodePoolSpecForProviderConfigAutoscalingMetricsCollection#metrics
   */
  readonly metrics?: string[];

}

/**
 * Converts an object of type 'NodePoolSpecForProviderConfigAutoscalingMetricsCollection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderConfigAutoscalingMetricsCollection(obj: NodePoolSpecForProviderConfigAutoscalingMetricsCollection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'granularity': obj.granularity,
    'metrics': obj.metrics?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecForProviderConfigConfigEncryption
 */
export interface NodePoolSpecForProviderConfigConfigEncryption {
  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema NodePoolSpecForProviderConfigConfigEncryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

}

/**
 * Converts an object of type 'NodePoolSpecForProviderConfigConfigEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderConfigConfigEncryption(obj: NodePoolSpecForProviderConfigConfigEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyArn': obj.kmsKeyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecForProviderConfigProxyConfig
 */
export interface NodePoolSpecForProviderConfigProxyConfig {
  /**
   * The ARN of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
   *
   * @schema NodePoolSpecForProviderConfigProxyConfig#secretArn
   */
  readonly secretArn?: string;

  /**
   * The version string of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
   *
   * @schema NodePoolSpecForProviderConfigProxyConfig#secretVersion
   */
  readonly secretVersion?: string;

}

/**
 * Converts an object of type 'NodePoolSpecForProviderConfigProxyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderConfigProxyConfig(obj: NodePoolSpecForProviderConfigProxyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretArn': obj.secretArn,
    'secretVersion': obj.secretVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecForProviderConfigRootVolume
 */
export interface NodePoolSpecForProviderConfigRootVolume {
  /**
   * Optional. The number of I/O operations per second (IOPS) to provision for GP3 volume.
   *
   * @schema NodePoolSpecForProviderConfigRootVolume#iops
   */
  readonly iops?: number;

  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema NodePoolSpecForProviderConfigRootVolume#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Optional. The size of the volume, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
   *
   * @schema NodePoolSpecForProviderConfigRootVolume#sizeGib
   */
  readonly sizeGib?: number;

  /**
   * Optional. The throughput to provision for the volume, in MiB/s. Only valid if the volume type is GP3.
   *
   * @schema NodePoolSpecForProviderConfigRootVolume#throughput
   */
  readonly throughput?: number;

  /**
   * Optional. Type of the EBS volume. When unspecified, it defaults to GP2 volume. Possible values: VOLUME_TYPE_UNSPECIFIED, GP2, GP3
   *
   * @schema NodePoolSpecForProviderConfigRootVolume#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'NodePoolSpecForProviderConfigRootVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderConfigRootVolume(obj: NodePoolSpecForProviderConfigRootVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iops': obj.iops,
    'kmsKeyArn': obj.kmsKeyArn,
    'sizeGib': obj.sizeGib,
    'throughput': obj.throughput,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecForProviderConfigSshConfig
 */
export interface NodePoolSpecForProviderConfigSshConfig {
  /**
   * The name of the EC2 key pair used to login into cluster machines.
   *
   * @schema NodePoolSpecForProviderConfigSshConfig#ec2KeyPair
   */
  readonly ec2KeyPair?: string;

}

/**
 * Converts an object of type 'NodePoolSpecForProviderConfigSshConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderConfigSshConfig(obj: NodePoolSpecForProviderConfigSshConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ec2KeyPair': obj.ec2KeyPair,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecForProviderConfigTaints
 */
export interface NodePoolSpecForProviderConfigTaints {
  /**
   * The taint effect. Possible values: EFFECT_UNSPECIFIED, NO_SCHEDULE, PREFER_NO_SCHEDULE, NO_EXECUTE
   *
   * @schema NodePoolSpecForProviderConfigTaints#effect
   */
  readonly effect?: string;

  /**
   * Key for the taint.
   *
   * @schema NodePoolSpecForProviderConfigTaints#key
   */
  readonly key?: string;

  /**
   * Value for the taint.
   *
   * @schema NodePoolSpecForProviderConfigTaints#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'NodePoolSpecForProviderConfigTaints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecForProviderConfigTaints(obj: NodePoolSpecForProviderConfigTaints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecInitProviderConfigAutoscalingMetricsCollection
 */
export interface NodePoolSpecInitProviderConfigAutoscalingMetricsCollection {
  /**
   * The frequency at which EC2 Auto Scaling sends aggregated data to AWS CloudWatch. The only valid value is "1Minute".
   *
   * @schema NodePoolSpecInitProviderConfigAutoscalingMetricsCollection#granularity
   */
  readonly granularity?: string;

  /**
   * The metrics to enable. For a list of valid metrics, see https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_EnableMetricsCollection.html. If you specify granularity and don't specify any metrics, all metrics are enabled.
   *
   * @schema NodePoolSpecInitProviderConfigAutoscalingMetricsCollection#metrics
   */
  readonly metrics?: string[];

}

/**
 * Converts an object of type 'NodePoolSpecInitProviderConfigAutoscalingMetricsCollection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecInitProviderConfigAutoscalingMetricsCollection(obj: NodePoolSpecInitProviderConfigAutoscalingMetricsCollection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'granularity': obj.granularity,
    'metrics': obj.metrics?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecInitProviderConfigConfigEncryption
 */
export interface NodePoolSpecInitProviderConfigConfigEncryption {
  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema NodePoolSpecInitProviderConfigConfigEncryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

}

/**
 * Converts an object of type 'NodePoolSpecInitProviderConfigConfigEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecInitProviderConfigConfigEncryption(obj: NodePoolSpecInitProviderConfigConfigEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyArn': obj.kmsKeyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecInitProviderConfigProxyConfig
 */
export interface NodePoolSpecInitProviderConfigProxyConfig {
  /**
   * The ARN of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
   *
   * @schema NodePoolSpecInitProviderConfigProxyConfig#secretArn
   */
  readonly secretArn?: string;

  /**
   * The version string of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.
   *
   * @schema NodePoolSpecInitProviderConfigProxyConfig#secretVersion
   */
  readonly secretVersion?: string;

}

/**
 * Converts an object of type 'NodePoolSpecInitProviderConfigProxyConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecInitProviderConfigProxyConfig(obj: NodePoolSpecInitProviderConfigProxyConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretArn': obj.secretArn,
    'secretVersion': obj.secretVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecInitProviderConfigRootVolume
 */
export interface NodePoolSpecInitProviderConfigRootVolume {
  /**
   * Optional. The number of I/O operations per second (IOPS) to provision for GP3 volume.
   *
   * @schema NodePoolSpecInitProviderConfigRootVolume#iops
   */
  readonly iops?: number;

  /**
   * Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.
   *
   * @schema NodePoolSpecInitProviderConfigRootVolume#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Optional. The size of the volume, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.
   *
   * @schema NodePoolSpecInitProviderConfigRootVolume#sizeGib
   */
  readonly sizeGib?: number;

  /**
   * Optional. The throughput to provision for the volume, in MiB/s. Only valid if the volume type is GP3.
   *
   * @schema NodePoolSpecInitProviderConfigRootVolume#throughput
   */
  readonly throughput?: number;

  /**
   * Optional. Type of the EBS volume. When unspecified, it defaults to GP2 volume. Possible values: VOLUME_TYPE_UNSPECIFIED, GP2, GP3
   *
   * @schema NodePoolSpecInitProviderConfigRootVolume#volumeType
   */
  readonly volumeType?: string;

}

/**
 * Converts an object of type 'NodePoolSpecInitProviderConfigRootVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecInitProviderConfigRootVolume(obj: NodePoolSpecInitProviderConfigRootVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iops': obj.iops,
    'kmsKeyArn': obj.kmsKeyArn,
    'sizeGib': obj.sizeGib,
    'throughput': obj.throughput,
    'volumeType': obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecInitProviderConfigSshConfig
 */
export interface NodePoolSpecInitProviderConfigSshConfig {
  /**
   * The name of the EC2 key pair used to login into cluster machines.
   *
   * @schema NodePoolSpecInitProviderConfigSshConfig#ec2KeyPair
   */
  readonly ec2KeyPair?: string;

}

/**
 * Converts an object of type 'NodePoolSpecInitProviderConfigSshConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecInitProviderConfigSshConfig(obj: NodePoolSpecInitProviderConfigSshConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ec2KeyPair': obj.ec2KeyPair,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodePoolSpecInitProviderConfigTaints
 */
export interface NodePoolSpecInitProviderConfigTaints {
  /**
   * The taint effect. Possible values: EFFECT_UNSPECIFIED, NO_SCHEDULE, PREFER_NO_SCHEDULE, NO_EXECUTE
   *
   * @schema NodePoolSpecInitProviderConfigTaints#effect
   */
  readonly effect?: string;

  /**
   * Key for the taint.
   *
   * @schema NodePoolSpecInitProviderConfigTaints#key
   */
  readonly key?: string;

  /**
   * Value for the taint.
   *
   * @schema NodePoolSpecInitProviderConfigTaints#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'NodePoolSpecInitProviderConfigTaints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecInitProviderConfigTaints(obj: NodePoolSpecInitProviderConfigTaints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodePoolSpecProviderConfigRefPolicyResolution
 */
export enum NodePoolSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodePoolSpecProviderConfigRefPolicyResolve
 */
export enum NodePoolSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NodePoolSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NodePoolSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodePoolSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NodePoolSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodePoolSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NodePoolSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NodePoolSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodePoolSpecPublishConnectionDetailsToConfigRefPolicy(obj: NodePoolSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodePoolSpecForProviderClusterRefPolicyResolution
 */
export enum NodePoolSpecForProviderClusterRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodePoolSpecForProviderClusterRefPolicyResolve
 */
export enum NodePoolSpecForProviderClusterRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodePoolSpecForProviderClusterSelectorPolicyResolution
 */
export enum NodePoolSpecForProviderClusterSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodePoolSpecForProviderClusterSelectorPolicyResolve
 */
export enum NodePoolSpecForProviderClusterSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodePoolSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NodePoolSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodePoolSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NodePoolSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

