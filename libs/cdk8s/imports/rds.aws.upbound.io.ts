// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Cluster is the Schema for the Clusters API. Manages an RDS Aurora Cluster
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API. Manages an RDS Aurora Cluster
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClusterSpec#initProvider
   */
  readonly initProvider?: ClusterSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.
   *
   * @schema ClusterSpecForProvider#allocatedStorage
   */
  readonly allocatedStorage?: number;

  /**
   * Enable to allow major engine version upgrades when changing engine versions. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecForProvider#allowMajorVersionUpgrade
   */
  readonly allowMajorVersionUpgrade?: boolean;

  /**
   * Specifies whether any cluster modifications are applied immediately, or during the next maintenance window. Default is false. See Amazon RDS Documentation for more information.
   *
   * @default false. See Amazon RDS Documentation for more information.
   * @schema ClusterSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * List of EC2 Availability Zones for the DB cluster storage where DB cluster instances can be created. We recommend specifying 3 AZs or using the  if necessary. A maximum of 3 AZs can be configured.
   *
   * @schema ClusterSpecForProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * The target backtrack window, in seconds. Only available for aurora and aurora-mysql engines currently. To disable backtracking, set this value to 0. Defaults to 0. Must be between 0 and 259200 (72 hours)
   *
   * @default 0. Must be between 0 and 259200 (72 hours)
   * @schema ClusterSpecForProvider#backtrackWindow
   */
  readonly backtrackWindow?: number;

  /**
   * The days to retain backups for. Default 1
   *
   * @schema ClusterSpecForProvider#backupRetentionPeriod
   */
  readonly backupRetentionPeriod?: number;

  /**
   * – List of RDS Instances that are a part of this cluster
   *
   * @schema ClusterSpecForProvider#clusterMembers
   */
  readonly clusterMembers?: string[];

  /**
   * –  Copy all Cluster tags to snapshots. Default is false.
   *
   * @default false.
   * @schema ClusterSpecForProvider#copyTagsToSnapshot
   */
  readonly copyTagsToSnapshot?: boolean;

  /**
   * Name for an automatically created database on cluster creation. There are different naming restrictions per database engine: RDS Naming Constraints
   *
   * @schema ClusterSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6g.xlarge. Not all DB instance classes are available in all AWS Regions, or for all database engines. For the full list of DB instance classes and availability for your engine, see DB instance class in the Amazon RDS User Guide.
   *
   * @schema ClusterSpecForProvider#dbClusterInstanceClass
   */
  readonly dbClusterInstanceClass?: string;

  /**
   * A cluster parameter group to associate with the cluster.
   *
   * @schema ClusterSpecForProvider#dbClusterParameterGroupName
   */
  readonly dbClusterParameterGroupName?: string;

  /**
   * Instance parameter group to associate with all instances of the DB cluster. The db_instance_parameter_group_name parameter is only valid in combination with the allow_major_version_upgrade parameter.
   *
   * @schema ClusterSpecForProvider#dbInstanceParameterGroupName
   */
  readonly dbInstanceParameterGroupName?: string;

  /**
   * A DB subnet group to associate with this DB instance. NOTE: This must match the db_subnet_group_name specified on every aws_rds_cluster_instance in the cluster.
   *
   * @schema ClusterSpecForProvider#dbSubnetGroupName
   */
  readonly dbSubnetGroupName?: string;

  /**
   * Reference to a SubnetGroup to populate dbSubnetGroupName.
   *
   * @schema ClusterSpecForProvider#dbSubnetGroupNameRef
   */
  readonly dbSubnetGroupNameRef?: ClusterSpecForProviderDbSubnetGroupNameRef;

  /**
   * Selector for a SubnetGroup to populate dbSubnetGroupName.
   *
   * @schema ClusterSpecForProvider#dbSubnetGroupNameSelector
   */
  readonly dbSubnetGroupNameSelector?: ClusterSpecForProviderDbSubnetGroupNameSelector;

  /**
   * If the DB instance should have deletion protection enabled. The database can't be deleted when this value is set to true. The default is false.
   *
   * @schema ClusterSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Whether cluster should forward writes to an associated global cluster. Applied to secondary clusters to enable them to forward writes to an aws_rds_global_cluster's primary cluster. See the Aurora Userguide documentation for more information.
   *
   * @schema ClusterSpecForProvider#enableGlobalWriteForwarding
   */
  readonly enableGlobalWriteForwarding?: boolean;

  /**
   * Enable HTTP endpoint (data API). Only valid when engine_mode is set to serverless.
   *
   * @schema ClusterSpecForProvider#enableHttpEndpoint
   */
  readonly enableHttpEndpoint?: boolean;

  /**
   * Set of log types to export to cloudwatch. If omitted, no logs will be exported. The following log types are supported: audit, error, general, slowquery, postgresql (PostgreSQL).
   *
   * @schema ClusterSpecForProvider#enabledCloudwatchLogsExports
   */
  readonly enabledCloudwatchLogsExports?: string[];

  /**
   * The name of the database engine to be used for this DB cluster. Defaults to aurora. Valid Values: aurora, aurora-mysql, aurora-postgresql, mysql, postgres. (Note that mysql and postgres are Multi-AZ RDS clusters).
   *
   * @default aurora. Valid Values: aurora, aurora-mysql, aurora-postgresql, mysql, postgres. (Note that mysql and postgres are Multi-AZ RDS clusters).
   * @schema ClusterSpecForProvider#engine
   */
  readonly engine?: string;

  /**
   * The database engine mode. Valid values: global (only valid for Aurora MySQL 1.21 and earlier), multimaster, parallelquery, provisioned, serverless. Defaults to: provisioned. See the RDS User Guide for limitations when using serverless.
   *
   * @default provisioned. See the RDS User Guide for limitations when using serverless.
   * @schema ClusterSpecForProvider#engineMode
   */
  readonly engineMode?: string;

  /**
   * The database engine version. Updating this argument results in an outage. See the Aurora MySQL and Aurora Postgres documentation for your configured engine to determine this value, or by running aws rds describe-db-engine-versions. For example with Aurora MySQL 2, a potential value for this argument is 5.7.mysql_aurora.2.03.2. The value can contain a partial version where supported by the API. The actual engine version used is returned in the attribute engine_version_actual, , see Attributes Reference below.
   *
   * @schema ClusterSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The name of your final DB snapshot when this DB cluster is deleted. If omitted, no final snapshot will be made.
   *
   * @schema ClusterSpecForProvider#finalSnapshotIdentifier
   */
  readonly finalSnapshotIdentifier?: string;

  /**
   * The global cluster identifier specified on aws_rds_global_cluster.
   *
   * @schema ClusterSpecForProvider#globalClusterIdentifier
   */
  readonly globalClusterIdentifier?: string;

  /**
   * Specifies whether or not mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled. Please see AWS Documentation for availability and limitations.
   *
   * @schema ClusterSpecForProvider#iamDatabaseAuthenticationEnabled
   */
  readonly iamDatabaseAuthenticationEnabled?: boolean;

  /**
   * The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster. For information about valid Iops values, see Amazon RDS Provisioned IOPS storage to improve performance in the Amazon RDS User Guide. Must be a multiple between .5 and 50 of the storage amount for the DB cluster.
   *
   * @schema ClusterSpecForProvider#iops
   */
  readonly iops?: number;

  /**
   * The ARN for the KMS encryption key. When specifying kms_key_id, storage_encrypted needs to be set to true.
   *
   * @schema ClusterSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema ClusterSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: ClusterSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema ClusterSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: ClusterSpecForProviderKmsKeyIdSelector;

  /**
   * Set to true to allow RDS to manage the master user password in Secrets Manager. Cannot be set if master_password is provided.
   *
   * @schema ClusterSpecForProvider#manageMasterUserPassword
   */
  readonly manageMasterUserPassword?: boolean;

  /**
   * Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Please refer to the RDS Naming Constraints. Cannot be set if manage_master_user_password is set to true.
   *
   * @schema ClusterSpecForProvider#masterPasswordSecretRef
   */
  readonly masterPasswordSecretRef?: ClusterSpecForProviderMasterPasswordSecretRef;

  /**
   * The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If not specified, the default KMS key for your Amazon Web Services account is used.
   *
   * @schema ClusterSpecForProvider#masterUserSecretKmsKeyId
   */
  readonly masterUserSecretKmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate masterUserSecretKmsKeyId.
   *
   * @schema ClusterSpecForProvider#masterUserSecretKmsKeyIdRef
   */
  readonly masterUserSecretKmsKeyIdRef?: ClusterSpecForProviderMasterUserSecretKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate masterUserSecretKmsKeyId.
   *
   * @schema ClusterSpecForProvider#masterUserSecretKmsKeyIdSelector
   */
  readonly masterUserSecretKmsKeyIdSelector?: ClusterSpecForProviderMasterUserSecretKmsKeyIdSelector;

  /**
   * Username for the master DB user. Please refer to the RDS Naming Constraints. This argument does not support in-place updates and cannot be changed during a restore from snapshot.
   *
   * @schema ClusterSpecForProvider#masterUsername
   */
  readonly masterUsername?: string;

  /**
   * The network type of the cluster. Valid values: IPV4, DUAL.
   *
   * @schema ClusterSpecForProvider#networkType
   */
  readonly networkType?: string;

  /**
   * The port on which the DB accepts connections
   *
   * @schema ClusterSpecForProvider#port
   */
  readonly port?: number;

  /**
   * The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.Time in UTC. Default: A 30-minute window selected at random from an 8-hour block of time per regionE.g., 04:00-09:00
   *
   * @schema ClusterSpecForProvider#preferredBackupWindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The weekly time range during which system maintenance can occur, in (UTC) e.g., wed:04:00-wed:04:30
   *
   * @schema ClusterSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN of a source DB cluster or DB instance if this DB cluster is to be created as a Read Replica.
   *
   * @schema ClusterSpecForProvider#replicationSourceIdentifier
   */
  readonly replicationSourceIdentifier?: string;

  /**
   * Nested attribute for point in time restore. More details below.
   *
   * @schema ClusterSpecForProvider#restoreToPointInTime
   */
  readonly restoreToPointInTime?: ClusterSpecForProviderRestoreToPointInTime[];

  /**
   * The port on which the DB accepts connections
   *
   * @schema ClusterSpecForProvider#s3Import
   */
  readonly s3Import?: ClusterSpecForProviderS3Import[];

  /**
   * Nested attribute with scaling properties. Only valid when engine_mode is set to serverless. More details below.
   *
   * @schema ClusterSpecForProvider#scalingConfiguration
   */
  readonly scalingConfiguration?: ClusterSpecForProviderScalingConfiguration[];

  /**
   * Nested attribute with scaling properties for ServerlessV2. Only valid when engine_mode is set to provisioned. More details below.
   *
   * @schema ClusterSpecForProvider#serverlessv2ScalingConfiguration
   */
  readonly serverlessv2ScalingConfiguration?: ClusterSpecForProviderServerlessv2ScalingConfiguration[];

  /**
   * Determines whether a final DB snapshot is created before the DB cluster is deleted. If true is specified, no DB snapshot is created. If false is specified, a DB snapshot is created before the DB cluster is deleted, using the value from final_snapshot_identifier. Default is false.
   *
   * @default false.
   * @schema ClusterSpecForProvider#skipFinalSnapshot
   */
  readonly skipFinalSnapshot?: boolean;

  /**
   * Specifies whether or not to create this cluster from a snapshot. You can use either the name or ARN when specifying a DB cluster snapshot, or the ARN when specifying a DB snapshot. Conflicts with global_cluster_identifier. Clusters cannot be restored from snapshot and joined to an existing global cluster in a single operation. See the AWS documentation or the Global Cluster Restored From Snapshot example for instructions on building a global cluster starting with a snapshot.
   *
   * @schema ClusterSpecForProvider#snapshotIdentifier
   */
  readonly snapshotIdentifier?: string;

  /**
   * The source region for an encrypted replica DB cluster.
   *
   * @schema ClusterSpecForProvider#sourceRegion
   */
  readonly sourceRegion?: string;

  /**
   * Specifies whether the DB cluster is encrypted. The default is false for provisioned engine_mode and true for serverless engine_mode. When restoring an unencrypted snapshot_identifier, the kms_key_id argument must be provided to encrypt the restored cluster.
   *
   * @schema ClusterSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

  /**
   * (Forces new for Multi-AZ DB clusters) Specifies the storage type to be associated with the DB cluster. For Aurora DB clusters, storage_type modifications can be done in-place. For Multi-AZ DB Clusters, the iops argument must also be set. Valid values are: "", aurora-iopt1 (Aurora DB Clusters); io1 (Multi-AZ DB Clusters). Default: "" (Aurora DB Clusters); io1 (Multi-AZ DB Clusters).
   *
   * @schema ClusterSpecForProvider#storageType
   */
  readonly storageType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIdRefs
   */
  readonly vpcSecurityGroupIdRefs?: ClusterSpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIdSelector
   */
  readonly vpcSecurityGroupIdSelector?: ClusterSpecForProviderVpcSecurityGroupIdSelector;

  /**
   * List of VPC security groups to associate with the Cluster
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIds
   */
  readonly vpcSecurityGroupIds?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedStorage': obj.allocatedStorage,
    'allowMajorVersionUpgrade': obj.allowMajorVersionUpgrade,
    'applyImmediately': obj.applyImmediately,
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'backtrackWindow': obj.backtrackWindow,
    'backupRetentionPeriod': obj.backupRetentionPeriod,
    'clusterMembers': obj.clusterMembers?.map(y => y),
    'copyTagsToSnapshot': obj.copyTagsToSnapshot,
    'databaseName': obj.databaseName,
    'dbClusterInstanceClass': obj.dbClusterInstanceClass,
    'dbClusterParameterGroupName': obj.dbClusterParameterGroupName,
    'dbInstanceParameterGroupName': obj.dbInstanceParameterGroupName,
    'dbSubnetGroupName': obj.dbSubnetGroupName,
    'dbSubnetGroupNameRef': toJson_ClusterSpecForProviderDbSubnetGroupNameRef(obj.dbSubnetGroupNameRef),
    'dbSubnetGroupNameSelector': toJson_ClusterSpecForProviderDbSubnetGroupNameSelector(obj.dbSubnetGroupNameSelector),
    'deletionProtection': obj.deletionProtection,
    'enableGlobalWriteForwarding': obj.enableGlobalWriteForwarding,
    'enableHttpEndpoint': obj.enableHttpEndpoint,
    'enabledCloudwatchLogsExports': obj.enabledCloudwatchLogsExports?.map(y => y),
    'engine': obj.engine,
    'engineMode': obj.engineMode,
    'engineVersion': obj.engineVersion,
    'finalSnapshotIdentifier': obj.finalSnapshotIdentifier,
    'globalClusterIdentifier': obj.globalClusterIdentifier,
    'iamDatabaseAuthenticationEnabled': obj.iamDatabaseAuthenticationEnabled,
    'iops': obj.iops,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_ClusterSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_ClusterSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'manageMasterUserPassword': obj.manageMasterUserPassword,
    'masterPasswordSecretRef': toJson_ClusterSpecForProviderMasterPasswordSecretRef(obj.masterPasswordSecretRef),
    'masterUserSecretKmsKeyId': obj.masterUserSecretKmsKeyId,
    'masterUserSecretKmsKeyIdRef': toJson_ClusterSpecForProviderMasterUserSecretKmsKeyIdRef(obj.masterUserSecretKmsKeyIdRef),
    'masterUserSecretKmsKeyIdSelector': toJson_ClusterSpecForProviderMasterUserSecretKmsKeyIdSelector(obj.masterUserSecretKmsKeyIdSelector),
    'masterUsername': obj.masterUsername,
    'networkType': obj.networkType,
    'port': obj.port,
    'preferredBackupWindow': obj.preferredBackupWindow,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'region': obj.region,
    'replicationSourceIdentifier': obj.replicationSourceIdentifier,
    'restoreToPointInTime': obj.restoreToPointInTime?.map(y => toJson_ClusterSpecForProviderRestoreToPointInTime(y)),
    's3Import': obj.s3Import?.map(y => toJson_ClusterSpecForProviderS3Import(y)),
    'scalingConfiguration': obj.scalingConfiguration?.map(y => toJson_ClusterSpecForProviderScalingConfiguration(y)),
    'serverlessv2ScalingConfiguration': obj.serverlessv2ScalingConfiguration?.map(y => toJson_ClusterSpecForProviderServerlessv2ScalingConfiguration(y)),
    'skipFinalSnapshot': obj.skipFinalSnapshot,
    'snapshotIdentifier': obj.snapshotIdentifier,
    'sourceRegion': obj.sourceRegion,
    'storageEncrypted': obj.storageEncrypted,
    'storageType': obj.storageType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcSecurityGroupIdRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_ClusterSpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIdSelector': toJson_ClusterSpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIds': obj.vpcSecurityGroupIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClusterSpecInitProvider
 */
export interface ClusterSpecInitProvider {
  /**
   * The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.
   *
   * @schema ClusterSpecInitProvider#allocatedStorage
   */
  readonly allocatedStorage?: number;

  /**
   * Enable to allow major engine version upgrades when changing engine versions. Defaults to false.
   *
   * @default false.
   * @schema ClusterSpecInitProvider#allowMajorVersionUpgrade
   */
  readonly allowMajorVersionUpgrade?: boolean;

  /**
   * Specifies whether any cluster modifications are applied immediately, or during the next maintenance window. Default is false. See Amazon RDS Documentation for more information.
   *
   * @default false. See Amazon RDS Documentation for more information.
   * @schema ClusterSpecInitProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * List of EC2 Availability Zones for the DB cluster storage where DB cluster instances can be created. We recommend specifying 3 AZs or using the  if necessary. A maximum of 3 AZs can be configured.
   *
   * @schema ClusterSpecInitProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * The target backtrack window, in seconds. Only available for aurora and aurora-mysql engines currently. To disable backtracking, set this value to 0. Defaults to 0. Must be between 0 and 259200 (72 hours)
   *
   * @default 0. Must be between 0 and 259200 (72 hours)
   * @schema ClusterSpecInitProvider#backtrackWindow
   */
  readonly backtrackWindow?: number;

  /**
   * The days to retain backups for. Default 1
   *
   * @schema ClusterSpecInitProvider#backupRetentionPeriod
   */
  readonly backupRetentionPeriod?: number;

  /**
   * – List of RDS Instances that are a part of this cluster
   *
   * @schema ClusterSpecInitProvider#clusterMembers
   */
  readonly clusterMembers?: string[];

  /**
   * –  Copy all Cluster tags to snapshots. Default is false.
   *
   * @default false.
   * @schema ClusterSpecInitProvider#copyTagsToSnapshot
   */
  readonly copyTagsToSnapshot?: boolean;

  /**
   * Name for an automatically created database on cluster creation. There are different naming restrictions per database engine: RDS Naming Constraints
   *
   * @schema ClusterSpecInitProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6g.xlarge. Not all DB instance classes are available in all AWS Regions, or for all database engines. For the full list of DB instance classes and availability for your engine, see DB instance class in the Amazon RDS User Guide.
   *
   * @schema ClusterSpecInitProvider#dbClusterInstanceClass
   */
  readonly dbClusterInstanceClass?: string;

  /**
   * A cluster parameter group to associate with the cluster.
   *
   * @schema ClusterSpecInitProvider#dbClusterParameterGroupName
   */
  readonly dbClusterParameterGroupName?: string;

  /**
   * Instance parameter group to associate with all instances of the DB cluster. The db_instance_parameter_group_name parameter is only valid in combination with the allow_major_version_upgrade parameter.
   *
   * @schema ClusterSpecInitProvider#dbInstanceParameterGroupName
   */
  readonly dbInstanceParameterGroupName?: string;

  /**
   * If the DB instance should have deletion protection enabled. The database can't be deleted when this value is set to true. The default is false.
   *
   * @schema ClusterSpecInitProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Whether cluster should forward writes to an associated global cluster. Applied to secondary clusters to enable them to forward writes to an aws_rds_global_cluster's primary cluster. See the Aurora Userguide documentation for more information.
   *
   * @schema ClusterSpecInitProvider#enableGlobalWriteForwarding
   */
  readonly enableGlobalWriteForwarding?: boolean;

  /**
   * Enable HTTP endpoint (data API). Only valid when engine_mode is set to serverless.
   *
   * @schema ClusterSpecInitProvider#enableHttpEndpoint
   */
  readonly enableHttpEndpoint?: boolean;

  /**
   * Set of log types to export to cloudwatch. If omitted, no logs will be exported. The following log types are supported: audit, error, general, slowquery, postgresql (PostgreSQL).
   *
   * @schema ClusterSpecInitProvider#enabledCloudwatchLogsExports
   */
  readonly enabledCloudwatchLogsExports?: string[];

  /**
   * The name of the database engine to be used for this DB cluster. Defaults to aurora. Valid Values: aurora, aurora-mysql, aurora-postgresql, mysql, postgres. (Note that mysql and postgres are Multi-AZ RDS clusters).
   *
   * @default aurora. Valid Values: aurora, aurora-mysql, aurora-postgresql, mysql, postgres. (Note that mysql and postgres are Multi-AZ RDS clusters).
   * @schema ClusterSpecInitProvider#engine
   */
  readonly engine?: string;

  /**
   * The database engine mode. Valid values: global (only valid for Aurora MySQL 1.21 and earlier), multimaster, parallelquery, provisioned, serverless. Defaults to: provisioned. See the RDS User Guide for limitations when using serverless.
   *
   * @default provisioned. See the RDS User Guide for limitations when using serverless.
   * @schema ClusterSpecInitProvider#engineMode
   */
  readonly engineMode?: string;

  /**
   * The database engine version. Updating this argument results in an outage. See the Aurora MySQL and Aurora Postgres documentation for your configured engine to determine this value, or by running aws rds describe-db-engine-versions. For example with Aurora MySQL 2, a potential value for this argument is 5.7.mysql_aurora.2.03.2. The value can contain a partial version where supported by the API. The actual engine version used is returned in the attribute engine_version_actual, , see Attributes Reference below.
   *
   * @schema ClusterSpecInitProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The name of your final DB snapshot when this DB cluster is deleted. If omitted, no final snapshot will be made.
   *
   * @schema ClusterSpecInitProvider#finalSnapshotIdentifier
   */
  readonly finalSnapshotIdentifier?: string;

  /**
   * The global cluster identifier specified on aws_rds_global_cluster.
   *
   * @schema ClusterSpecInitProvider#globalClusterIdentifier
   */
  readonly globalClusterIdentifier?: string;

  /**
   * Specifies whether or not mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled. Please see AWS Documentation for availability and limitations.
   *
   * @schema ClusterSpecInitProvider#iamDatabaseAuthenticationEnabled
   */
  readonly iamDatabaseAuthenticationEnabled?: boolean;

  /**
   * The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster. For information about valid Iops values, see Amazon RDS Provisioned IOPS storage to improve performance in the Amazon RDS User Guide. Must be a multiple between .5 and 50 of the storage amount for the DB cluster.
   *
   * @schema ClusterSpecInitProvider#iops
   */
  readonly iops?: number;

  /**
   * Set to true to allow RDS to manage the master user password in Secrets Manager. Cannot be set if master_password is provided.
   *
   * @schema ClusterSpecInitProvider#manageMasterUserPassword
   */
  readonly manageMasterUserPassword?: boolean;

  /**
   * Username for the master DB user. Please refer to the RDS Naming Constraints. This argument does not support in-place updates and cannot be changed during a restore from snapshot.
   *
   * @schema ClusterSpecInitProvider#masterUsername
   */
  readonly masterUsername?: string;

  /**
   * The network type of the cluster. Valid values: IPV4, DUAL.
   *
   * @schema ClusterSpecInitProvider#networkType
   */
  readonly networkType?: string;

  /**
   * The port on which the DB accepts connections
   *
   * @schema ClusterSpecInitProvider#port
   */
  readonly port?: number;

  /**
   * The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.Time in UTC. Default: A 30-minute window selected at random from an 8-hour block of time per regionE.g., 04:00-09:00
   *
   * @schema ClusterSpecInitProvider#preferredBackupWindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The weekly time range during which system maintenance can occur, in (UTC) e.g., wed:04:00-wed:04:30
   *
   * @schema ClusterSpecInitProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * ARN of a source DB cluster or DB instance if this DB cluster is to be created as a Read Replica.
   *
   * @schema ClusterSpecInitProvider#replicationSourceIdentifier
   */
  readonly replicationSourceIdentifier?: string;

  /**
   * Nested attribute for point in time restore. More details below.
   *
   * @schema ClusterSpecInitProvider#restoreToPointInTime
   */
  readonly restoreToPointInTime?: ClusterSpecInitProviderRestoreToPointInTime[];

  /**
   * The port on which the DB accepts connections
   *
   * @schema ClusterSpecInitProvider#s3Import
   */
  readonly s3Import?: ClusterSpecInitProviderS3Import[];

  /**
   * Nested attribute with scaling properties. Only valid when engine_mode is set to serverless. More details below.
   *
   * @schema ClusterSpecInitProvider#scalingConfiguration
   */
  readonly scalingConfiguration?: ClusterSpecInitProviderScalingConfiguration[];

  /**
   * Nested attribute with scaling properties for ServerlessV2. Only valid when engine_mode is set to provisioned. More details below.
   *
   * @schema ClusterSpecInitProvider#serverlessv2ScalingConfiguration
   */
  readonly serverlessv2ScalingConfiguration?: ClusterSpecInitProviderServerlessv2ScalingConfiguration[];

  /**
   * Determines whether a final DB snapshot is created before the DB cluster is deleted. If true is specified, no DB snapshot is created. If false is specified, a DB snapshot is created before the DB cluster is deleted, using the value from final_snapshot_identifier. Default is false.
   *
   * @default false.
   * @schema ClusterSpecInitProvider#skipFinalSnapshot
   */
  readonly skipFinalSnapshot?: boolean;

  /**
   * Specifies whether or not to create this cluster from a snapshot. You can use either the name or ARN when specifying a DB cluster snapshot, or the ARN when specifying a DB snapshot. Conflicts with global_cluster_identifier. Clusters cannot be restored from snapshot and joined to an existing global cluster in a single operation. See the AWS documentation or the Global Cluster Restored From Snapshot example for instructions on building a global cluster starting with a snapshot.
   *
   * @schema ClusterSpecInitProvider#snapshotIdentifier
   */
  readonly snapshotIdentifier?: string;

  /**
   * The source region for an encrypted replica DB cluster.
   *
   * @schema ClusterSpecInitProvider#sourceRegion
   */
  readonly sourceRegion?: string;

  /**
   * Specifies whether the DB cluster is encrypted. The default is false for provisioned engine_mode and true for serverless engine_mode. When restoring an unencrypted snapshot_identifier, the kms_key_id argument must be provided to encrypt the restored cluster.
   *
   * @schema ClusterSpecInitProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

  /**
   * (Forces new for Multi-AZ DB clusters) Specifies the storage type to be associated with the DB cluster. For Aurora DB clusters, storage_type modifications can be done in-place. For Multi-AZ DB Clusters, the iops argument must also be set. Valid values are: "", aurora-iopt1 (Aurora DB Clusters); io1 (Multi-AZ DB Clusters). Default: "" (Aurora DB Clusters); io1 (Multi-AZ DB Clusters).
   *
   * @schema ClusterSpecInitProvider#storageType
   */
  readonly storageType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProvider(obj: ClusterSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedStorage': obj.allocatedStorage,
    'allowMajorVersionUpgrade': obj.allowMajorVersionUpgrade,
    'applyImmediately': obj.applyImmediately,
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'backtrackWindow': obj.backtrackWindow,
    'backupRetentionPeriod': obj.backupRetentionPeriod,
    'clusterMembers': obj.clusterMembers?.map(y => y),
    'copyTagsToSnapshot': obj.copyTagsToSnapshot,
    'databaseName': obj.databaseName,
    'dbClusterInstanceClass': obj.dbClusterInstanceClass,
    'dbClusterParameterGroupName': obj.dbClusterParameterGroupName,
    'dbInstanceParameterGroupName': obj.dbInstanceParameterGroupName,
    'deletionProtection': obj.deletionProtection,
    'enableGlobalWriteForwarding': obj.enableGlobalWriteForwarding,
    'enableHttpEndpoint': obj.enableHttpEndpoint,
    'enabledCloudwatchLogsExports': obj.enabledCloudwatchLogsExports?.map(y => y),
    'engine': obj.engine,
    'engineMode': obj.engineMode,
    'engineVersion': obj.engineVersion,
    'finalSnapshotIdentifier': obj.finalSnapshotIdentifier,
    'globalClusterIdentifier': obj.globalClusterIdentifier,
    'iamDatabaseAuthenticationEnabled': obj.iamDatabaseAuthenticationEnabled,
    'iops': obj.iops,
    'manageMasterUserPassword': obj.manageMasterUserPassword,
    'masterUsername': obj.masterUsername,
    'networkType': obj.networkType,
    'port': obj.port,
    'preferredBackupWindow': obj.preferredBackupWindow,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'replicationSourceIdentifier': obj.replicationSourceIdentifier,
    'restoreToPointInTime': obj.restoreToPointInTime?.map(y => toJson_ClusterSpecInitProviderRestoreToPointInTime(y)),
    's3Import': obj.s3Import?.map(y => toJson_ClusterSpecInitProviderS3Import(y)),
    'scalingConfiguration': obj.scalingConfiguration?.map(y => toJson_ClusterSpecInitProviderScalingConfiguration(y)),
    'serverlessv2ScalingConfiguration': obj.serverlessv2ScalingConfiguration?.map(y => toJson_ClusterSpecInitProviderServerlessv2ScalingConfiguration(y)),
    'skipFinalSnapshot': obj.skipFinalSnapshot,
    'snapshotIdentifier': obj.snapshotIdentifier,
    'sourceRegion': obj.sourceRegion,
    'storageEncrypted': obj.storageEncrypted,
    'storageType': obj.storageType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterSpecManagementPolicies
 */
export enum ClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a SubnetGroup to populate dbSubnetGroupName.
 *
 * @schema ClusterSpecForProviderDbSubnetGroupNameRef
 */
export interface ClusterSpecForProviderDbSubnetGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderDbSubnetGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderDbSubnetGroupNameRef#policy
   */
  readonly policy?: ClusterSpecForProviderDbSubnetGroupNameRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderDbSubnetGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderDbSubnetGroupNameRef(obj: ClusterSpecForProviderDbSubnetGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderDbSubnetGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a SubnetGroup to populate dbSubnetGroupName.
 *
 * @schema ClusterSpecForProviderDbSubnetGroupNameSelector
 */
export interface ClusterSpecForProviderDbSubnetGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderDbSubnetGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderDbSubnetGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderDbSubnetGroupNameSelector#policy
   */
  readonly policy?: ClusterSpecForProviderDbSubnetGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderDbSubnetGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderDbSubnetGroupNameSelector(obj: ClusterSpecForProviderDbSubnetGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderDbSubnetGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRef
 */
export interface ClusterSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: ClusterSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdRef(obj: ClusterSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelector
 */
export interface ClusterSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdSelector(obj: ClusterSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Please refer to the RDS Naming Constraints. Cannot be set if manage_master_user_password is set to true.
 *
 * @schema ClusterSpecForProviderMasterPasswordSecretRef
 */
export interface ClusterSpecForProviderMasterPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema ClusterSpecForProviderMasterPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ClusterSpecForProviderMasterPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecForProviderMasterPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderMasterPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderMasterPasswordSecretRef(obj: ClusterSpecForProviderMasterPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate masterUserSecretKmsKeyId.
 *
 * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdRef
 */
export interface ClusterSpecForProviderMasterUserSecretKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdRef#policy
   */
  readonly policy?: ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderMasterUserSecretKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderMasterUserSecretKmsKeyIdRef(obj: ClusterSpecForProviderMasterUserSecretKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate masterUserSecretKmsKeyId.
 *
 * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdSelector
 */
export interface ClusterSpecForProviderMasterUserSecretKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderMasterUserSecretKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderMasterUserSecretKmsKeyIdSelector(obj: ClusterSpecForProviderMasterUserSecretKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderRestoreToPointInTime
 */
export interface ClusterSpecForProviderRestoreToPointInTime {
  /**
   * Date and time in UTC format to restore the database cluster to. Conflicts with use_latest_restorable_time.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTime#restoreToTime
   */
  readonly restoreToTime?: string;

  /**
   * Type of restore to be performed. Valid options are full-copy (default) and copy-on-write.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTime#restoreType
   */
  readonly restoreType?: string;

  /**
   * The identifier of the source database cluster from which to restore.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTime#sourceClusterIdentifier
   */
  readonly sourceClusterIdentifier?: string;

  /**
   * Reference to a Cluster to populate sourceClusterIdentifier.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTime#sourceClusterIdentifierRef
   */
  readonly sourceClusterIdentifierRef?: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRef;

  /**
   * Selector for a Cluster to populate sourceClusterIdentifier.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTime#sourceClusterIdentifierSelector
   */
  readonly sourceClusterIdentifierSelector?: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelector;

  /**
   * Set to true to restore the database cluster to the latest restorable backup time. Defaults to false. Conflicts with restore_to_time.
   *
   * @default false. Conflicts with restore_to_time.
   * @schema ClusterSpecForProviderRestoreToPointInTime#useLatestRestorableTime
   */
  readonly useLatestRestorableTime?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRestoreToPointInTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRestoreToPointInTime(obj: ClusterSpecForProviderRestoreToPointInTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'restoreToTime': obj.restoreToTime,
    'restoreType': obj.restoreType,
    'sourceClusterIdentifier': obj.sourceClusterIdentifier,
    'sourceClusterIdentifierRef': toJson_ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRef(obj.sourceClusterIdentifierRef),
    'sourceClusterIdentifierSelector': toJson_ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelector(obj.sourceClusterIdentifierSelector),
    'useLatestRestorableTime': obj.useLatestRestorableTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderS3Import
 */
export interface ClusterSpecForProviderS3Import {
  /**
   * The bucket name where your backup is stored
   *
   * @schema ClusterSpecForProviderS3Import#bucketName
   */
  readonly bucketName?: string;

  /**
   * Reference to a Bucket in s3 to populate bucketName.
   *
   * @schema ClusterSpecForProviderS3Import#bucketNameRef
   */
  readonly bucketNameRef?: ClusterSpecForProviderS3ImportBucketNameRef;

  /**
   * Selector for a Bucket in s3 to populate bucketName.
   *
   * @schema ClusterSpecForProviderS3Import#bucketNameSelector
   */
  readonly bucketNameSelector?: ClusterSpecForProviderS3ImportBucketNameSelector;

  /**
   * Can be blank, but is the path to your backup
   *
   * @schema ClusterSpecForProviderS3Import#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * Role applied to load the data.
   *
   * @schema ClusterSpecForProviderS3Import#ingestionRole
   */
  readonly ingestionRole?: string;

  /**
   * Source engine for the backup
   *
   * @schema ClusterSpecForProviderS3Import#sourceEngine
   */
  readonly sourceEngine?: string;

  /**
   * Version of the source engine used to make the backup
   *
   * @schema ClusterSpecForProviderS3Import#sourceEngineVersion
   */
  readonly sourceEngineVersion?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderS3Import' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderS3Import(obj: ClusterSpecForProviderS3Import | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketNameRef': toJson_ClusterSpecForProviderS3ImportBucketNameRef(obj.bucketNameRef),
    'bucketNameSelector': toJson_ClusterSpecForProviderS3ImportBucketNameSelector(obj.bucketNameSelector),
    'bucketPrefix': obj.bucketPrefix,
    'ingestionRole': obj.ingestionRole,
    'sourceEngine': obj.sourceEngine,
    'sourceEngineVersion': obj.sourceEngineVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderScalingConfiguration
 */
export interface ClusterSpecForProviderScalingConfiguration {
  /**
   * Whether to enable automatic pause. A DB cluster can be paused only when it's idle (it has no connections). If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it. Defaults to true.
   *
   * @default true.
   * @schema ClusterSpecForProviderScalingConfiguration#autoPause
   */
  readonly autoPause?: boolean;

  /**
   * The maximum capacity for an Aurora DB cluster in serverless DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 16.
   *
   * @default 16.
   * @schema ClusterSpecForProviderScalingConfiguration#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * The minimum capacity for an Aurora DB cluster in serverless DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 1.
   *
   * @default 1.
   * @schema ClusterSpecForProviderScalingConfiguration#minCapacity
   */
  readonly minCapacity?: number;

  /**
   * The time, in seconds, before an Aurora DB cluster in serverless mode is paused. Valid values are 300 through 86400. Defaults to 300.
   *
   * @default 300.
   * @schema ClusterSpecForProviderScalingConfiguration#secondsUntilAutoPause
   */
  readonly secondsUntilAutoPause?: number;

  /**
   * The action to take when the timeout is reached. Valid values: ForceApplyCapacityChange, RollbackCapacityChange. Defaults to RollbackCapacityChange. See documentation.
   *
   * @default RollbackCapacityChange. See documentation.
   * @schema ClusterSpecForProviderScalingConfiguration#timeoutAction
   */
  readonly timeoutAction?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderScalingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderScalingConfiguration(obj: ClusterSpecForProviderScalingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoPause': obj.autoPause,
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
    'secondsUntilAutoPause': obj.secondsUntilAutoPause,
    'timeoutAction': obj.timeoutAction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderServerlessv2ScalingConfiguration
 */
export interface ClusterSpecForProviderServerlessv2ScalingConfiguration {
  /**
   * The maximum capacity for an Aurora DB cluster in serverless DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 16.
   *
   * @default 16.
   * @schema ClusterSpecForProviderServerlessv2ScalingConfiguration#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * The minimum capacity for an Aurora DB cluster in serverless DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 1.
   *
   * @default 1.
   * @schema ClusterSpecForProviderServerlessv2ScalingConfiguration#minCapacity
   */
  readonly minCapacity?: number;

}

/**
 * Converts an object of type 'ClusterSpecForProviderServerlessv2ScalingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderServerlessv2ScalingConfiguration(obj: ClusterSpecForProviderServerlessv2ScalingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdRefs(obj: ClusterSpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdSelector(obj: ClusterSpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderRestoreToPointInTime
 */
export interface ClusterSpecInitProviderRestoreToPointInTime {
  /**
   * Date and time in UTC format to restore the database cluster to. Conflicts with use_latest_restorable_time.
   *
   * @schema ClusterSpecInitProviderRestoreToPointInTime#restoreToTime
   */
  readonly restoreToTime?: string;

  /**
   * Type of restore to be performed. Valid options are full-copy (default) and copy-on-write.
   *
   * @schema ClusterSpecInitProviderRestoreToPointInTime#restoreType
   */
  readonly restoreType?: string;

  /**
   * Set to true to restore the database cluster to the latest restorable backup time. Defaults to false. Conflicts with restore_to_time.
   *
   * @default false. Conflicts with restore_to_time.
   * @schema ClusterSpecInitProviderRestoreToPointInTime#useLatestRestorableTime
   */
  readonly useLatestRestorableTime?: boolean;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderRestoreToPointInTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderRestoreToPointInTime(obj: ClusterSpecInitProviderRestoreToPointInTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'restoreToTime': obj.restoreToTime,
    'restoreType': obj.restoreType,
    'useLatestRestorableTime': obj.useLatestRestorableTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderS3Import
 */
export interface ClusterSpecInitProviderS3Import {
  /**
   * Can be blank, but is the path to your backup
   *
   * @schema ClusterSpecInitProviderS3Import#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * Role applied to load the data.
   *
   * @schema ClusterSpecInitProviderS3Import#ingestionRole
   */
  readonly ingestionRole?: string;

  /**
   * Source engine for the backup
   *
   * @schema ClusterSpecInitProviderS3Import#sourceEngine
   */
  readonly sourceEngine?: string;

  /**
   * Version of the source engine used to make the backup
   *
   * @schema ClusterSpecInitProviderS3Import#sourceEngineVersion
   */
  readonly sourceEngineVersion?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderS3Import' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderS3Import(obj: ClusterSpecInitProviderS3Import | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketPrefix': obj.bucketPrefix,
    'ingestionRole': obj.ingestionRole,
    'sourceEngine': obj.sourceEngine,
    'sourceEngineVersion': obj.sourceEngineVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderScalingConfiguration
 */
export interface ClusterSpecInitProviderScalingConfiguration {
  /**
   * Whether to enable automatic pause. A DB cluster can be paused only when it's idle (it has no connections). If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot. In this case, the DB cluster is restored when there is a request to connect to it. Defaults to true.
   *
   * @default true.
   * @schema ClusterSpecInitProviderScalingConfiguration#autoPause
   */
  readonly autoPause?: boolean;

  /**
   * The maximum capacity for an Aurora DB cluster in serverless DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 16.
   *
   * @default 16.
   * @schema ClusterSpecInitProviderScalingConfiguration#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * The minimum capacity for an Aurora DB cluster in serverless DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 1.
   *
   * @default 1.
   * @schema ClusterSpecInitProviderScalingConfiguration#minCapacity
   */
  readonly minCapacity?: number;

  /**
   * The time, in seconds, before an Aurora DB cluster in serverless mode is paused. Valid values are 300 through 86400. Defaults to 300.
   *
   * @default 300.
   * @schema ClusterSpecInitProviderScalingConfiguration#secondsUntilAutoPause
   */
  readonly secondsUntilAutoPause?: number;

  /**
   * The action to take when the timeout is reached. Valid values: ForceApplyCapacityChange, RollbackCapacityChange. Defaults to RollbackCapacityChange. See documentation.
   *
   * @default RollbackCapacityChange. See documentation.
   * @schema ClusterSpecInitProviderScalingConfiguration#timeoutAction
   */
  readonly timeoutAction?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderScalingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderScalingConfiguration(obj: ClusterSpecInitProviderScalingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoPause': obj.autoPause,
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
    'secondsUntilAutoPause': obj.secondsUntilAutoPause,
    'timeoutAction': obj.timeoutAction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderServerlessv2ScalingConfiguration
 */
export interface ClusterSpecInitProviderServerlessv2ScalingConfiguration {
  /**
   * The maximum capacity for an Aurora DB cluster in serverless DB engine mode. The maximum capacity must be greater than or equal to the minimum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 16.
   *
   * @default 16.
   * @schema ClusterSpecInitProviderServerlessv2ScalingConfiguration#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * The minimum capacity for an Aurora DB cluster in serverless DB engine mode. The minimum capacity must be lesser than or equal to the maximum capacity. Valid Aurora MySQL capacity values are 1, 2, 4, 8, 16, 32, 64, 128, 256. Valid Aurora PostgreSQL capacity values are (2, 4, 8, 16, 32, 64, 192, and 384). Defaults to 1.
   *
   * @default 1.
   * @schema ClusterSpecInitProviderServerlessv2ScalingConfiguration#minCapacity
   */
  readonly minCapacity?: number;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderServerlessv2ScalingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderServerlessv2ScalingConfiguration(obj: ClusterSpecInitProviderServerlessv2ScalingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderDbSubnetGroupNameRefPolicy
 */
export interface ClusterSpecForProviderDbSubnetGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderDbSubnetGroupNameRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderDbSubnetGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderDbSubnetGroupNameRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderDbSubnetGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderDbSubnetGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderDbSubnetGroupNameRefPolicy(obj: ClusterSpecForProviderDbSubnetGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderDbSubnetGroupNameSelectorPolicy
 */
export interface ClusterSpecForProviderDbSubnetGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderDbSubnetGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderDbSubnetGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderDbSubnetGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderDbSubnetGroupNameSelectorPolicy(obj: ClusterSpecForProviderDbSubnetGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRefPolicy
 */
export interface ClusterSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdRefPolicy(obj: ClusterSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface ClusterSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdSelectorPolicy(obj: ClusterSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicy
 */
export interface ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicy(obj: ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy
 */
export interface ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy(obj: ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate sourceClusterIdentifier.
 *
 * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRef
 */
export interface ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRef#policy
   */
  readonly policy?: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRef(obj: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate sourceClusterIdentifier.
 *
 * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelector
 */
export interface ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelector#policy
   */
  readonly policy?: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelector(obj: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucketName.
 *
 * @schema ClusterSpecForProviderS3ImportBucketNameRef
 */
export interface ClusterSpecForProviderS3ImportBucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderS3ImportBucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderS3ImportBucketNameRef#policy
   */
  readonly policy?: ClusterSpecForProviderS3ImportBucketNameRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderS3ImportBucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderS3ImportBucketNameRef(obj: ClusterSpecForProviderS3ImportBucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderS3ImportBucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucketName.
 *
 * @schema ClusterSpecForProviderS3ImportBucketNameSelector
 */
export interface ClusterSpecForProviderS3ImportBucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderS3ImportBucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderS3ImportBucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderS3ImportBucketNameSelector#policy
   */
  readonly policy?: ClusterSpecForProviderS3ImportBucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderS3ImportBucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderS3ImportBucketNameSelector(obj: ClusterSpecForProviderS3ImportBucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderS3ImportBucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderDbSubnetGroupNameRefPolicyResolution
 */
export enum ClusterSpecForProviderDbSubnetGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderDbSubnetGroupNameRefPolicyResolve
 */
export enum ClusterSpecForProviderDbSubnetGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolution
 */
export enum ClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolve
 */
export enum ClusterSpecForProviderDbSubnetGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum ClusterSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum ClusterSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolution
 */
export enum ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolve
 */
export enum ClusterSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy
 */
export interface ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy(obj: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy
 */
export interface ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy(obj: ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderS3ImportBucketNameRefPolicy
 */
export interface ClusterSpecForProviderS3ImportBucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderS3ImportBucketNameRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderS3ImportBucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderS3ImportBucketNameRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderS3ImportBucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderS3ImportBucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderS3ImportBucketNameRefPolicy(obj: ClusterSpecForProviderS3ImportBucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderS3ImportBucketNameSelectorPolicy
 */
export interface ClusterSpecForProviderS3ImportBucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderS3ImportBucketNameSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderS3ImportBucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderS3ImportBucketNameSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderS3ImportBucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderS3ImportBucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderS3ImportBucketNameSelectorPolicy(obj: ClusterSpecForProviderS3ImportBucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolution
 */
export enum ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolve
 */
export enum ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolution
 */
export enum ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolve
 */
export enum ClusterSpecForProviderRestoreToPointInTimeSourceClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderS3ImportBucketNameRefPolicyResolution
 */
export enum ClusterSpecForProviderS3ImportBucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderS3ImportBucketNameRefPolicyResolve
 */
export enum ClusterSpecForProviderS3ImportBucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderS3ImportBucketNameSelectorPolicyResolution
 */
export enum ClusterSpecForProviderS3ImportBucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderS3ImportBucketNameSelectorPolicyResolve
 */
export enum ClusterSpecForProviderS3ImportBucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterActivityStream is the Schema for the ClusterActivityStreams API. Manages RDS Aurora Cluster Database Activity Streams
 *
 * @schema ClusterActivityStream
 */
export class ClusterActivityStream extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterActivityStream"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'ClusterActivityStream',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterActivityStream".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterActivityStreamProps): any {
    return {
      ...ClusterActivityStream.GVK,
      ...toJson_ClusterActivityStreamProps(props),
    };
  }

  /**
   * Defines a "ClusterActivityStream" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterActivityStreamProps) {
    super(scope, id, {
      ...ClusterActivityStream.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterActivityStream.GVK,
      ...toJson_ClusterActivityStreamProps(resolved),
    };
  }
}

/**
 * ClusterActivityStream is the Schema for the ClusterActivityStreams API. Manages RDS Aurora Cluster Database Activity Streams
 *
 * @schema ClusterActivityStream
 */
export interface ClusterActivityStreamProps {
  /**
   * @schema ClusterActivityStream#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterActivityStreamSpec defines the desired state of ClusterActivityStream
   *
   * @schema ClusterActivityStream#spec
   */
  readonly spec: ClusterActivityStreamSpec;

}

/**
 * Converts an object of type 'ClusterActivityStreamProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamProps(obj: ClusterActivityStreamProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterActivityStreamSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterActivityStreamSpec defines the desired state of ClusterActivityStream
 *
 * @schema ClusterActivityStreamSpec
 */
export interface ClusterActivityStreamSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterActivityStreamSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterActivityStreamSpecDeletionPolicy;

  /**
   * @schema ClusterActivityStreamSpec#forProvider
   */
  readonly forProvider: ClusterActivityStreamSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClusterActivityStreamSpec#initProvider
   */
  readonly initProvider?: ClusterActivityStreamSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterActivityStreamSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterActivityStreamSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterActivityStreamSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterActivityStreamSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterActivityStreamSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterActivityStreamSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterActivityStreamSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterActivityStreamSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpec(obj: ClusterActivityStreamSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterActivityStreamSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterActivityStreamSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterActivityStreamSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterActivityStreamSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterActivityStreamSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterActivityStreamSpecDeletionPolicy
 */
export enum ClusterActivityStreamSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterActivityStreamSpecForProvider
 */
export interface ClusterActivityStreamSpecForProvider {
  /**
   * Specifies whether the database activity stream includes engine-native audit fields. This option only applies to an Oracle DB instance. By default, no engine-native audit fields are included. Defaults false.
   *
   * @schema ClusterActivityStreamSpecForProvider#engineNativeAuditFieldsIncluded
   */
  readonly engineNativeAuditFieldsIncluded?: boolean;

  /**
   * The AWS KMS key identifier for encrypting messages in the database activity stream. The AWS KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
   *
   * @schema ClusterActivityStreamSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema ClusterActivityStreamSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: ClusterActivityStreamSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema ClusterActivityStreamSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: ClusterActivityStreamSpecForProviderKmsKeyIdSelector;

  /**
   * Specifies the mode of the database activity stream. Database events such as a change or access generate an activity stream event. The database session can handle these events either synchronously or asynchronously. One of: sync, async.
   *
   * @schema ClusterActivityStreamSpecForProvider#mode
   */
  readonly mode?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterActivityStreamSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the DB cluster.
   *
   * @schema ClusterActivityStreamSpecForProvider#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a Cluster in rds to populate resourceArn.
   *
   * @schema ClusterActivityStreamSpecForProvider#resourceArnRef
   */
  readonly resourceArnRef?: ClusterActivityStreamSpecForProviderResourceArnRef;

  /**
   * Selector for a Cluster in rds to populate resourceArn.
   *
   * @schema ClusterActivityStreamSpecForProvider#resourceArnSelector
   */
  readonly resourceArnSelector?: ClusterActivityStreamSpecForProviderResourceArnSelector;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecForProvider(obj: ClusterActivityStreamSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'engineNativeAuditFieldsIncluded': obj.engineNativeAuditFieldsIncluded,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_ClusterActivityStreamSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_ClusterActivityStreamSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'mode': obj.mode,
    'region': obj.region,
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_ClusterActivityStreamSpecForProviderResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_ClusterActivityStreamSpecForProviderResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClusterActivityStreamSpecInitProvider
 */
export interface ClusterActivityStreamSpecInitProvider {
  /**
   * Specifies whether the database activity stream includes engine-native audit fields. This option only applies to an Oracle DB instance. By default, no engine-native audit fields are included. Defaults false.
   *
   * @schema ClusterActivityStreamSpecInitProvider#engineNativeAuditFieldsIncluded
   */
  readonly engineNativeAuditFieldsIncluded?: boolean;

  /**
   * Specifies the mode of the database activity stream. Database events such as a change or access generate an activity stream event. The database session can handle these events either synchronously or asynchronously. One of: sync, async.
   *
   * @schema ClusterActivityStreamSpecInitProvider#mode
   */
  readonly mode?: string;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecInitProvider(obj: ClusterActivityStreamSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'engineNativeAuditFieldsIncluded': obj.engineNativeAuditFieldsIncluded,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterActivityStreamSpecManagementPolicies
 */
export enum ClusterActivityStreamSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterActivityStreamSpecProviderConfigRef
 */
export interface ClusterActivityStreamSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterActivityStreamSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterActivityStreamSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterActivityStreamSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecProviderConfigRef(obj: ClusterActivityStreamSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterActivityStreamSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterActivityStreamSpecPublishConnectionDetailsTo
 */
export interface ClusterActivityStreamSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterActivityStreamSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterActivityStreamSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterActivityStreamSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterActivityStreamSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterActivityStreamSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecPublishConnectionDetailsTo(obj: ClusterActivityStreamSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterActivityStreamSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterActivityStreamSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterActivityStreamSpecWriteConnectionSecretToRef
 */
export interface ClusterActivityStreamSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterActivityStreamSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterActivityStreamSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecWriteConnectionSecretToRef(obj: ClusterActivityStreamSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema ClusterActivityStreamSpecForProviderKmsKeyIdRef
 */
export interface ClusterActivityStreamSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterActivityStreamSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterActivityStreamSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecForProviderKmsKeyIdRef(obj: ClusterActivityStreamSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema ClusterActivityStreamSpecForProviderKmsKeyIdSelector
 */
export interface ClusterActivityStreamSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterActivityStreamSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterActivityStreamSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterActivityStreamSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecForProviderKmsKeyIdSelector(obj: ClusterActivityStreamSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in rds to populate resourceArn.
 *
 * @schema ClusterActivityStreamSpecForProviderResourceArnRef
 */
export interface ClusterActivityStreamSpecForProviderResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterActivityStreamSpecForProviderResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterActivityStreamSpecForProviderResourceArnRef#policy
   */
  readonly policy?: ClusterActivityStreamSpecForProviderResourceArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecForProviderResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecForProviderResourceArnRef(obj: ClusterActivityStreamSpecForProviderResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterActivityStreamSpecForProviderResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in rds to populate resourceArn.
 *
 * @schema ClusterActivityStreamSpecForProviderResourceArnSelector
 */
export interface ClusterActivityStreamSpecForProviderResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterActivityStreamSpecForProviderResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterActivityStreamSpecForProviderResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterActivityStreamSpecForProviderResourceArnSelector#policy
   */
  readonly policy?: ClusterActivityStreamSpecForProviderResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecForProviderResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecForProviderResourceArnSelector(obj: ClusterActivityStreamSpecForProviderResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterActivityStreamSpecForProviderResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterActivityStreamSpecProviderConfigRefPolicy
 */
export interface ClusterActivityStreamSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterActivityStreamSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterActivityStreamSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterActivityStreamSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterActivityStreamSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecProviderConfigRefPolicy(obj: ClusterActivityStreamSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterActivityStreamSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterActivityStreamSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterActivityStreamSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterActivityStreamSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecPublishConnectionDetailsToConfigRef(obj: ClusterActivityStreamSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterActivityStreamSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterActivityStreamSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterActivityStreamSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterActivityStreamSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterActivityStreamSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecPublishConnectionDetailsToMetadata(obj: ClusterActivityStreamSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicy
 */
export interface ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicy(obj: ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicy(obj: ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterActivityStreamSpecForProviderResourceArnRefPolicy
 */
export interface ClusterActivityStreamSpecForProviderResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterActivityStreamSpecForProviderResourceArnRefPolicy#resolution
   */
  readonly resolution?: ClusterActivityStreamSpecForProviderResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterActivityStreamSpecForProviderResourceArnRefPolicy#resolve
   */
  readonly resolve?: ClusterActivityStreamSpecForProviderResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecForProviderResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecForProviderResourceArnRefPolicy(obj: ClusterActivityStreamSpecForProviderResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterActivityStreamSpecForProviderResourceArnSelectorPolicy
 */
export interface ClusterActivityStreamSpecForProviderResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterActivityStreamSpecForProviderResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterActivityStreamSpecForProviderResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterActivityStreamSpecForProviderResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterActivityStreamSpecForProviderResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecForProviderResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecForProviderResourceArnSelectorPolicy(obj: ClusterActivityStreamSpecForProviderResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterActivityStreamSpecProviderConfigRefPolicyResolution
 */
export enum ClusterActivityStreamSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterActivityStreamSpecProviderConfigRefPolicyResolve
 */
export enum ClusterActivityStreamSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum ClusterActivityStreamSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum ClusterActivityStreamSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterActivityStreamSpecForProviderResourceArnRefPolicyResolution
 */
export enum ClusterActivityStreamSpecForProviderResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterActivityStreamSpecForProviderResourceArnRefPolicyResolve
 */
export enum ClusterActivityStreamSpecForProviderResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterActivityStreamSpecForProviderResourceArnSelectorPolicyResolution
 */
export enum ClusterActivityStreamSpecForProviderResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterActivityStreamSpecForProviderResourceArnSelectorPolicyResolve
 */
export enum ClusterActivityStreamSpecForProviderResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterActivityStreamSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterEndpoint is the Schema for the ClusterEndpoints API. Manages an RDS Aurora Cluster Endpoint
 *
 * @schema ClusterEndpoint
 */
export class ClusterEndpoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterEndpoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'ClusterEndpoint',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterEndpoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterEndpointProps): any {
    return {
      ...ClusterEndpoint.GVK,
      ...toJson_ClusterEndpointProps(props),
    };
  }

  /**
   * Defines a "ClusterEndpoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterEndpointProps) {
    super(scope, id, {
      ...ClusterEndpoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterEndpoint.GVK,
      ...toJson_ClusterEndpointProps(resolved),
    };
  }
}

/**
 * ClusterEndpoint is the Schema for the ClusterEndpoints API. Manages an RDS Aurora Cluster Endpoint
 *
 * @schema ClusterEndpoint
 */
export interface ClusterEndpointProps {
  /**
   * @schema ClusterEndpoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterEndpointSpec defines the desired state of ClusterEndpoint
   *
   * @schema ClusterEndpoint#spec
   */
  readonly spec: ClusterEndpointSpec;

}

/**
 * Converts an object of type 'ClusterEndpointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointProps(obj: ClusterEndpointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterEndpointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterEndpointSpec defines the desired state of ClusterEndpoint
 *
 * @schema ClusterEndpointSpec
 */
export interface ClusterEndpointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterEndpointSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterEndpointSpecDeletionPolicy;

  /**
   * @schema ClusterEndpointSpec#forProvider
   */
  readonly forProvider: ClusterEndpointSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClusterEndpointSpec#initProvider
   */
  readonly initProvider?: ClusterEndpointSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterEndpointSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterEndpointSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterEndpointSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterEndpointSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterEndpointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterEndpointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterEndpointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterEndpointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterEndpointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpec(obj: ClusterEndpointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterEndpointSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterEndpointSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterEndpointSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterEndpointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterEndpointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterEndpointSpecDeletionPolicy
 */
export enum ClusterEndpointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterEndpointSpecForProvider
 */
export interface ClusterEndpointSpecForProvider {
  /**
   * The cluster identifier.
   *
   * @schema ClusterEndpointSpecForProvider#clusterIdentifier
   */
  readonly clusterIdentifier?: string;

  /**
   * Reference to a Cluster in rds to populate clusterIdentifier.
   *
   * @schema ClusterEndpointSpecForProvider#clusterIdentifierRef
   */
  readonly clusterIdentifierRef?: ClusterEndpointSpecForProviderClusterIdentifierRef;

  /**
   * Selector for a Cluster in rds to populate clusterIdentifier.
   *
   * @schema ClusterEndpointSpecForProvider#clusterIdentifierSelector
   */
  readonly clusterIdentifierSelector?: ClusterEndpointSpecForProviderClusterIdentifierSelector;

  /**
   * The type of the endpoint. One of: READER , ANY .
   *
   * @schema ClusterEndpointSpecForProvider#customEndpointType
   */
  readonly customEndpointType?: string;

  /**
   * List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. Only relevant if the list of static members is empty. Conflicts with static_members.
   *
   * @schema ClusterEndpointSpecForProvider#excludedMembers
   */
  readonly excludedMembers?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterEndpointSpecForProvider#region
   */
  readonly region: string;

  /**
   * List of DB instance identifiers that are part of the custom endpoint group. Conflicts with excluded_members.
   *
   * @schema ClusterEndpointSpecForProvider#staticMembers
   */
  readonly staticMembers?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterEndpointSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterEndpointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecForProvider(obj: ClusterEndpointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterIdentifier': obj.clusterIdentifier,
    'clusterIdentifierRef': toJson_ClusterEndpointSpecForProviderClusterIdentifierRef(obj.clusterIdentifierRef),
    'clusterIdentifierSelector': toJson_ClusterEndpointSpecForProviderClusterIdentifierSelector(obj.clusterIdentifierSelector),
    'customEndpointType': obj.customEndpointType,
    'excludedMembers': obj.excludedMembers?.map(y => y),
    'region': obj.region,
    'staticMembers': obj.staticMembers?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClusterEndpointSpecInitProvider
 */
export interface ClusterEndpointSpecInitProvider {
  /**
   * The type of the endpoint. One of: READER , ANY .
   *
   * @schema ClusterEndpointSpecInitProvider#customEndpointType
   */
  readonly customEndpointType?: string;

  /**
   * List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. Only relevant if the list of static members is empty. Conflicts with static_members.
   *
   * @schema ClusterEndpointSpecInitProvider#excludedMembers
   */
  readonly excludedMembers?: string[];

  /**
   * List of DB instance identifiers that are part of the custom endpoint group. Conflicts with excluded_members.
   *
   * @schema ClusterEndpointSpecInitProvider#staticMembers
   */
  readonly staticMembers?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterEndpointSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterEndpointSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecInitProvider(obj: ClusterEndpointSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customEndpointType': obj.customEndpointType,
    'excludedMembers': obj.excludedMembers?.map(y => y),
    'staticMembers': obj.staticMembers?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterEndpointSpecManagementPolicies
 */
export enum ClusterEndpointSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterEndpointSpecProviderConfigRef
 */
export interface ClusterEndpointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterEndpointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterEndpointSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterEndpointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterEndpointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecProviderConfigRef(obj: ClusterEndpointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterEndpointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsTo
 */
export interface ClusterEndpointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterEndpointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterEndpointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterEndpointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecPublishConnectionDetailsTo(obj: ClusterEndpointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterEndpointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterEndpointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterEndpointSpecWriteConnectionSecretToRef
 */
export interface ClusterEndpointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterEndpointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterEndpointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterEndpointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecWriteConnectionSecretToRef(obj: ClusterEndpointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in rds to populate clusterIdentifier.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierRef
 */
export interface ClusterEndpointSpecForProviderClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierRef#policy
   */
  readonly policy?: ClusterEndpointSpecForProviderClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterEndpointSpecForProviderClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecForProviderClusterIdentifierRef(obj: ClusterEndpointSpecForProviderClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterEndpointSpecForProviderClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in rds to populate clusterIdentifier.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierSelector
 */
export interface ClusterEndpointSpecForProviderClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierSelector#policy
   */
  readonly policy?: ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterEndpointSpecForProviderClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecForProviderClusterIdentifierSelector(obj: ClusterEndpointSpecForProviderClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterEndpointSpecProviderConfigRefPolicy
 */
export interface ClusterEndpointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterEndpointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterEndpointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterEndpointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterEndpointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterEndpointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecProviderConfigRefPolicy(obj: ClusterEndpointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterEndpointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterEndpointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecPublishConnectionDetailsToConfigRef(obj: ClusterEndpointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterEndpointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterEndpointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecPublishConnectionDetailsToMetadata(obj: ClusterEndpointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierRefPolicy
 */
export interface ClusterEndpointSpecForProviderClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterEndpointSpecForProviderClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecForProviderClusterIdentifierRefPolicy(obj: ClusterEndpointSpecForProviderClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy
 */
export interface ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy(obj: ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterEndpointSpecProviderConfigRefPolicyResolution
 */
export enum ClusterEndpointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterEndpointSpecProviderConfigRefPolicyResolve
 */
export enum ClusterEndpointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolution
 */
export enum ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolve
 */
export enum ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolution
 */
export enum ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolve
 */
export enum ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterInstance is the Schema for the ClusterInstances API. Provides an RDS Cluster Resource Instance
 *
 * @schema ClusterInstance
 */
export class ClusterInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'ClusterInstance',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterInstanceProps): any {
    return {
      ...ClusterInstance.GVK,
      ...toJson_ClusterInstanceProps(props),
    };
  }

  /**
   * Defines a "ClusterInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterInstanceProps) {
    super(scope, id, {
      ...ClusterInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterInstance.GVK,
      ...toJson_ClusterInstanceProps(resolved),
    };
  }
}

/**
 * ClusterInstance is the Schema for the ClusterInstances API. Provides an RDS Cluster Resource Instance
 *
 * @schema ClusterInstance
 */
export interface ClusterInstanceProps {
  /**
   * @schema ClusterInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterInstanceSpec defines the desired state of ClusterInstance
   *
   * @schema ClusterInstance#spec
   */
  readonly spec: ClusterInstanceSpec;

}

/**
 * Converts an object of type 'ClusterInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceProps(obj: ClusterInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterInstanceSpec defines the desired state of ClusterInstance
 *
 * @schema ClusterInstanceSpec
 */
export interface ClusterInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterInstanceSpecDeletionPolicy;

  /**
   * @schema ClusterInstanceSpec#forProvider
   */
  readonly forProvider: ClusterInstanceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClusterInstanceSpec#initProvider
   */
  readonly initProvider?: ClusterInstanceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterInstanceSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterInstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterInstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpec(obj: ClusterInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterInstanceSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterInstanceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterInstanceSpecDeletionPolicy
 */
export enum ClusterInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterInstanceSpecForProvider
 */
export interface ClusterInstanceSpecForProvider {
  /**
   * Specifies whether any database modifications are applied immediately, or during the next maintenance window. Default isfalse.
   *
   * @schema ClusterInstanceSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * Indicates that minor engine upgrades will be applied automatically to the DB instance during the maintenance window. Default true.
   *
   * @schema ClusterInstanceSpecForProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * The EC2 Availability Zone that the DB instance is created in. See docs about the details.
   *
   * @schema ClusterInstanceSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The identifier of the CA certificate for the DB instance.
   *
   * @schema ClusterInstanceSpecForProvider#caCertIdentifier
   */
  readonly caCertIdentifier?: string;

  /**
   * The identifier of the aws_rds_cluster in which to launch this instance.
   *
   * @schema ClusterInstanceSpecForProvider#clusterIdentifier
   */
  readonly clusterIdentifier?: string;

  /**
   * Reference to a Cluster in rds to populate clusterIdentifier.
   *
   * @schema ClusterInstanceSpecForProvider#clusterIdentifierRef
   */
  readonly clusterIdentifierRef?: ClusterInstanceSpecForProviderClusterIdentifierRef;

  /**
   * Selector for a Cluster in rds to populate clusterIdentifier.
   *
   * @schema ClusterInstanceSpecForProvider#clusterIdentifierSelector
   */
  readonly clusterIdentifierSelector?: ClusterInstanceSpecForProviderClusterIdentifierSelector;

  /**
   * defined tags from the DB instance to snapshots of the DB instance. Default false.
   *
   * @schema ClusterInstanceSpecForProvider#copyTagsToSnapshot
   */
  readonly copyTagsToSnapshot?: boolean;

  /**
   * The name of the DB parameter group to associate with this instance.
   *
   * @schema ClusterInstanceSpecForProvider#dbParameterGroupName
   */
  readonly dbParameterGroupName?: string;

  /**
   * A DB subnet group to associate with this DB instance. NOTE: This must match the db_subnet_group_name of the attached aws_rds_cluster.
   *
   * @schema ClusterInstanceSpecForProvider#dbSubnetGroupName
   */
  readonly dbSubnetGroupName?: string;

  /**
   * Reference to a SubnetGroup to populate dbSubnetGroupName.
   *
   * @schema ClusterInstanceSpecForProvider#dbSubnetGroupNameRef
   */
  readonly dbSubnetGroupNameRef?: ClusterInstanceSpecForProviderDbSubnetGroupNameRef;

  /**
   * Selector for a SubnetGroup to populate dbSubnetGroupName.
   *
   * @schema ClusterInstanceSpecForProvider#dbSubnetGroupNameSelector
   */
  readonly dbSubnetGroupNameSelector?: ClusterInstanceSpecForProviderDbSubnetGroupNameSelector;

  /**
   * The name of the database engine to be used for the RDS instance. Defaults to aurora. Valid Values: aurora, aurora-mysql, aurora-postgresql. For information on the difference between the available Aurora MySQL engines see Comparison between Aurora MySQL 1 and Aurora MySQL 2 in the Amazon RDS User Guide.
   *
   * @default aurora. Valid Values: aurora, aurora-mysql, aurora-postgresql. For information on the difference between the available Aurora MySQL engines see Comparison between Aurora MySQL 1 and Aurora MySQL 2 in the Amazon RDS User Guide.
   * @schema ClusterInstanceSpecForProvider#engine
   */
  readonly engine?: string;

  /**
   * The database engine version.
   *
   * @schema ClusterInstanceSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The instance class to use. For details on CPU and memory, see Scaling Aurora DB Instances. Aurora uses db.* instance classes/types. Please see AWS Documentation for currently available instance classes and complete details.
   *
   * @schema ClusterInstanceSpecForProvider#instanceClass
   */
  readonly instanceClass?: string;

  /**
   * The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0. Valid Values: 0, 1, 5, 10, 15, 30, 60.
   *
   * @schema ClusterInstanceSpecForProvider#monitoringInterval
   */
  readonly monitoringInterval?: number;

  /**
   * The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to CloudWatch Logs. You can find more information on the AWS Documentation what IAM permissions are needed to allow Enhanced Monitoring for RDS Instances.
   *
   * @schema ClusterInstanceSpecForProvider#monitoringRoleArn
   */
  readonly monitoringRoleArn?: string;

  /**
   * Reference to a Role in iam to populate monitoringRoleArn.
   *
   * @schema ClusterInstanceSpecForProvider#monitoringRoleArnRef
   */
  readonly monitoringRoleArnRef?: ClusterInstanceSpecForProviderMonitoringRoleArnRef;

  /**
   * Selector for a Role in iam to populate monitoringRoleArn.
   *
   * @schema ClusterInstanceSpecForProvider#monitoringRoleArnSelector
   */
  readonly monitoringRoleArnSelector?: ClusterInstanceSpecForProviderMonitoringRoleArnSelector;

  /**
   * Specifies whether Performance Insights is enabled or not.
   *
   * @schema ClusterInstanceSpecForProvider#performanceInsightsEnabled
   */
  readonly performanceInsightsEnabled?: boolean;

  /**
   * ARN for the KMS key to encrypt Performance Insights data. When specifying performance_insights_kms_key_id, performance_insights_enabled needs to be set to true.
   *
   * @schema ClusterInstanceSpecForProvider#performanceInsightsKmsKeyId
   */
  readonly performanceInsightsKmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate performanceInsightsKmsKeyId.
   *
   * @schema ClusterInstanceSpecForProvider#performanceInsightsKmsKeyIdRef
   */
  readonly performanceInsightsKmsKeyIdRef?: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate performanceInsightsKmsKeyId.
   *
   * @schema ClusterInstanceSpecForProvider#performanceInsightsKmsKeyIdSelector
   */
  readonly performanceInsightsKmsKeyIdSelector?: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelector;

  /**
   * Amount of time in days to retain Performance Insights data. Valid values are 7, 731 (2 years) or a multiple of 31. When specifying performance_insights_retention_period, performance_insights_enabled needs to be set to true. Defaults to '7'.
   *
   * @default 7'.
   * @schema ClusterInstanceSpecForProvider#performanceInsightsRetentionPeriod
   */
  readonly performanceInsightsRetentionPeriod?: number;

  /**
   * The daily time range during which automated backups are created if automated backups are enabled. Eg: "04:00-09:00". NOTE: If preferred_backup_window is set at the cluster level, this argument must be omitted.
   *
   * @schema ClusterInstanceSpecForProvider#preferredBackupWindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The window to perform maintenance in. Syntax: "ddd:hh24:mi-ddd:hh24:mi". Eg: "Mon:00:00-Mon:03:00".
   *
   * @schema ClusterInstanceSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * Default 0. Failover Priority setting on instance level. The reader who has lower tier has higher priority to get promoted to writer.
   *
   * @schema ClusterInstanceSpecForProvider#promotionTier
   */
  readonly promotionTier?: number;

  /**
   * Bool to control if instance is publicly accessible. Default false. See the documentation on Creating DB Instances for more details on controlling this property.
   *
   * @schema ClusterInstanceSpecForProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterInstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterInstanceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProvider(obj: ClusterInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyImmediately': obj.applyImmediately,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'availabilityZone': obj.availabilityZone,
    'caCertIdentifier': obj.caCertIdentifier,
    'clusterIdentifier': obj.clusterIdentifier,
    'clusterIdentifierRef': toJson_ClusterInstanceSpecForProviderClusterIdentifierRef(obj.clusterIdentifierRef),
    'clusterIdentifierSelector': toJson_ClusterInstanceSpecForProviderClusterIdentifierSelector(obj.clusterIdentifierSelector),
    'copyTagsToSnapshot': obj.copyTagsToSnapshot,
    'dbParameterGroupName': obj.dbParameterGroupName,
    'dbSubnetGroupName': obj.dbSubnetGroupName,
    'dbSubnetGroupNameRef': toJson_ClusterInstanceSpecForProviderDbSubnetGroupNameRef(obj.dbSubnetGroupNameRef),
    'dbSubnetGroupNameSelector': toJson_ClusterInstanceSpecForProviderDbSubnetGroupNameSelector(obj.dbSubnetGroupNameSelector),
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'instanceClass': obj.instanceClass,
    'monitoringInterval': obj.monitoringInterval,
    'monitoringRoleArn': obj.monitoringRoleArn,
    'monitoringRoleArnRef': toJson_ClusterInstanceSpecForProviderMonitoringRoleArnRef(obj.monitoringRoleArnRef),
    'monitoringRoleArnSelector': toJson_ClusterInstanceSpecForProviderMonitoringRoleArnSelector(obj.monitoringRoleArnSelector),
    'performanceInsightsEnabled': obj.performanceInsightsEnabled,
    'performanceInsightsKmsKeyId': obj.performanceInsightsKmsKeyId,
    'performanceInsightsKmsKeyIdRef': toJson_ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRef(obj.performanceInsightsKmsKeyIdRef),
    'performanceInsightsKmsKeyIdSelector': toJson_ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelector(obj.performanceInsightsKmsKeyIdSelector),
    'performanceInsightsRetentionPeriod': obj.performanceInsightsRetentionPeriod,
    'preferredBackupWindow': obj.preferredBackupWindow,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'promotionTier': obj.promotionTier,
    'publiclyAccessible': obj.publiclyAccessible,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClusterInstanceSpecInitProvider
 */
export interface ClusterInstanceSpecInitProvider {
  /**
   * Specifies whether any database modifications are applied immediately, or during the next maintenance window. Default isfalse.
   *
   * @schema ClusterInstanceSpecInitProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * Indicates that minor engine upgrades will be applied automatically to the DB instance during the maintenance window. Default true.
   *
   * @schema ClusterInstanceSpecInitProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * The EC2 Availability Zone that the DB instance is created in. See docs about the details.
   *
   * @schema ClusterInstanceSpecInitProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The identifier of the CA certificate for the DB instance.
   *
   * @schema ClusterInstanceSpecInitProvider#caCertIdentifier
   */
  readonly caCertIdentifier?: string;

  /**
   * defined tags from the DB instance to snapshots of the DB instance. Default false.
   *
   * @schema ClusterInstanceSpecInitProvider#copyTagsToSnapshot
   */
  readonly copyTagsToSnapshot?: boolean;

  /**
   * The name of the DB parameter group to associate with this instance.
   *
   * @schema ClusterInstanceSpecInitProvider#dbParameterGroupName
   */
  readonly dbParameterGroupName?: string;

  /**
   * The name of the database engine to be used for the RDS instance. Defaults to aurora. Valid Values: aurora, aurora-mysql, aurora-postgresql. For information on the difference between the available Aurora MySQL engines see Comparison between Aurora MySQL 1 and Aurora MySQL 2 in the Amazon RDS User Guide.
   *
   * @default aurora. Valid Values: aurora, aurora-mysql, aurora-postgresql. For information on the difference between the available Aurora MySQL engines see Comparison between Aurora MySQL 1 and Aurora MySQL 2 in the Amazon RDS User Guide.
   * @schema ClusterInstanceSpecInitProvider#engine
   */
  readonly engine?: string;

  /**
   * The database engine version.
   *
   * @schema ClusterInstanceSpecInitProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The instance class to use. For details on CPU and memory, see Scaling Aurora DB Instances. Aurora uses db.* instance classes/types. Please see AWS Documentation for currently available instance classes and complete details.
   *
   * @schema ClusterInstanceSpecInitProvider#instanceClass
   */
  readonly instanceClass?: string;

  /**
   * The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0. Valid Values: 0, 1, 5, 10, 15, 30, 60.
   *
   * @schema ClusterInstanceSpecInitProvider#monitoringInterval
   */
  readonly monitoringInterval?: number;

  /**
   * Specifies whether Performance Insights is enabled or not.
   *
   * @schema ClusterInstanceSpecInitProvider#performanceInsightsEnabled
   */
  readonly performanceInsightsEnabled?: boolean;

  /**
   * Amount of time in days to retain Performance Insights data. Valid values are 7, 731 (2 years) or a multiple of 31. When specifying performance_insights_retention_period, performance_insights_enabled needs to be set to true. Defaults to '7'.
   *
   * @default 7'.
   * @schema ClusterInstanceSpecInitProvider#performanceInsightsRetentionPeriod
   */
  readonly performanceInsightsRetentionPeriod?: number;

  /**
   * The daily time range during which automated backups are created if automated backups are enabled. Eg: "04:00-09:00". NOTE: If preferred_backup_window is set at the cluster level, this argument must be omitted.
   *
   * @schema ClusterInstanceSpecInitProvider#preferredBackupWindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The window to perform maintenance in. Syntax: "ddd:hh24:mi-ddd:hh24:mi". Eg: "Mon:00:00-Mon:03:00".
   *
   * @schema ClusterInstanceSpecInitProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * Default 0. Failover Priority setting on instance level. The reader who has lower tier has higher priority to get promoted to writer.
   *
   * @schema ClusterInstanceSpecInitProvider#promotionTier
   */
  readonly promotionTier?: number;

  /**
   * Bool to control if instance is publicly accessible. Default false. See the documentation on Creating DB Instances for more details on controlling this property.
   *
   * @schema ClusterInstanceSpecInitProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterInstanceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterInstanceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecInitProvider(obj: ClusterInstanceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyImmediately': obj.applyImmediately,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'availabilityZone': obj.availabilityZone,
    'caCertIdentifier': obj.caCertIdentifier,
    'copyTagsToSnapshot': obj.copyTagsToSnapshot,
    'dbParameterGroupName': obj.dbParameterGroupName,
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'instanceClass': obj.instanceClass,
    'monitoringInterval': obj.monitoringInterval,
    'performanceInsightsEnabled': obj.performanceInsightsEnabled,
    'performanceInsightsRetentionPeriod': obj.performanceInsightsRetentionPeriod,
    'preferredBackupWindow': obj.preferredBackupWindow,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'promotionTier': obj.promotionTier,
    'publiclyAccessible': obj.publiclyAccessible,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterInstanceSpecManagementPolicies
 */
export enum ClusterInstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterInstanceSpecProviderConfigRef
 */
export interface ClusterInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecProviderConfigRef(obj: ClusterInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsTo
 */
export interface ClusterInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsTo(obj: ClusterInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterInstanceSpecWriteConnectionSecretToRef
 */
export interface ClusterInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecWriteConnectionSecretToRef(obj: ClusterInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in rds to populate clusterIdentifier.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRef
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRef#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierRef(obj: ClusterInstanceSpecForProviderClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecForProviderClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in rds to populate clusterIdentifier.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierSelector(obj: ClusterInstanceSpecForProviderClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a SubnetGroup to populate dbSubnetGroupName.
 *
 * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameRef
 */
export interface ClusterInstanceSpecForProviderDbSubnetGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameRef#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderDbSubnetGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderDbSubnetGroupNameRef(obj: ClusterInstanceSpecForProviderDbSubnetGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a SubnetGroup to populate dbSubnetGroupName.
 *
 * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameSelector
 */
export interface ClusterInstanceSpecForProviderDbSubnetGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameSelector#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderDbSubnetGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderDbSubnetGroupNameSelector(obj: ClusterInstanceSpecForProviderDbSubnetGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate monitoringRoleArn.
 *
 * @schema ClusterInstanceSpecForProviderMonitoringRoleArnRef
 */
export interface ClusterInstanceSpecForProviderMonitoringRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecForProviderMonitoringRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecForProviderMonitoringRoleArnRef#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderMonitoringRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderMonitoringRoleArnRef(obj: ClusterInstanceSpecForProviderMonitoringRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate monitoringRoleArn.
 *
 * @schema ClusterInstanceSpecForProviderMonitoringRoleArnSelector
 */
export interface ClusterInstanceSpecForProviderMonitoringRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterInstanceSpecForProviderMonitoringRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterInstanceSpecForProviderMonitoringRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterInstanceSpecForProviderMonitoringRoleArnSelector#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderMonitoringRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderMonitoringRoleArnSelector(obj: ClusterInstanceSpecForProviderMonitoringRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate performanceInsightsKmsKeyId.
 *
 * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRef
 */
export interface ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRef#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRef(obj: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate performanceInsightsKmsKeyId.
 *
 * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelector
 */
export interface ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelector#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelector(obj: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecProviderConfigRefPolicy
 */
export interface ClusterInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecProviderConfigRefPolicy(obj: ClusterInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRef(obj: ClusterInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsToMetadata(obj: ClusterInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicy
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierRefPolicy(obj: ClusterInstanceSpecForProviderClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy(obj: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicy
 */
export interface ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicy(obj: ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy
 */
export interface ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy(obj: ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicy
 */
export interface ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicy(obj: ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicy
 */
export interface ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicy(obj: ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicy
 */
export interface ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicy(obj: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicy
 */
export interface ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicy(obj: ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecProviderConfigRefPolicyResolution
 */
export enum ClusterInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecProviderConfigRefPolicyResolve
 */
export enum ClusterInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolution
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolve
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolution
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolve
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolution
 */
export enum ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolve
 */
export enum ClusterInstanceSpecForProviderDbSubnetGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolution
 */
export enum ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolve
 */
export enum ClusterInstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicyResolution
 */
export enum ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicyResolve
 */
export enum ClusterInstanceSpecForProviderMonitoringRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolution
 */
export enum ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolve
 */
export enum ClusterInstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicyResolution
 */
export enum ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicyResolve
 */
export enum ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicyResolution
 */
export enum ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicyResolve
 */
export enum ClusterInstanceSpecForProviderPerformanceInsightsKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterParameterGroup is the Schema for the ClusterParameterGroups API. Provides an RDS DB cluster parameter group resource.
 *
 * @schema ClusterParameterGroup
 */
export class ClusterParameterGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterParameterGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'ClusterParameterGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterParameterGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterParameterGroupProps): any {
    return {
      ...ClusterParameterGroup.GVK,
      ...toJson_ClusterParameterGroupProps(props),
    };
  }

  /**
   * Defines a "ClusterParameterGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterParameterGroupProps) {
    super(scope, id, {
      ...ClusterParameterGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterParameterGroup.GVK,
      ...toJson_ClusterParameterGroupProps(resolved),
    };
  }
}

/**
 * ClusterParameterGroup is the Schema for the ClusterParameterGroups API. Provides an RDS DB cluster parameter group resource.
 *
 * @schema ClusterParameterGroup
 */
export interface ClusterParameterGroupProps {
  /**
   * @schema ClusterParameterGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterParameterGroupSpec defines the desired state of ClusterParameterGroup
   *
   * @schema ClusterParameterGroup#spec
   */
  readonly spec: ClusterParameterGroupSpec;

}

/**
 * Converts an object of type 'ClusterParameterGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupProps(obj: ClusterParameterGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterParameterGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterParameterGroupSpec defines the desired state of ClusterParameterGroup
 *
 * @schema ClusterParameterGroupSpec
 */
export interface ClusterParameterGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterParameterGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterParameterGroupSpecDeletionPolicy;

  /**
   * @schema ClusterParameterGroupSpec#forProvider
   */
  readonly forProvider: ClusterParameterGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClusterParameterGroupSpec#initProvider
   */
  readonly initProvider?: ClusterParameterGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterParameterGroupSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterParameterGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterParameterGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterParameterGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterParameterGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterParameterGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterParameterGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterParameterGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpec(obj: ClusterParameterGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterParameterGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterParameterGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterParameterGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterParameterGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterParameterGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterParameterGroupSpecDeletionPolicy
 */
export enum ClusterParameterGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterParameterGroupSpecForProvider
 */
export interface ClusterParameterGroupSpecForProvider {
  /**
   * The description of the DB cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The family of the DB cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecForProvider#family
   */
  readonly family?: string;

  /**
   * A list of DB parameters to apply. Note that parameters may differ from a family to an other. Full list of all parameters can be discovered via aws rds describe-db-cluster-parameters after initial creation of the group.
   *
   * @schema ClusterParameterGroupSpecForProvider#parameter
   */
  readonly parameter?: ClusterParameterGroupSpecForProviderParameter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterParameterGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterParameterGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecForProvider(obj: ClusterParameterGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'family': obj.family,
    'parameter': obj.parameter?.map(y => toJson_ClusterParameterGroupSpecForProviderParameter(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClusterParameterGroupSpecInitProvider
 */
export interface ClusterParameterGroupSpecInitProvider {
  /**
   * The description of the DB cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The family of the DB cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecInitProvider#family
   */
  readonly family?: string;

  /**
   * A list of DB parameters to apply. Note that parameters may differ from a family to an other. Full list of all parameters can be discovered via aws rds describe-db-cluster-parameters after initial creation of the group.
   *
   * @schema ClusterParameterGroupSpecInitProvider#parameter
   */
  readonly parameter?: ClusterParameterGroupSpecInitProviderParameter[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterParameterGroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecInitProvider(obj: ClusterParameterGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'family': obj.family,
    'parameter': obj.parameter?.map(y => toJson_ClusterParameterGroupSpecInitProviderParameter(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterParameterGroupSpecManagementPolicies
 */
export enum ClusterParameterGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRef
 */
export interface ClusterParameterGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterParameterGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecProviderConfigRef(obj: ClusterParameterGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterParameterGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterParameterGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsTo(obj: ClusterParameterGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterParameterGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterParameterGroupSpecWriteConnectionSecretToRef
 */
export interface ClusterParameterGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterParameterGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterParameterGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecWriteConnectionSecretToRef(obj: ClusterParameterGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterParameterGroupSpecForProviderParameter
 */
export interface ClusterParameterGroupSpecForProviderParameter {
  /**
   * "immediate" (default), or "pending-reboot". Some engines can't apply some parameters without a reboot, and you will need to specify "pending-reboot" here.
   *
   * @schema ClusterParameterGroupSpecForProviderParameter#applyMethod
   */
  readonly applyMethod?: string;

  /**
   * The name of the DB cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecForProviderParameter#name
   */
  readonly name?: string;

  /**
   * The value of the DB parameter.
   *
   * @schema ClusterParameterGroupSpecForProviderParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecForProviderParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecForProviderParameter(obj: ClusterParameterGroupSpecForProviderParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyMethod': obj.applyMethod,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterParameterGroupSpecInitProviderParameter
 */
export interface ClusterParameterGroupSpecInitProviderParameter {
  /**
   * "immediate" (default), or "pending-reboot". Some engines can't apply some parameters without a reboot, and you will need to specify "pending-reboot" here.
   *
   * @schema ClusterParameterGroupSpecInitProviderParameter#applyMethod
   */
  readonly applyMethod?: string;

  /**
   * The name of the DB cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecInitProviderParameter#name
   */
  readonly name?: string;

  /**
   * The value of the DB parameter.
   *
   * @schema ClusterParameterGroupSpecInitProviderParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecInitProviderParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecInitProviderParameter(obj: ClusterParameterGroupSpecInitProviderParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyMethod': obj.applyMethod,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRefPolicy
 */
export interface ClusterParameterGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterParameterGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterParameterGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecProviderConfigRefPolicy(obj: ClusterParameterGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef(obj: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsToMetadata(obj: ClusterParameterGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRefPolicyResolution
 */
export enum ClusterParameterGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRefPolicyResolve
 */
export enum ClusterParameterGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterRoleAssociation is the Schema for the ClusterRoleAssociations API. Manages a RDS DB Cluster association with an IAM Role.
 *
 * @schema ClusterRoleAssociation
 */
export class ClusterRoleAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterRoleAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'ClusterRoleAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterRoleAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterRoleAssociationProps): any {
    return {
      ...ClusterRoleAssociation.GVK,
      ...toJson_ClusterRoleAssociationProps(props),
    };
  }

  /**
   * Defines a "ClusterRoleAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterRoleAssociationProps) {
    super(scope, id, {
      ...ClusterRoleAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterRoleAssociation.GVK,
      ...toJson_ClusterRoleAssociationProps(resolved),
    };
  }
}

/**
 * ClusterRoleAssociation is the Schema for the ClusterRoleAssociations API. Manages a RDS DB Cluster association with an IAM Role.
 *
 * @schema ClusterRoleAssociation
 */
export interface ClusterRoleAssociationProps {
  /**
   * @schema ClusterRoleAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterRoleAssociationSpec defines the desired state of ClusterRoleAssociation
   *
   * @schema ClusterRoleAssociation#spec
   */
  readonly spec: ClusterRoleAssociationSpec;

}

/**
 * Converts an object of type 'ClusterRoleAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationProps(obj: ClusterRoleAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterRoleAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterRoleAssociationSpec defines the desired state of ClusterRoleAssociation
 *
 * @schema ClusterRoleAssociationSpec
 */
export interface ClusterRoleAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterRoleAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterRoleAssociationSpecDeletionPolicy;

  /**
   * @schema ClusterRoleAssociationSpec#forProvider
   */
  readonly forProvider: ClusterRoleAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClusterRoleAssociationSpec#initProvider
   */
  readonly initProvider?: ClusterRoleAssociationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterRoleAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterRoleAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterRoleAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterRoleAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterRoleAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterRoleAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterRoleAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterRoleAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpec(obj: ClusterRoleAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterRoleAssociationSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterRoleAssociationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterRoleAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterRoleAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterRoleAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterRoleAssociationSpecDeletionPolicy
 */
export enum ClusterRoleAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterRoleAssociationSpecForProvider
 */
export interface ClusterRoleAssociationSpecForProvider {
  /**
   * DB Cluster Identifier to associate with the IAM Role.
   *
   * @schema ClusterRoleAssociationSpecForProvider#dbClusterIdentifier
   */
  readonly dbClusterIdentifier?: string;

  /**
   * Reference to a Cluster in rds to populate dbClusterIdentifier.
   *
   * @schema ClusterRoleAssociationSpecForProvider#dbClusterIdentifierRef
   */
  readonly dbClusterIdentifierRef?: ClusterRoleAssociationSpecForProviderDbClusterIdentifierRef;

  /**
   * Selector for a Cluster in rds to populate dbClusterIdentifier.
   *
   * @schema ClusterRoleAssociationSpecForProvider#dbClusterIdentifierSelector
   */
  readonly dbClusterIdentifierSelector?: ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelector;

  /**
   * Name of the feature for association. This can be found in the AWS documentation relevant to the integration or a full list is available in the SupportedFeatureNames list returned by AWS CLI rds describe-db-engine-versions.
   *
   * @schema ClusterRoleAssociationSpecForProvider#featureName
   */
  readonly featureName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterRoleAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon Resource Name (ARN) of the IAM Role to associate with the DB Cluster.
   *
   * @schema ClusterRoleAssociationSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ClusterRoleAssociationSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ClusterRoleAssociationSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ClusterRoleAssociationSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ClusterRoleAssociationSpecForProviderRoleArnSelector;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecForProvider(obj: ClusterRoleAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbClusterIdentifier': obj.dbClusterIdentifier,
    'dbClusterIdentifierRef': toJson_ClusterRoleAssociationSpecForProviderDbClusterIdentifierRef(obj.dbClusterIdentifierRef),
    'dbClusterIdentifierSelector': toJson_ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelector(obj.dbClusterIdentifierSelector),
    'featureName': obj.featureName,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ClusterRoleAssociationSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ClusterRoleAssociationSpecForProviderRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClusterRoleAssociationSpecInitProvider
 */
export interface ClusterRoleAssociationSpecInitProvider {
  /**
   * Name of the feature for association. This can be found in the AWS documentation relevant to the integration or a full list is available in the SupportedFeatureNames list returned by AWS CLI rds describe-db-engine-versions.
   *
   * @schema ClusterRoleAssociationSpecInitProvider#featureName
   */
  readonly featureName?: string;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecInitProvider(obj: ClusterRoleAssociationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'featureName': obj.featureName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterRoleAssociationSpecManagementPolicies
 */
export enum ClusterRoleAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterRoleAssociationSpecProviderConfigRef
 */
export interface ClusterRoleAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterRoleAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterRoleAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterRoleAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecProviderConfigRef(obj: ClusterRoleAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterRoleAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterRoleAssociationSpecPublishConnectionDetailsTo
 */
export interface ClusterRoleAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterRoleAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterRoleAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterRoleAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterRoleAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecPublishConnectionDetailsTo(obj: ClusterRoleAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterRoleAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterRoleAssociationSpecWriteConnectionSecretToRef
 */
export interface ClusterRoleAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterRoleAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterRoleAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecWriteConnectionSecretToRef(obj: ClusterRoleAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in rds to populate dbClusterIdentifier.
 *
 * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierRef
 */
export interface ClusterRoleAssociationSpecForProviderDbClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierRef#policy
   */
  readonly policy?: ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecForProviderDbClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecForProviderDbClusterIdentifierRef(obj: ClusterRoleAssociationSpecForProviderDbClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in rds to populate dbClusterIdentifier.
 *
 * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelector
 */
export interface ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelector#policy
   */
  readonly policy?: ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelector(obj: ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ClusterRoleAssociationSpecForProviderRoleArnRef
 */
export interface ClusterRoleAssociationSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterRoleAssociationSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterRoleAssociationSpecForProviderRoleArnRef#policy
   */
  readonly policy?: ClusterRoleAssociationSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecForProviderRoleArnRef(obj: ClusterRoleAssociationSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterRoleAssociationSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ClusterRoleAssociationSpecForProviderRoleArnSelector
 */
export interface ClusterRoleAssociationSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterRoleAssociationSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterRoleAssociationSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterRoleAssociationSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecForProviderRoleArnSelector(obj: ClusterRoleAssociationSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterRoleAssociationSpecProviderConfigRefPolicy
 */
export interface ClusterRoleAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterRoleAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterRoleAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterRoleAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterRoleAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecProviderConfigRefPolicy(obj: ClusterRoleAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRef(obj: ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterRoleAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecPublishConnectionDetailsToMetadata(obj: ClusterRoleAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicy
 */
export interface ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicy(obj: ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicy
 */
export interface ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicy(obj: ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterRoleAssociationSpecForProviderRoleArnRefPolicy
 */
export interface ClusterRoleAssociationSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterRoleAssociationSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ClusterRoleAssociationSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterRoleAssociationSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ClusterRoleAssociationSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecForProviderRoleArnRefPolicy(obj: ClusterRoleAssociationSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicy
 */
export interface ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicy(obj: ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterRoleAssociationSpecProviderConfigRefPolicyResolution
 */
export enum ClusterRoleAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterRoleAssociationSpecProviderConfigRefPolicyResolve
 */
export enum ClusterRoleAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicyResolution
 */
export enum ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicyResolve
 */
export enum ClusterRoleAssociationSpecForProviderDbClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicyResolution
 */
export enum ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicyResolve
 */
export enum ClusterRoleAssociationSpecForProviderDbClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterRoleAssociationSpecForProviderRoleArnRefPolicyResolution
 */
export enum ClusterRoleAssociationSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterRoleAssociationSpecForProviderRoleArnRefPolicyResolve
 */
export enum ClusterRoleAssociationSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ClusterRoleAssociationSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterSnapshot is the Schema for the ClusterSnapshots API. Manages an RDS database cluster snapshot.
 *
 * @schema ClusterSnapshot
 */
export class ClusterSnapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterSnapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'ClusterSnapshot',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterSnapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterSnapshotProps): any {
    return {
      ...ClusterSnapshot.GVK,
      ...toJson_ClusterSnapshotProps(props),
    };
  }

  /**
   * Defines a "ClusterSnapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterSnapshotProps) {
    super(scope, id, {
      ...ClusterSnapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterSnapshot.GVK,
      ...toJson_ClusterSnapshotProps(resolved),
    };
  }
}

/**
 * ClusterSnapshot is the Schema for the ClusterSnapshots API. Manages an RDS database cluster snapshot.
 *
 * @schema ClusterSnapshot
 */
export interface ClusterSnapshotProps {
  /**
   * @schema ClusterSnapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSnapshotSpec defines the desired state of ClusterSnapshot
   *
   * @schema ClusterSnapshot#spec
   */
  readonly spec: ClusterSnapshotSpec;

}

/**
 * Converts an object of type 'ClusterSnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotProps(obj: ClusterSnapshotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSnapshotSpec defines the desired state of ClusterSnapshot
 *
 * @schema ClusterSnapshotSpec
 */
export interface ClusterSnapshotSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSnapshotSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSnapshotSpecDeletionPolicy;

  /**
   * @schema ClusterSnapshotSpec#forProvider
   */
  readonly forProvider: ClusterSnapshotSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClusterSnapshotSpec#initProvider
   */
  readonly initProvider?: ClusterSnapshotSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterSnapshotSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterSnapshotSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSnapshotSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSnapshotSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSnapshotSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSnapshotSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSnapshotSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSnapshotSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpec(obj: ClusterSnapshotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSnapshotSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterSnapshotSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterSnapshotSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterSnapshotSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSnapshotSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSnapshotSpecDeletionPolicy
 */
export enum ClusterSnapshotSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSnapshotSpecForProvider
 */
export interface ClusterSnapshotSpecForProvider {
  /**
   * The DB Cluster Identifier from which to take the snapshot.
   *
   * @schema ClusterSnapshotSpecForProvider#dbClusterIdentifier
   */
  readonly dbClusterIdentifier?: string;

  /**
   * Reference to a Cluster in rds to populate dbClusterIdentifier.
   *
   * @schema ClusterSnapshotSpecForProvider#dbClusterIdentifierRef
   */
  readonly dbClusterIdentifierRef?: ClusterSnapshotSpecForProviderDbClusterIdentifierRef;

  /**
   * Selector for a Cluster in rds to populate dbClusterIdentifier.
   *
   * @schema ClusterSnapshotSpecForProvider#dbClusterIdentifierSelector
   */
  readonly dbClusterIdentifierSelector?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelector;

  /**
   * The Identifier for the snapshot.
   *
   * @schema ClusterSnapshotSpecForProvider#dbClusterSnapshotIdentifier
   */
  readonly dbClusterSnapshotIdentifier?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterSnapshotSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSnapshotSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProvider(obj: ClusterSnapshotSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbClusterIdentifier': obj.dbClusterIdentifier,
    'dbClusterIdentifierRef': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRef(obj.dbClusterIdentifierRef),
    'dbClusterIdentifierSelector': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelector(obj.dbClusterIdentifierSelector),
    'dbClusterSnapshotIdentifier': obj.dbClusterSnapshotIdentifier,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClusterSnapshotSpecInitProvider
 */
export interface ClusterSnapshotSpecInitProvider {
  /**
   * The Identifier for the snapshot.
   *
   * @schema ClusterSnapshotSpecInitProvider#dbClusterSnapshotIdentifier
   */
  readonly dbClusterSnapshotIdentifier?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSnapshotSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSnapshotSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecInitProvider(obj: ClusterSnapshotSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbClusterSnapshotIdentifier': obj.dbClusterSnapshotIdentifier,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterSnapshotSpecManagementPolicies
 */
export enum ClusterSnapshotSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSnapshotSpecProviderConfigRef
 */
export interface ClusterSnapshotSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSnapshotSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSnapshotSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSnapshotSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecProviderConfigRef(obj: ClusterSnapshotSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSnapshotSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsTo
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSnapshotSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsTo(obj: ClusterSnapshotSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSnapshotSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSnapshotSpecWriteConnectionSecretToRef
 */
export interface ClusterSnapshotSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSnapshotSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSnapshotSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecWriteConnectionSecretToRef(obj: ClusterSnapshotSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in rds to populate dbClusterIdentifier.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRef
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRef#policy
   */
  readonly policy?: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRef(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in rds to populate dbClusterIdentifier.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector#policy
   */
  readonly policy?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelector(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSnapshotSpecProviderConfigRefPolicy
 */
export interface ClusterSnapshotSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecProviderConfigRefPolicy(obj: ClusterSnapshotSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRef(obj: ClusterSnapshotSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsToMetadata(obj: ClusterSnapshotSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSnapshotSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSnapshotSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolution
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolve
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolution
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolve
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DBInstanceAutomatedBackupsReplication is the Schema for the DBInstanceAutomatedBackupsReplications API. Enables replication of automated backups to a different AWS Region.
 *
 * @schema DBInstanceAutomatedBackupsReplication
 */
export class DbInstanceAutomatedBackupsReplication extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBInstanceAutomatedBackupsReplication"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'DBInstanceAutomatedBackupsReplication',
  }

  /**
   * Renders a Kubernetes manifest for "DBInstanceAutomatedBackupsReplication".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbInstanceAutomatedBackupsReplicationProps): any {
    return {
      ...DbInstanceAutomatedBackupsReplication.GVK,
      ...toJson_DbInstanceAutomatedBackupsReplicationProps(props),
    };
  }

  /**
   * Defines a "DBInstanceAutomatedBackupsReplication" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbInstanceAutomatedBackupsReplicationProps) {
    super(scope, id, {
      ...DbInstanceAutomatedBackupsReplication.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbInstanceAutomatedBackupsReplication.GVK,
      ...toJson_DbInstanceAutomatedBackupsReplicationProps(resolved),
    };
  }
}

/**
 * DBInstanceAutomatedBackupsReplication is the Schema for the DBInstanceAutomatedBackupsReplications API. Enables replication of automated backups to a different AWS Region.
 *
 * @schema DBInstanceAutomatedBackupsReplication
 */
export interface DbInstanceAutomatedBackupsReplicationProps {
  /**
   * @schema DBInstanceAutomatedBackupsReplication#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBInstanceAutomatedBackupsReplicationSpec defines the desired state of DBInstanceAutomatedBackupsReplication
   *
   * @schema DBInstanceAutomatedBackupsReplication#spec
   */
  readonly spec: DbInstanceAutomatedBackupsReplicationSpec;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationProps(obj: DbInstanceAutomatedBackupsReplicationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbInstanceAutomatedBackupsReplicationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBInstanceAutomatedBackupsReplicationSpec defines the desired state of DBInstanceAutomatedBackupsReplication
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpec
 */
export interface DbInstanceAutomatedBackupsReplicationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpec#deletionPolicy
   */
  readonly deletionPolicy?: DbInstanceAutomatedBackupsReplicationSpecDeletionPolicy;

  /**
   * @schema DbInstanceAutomatedBackupsReplicationSpec#forProvider
   */
  readonly forProvider: DbInstanceAutomatedBackupsReplicationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpec#initProvider
   */
  readonly initProvider?: DbInstanceAutomatedBackupsReplicationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpec#managementPolicies
   */
  readonly managementPolicies?: DbInstanceAutomatedBackupsReplicationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpec#providerConfigRef
   */
  readonly providerConfigRef?: DbInstanceAutomatedBackupsReplicationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbInstanceAutomatedBackupsReplicationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpec(obj: DbInstanceAutomatedBackupsReplicationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbInstanceAutomatedBackupsReplicationSpecForProvider(obj.forProvider),
    'initProvider': toJson_DbInstanceAutomatedBackupsReplicationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbInstanceAutomatedBackupsReplicationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbInstanceAutomatedBackupsReplicationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecDeletionPolicy
 */
export enum DbInstanceAutomatedBackupsReplicationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProvider
 */
export interface DbInstanceAutomatedBackupsReplicationSpecForProvider {
  /**
   * The AWS KMS key identifier for encryption of the replicated automated backups. The KMS key ID is the Amazon Resource Name (ARN) for the KMS encryption key in the destination AWS Region, for example, arn:aws:kms:us-east-1:123456789012:key/AKIAIOSFODNN7EXAMPLE.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelector;

  /**
   * A URL that contains a Signature Version 4 signed request for the StartDBInstanceAutomatedBackupsReplication action to be called in the AWS Region of the source DB instance.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProvider#preSignedUrl
   */
  readonly preSignedUrl?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The retention period for the replicated automated backups, defaults to 7.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProvider#retentionPeriod
   */
  readonly retentionPeriod?: number;

  /**
   * The Amazon Resource Name (ARN) of the source DB instance for the replicated automated backups, for example, arn:aws:rds:us-west-2:123456789012:db:mydatabase.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProvider#sourceDbInstanceArn
   */
  readonly sourceDbInstanceArn?: string;

  /**
   * Reference to a Instance in rds to populate sourceDbInstanceArn.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProvider#sourceDbInstanceArnRef
   */
  readonly sourceDbInstanceArnRef?: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRef;

  /**
   * Selector for a Instance in rds to populate sourceDbInstanceArn.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProvider#sourceDbInstanceArnSelector
   */
  readonly sourceDbInstanceArnSelector?: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelector;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecForProvider(obj: DbInstanceAutomatedBackupsReplicationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'preSignedUrl': obj.preSignedUrl,
    'region': obj.region,
    'retentionPeriod': obj.retentionPeriod,
    'sourceDbInstanceArn': obj.sourceDbInstanceArn,
    'sourceDbInstanceArnRef': toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRef(obj.sourceDbInstanceArnRef),
    'sourceDbInstanceArnSelector': toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelector(obj.sourceDbInstanceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecInitProvider
 */
export interface DbInstanceAutomatedBackupsReplicationSpecInitProvider {
  /**
   * A URL that contains a Signature Version 4 signed request for the StartDBInstanceAutomatedBackupsReplication action to be called in the AWS Region of the source DB instance.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecInitProvider#preSignedUrl
   */
  readonly preSignedUrl?: string;

  /**
   * The retention period for the replicated automated backups, defaults to 7.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecInitProvider#retentionPeriod
   */
  readonly retentionPeriod?: number;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecInitProvider(obj: DbInstanceAutomatedBackupsReplicationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preSignedUrl': obj.preSignedUrl,
    'retentionPeriod': obj.retentionPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecManagementPolicies
 */
export enum DbInstanceAutomatedBackupsReplicationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecProviderConfigRef
 */
export interface DbInstanceAutomatedBackupsReplicationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecProviderConfigRef#policy
   */
  readonly policy?: DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecProviderConfigRef(obj: DbInstanceAutomatedBackupsReplicationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsTo
 */
export interface DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsTo(obj: DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecWriteConnectionSecretToRef
 */
export interface DbInstanceAutomatedBackupsReplicationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecWriteConnectionSecretToRef(obj: DbInstanceAutomatedBackupsReplicationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRef
 */
export interface DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRef(obj: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelector
 */
export interface DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelector(obj: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in rds to populate sourceDbInstanceArn.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRef
 */
export interface DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRef#policy
   */
  readonly policy?: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRef(obj: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in rds to populate sourceDbInstanceArn.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelector
 */
export interface DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelector#policy
   */
  readonly policy?: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicy;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelector(obj: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicy
 */
export interface DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicy(obj: DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRef
 */
export interface DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRef(obj: DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToMetadata
 */
export interface DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToMetadata(obj: DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicy
 */
export interface DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicy(obj: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicy(obj: DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicy
 */
export interface DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicy#resolution
   */
  readonly resolution?: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicy#resolve
   */
  readonly resolve?: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicy(obj: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicy
 */
export interface DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicy#resolution
   */
  readonly resolution?: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicy#resolve
   */
  readonly resolve?: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicy(obj: DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicyResolution
 */
export enum DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicyResolve
 */
export enum DbInstanceAutomatedBackupsReplicationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj: DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum DbInstanceAutomatedBackupsReplicationSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicyResolution
 */
export enum DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicyResolve
 */
export enum DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicyResolution
 */
export enum DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicyResolve
 */
export enum DbInstanceAutomatedBackupsReplicationSpecForProviderSourceDbInstanceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbInstanceAutomatedBackupsReplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DBSnapshotCopy is the Schema for the DBSnapshotCopys API. Manages an RDS database instance snapshot copy.
 *
 * @schema DBSnapshotCopy
 */
export class DbSnapshotCopy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DBSnapshotCopy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'DBSnapshotCopy',
  }

  /**
   * Renders a Kubernetes manifest for "DBSnapshotCopy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DbSnapshotCopyProps): any {
    return {
      ...DbSnapshotCopy.GVK,
      ...toJson_DbSnapshotCopyProps(props),
    };
  }

  /**
   * Defines a "DBSnapshotCopy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DbSnapshotCopyProps) {
    super(scope, id, {
      ...DbSnapshotCopy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DbSnapshotCopy.GVK,
      ...toJson_DbSnapshotCopyProps(resolved),
    };
  }
}

/**
 * DBSnapshotCopy is the Schema for the DBSnapshotCopys API. Manages an RDS database instance snapshot copy.
 *
 * @schema DBSnapshotCopy
 */
export interface DbSnapshotCopyProps {
  /**
   * @schema DBSnapshotCopy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DBSnapshotCopySpec defines the desired state of DBSnapshotCopy
   *
   * @schema DBSnapshotCopy#spec
   */
  readonly spec: DbSnapshotCopySpec;

}

/**
 * Converts an object of type 'DbSnapshotCopyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopyProps(obj: DbSnapshotCopyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DbSnapshotCopySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DBSnapshotCopySpec defines the desired state of DBSnapshotCopy
 *
 * @schema DbSnapshotCopySpec
 */
export interface DbSnapshotCopySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DbSnapshotCopySpec#deletionPolicy
   */
  readonly deletionPolicy?: DbSnapshotCopySpecDeletionPolicy;

  /**
   * @schema DbSnapshotCopySpec#forProvider
   */
  readonly forProvider: DbSnapshotCopySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DbSnapshotCopySpec#initProvider
   */
  readonly initProvider?: DbSnapshotCopySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DbSnapshotCopySpec#managementPolicies
   */
  readonly managementPolicies?: DbSnapshotCopySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DbSnapshotCopySpec#providerConfigRef
   */
  readonly providerConfigRef?: DbSnapshotCopySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DbSnapshotCopySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DbSnapshotCopySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DbSnapshotCopySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DbSnapshotCopySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DbSnapshotCopySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpec(obj: DbSnapshotCopySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DbSnapshotCopySpecForProvider(obj.forProvider),
    'initProvider': toJson_DbSnapshotCopySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DbSnapshotCopySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DbSnapshotCopySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DbSnapshotCopySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DbSnapshotCopySpecDeletionPolicy
 */
export enum DbSnapshotCopySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DbSnapshotCopySpecForProvider
 */
export interface DbSnapshotCopySpecForProvider {
  /**
   * Whether to copy existing tags. Defaults to false.
   *
   * @default false.
   * @schema DbSnapshotCopySpecForProvider#copyTags
   */
  readonly copyTags?: boolean;

  /**
   * The Destination region to place snapshot copy.
   *
   * @schema DbSnapshotCopySpecForProvider#destinationRegion
   */
  readonly destinationRegion?: string;

  /**
   * KMS key ID.
   *
   * @schema DbSnapshotCopySpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema DbSnapshotCopySpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: DbSnapshotCopySpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema DbSnapshotCopySpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: DbSnapshotCopySpecForProviderKmsKeyIdSelector;

  /**
   * The name of an option group to associate with the copy of the snapshot.
   *
   * @schema DbSnapshotCopySpecForProvider#optionGroupName
   */
  readonly optionGroupName?: string;

  /**
   * he URL that contains a Signature Version 4 signed request.
   *
   * @schema DbSnapshotCopySpecForProvider#presignedUrl
   */
  readonly presignedUrl?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DbSnapshotCopySpecForProvider#region
   */
  readonly region: string;

  /**
   * Snapshot identifier of the source snapshot.
   *
   * @schema DbSnapshotCopySpecForProvider#sourceDbSnapshotIdentifier
   */
  readonly sourceDbSnapshotIdentifier?: string;

  /**
   * Reference to a Snapshot in rds to populate sourceDbSnapshotIdentifier.
   *
   * @schema DbSnapshotCopySpecForProvider#sourceDbSnapshotIdentifierRef
   */
  readonly sourceDbSnapshotIdentifierRef?: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRef;

  /**
   * Selector for a Snapshot in rds to populate sourceDbSnapshotIdentifier.
   *
   * @schema DbSnapshotCopySpecForProvider#sourceDbSnapshotIdentifierSelector
   */
  readonly sourceDbSnapshotIdentifierSelector?: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema DbSnapshotCopySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The external custom Availability Zone.
   *
   * @schema DbSnapshotCopySpecForProvider#targetCustomAvailabilityZone
   */
  readonly targetCustomAvailabilityZone?: string;

  /**
   * The Identifier for the snapshot.
   *
   * @schema DbSnapshotCopySpecForProvider#targetDbSnapshotIdentifier
   */
  readonly targetDbSnapshotIdentifier?: string;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecForProvider(obj: DbSnapshotCopySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'copyTags': obj.copyTags,
    'destinationRegion': obj.destinationRegion,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_DbSnapshotCopySpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_DbSnapshotCopySpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'optionGroupName': obj.optionGroupName,
    'presignedUrl': obj.presignedUrl,
    'region': obj.region,
    'sourceDbSnapshotIdentifier': obj.sourceDbSnapshotIdentifier,
    'sourceDbSnapshotIdentifierRef': toJson_DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRef(obj.sourceDbSnapshotIdentifierRef),
    'sourceDbSnapshotIdentifierSelector': toJson_DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelector(obj.sourceDbSnapshotIdentifierSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetCustomAvailabilityZone': obj.targetCustomAvailabilityZone,
    'targetDbSnapshotIdentifier': obj.targetDbSnapshotIdentifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DbSnapshotCopySpecInitProvider
 */
export interface DbSnapshotCopySpecInitProvider {
  /**
   * Whether to copy existing tags. Defaults to false.
   *
   * @default false.
   * @schema DbSnapshotCopySpecInitProvider#copyTags
   */
  readonly copyTags?: boolean;

  /**
   * The Destination region to place snapshot copy.
   *
   * @schema DbSnapshotCopySpecInitProvider#destinationRegion
   */
  readonly destinationRegion?: string;

  /**
   * The name of an option group to associate with the copy of the snapshot.
   *
   * @schema DbSnapshotCopySpecInitProvider#optionGroupName
   */
  readonly optionGroupName?: string;

  /**
   * he URL that contains a Signature Version 4 signed request.
   *
   * @schema DbSnapshotCopySpecInitProvider#presignedUrl
   */
  readonly presignedUrl?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DbSnapshotCopySpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The external custom Availability Zone.
   *
   * @schema DbSnapshotCopySpecInitProvider#targetCustomAvailabilityZone
   */
  readonly targetCustomAvailabilityZone?: string;

  /**
   * The Identifier for the snapshot.
   *
   * @schema DbSnapshotCopySpecInitProvider#targetDbSnapshotIdentifier
   */
  readonly targetDbSnapshotIdentifier?: string;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecInitProvider(obj: DbSnapshotCopySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'copyTags': obj.copyTags,
    'destinationRegion': obj.destinationRegion,
    'optionGroupName': obj.optionGroupName,
    'presignedUrl': obj.presignedUrl,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetCustomAvailabilityZone': obj.targetCustomAvailabilityZone,
    'targetDbSnapshotIdentifier': obj.targetDbSnapshotIdentifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DbSnapshotCopySpecManagementPolicies
 */
export enum DbSnapshotCopySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DbSnapshotCopySpecProviderConfigRef
 */
export interface DbSnapshotCopySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbSnapshotCopySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbSnapshotCopySpecProviderConfigRef#policy
   */
  readonly policy?: DbSnapshotCopySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecProviderConfigRef(obj: DbSnapshotCopySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbSnapshotCopySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DbSnapshotCopySpecPublishConnectionDetailsTo
 */
export interface DbSnapshotCopySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DbSnapshotCopySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DbSnapshotCopySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DbSnapshotCopySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DbSnapshotCopySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DbSnapshotCopySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecPublishConnectionDetailsTo(obj: DbSnapshotCopySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DbSnapshotCopySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DbSnapshotCopySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DbSnapshotCopySpecWriteConnectionSecretToRef
 */
export interface DbSnapshotCopySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DbSnapshotCopySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DbSnapshotCopySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecWriteConnectionSecretToRef(obj: DbSnapshotCopySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema DbSnapshotCopySpecForProviderKmsKeyIdRef
 */
export interface DbSnapshotCopySpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbSnapshotCopySpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbSnapshotCopySpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: DbSnapshotCopySpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecForProviderKmsKeyIdRef(obj: DbSnapshotCopySpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbSnapshotCopySpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema DbSnapshotCopySpecForProviderKmsKeyIdSelector
 */
export interface DbSnapshotCopySpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbSnapshotCopySpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbSnapshotCopySpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbSnapshotCopySpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecForProviderKmsKeyIdSelector(obj: DbSnapshotCopySpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Snapshot in rds to populate sourceDbSnapshotIdentifier.
 *
 * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRef
 */
export interface DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRef#policy
   */
  readonly policy?: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicy;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRef(obj: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Snapshot in rds to populate sourceDbSnapshotIdentifier.
 *
 * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelector
 */
export interface DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelector#policy
   */
  readonly policy?: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelector(obj: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbSnapshotCopySpecProviderConfigRefPolicy
 */
export interface DbSnapshotCopySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbSnapshotCopySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DbSnapshotCopySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbSnapshotCopySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DbSnapshotCopySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecProviderConfigRefPolicy(obj: DbSnapshotCopySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DbSnapshotCopySpecPublishConnectionDetailsToConfigRef
 */
export interface DbSnapshotCopySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DbSnapshotCopySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DbSnapshotCopySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecPublishConnectionDetailsToConfigRef(obj: DbSnapshotCopySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DbSnapshotCopySpecPublishConnectionDetailsToMetadata
 */
export interface DbSnapshotCopySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbSnapshotCopySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DbSnapshotCopySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DbSnapshotCopySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecPublishConnectionDetailsToMetadata(obj: DbSnapshotCopySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbSnapshotCopySpecForProviderKmsKeyIdRefPolicy
 */
export interface DbSnapshotCopySpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbSnapshotCopySpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: DbSnapshotCopySpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbSnapshotCopySpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: DbSnapshotCopySpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecForProviderKmsKeyIdRefPolicy(obj: DbSnapshotCopySpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicy
 */
export interface DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicy(obj: DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicy
 */
export interface DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicy#resolution
   */
  readonly resolution?: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicy#resolve
   */
  readonly resolve?: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicy(obj: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicy
 */
export interface DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicy(obj: DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbSnapshotCopySpecProviderConfigRefPolicyResolution
 */
export enum DbSnapshotCopySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbSnapshotCopySpecProviderConfigRefPolicyResolve
 */
export enum DbSnapshotCopySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicy(obj: DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbSnapshotCopySpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum DbSnapshotCopySpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbSnapshotCopySpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum DbSnapshotCopySpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum DbSnapshotCopySpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicyResolution
 */
export enum DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicyResolve
 */
export enum DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicyResolution
 */
export enum DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicyResolve
 */
export enum DbSnapshotCopySpecForProviderSourceDbSnapshotIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DbSnapshotCopySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EventSubscription is the Schema for the EventSubscriptions API. Provides a DB event subscription resource.
 *
 * @schema EventSubscription
 */
export class EventSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EventSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'EventSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "EventSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EventSubscriptionProps): any {
    return {
      ...EventSubscription.GVK,
      ...toJson_EventSubscriptionProps(props),
    };
  }

  /**
   * Defines a "EventSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EventSubscriptionProps) {
    super(scope, id, {
      ...EventSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EventSubscription.GVK,
      ...toJson_EventSubscriptionProps(resolved),
    };
  }
}

/**
 * EventSubscription is the Schema for the EventSubscriptions API. Provides a DB event subscription resource.
 *
 * @schema EventSubscription
 */
export interface EventSubscriptionProps {
  /**
   * @schema EventSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EventSubscriptionSpec defines the desired state of EventSubscription
   *
   * @schema EventSubscription#spec
   */
  readonly spec: EventSubscriptionSpec;

}

/**
 * Converts an object of type 'EventSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionProps(obj: EventSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EventSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventSubscriptionSpec defines the desired state of EventSubscription
 *
 * @schema EventSubscriptionSpec
 */
export interface EventSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EventSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: EventSubscriptionSpecDeletionPolicy;

  /**
   * @schema EventSubscriptionSpec#forProvider
   */
  readonly forProvider: EventSubscriptionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema EventSubscriptionSpec#initProvider
   */
  readonly initProvider?: EventSubscriptionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema EventSubscriptionSpec#managementPolicies
   */
  readonly managementPolicies?: EventSubscriptionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EventSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: EventSubscriptionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EventSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EventSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EventSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EventSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EventSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpec(obj: EventSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EventSubscriptionSpecForProvider(obj.forProvider),
    'initProvider': toJson_EventSubscriptionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_EventSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_EventSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EventSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EventSubscriptionSpecDeletionPolicy
 */
export enum EventSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EventSubscriptionSpecForProvider
 */
export interface EventSubscriptionSpecForProvider {
  /**
   * A boolean flag to enable/disable the subscription. Defaults to true.
   *
   * @default true.
   * @schema EventSubscriptionSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * A list of event categories for a SourceType that you want to subscribe to. See http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.html or run aws rds describe-event-categories.
   *
   * @schema EventSubscriptionSpecForProvider#eventCategories
   */
  readonly eventCategories?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EventSubscriptionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The SNS topic to send events to.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopic
   */
  readonly snsTopic?: string;

  /**
   * Reference to a Topic in sns to populate snsTopic.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicRef
   */
  readonly snsTopicRef?: EventSubscriptionSpecForProviderSnsTopicRef;

  /**
   * Selector for a Topic in sns to populate snsTopic.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicSelector
   */
  readonly snsTopicSelector?: EventSubscriptionSpecForProviderSnsTopicSelector;

  /**
   * A list of identifiers of the event sources for which events will be returned. If not specified, then all sources are included in the response. If specified, a source_type must also be specified.
   *
   * @schema EventSubscriptionSpecForProvider#sourceIds
   */
  readonly sourceIds?: string[];

  /**
   * The type of source that will be generating the events. Valid options are db-instance, db-security-group, db-parameter-group, db-snapshot, db-cluster or db-cluster-snapshot. If not set, all sources will be subscribed to.
   *
   * @schema EventSubscriptionSpecForProvider#sourceType
   */
  readonly sourceType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema EventSubscriptionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProvider(obj: EventSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'eventCategories': obj.eventCategories?.map(y => y),
    'region': obj.region,
    'snsTopic': obj.snsTopic,
    'snsTopicRef': toJson_EventSubscriptionSpecForProviderSnsTopicRef(obj.snsTopicRef),
    'snsTopicSelector': toJson_EventSubscriptionSpecForProviderSnsTopicSelector(obj.snsTopicSelector),
    'sourceIds': obj.sourceIds?.map(y => y),
    'sourceType': obj.sourceType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema EventSubscriptionSpecInitProvider
 */
export interface EventSubscriptionSpecInitProvider {
  /**
   * A boolean flag to enable/disable the subscription. Defaults to true.
   *
   * @default true.
   * @schema EventSubscriptionSpecInitProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * A list of event categories for a SourceType that you want to subscribe to. See http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.html or run aws rds describe-event-categories.
   *
   * @schema EventSubscriptionSpecInitProvider#eventCategories
   */
  readonly eventCategories?: string[];

  /**
   * A list of identifiers of the event sources for which events will be returned. If not specified, then all sources are included in the response. If specified, a source_type must also be specified.
   *
   * @schema EventSubscriptionSpecInitProvider#sourceIds
   */
  readonly sourceIds?: string[];

  /**
   * The type of source that will be generating the events. Valid options are db-instance, db-security-group, db-parameter-group, db-snapshot, db-cluster or db-cluster-snapshot. If not set, all sources will be subscribed to.
   *
   * @schema EventSubscriptionSpecInitProvider#sourceType
   */
  readonly sourceType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema EventSubscriptionSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'EventSubscriptionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecInitProvider(obj: EventSubscriptionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'eventCategories': obj.eventCategories?.map(y => y),
    'sourceIds': obj.sourceIds?.map(y => y),
    'sourceType': obj.sourceType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema EventSubscriptionSpecManagementPolicies
 */
export enum EventSubscriptionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EventSubscriptionSpecProviderConfigRef
 */
export interface EventSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: EventSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderConfigRef(obj: EventSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsTo
 */
export interface EventSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EventSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EventSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsTo(obj: EventSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EventSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EventSubscriptionSpecWriteConnectionSecretToRef
 */
export interface EventSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EventSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EventSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecWriteConnectionSecretToRef(obj: EventSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate snsTopic.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicRef
 */
export interface EventSubscriptionSpecForProviderSnsTopicRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicRef#policy
   */
  readonly policy?: EventSubscriptionSpecForProviderSnsTopicRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicRef(obj: EventSubscriptionSpecForProviderSnsTopicRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecForProviderSnsTopicRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate snsTopic.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicSelector
 */
export interface EventSubscriptionSpecForProviderSnsTopicSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicSelector#policy
   */
  readonly policy?: EventSubscriptionSpecForProviderSnsTopicSelectorPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicSelector(obj: EventSubscriptionSpecForProviderSnsTopicSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EventSubscriptionSpecForProviderSnsTopicSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicy
 */
export interface EventSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderConfigRefPolicy(obj: EventSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: EventSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToMetadata(obj: EventSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicRefPolicy
 */
export interface EventSubscriptionSpecForProviderSnsTopicRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecForProviderSnsTopicRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecForProviderSnsTopicRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicRefPolicy(obj: EventSubscriptionSpecForProviderSnsTopicRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicSelectorPolicy
 */
export interface EventSubscriptionSpecForProviderSnsTopicSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicSelectorPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecForProviderSnsTopicSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicSelectorPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecForProviderSnsTopicSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicSelectorPolicy(obj: EventSubscriptionSpecForProviderSnsTopicSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum EventSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum EventSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicRefPolicyResolution
 */
export enum EventSubscriptionSpecForProviderSnsTopicRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicRefPolicyResolve
 */
export enum EventSubscriptionSpecForProviderSnsTopicRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicSelectorPolicyResolution
 */
export enum EventSubscriptionSpecForProviderSnsTopicSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicSelectorPolicyResolve
 */
export enum EventSubscriptionSpecForProviderSnsTopicSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GlobalCluster is the Schema for the GlobalClusters API. Manages an RDS Global Cluster
 *
 * @schema GlobalCluster
 */
export class GlobalCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GlobalCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'GlobalCluster',
  }

  /**
   * Renders a Kubernetes manifest for "GlobalCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GlobalClusterProps): any {
    return {
      ...GlobalCluster.GVK,
      ...toJson_GlobalClusterProps(props),
    };
  }

  /**
   * Defines a "GlobalCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GlobalClusterProps) {
    super(scope, id, {
      ...GlobalCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GlobalCluster.GVK,
      ...toJson_GlobalClusterProps(resolved),
    };
  }
}

/**
 * GlobalCluster is the Schema for the GlobalClusters API. Manages an RDS Global Cluster
 *
 * @schema GlobalCluster
 */
export interface GlobalClusterProps {
  /**
   * @schema GlobalCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GlobalClusterSpec defines the desired state of GlobalCluster
   *
   * @schema GlobalCluster#spec
   */
  readonly spec: GlobalClusterSpec;

}

/**
 * Converts an object of type 'GlobalClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterProps(obj: GlobalClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GlobalClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalClusterSpec defines the desired state of GlobalCluster
 *
 * @schema GlobalClusterSpec
 */
export interface GlobalClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GlobalClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: GlobalClusterSpecDeletionPolicy;

  /**
   * @schema GlobalClusterSpec#forProvider
   */
  readonly forProvider: GlobalClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema GlobalClusterSpec#initProvider
   */
  readonly initProvider?: GlobalClusterSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GlobalClusterSpec#managementPolicies
   */
  readonly managementPolicies?: GlobalClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GlobalClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: GlobalClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GlobalClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GlobalClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GlobalClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GlobalClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GlobalClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpec(obj: GlobalClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GlobalClusterSpecForProvider(obj.forProvider),
    'initProvider': toJson_GlobalClusterSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GlobalClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GlobalClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GlobalClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GlobalClusterSpecDeletionPolicy
 */
export enum GlobalClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GlobalClusterSpecForProvider
 */
export interface GlobalClusterSpecForProvider {
  /**
   * Name for an automatically created database on cluster creation.
   *
   * @schema GlobalClusterSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * If the Global Cluster should have deletion protection enabled. The database can't be deleted when this value is set to true. The default is false.
   *
   * @schema GlobalClusterSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Name of the database engine to be used for this DB cluster. Valid values: aurora, aurora-mysql, aurora-postgresql. Defaults to aurora. Conflicts with source_db_cluster_identifier.
   *
   * @default aurora. Conflicts with source_db_cluster_identifier.
   * @schema GlobalClusterSpecForProvider#engine
   */
  readonly engine?: string;

  /**
   * Engine version of the Aurora global database. The engine, engine_version, and instance_class (on the aws_rds_cluster_instance) must together support global databases. See Using Amazon Aurora global databases for more information. NOTE: To avoid an inconsistent final plan error while upgrading, use the lifecycle ignore_changes for engine_version meta argument on the associated aws_rds_cluster resource as shown above in Upgrading Engine Versions example.
   *
   * @schema GlobalClusterSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * Enable to remove DB Cluster members from Global Cluster on destroy. Required with source_db_cluster_identifier.
   *
   * @schema GlobalClusterSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GlobalClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon Resource Name (ARN) to use as the primary DB Cluster of the Global Cluster on creation.
   *
   * @schema GlobalClusterSpecForProvider#sourceDbClusterIdentifier
   */
  readonly sourceDbClusterIdentifier?: string;

  /**
   * Reference to a Cluster in rds to populate sourceDbClusterIdentifier.
   *
   * @schema GlobalClusterSpecForProvider#sourceDbClusterIdentifierRef
   */
  readonly sourceDbClusterIdentifierRef?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRef;

  /**
   * Selector for a Cluster in rds to populate sourceDbClusterIdentifier.
   *
   * @schema GlobalClusterSpecForProvider#sourceDbClusterIdentifierSelector
   */
  readonly sourceDbClusterIdentifierSelector?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector;

  /**
   * Specifies whether the DB cluster is encrypted. The default is false unless source_db_cluster_identifier is specified and encrypted.
   *
   * @schema GlobalClusterSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProvider(obj: GlobalClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseName': obj.databaseName,
    'deletionProtection': obj.deletionProtection,
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'forceDestroy': obj.forceDestroy,
    'region': obj.region,
    'sourceDbClusterIdentifier': obj.sourceDbClusterIdentifier,
    'sourceDbClusterIdentifierRef': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRef(obj.sourceDbClusterIdentifierRef),
    'sourceDbClusterIdentifierSelector': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector(obj.sourceDbClusterIdentifierSelector),
    'storageEncrypted': obj.storageEncrypted,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema GlobalClusterSpecInitProvider
 */
export interface GlobalClusterSpecInitProvider {
  /**
   * Name for an automatically created database on cluster creation.
   *
   * @schema GlobalClusterSpecInitProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * If the Global Cluster should have deletion protection enabled. The database can't be deleted when this value is set to true. The default is false.
   *
   * @schema GlobalClusterSpecInitProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Name of the database engine to be used for this DB cluster. Valid values: aurora, aurora-mysql, aurora-postgresql. Defaults to aurora. Conflicts with source_db_cluster_identifier.
   *
   * @default aurora. Conflicts with source_db_cluster_identifier.
   * @schema GlobalClusterSpecInitProvider#engine
   */
  readonly engine?: string;

  /**
   * Engine version of the Aurora global database. The engine, engine_version, and instance_class (on the aws_rds_cluster_instance) must together support global databases. See Using Amazon Aurora global databases for more information. NOTE: To avoid an inconsistent final plan error while upgrading, use the lifecycle ignore_changes for engine_version meta argument on the associated aws_rds_cluster resource as shown above in Upgrading Engine Versions example.
   *
   * @schema GlobalClusterSpecInitProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * Enable to remove DB Cluster members from Global Cluster on destroy. Required with source_db_cluster_identifier.
   *
   * @schema GlobalClusterSpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * Specifies whether the DB cluster is encrypted. The default is false unless source_db_cluster_identifier is specified and encrypted.
   *
   * @schema GlobalClusterSpecInitProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

}

/**
 * Converts an object of type 'GlobalClusterSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecInitProvider(obj: GlobalClusterSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseName': obj.databaseName,
    'deletionProtection': obj.deletionProtection,
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'forceDestroy': obj.forceDestroy,
    'storageEncrypted': obj.storageEncrypted,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GlobalClusterSpecManagementPolicies
 */
export enum GlobalClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GlobalClusterSpecProviderConfigRef
 */
export interface GlobalClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecProviderConfigRef#policy
   */
  readonly policy?: GlobalClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderConfigRef(obj: GlobalClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsTo
 */
export interface GlobalClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GlobalClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GlobalClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsTo(obj: GlobalClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GlobalClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GlobalClusterSpecWriteConnectionSecretToRef
 */
export interface GlobalClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GlobalClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GlobalClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecWriteConnectionSecretToRef(obj: GlobalClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in rds to populate sourceDbClusterIdentifier.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef#policy
   */
  readonly policy?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRef(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in rds to populate sourceDbClusterIdentifier.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#policy
   */
  readonly policy?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicy
 */
export interface GlobalClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderConfigRefPolicy(obj: GlobalClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface GlobalClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRef(obj: GlobalClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata
 */
export interface GlobalClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToMetadata(obj: GlobalClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicyResolution
 */
export enum GlobalClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicyResolve
 */
export enum GlobalClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Instance is the Schema for the Instances API. Provides an RDS instance resource.
 *
 * @schema Instance
 */
export class Instance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Instance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'Instance',
  }

  /**
   * Renders a Kubernetes manifest for "Instance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceProps): any {
    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(props),
    };
  }

  /**
   * Defines a "Instance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceProps) {
    super(scope, id, {
      ...Instance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(resolved),
    };
  }
}

/**
 * Instance is the Schema for the Instances API. Provides an RDS instance resource.
 *
 * @schema Instance
 */
export interface InstanceProps {
  /**
   * @schema Instance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceSpec defines the desired state of Instance
   *
   * @schema Instance#spec
   */
  readonly spec: InstanceSpec;

}

/**
 * Converts an object of type 'InstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProps(obj: InstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSpec defines the desired state of Instance
 *
 * @schema InstanceSpec
 */
export interface InstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceSpecDeletionPolicy;

  /**
   * @schema InstanceSpec#forProvider
   */
  readonly forProvider: InstanceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema InstanceSpec#initProvider
   */
  readonly initProvider?: InstanceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InstanceSpec#managementPolicies
   */
  readonly managementPolicies?: InstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpec(obj: InstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceSpecForProvider(obj.forProvider),
    'initProvider': toJson_InstanceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceSpecDeletionPolicy
 */
export enum InstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceSpecForProvider
 */
export interface InstanceSpecForProvider {
  /**
   * The allocated storage in gibibytes. If max_allocated_storage is configured, this argument represents the initial storage allocation and differences from the configuration will be ignored automatically when Storage Autoscaling occurs. If replicate_source_db is set, the value is ignored during the creation of the instance.
   *
   * @schema InstanceSpecForProvider#allocatedStorage
   */
  readonly allocatedStorage?: number;

  /**
   * Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage and the change is asynchronously applied as soon as possible.
   *
   * @schema InstanceSpecForProvider#allowMajorVersionUpgrade
   */
  readonly allowMajorVersionUpgrade?: boolean;

  /**
   * Specifies whether any database modifications are applied immediately, or during the next maintenance window. Default is false. See Amazon RDS Documentation for more information.
   *
   * @default false. See Amazon RDS Documentation for more information.
   * @schema InstanceSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Cannot be set if manage_master_user_password is set to true. If true, the password will be auto-generated and stored in the Secret referenced by the passwordSecretRef field.
   *
   * @schema InstanceSpecForProvider#autoGeneratePassword
   */
  readonly autoGeneratePassword?: boolean;

  /**
   * Indicates that minor engine upgrades will be applied automatically to the DB instance during the maintenance window. Defaults to true.
   *
   * @default true.
   * @schema InstanceSpecForProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * The AZ for the RDS instance.
   *
   * @schema InstanceSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The days to retain backups for. Must be between 0 and 35. Default is 0. Must be greater than 0 if the database is used as a source for a Read Replica, uses low-downtime updates, or will use RDS Blue/Green deployments.
   *
   * @default 0. Must be greater than 0 if the database is used as a source for a Read Replica, uses low-downtime updates, or will use RDS Blue/Green deployments.
   * @schema InstanceSpecForProvider#backupRetentionPeriod
   */
  readonly backupRetentionPeriod?: number;

  /**
   * The daily time range (in UTC) during which automated backups are created if they are enabled. Example: "09:46-10:16". Must not overlap with maintenance_window.
   *
   * @schema InstanceSpecForProvider#backupWindow
   */
  readonly backupWindow?: string;

  /**
   * Enables low-downtime updates using RDS Blue/Green deployments. See blue_green_update below
   *
   * @schema InstanceSpecForProvider#blueGreenUpdate
   */
  readonly blueGreenUpdate?: InstanceSpecForProviderBlueGreenUpdate[];

  /**
   * The identifier of the CA certificate for the DB instance.
   *
   * @schema InstanceSpecForProvider#caCertIdentifier
   */
  readonly caCertIdentifier?: string;

  /**
   * The character set name to use for DB encoding in Oracle and Microsoft SQL instances (collation). This can't be changed. See Oracle Character Sets Supported in Amazon RDS or Server-Level Collation for Microsoft SQL Server for more information.
   *
   * @schema InstanceSpecForProvider#characterSetName
   */
  readonly characterSetName?: string;

  /**
   * –  Copy all Instance tags to snapshots. Default is false.
   *
   * @default false.
   * @schema InstanceSpecForProvider#copyTagsToSnapshot
   */
  readonly copyTagsToSnapshot?: boolean;

  /**
   * The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance.
   *
   * @schema InstanceSpecForProvider#customIamInstanceProfile
   */
  readonly customIamInstanceProfile?: string;

  /**
   * Indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance. See CoIP for RDS on Outposts for more information.
   *
   * @schema InstanceSpecForProvider#customerOwnedIpEnabled
   */
  readonly customerOwnedIpEnabled?: boolean;

  /**
   * The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Note that this does not apply for Oracle or SQL Server engines. See the AWS documentation for more details on what applies for those engines. If you are providing an Oracle db name, it needs to be in all upper case. Cannot be specified for a replica.
   *
   * @schema InstanceSpecForProvider#dbName
   */
  readonly dbName?: string;

  /**
   * Name of DB subnet group. DB instance will be created in the VPC associated with the DB subnet group. If unspecified, will be created in the default VPC, or in EC2 Classic, if available. When working with read replicas, it should be specified only if the source database specifies an instance in another AWS Region. See DBSubnetGroupName in API action CreateDBInstanceReadReplica for additional read replica contraints.
   *
   * @schema InstanceSpecForProvider#dbSubnetGroupName
   */
  readonly dbSubnetGroupName?: string;

  /**
   * Reference to a SubnetGroup to populate dbSubnetGroupName.
   *
   * @schema InstanceSpecForProvider#dbSubnetGroupNameRef
   */
  readonly dbSubnetGroupNameRef?: InstanceSpecForProviderDbSubnetGroupNameRef;

  /**
   * Selector for a SubnetGroup to populate dbSubnetGroupName.
   *
   * @schema InstanceSpecForProvider#dbSubnetGroupNameSelector
   */
  readonly dbSubnetGroupNameSelector?: InstanceSpecForProviderDbSubnetGroupNameSelector;

  /**
   * Specifies whether to remove automated backups immediately after the DB instance is deleted. Default is true.
   *
   * @default true.
   * @schema InstanceSpecForProvider#deleteAutomatedBackups
   */
  readonly deleteAutomatedBackups?: boolean;

  /**
   * If the DB instance should have deletion protection enabled. The database can't be deleted when this value is set to true. The default is false.
   *
   * @schema InstanceSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * The ID of the Directory Service Active Directory domain to create the instance in.
   *
   * @schema InstanceSpecForProvider#domain
   */
  readonly domain?: string;

  /**
   * The name of the IAM role to be used when making API calls to the Directory Service.
   *
   * @schema InstanceSpecForProvider#domainIamRoleName
   */
  readonly domainIamRoleName?: string;

  /**
   * Set of log types to enable for exporting to CloudWatch logs. If omitted, no logs will be exported. Valid values (depending on engine). MySQL and MariaDB: audit, error, general, slowquery. PostgreSQL: postgresql, upgrade. MSSQL: agent , error. Oracle: alert, audit, listener, trace.
   *
   * @schema InstanceSpecForProvider#enabledCloudwatchLogsExports
   */
  readonly enabledCloudwatchLogsExports?: string[];

  /**
   * The database engine to use. For supported values, see the Engine parameter in [API action CreateDBInstance](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html). Note that for Amazon Aurora instances the engine must match the [DB Cluster](https://marketplace.upbound.io/providers/upbound/provider-aws/latest/resources/rds.aws.upbound.io/Cluster/v1beta1)'s engine'. For information on the difference between the available Aurora MySQL engines see Comparison in the [Amazon RDS Release Notes](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraMySQLReleaseNotes/Welcome.html).
   *
   * @schema InstanceSpecForProvider#engine
   */
  readonly engine?: string;

  /**
   * The engine version to use. If `autoMinorVersionUpgrade` is enabled, you can provide a prefix of the version such as 5.7 (for 5.7.10). The actual engine version used is returned in the attribute `status.atProvider.engineVersionActual`. For supported values, see the EngineVersion parameter in [API action CreateDBInstance](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html). Note that for Amazon Aurora instances the engine version must match the [DB Cluster](https://marketplace.upbound.io/providers/upbound/provider-aws/latest/resources/rds.aws.upbound.io/Cluster/v1beta1)'s engine version'.
   *
   * @schema InstanceSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The name of your final DB snapshot when this DB instance is deleted. Must be provided if skip_final_snapshot is set to false. The value must begin with a letter, only contain alphanumeric characters and hyphens, and not end with a hyphen or contain two consecutive hyphens. Must not be provided when deleting a read replica.
   *
   * @schema InstanceSpecForProvider#finalSnapshotIdentifier
   */
  readonly finalSnapshotIdentifier?: string;

  /**
   * Specifies whether mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled.
   *
   * @schema InstanceSpecForProvider#iamDatabaseAuthenticationEnabled
   */
  readonly iamDatabaseAuthenticationEnabled?: boolean;

  /**
   * The instance type of the RDS instance.
   *
   * @schema InstanceSpecForProvider#instanceClass
   */
  readonly instanceClass?: string;

  /**
   * The amount of provisioned IOPS. Setting this implies a storage_type of "io1". Can only be set when storage_type is "io1" or "gp3". Cannot be specified for gp3 storage if the allocated_storage value is below a per-engine threshold. See the RDS User Guide for details.
   *
   * @schema InstanceSpecForProvider#iops
   */
  readonly iops?: number;

  /**
   * The ARN for the KMS encryption key. If creating an encrypted replica, set this to the destination KMS ARN.
   *
   * @schema InstanceSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema InstanceSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: InstanceSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema InstanceSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: InstanceSpecForProviderKmsKeyIdSelector;

  /**
   * License model information for this DB instance.
   *
   * @schema InstanceSpecForProvider#licenseModel
   */
  readonly licenseModel?: string;

  /**
   * The window to perform maintenance in. Syntax: "ddd:hh24:mi-ddd:hh24:mi". Eg: "Mon:00:00-Mon:03:00". See RDS Maintenance Window docs for more information.
   *
   * @schema InstanceSpecForProvider#maintenanceWindow
   */
  readonly maintenanceWindow?: string;

  /**
   * Set to true to allow RDS to manage the master user password in Secrets Manager. Cannot be set if password is provided.
   *
   * @schema InstanceSpecForProvider#manageMasterUserPassword
   */
  readonly manageMasterUserPassword?: boolean;

  /**
   * The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. To use a KMS key in a different Amazon Web Services account, specify the key ARN or alias ARN. If not specified, the default KMS key for your Amazon Web Services account is used.
   *
   * @schema InstanceSpecForProvider#masterUserSecretKmsKeyId
   */
  readonly masterUserSecretKmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate masterUserSecretKmsKeyId.
   *
   * @schema InstanceSpecForProvider#masterUserSecretKmsKeyIdRef
   */
  readonly masterUserSecretKmsKeyIdRef?: InstanceSpecForProviderMasterUserSecretKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate masterUserSecretKmsKeyId.
   *
   * @schema InstanceSpecForProvider#masterUserSecretKmsKeyIdSelector
   */
  readonly masterUserSecretKmsKeyIdSelector?: InstanceSpecForProviderMasterUserSecretKmsKeyIdSelector;

  /**
   * When configured, the upper limit to which Amazon RDS can automatically scale the storage of the DB instance. Configuring this will automatically ignore differences to allocated_storage. Must be greater than or equal to allocated_storage or 0 to disable Storage Autoscaling.
   *
   * @schema InstanceSpecForProvider#maxAllocatedStorage
   */
  readonly maxAllocatedStorage?: number;

  /**
   * The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0. Valid Values: 0, 1, 5, 10, 15, 30, 60.
   *
   * @schema InstanceSpecForProvider#monitoringInterval
   */
  readonly monitoringInterval?: number;

  /**
   * The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to CloudWatch Logs. You can find more information on the AWS Documentation what IAM permissions are needed to allow Enhanced Monitoring for RDS Instances.
   *
   * @schema InstanceSpecForProvider#monitoringRoleArn
   */
  readonly monitoringRoleArn?: string;

  /**
   * Reference to a Role in iam to populate monitoringRoleArn.
   *
   * @schema InstanceSpecForProvider#monitoringRoleArnRef
   */
  readonly monitoringRoleArnRef?: InstanceSpecForProviderMonitoringRoleArnRef;

  /**
   * Selector for a Role in iam to populate monitoringRoleArn.
   *
   * @schema InstanceSpecForProvider#monitoringRoleArnSelector
   */
  readonly monitoringRoleArnSelector?: InstanceSpecForProviderMonitoringRoleArnSelector;

  /**
   * Specifies if the RDS instance is multi-AZ
   *
   * @schema InstanceSpecForProvider#multiAz
   */
  readonly multiAz?: boolean;

  /**
   * The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Note that this does not apply for Oracle or SQL Server engines. See the AWS documentation for more details on what applies for those engines. If you are providing an Oracle db name, it needs to be in all upper case. Cannot be specified for a replica.
   *
   * @schema InstanceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The national character set is used in the NCHAR, NVARCHAR2, and NCLOB data types for Oracle instances. This can't be changed. See Oracle Character Sets Supported in Amazon RDS.
   *
   * @schema InstanceSpecForProvider#ncharCharacterSetName
   */
  readonly ncharCharacterSetName?: string;

  /**
   * The network type of the DB instance. Valid values: IPV4, DUAL.
   *
   * @schema InstanceSpecForProvider#networkType
   */
  readonly networkType?: string;

  /**
   * Name of the DB option group to associate.
   *
   * @schema InstanceSpecForProvider#optionGroupName
   */
  readonly optionGroupName?: string;

  /**
   * Name of the DB parameter group to associate.
   *
   * @schema InstanceSpecForProvider#parameterGroupName
   */
  readonly parameterGroupName?: string;

  /**
   * Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Cannot be set if manage_master_user_password is set to true. Password for the master DB user. If you set autoGeneratePassword to true, the Secret referenced here will be created or updated with generated password if it does not already contain one.
   *
   * @schema InstanceSpecForProvider#passwordSecretRef
   */
  readonly passwordSecretRef?: InstanceSpecForProviderPasswordSecretRef;

  /**
   * Specifies whether Performance Insights are enabled. Defaults to false.
   *
   * @default false.
   * @schema InstanceSpecForProvider#performanceInsightsEnabled
   */
  readonly performanceInsightsEnabled?: boolean;

  /**
   * The ARN for the KMS key to encrypt Performance Insights data. When specifying performance_insights_kms_key_id, performance_insights_enabled needs to be set to true. Once KMS key is set, it can never be changed.
   *
   * @schema InstanceSpecForProvider#performanceInsightsKmsKeyId
   */
  readonly performanceInsightsKmsKeyId?: string;

  /**
   * Amount of time in days to retain Performance Insights data. Valid values are 7, 731 (2 years) or a multiple of 31. When specifying performance_insights_retention_period, performance_insights_enabled needs to be set to true. Defaults to '7'.
   *
   * @default 7'.
   * @schema InstanceSpecForProvider#performanceInsightsRetentionPeriod
   */
  readonly performanceInsightsRetentionPeriod?: number;

  /**
   * The port on which the DB accepts connections.
   *
   * @schema InstanceSpecForProvider#port
   */
  readonly port?: number;

  /**
   * Bool to control if instance is publicly accessible. Default is false.
   *
   * @default false.
   * @schema InstanceSpecForProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies whether the replica is in either mounted or open-read-only mode. This attribute is only supported by Oracle instances. Oracle replicas operate in open-read-only mode unless otherwise specified. See Working with Oracle Read Replicas for more information.
   *
   * @schema InstanceSpecForProvider#replicaMode
   */
  readonly replicaMode?: string;

  /**
   * Specifies that this resource is a Replicate database, and to use this value as the source database. This correlates to the identifier of another Amazon RDS Database to replicate (if replicating within a single region) or ARN of the Amazon RDS Database to replicate (if replicating cross-region). Note that if you are creating a cross-region replica of an encrypted database you will also need to specify a kms_key_id. See DB Instance Replication and Working with PostgreSQL and MySQL Read Replicas for more information on using Replication.
   *
   * @schema InstanceSpecForProvider#replicateSourceDb
   */
  readonly replicateSourceDb?: string;

  /**
   * Reference to a Instance in rds to populate replicateSourceDb.
   *
   * @schema InstanceSpecForProvider#replicateSourceDbRef
   */
  readonly replicateSourceDbRef?: InstanceSpecForProviderReplicateSourceDbRef;

  /**
   * Selector for a Instance in rds to populate replicateSourceDb.
   *
   * @schema InstanceSpecForProvider#replicateSourceDbSelector
   */
  readonly replicateSourceDbSelector?: InstanceSpecForProviderReplicateSourceDbSelector;

  /**
   * A configuration block for restoring a DB instance to an arbitrary point in time. Requires the identifier argument to be set with the name of the new DB instance to be created. See Restore To Point In Time below for details.
   *
   * @schema InstanceSpecForProvider#restoreToPointInTime
   */
  readonly restoreToPointInTime?: InstanceSpecForProviderRestoreToPointInTime[];

  /**
   * Restore from a Percona Xtrabackup in S3.  See Importing Data into an Amazon RDS MySQL DB Instance
   *
   * @schema InstanceSpecForProvider#s3Import
   */
  readonly s3Import?: InstanceSpecForProviderS3Import[];

  /**
   * List of DB Security Groups to associate. Only used for DB Instances on the .
   *
   * @schema InstanceSpecForProvider#securityGroupNames
   */
  readonly securityGroupNames?: string[];

  /**
   * Determines whether a final DB snapshot is created before the DB instance is deleted. If true is specified, no DBSnapshot is created. If false is specified, a DB snapshot is created before the DB instance is deleted, using the value from final_snapshot_identifier. Default is false.
   *
   * @default false.
   * @schema InstanceSpecForProvider#skipFinalSnapshot
   */
  readonly skipFinalSnapshot?: boolean;

  /**
   * Specifies whether or not to create this database from a snapshot. This correlates to the snapshot ID you'd find in the RDS console, e.g: rds:production-2015-06-26-06-05.
   *
   * @schema InstanceSpecForProvider#snapshotIdentifier
   */
  readonly snapshotIdentifier?: string;

  /**
   * Specifies whether the DB instance is encrypted. Note that if you are creating a cross-region read replica this field is ignored and you should instead declare kms_key_id with a valid ARN. The default is false if not specified.
   *
   * @schema InstanceSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

  /**
   * The storage throughput value for the DB instance. Can only be set when storage_type is "gp3". Cannot be specified if the allocated_storage value is below a per-engine threshold. See the RDS User Guide for details.
   *
   * @schema InstanceSpecForProvider#storageThroughput
   */
  readonly storageThroughput?: number;

  /**
   * One of "standard" (magnetic), "gp2" (general purpose SSD), "gp3" (general purpose SSD that needs iops independently) or "io1" (provisioned IOPS SSD). The default is "io1" if iops is specified, "gp2" if not.
   *
   * @schema InstanceSpecForProvider#storageType
   */
  readonly storageType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema InstanceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Time zone of the DB instance. timezone is currently only supported by Microsoft SQL Server. The timezone can only be set on creation. See MSSQL User Guide for more information.
   *
   * @schema InstanceSpecForProvider#timezone
   */
  readonly timezone?: string;

  /**
   * Username for the master DB user. Cannot be specified for a replica.
   *
   * @schema InstanceSpecForProvider#username
   */
  readonly username?: string;

  /**
   * References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema InstanceSpecForProvider#vpcSecurityGroupIdRefs
   */
  readonly vpcSecurityGroupIdRefs?: InstanceSpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema InstanceSpecForProvider#vpcSecurityGroupIdSelector
   */
  readonly vpcSecurityGroupIdSelector?: InstanceSpecForProviderVpcSecurityGroupIdSelector;

  /**
   * List of VPC security groups to associate.
   *
   * @schema InstanceSpecForProvider#vpcSecurityGroupIds
   */
  readonly vpcSecurityGroupIds?: string[];

}

/**
 * Converts an object of type 'InstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProvider(obj: InstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedStorage': obj.allocatedStorage,
    'allowMajorVersionUpgrade': obj.allowMajorVersionUpgrade,
    'applyImmediately': obj.applyImmediately,
    'autoGeneratePassword': obj.autoGeneratePassword,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'availabilityZone': obj.availabilityZone,
    'backupRetentionPeriod': obj.backupRetentionPeriod,
    'backupWindow': obj.backupWindow,
    'blueGreenUpdate': obj.blueGreenUpdate?.map(y => toJson_InstanceSpecForProviderBlueGreenUpdate(y)),
    'caCertIdentifier': obj.caCertIdentifier,
    'characterSetName': obj.characterSetName,
    'copyTagsToSnapshot': obj.copyTagsToSnapshot,
    'customIamInstanceProfile': obj.customIamInstanceProfile,
    'customerOwnedIpEnabled': obj.customerOwnedIpEnabled,
    'dbName': obj.dbName,
    'dbSubnetGroupName': obj.dbSubnetGroupName,
    'dbSubnetGroupNameRef': toJson_InstanceSpecForProviderDbSubnetGroupNameRef(obj.dbSubnetGroupNameRef),
    'dbSubnetGroupNameSelector': toJson_InstanceSpecForProviderDbSubnetGroupNameSelector(obj.dbSubnetGroupNameSelector),
    'deleteAutomatedBackups': obj.deleteAutomatedBackups,
    'deletionProtection': obj.deletionProtection,
    'domain': obj.domain,
    'domainIamRoleName': obj.domainIamRoleName,
    'enabledCloudwatchLogsExports': obj.enabledCloudwatchLogsExports?.map(y => y),
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'finalSnapshotIdentifier': obj.finalSnapshotIdentifier,
    'iamDatabaseAuthenticationEnabled': obj.iamDatabaseAuthenticationEnabled,
    'instanceClass': obj.instanceClass,
    'iops': obj.iops,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_InstanceSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_InstanceSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'licenseModel': obj.licenseModel,
    'maintenanceWindow': obj.maintenanceWindow,
    'manageMasterUserPassword': obj.manageMasterUserPassword,
    'masterUserSecretKmsKeyId': obj.masterUserSecretKmsKeyId,
    'masterUserSecretKmsKeyIdRef': toJson_InstanceSpecForProviderMasterUserSecretKmsKeyIdRef(obj.masterUserSecretKmsKeyIdRef),
    'masterUserSecretKmsKeyIdSelector': toJson_InstanceSpecForProviderMasterUserSecretKmsKeyIdSelector(obj.masterUserSecretKmsKeyIdSelector),
    'maxAllocatedStorage': obj.maxAllocatedStorage,
    'monitoringInterval': obj.monitoringInterval,
    'monitoringRoleArn': obj.monitoringRoleArn,
    'monitoringRoleArnRef': toJson_InstanceSpecForProviderMonitoringRoleArnRef(obj.monitoringRoleArnRef),
    'monitoringRoleArnSelector': toJson_InstanceSpecForProviderMonitoringRoleArnSelector(obj.monitoringRoleArnSelector),
    'multiAz': obj.multiAz,
    'name': obj.name,
    'ncharCharacterSetName': obj.ncharCharacterSetName,
    'networkType': obj.networkType,
    'optionGroupName': obj.optionGroupName,
    'parameterGroupName': obj.parameterGroupName,
    'passwordSecretRef': toJson_InstanceSpecForProviderPasswordSecretRef(obj.passwordSecretRef),
    'performanceInsightsEnabled': obj.performanceInsightsEnabled,
    'performanceInsightsKmsKeyId': obj.performanceInsightsKmsKeyId,
    'performanceInsightsRetentionPeriod': obj.performanceInsightsRetentionPeriod,
    'port': obj.port,
    'publiclyAccessible': obj.publiclyAccessible,
    'region': obj.region,
    'replicaMode': obj.replicaMode,
    'replicateSourceDb': obj.replicateSourceDb,
    'replicateSourceDbRef': toJson_InstanceSpecForProviderReplicateSourceDbRef(obj.replicateSourceDbRef),
    'replicateSourceDbSelector': toJson_InstanceSpecForProviderReplicateSourceDbSelector(obj.replicateSourceDbSelector),
    'restoreToPointInTime': obj.restoreToPointInTime?.map(y => toJson_InstanceSpecForProviderRestoreToPointInTime(y)),
    's3Import': obj.s3Import?.map(y => toJson_InstanceSpecForProviderS3Import(y)),
    'securityGroupNames': obj.securityGroupNames?.map(y => y),
    'skipFinalSnapshot': obj.skipFinalSnapshot,
    'snapshotIdentifier': obj.snapshotIdentifier,
    'storageEncrypted': obj.storageEncrypted,
    'storageThroughput': obj.storageThroughput,
    'storageType': obj.storageType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timezone': obj.timezone,
    'username': obj.username,
    'vpcSecurityGroupIdRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_InstanceSpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIdSelector': toJson_InstanceSpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIds': obj.vpcSecurityGroupIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema InstanceSpecInitProvider
 */
export interface InstanceSpecInitProvider {
  /**
   * The allocated storage in gibibytes. If max_allocated_storage is configured, this argument represents the initial storage allocation and differences from the configuration will be ignored automatically when Storage Autoscaling occurs. If replicate_source_db is set, the value is ignored during the creation of the instance.
   *
   * @schema InstanceSpecInitProvider#allocatedStorage
   */
  readonly allocatedStorage?: number;

  /**
   * Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage and the change is asynchronously applied as soon as possible.
   *
   * @schema InstanceSpecInitProvider#allowMajorVersionUpgrade
   */
  readonly allowMajorVersionUpgrade?: boolean;

  /**
   * Specifies whether any database modifications are applied immediately, or during the next maintenance window. Default is false. See Amazon RDS Documentation for more information.
   *
   * @default false. See Amazon RDS Documentation for more information.
   * @schema InstanceSpecInitProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * Indicates that minor engine upgrades will be applied automatically to the DB instance during the maintenance window. Defaults to true.
   *
   * @default true.
   * @schema InstanceSpecInitProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * The AZ for the RDS instance.
   *
   * @schema InstanceSpecInitProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The days to retain backups for. Must be between 0 and 35. Default is 0. Must be greater than 0 if the database is used as a source for a Read Replica, uses low-downtime updates, or will use RDS Blue/Green deployments.
   *
   * @default 0. Must be greater than 0 if the database is used as a source for a Read Replica, uses low-downtime updates, or will use RDS Blue/Green deployments.
   * @schema InstanceSpecInitProvider#backupRetentionPeriod
   */
  readonly backupRetentionPeriod?: number;

  /**
   * The daily time range (in UTC) during which automated backups are created if they are enabled. Example: "09:46-10:16". Must not overlap with maintenance_window.
   *
   * @schema InstanceSpecInitProvider#backupWindow
   */
  readonly backupWindow?: string;

  /**
   * Enables low-downtime updates using RDS Blue/Green deployments. See blue_green_update below
   *
   * @schema InstanceSpecInitProvider#blueGreenUpdate
   */
  readonly blueGreenUpdate?: InstanceSpecInitProviderBlueGreenUpdate[];

  /**
   * The identifier of the CA certificate for the DB instance.
   *
   * @schema InstanceSpecInitProvider#caCertIdentifier
   */
  readonly caCertIdentifier?: string;

  /**
   * The character set name to use for DB encoding in Oracle and Microsoft SQL instances (collation). This can't be changed. See Oracle Character Sets Supported in Amazon RDS or Server-Level Collation for Microsoft SQL Server for more information.
   *
   * @schema InstanceSpecInitProvider#characterSetName
   */
  readonly characterSetName?: string;

  /**
   * –  Copy all Instance tags to snapshots. Default is false.
   *
   * @default false.
   * @schema InstanceSpecInitProvider#copyTagsToSnapshot
   */
  readonly copyTagsToSnapshot?: boolean;

  /**
   * The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance.
   *
   * @schema InstanceSpecInitProvider#customIamInstanceProfile
   */
  readonly customIamInstanceProfile?: string;

  /**
   * Indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance. See CoIP for RDS on Outposts for more information.
   *
   * @schema InstanceSpecInitProvider#customerOwnedIpEnabled
   */
  readonly customerOwnedIpEnabled?: boolean;

  /**
   * The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Note that this does not apply for Oracle or SQL Server engines. See the AWS documentation for more details on what applies for those engines. If you are providing an Oracle db name, it needs to be in all upper case. Cannot be specified for a replica.
   *
   * @schema InstanceSpecInitProvider#dbName
   */
  readonly dbName?: string;

  /**
   * Specifies whether to remove automated backups immediately after the DB instance is deleted. Default is true.
   *
   * @default true.
   * @schema InstanceSpecInitProvider#deleteAutomatedBackups
   */
  readonly deleteAutomatedBackups?: boolean;

  /**
   * If the DB instance should have deletion protection enabled. The database can't be deleted when this value is set to true. The default is false.
   *
   * @schema InstanceSpecInitProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * The ID of the Directory Service Active Directory domain to create the instance in.
   *
   * @schema InstanceSpecInitProvider#domain
   */
  readonly domain?: string;

  /**
   * The name of the IAM role to be used when making API calls to the Directory Service.
   *
   * @schema InstanceSpecInitProvider#domainIamRoleName
   */
  readonly domainIamRoleName?: string;

  /**
   * Set of log types to enable for exporting to CloudWatch logs. If omitted, no logs will be exported. Valid values (depending on engine). MySQL and MariaDB: audit, error, general, slowquery. PostgreSQL: postgresql, upgrade. MSSQL: agent , error. Oracle: alert, audit, listener, trace.
   *
   * @schema InstanceSpecInitProvider#enabledCloudwatchLogsExports
   */
  readonly enabledCloudwatchLogsExports?: string[];

  /**
   * The database engine to use. For supported values, see the Engine parameter in [API action CreateDBInstance](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html). Note that for Amazon Aurora instances the engine must match the [DB Cluster](https://marketplace.upbound.io/providers/upbound/provider-aws/latest/resources/rds.aws.upbound.io/Cluster/v1beta1)'s engine'. For information on the difference between the available Aurora MySQL engines see Comparison in the [Amazon RDS Release Notes](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraMySQLReleaseNotes/Welcome.html).
   *
   * @schema InstanceSpecInitProvider#engine
   */
  readonly engine?: string;

  /**
   * The engine version to use. If `autoMinorVersionUpgrade` is enabled, you can provide a prefix of the version such as 5.7 (for 5.7.10). The actual engine version used is returned in the attribute `status.atProvider.engineVersionActual`. For supported values, see the EngineVersion parameter in [API action CreateDBInstance](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html). Note that for Amazon Aurora instances the engine version must match the [DB Cluster](https://marketplace.upbound.io/providers/upbound/provider-aws/latest/resources/rds.aws.upbound.io/Cluster/v1beta1)'s engine version'.
   *
   * @schema InstanceSpecInitProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The name of your final DB snapshot when this DB instance is deleted. Must be provided if skip_final_snapshot is set to false. The value must begin with a letter, only contain alphanumeric characters and hyphens, and not end with a hyphen or contain two consecutive hyphens. Must not be provided when deleting a read replica.
   *
   * @schema InstanceSpecInitProvider#finalSnapshotIdentifier
   */
  readonly finalSnapshotIdentifier?: string;

  /**
   * Specifies whether mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled.
   *
   * @schema InstanceSpecInitProvider#iamDatabaseAuthenticationEnabled
   */
  readonly iamDatabaseAuthenticationEnabled?: boolean;

  /**
   * The instance type of the RDS instance.
   *
   * @schema InstanceSpecInitProvider#instanceClass
   */
  readonly instanceClass?: string;

  /**
   * The amount of provisioned IOPS. Setting this implies a storage_type of "io1". Can only be set when storage_type is "io1" or "gp3". Cannot be specified for gp3 storage if the allocated_storage value is below a per-engine threshold. See the RDS User Guide for details.
   *
   * @schema InstanceSpecInitProvider#iops
   */
  readonly iops?: number;

  /**
   * License model information for this DB instance.
   *
   * @schema InstanceSpecInitProvider#licenseModel
   */
  readonly licenseModel?: string;

  /**
   * The window to perform maintenance in. Syntax: "ddd:hh24:mi-ddd:hh24:mi". Eg: "Mon:00:00-Mon:03:00". See RDS Maintenance Window docs for more information.
   *
   * @schema InstanceSpecInitProvider#maintenanceWindow
   */
  readonly maintenanceWindow?: string;

  /**
   * Set to true to allow RDS to manage the master user password in Secrets Manager. Cannot be set if password is provided.
   *
   * @schema InstanceSpecInitProvider#manageMasterUserPassword
   */
  readonly manageMasterUserPassword?: boolean;

  /**
   * When configured, the upper limit to which Amazon RDS can automatically scale the storage of the DB instance. Configuring this will automatically ignore differences to allocated_storage. Must be greater than or equal to allocated_storage or 0 to disable Storage Autoscaling.
   *
   * @schema InstanceSpecInitProvider#maxAllocatedStorage
   */
  readonly maxAllocatedStorage?: number;

  /**
   * The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0. Valid Values: 0, 1, 5, 10, 15, 30, 60.
   *
   * @schema InstanceSpecInitProvider#monitoringInterval
   */
  readonly monitoringInterval?: number;

  /**
   * Specifies if the RDS instance is multi-AZ
   *
   * @schema InstanceSpecInitProvider#multiAz
   */
  readonly multiAz?: boolean;

  /**
   * The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Note that this does not apply for Oracle or SQL Server engines. See the AWS documentation for more details on what applies for those engines. If you are providing an Oracle db name, it needs to be in all upper case. Cannot be specified for a replica.
   *
   * @schema InstanceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The national character set is used in the NCHAR, NVARCHAR2, and NCLOB data types for Oracle instances. This can't be changed. See Oracle Character Sets Supported in Amazon RDS.
   *
   * @schema InstanceSpecInitProvider#ncharCharacterSetName
   */
  readonly ncharCharacterSetName?: string;

  /**
   * The network type of the DB instance. Valid values: IPV4, DUAL.
   *
   * @schema InstanceSpecInitProvider#networkType
   */
  readonly networkType?: string;

  /**
   * Name of the DB option group to associate.
   *
   * @schema InstanceSpecInitProvider#optionGroupName
   */
  readonly optionGroupName?: string;

  /**
   * Name of the DB parameter group to associate.
   *
   * @schema InstanceSpecInitProvider#parameterGroupName
   */
  readonly parameterGroupName?: string;

  /**
   * Specifies whether Performance Insights are enabled. Defaults to false.
   *
   * @default false.
   * @schema InstanceSpecInitProvider#performanceInsightsEnabled
   */
  readonly performanceInsightsEnabled?: boolean;

  /**
   * The ARN for the KMS key to encrypt Performance Insights data. When specifying performance_insights_kms_key_id, performance_insights_enabled needs to be set to true. Once KMS key is set, it can never be changed.
   *
   * @schema InstanceSpecInitProvider#performanceInsightsKmsKeyId
   */
  readonly performanceInsightsKmsKeyId?: string;

  /**
   * Amount of time in days to retain Performance Insights data. Valid values are 7, 731 (2 years) or a multiple of 31. When specifying performance_insights_retention_period, performance_insights_enabled needs to be set to true. Defaults to '7'.
   *
   * @default 7'.
   * @schema InstanceSpecInitProvider#performanceInsightsRetentionPeriod
   */
  readonly performanceInsightsRetentionPeriod?: number;

  /**
   * The port on which the DB accepts connections.
   *
   * @schema InstanceSpecInitProvider#port
   */
  readonly port?: number;

  /**
   * Bool to control if instance is publicly accessible. Default is false.
   *
   * @default false.
   * @schema InstanceSpecInitProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Specifies whether the replica is in either mounted or open-read-only mode. This attribute is only supported by Oracle instances. Oracle replicas operate in open-read-only mode unless otherwise specified. See Working with Oracle Read Replicas for more information.
   *
   * @schema InstanceSpecInitProvider#replicaMode
   */
  readonly replicaMode?: string;

  /**
   * A configuration block for restoring a DB instance to an arbitrary point in time. Requires the identifier argument to be set with the name of the new DB instance to be created. See Restore To Point In Time below for details.
   *
   * @schema InstanceSpecInitProvider#restoreToPointInTime
   */
  readonly restoreToPointInTime?: InstanceSpecInitProviderRestoreToPointInTime[];

  /**
   * Restore from a Percona Xtrabackup in S3.  See Importing Data into an Amazon RDS MySQL DB Instance
   *
   * @schema InstanceSpecInitProvider#s3Import
   */
  readonly s3Import?: InstanceSpecInitProviderS3Import[];

  /**
   * List of DB Security Groups to associate. Only used for DB Instances on the .
   *
   * @schema InstanceSpecInitProvider#securityGroupNames
   */
  readonly securityGroupNames?: string[];

  /**
   * Determines whether a final DB snapshot is created before the DB instance is deleted. If true is specified, no DBSnapshot is created. If false is specified, a DB snapshot is created before the DB instance is deleted, using the value from final_snapshot_identifier. Default is false.
   *
   * @default false.
   * @schema InstanceSpecInitProvider#skipFinalSnapshot
   */
  readonly skipFinalSnapshot?: boolean;

  /**
   * Specifies whether or not to create this database from a snapshot. This correlates to the snapshot ID you'd find in the RDS console, e.g: rds:production-2015-06-26-06-05.
   *
   * @schema InstanceSpecInitProvider#snapshotIdentifier
   */
  readonly snapshotIdentifier?: string;

  /**
   * Specifies whether the DB instance is encrypted. Note that if you are creating a cross-region read replica this field is ignored and you should instead declare kms_key_id with a valid ARN. The default is false if not specified.
   *
   * @schema InstanceSpecInitProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

  /**
   * The storage throughput value for the DB instance. Can only be set when storage_type is "gp3". Cannot be specified if the allocated_storage value is below a per-engine threshold. See the RDS User Guide for details.
   *
   * @schema InstanceSpecInitProvider#storageThroughput
   */
  readonly storageThroughput?: number;

  /**
   * One of "standard" (magnetic), "gp2" (general purpose SSD), "gp3" (general purpose SSD that needs iops independently) or "io1" (provisioned IOPS SSD). The default is "io1" if iops is specified, "gp2" if not.
   *
   * @schema InstanceSpecInitProvider#storageType
   */
  readonly storageType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema InstanceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Time zone of the DB instance. timezone is currently only supported by Microsoft SQL Server. The timezone can only be set on creation. See MSSQL User Guide for more information.
   *
   * @schema InstanceSpecInitProvider#timezone
   */
  readonly timezone?: string;

  /**
   * Username for the master DB user. Cannot be specified for a replica.
   *
   * @schema InstanceSpecInitProvider#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'InstanceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProvider(obj: InstanceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedStorage': obj.allocatedStorage,
    'allowMajorVersionUpgrade': obj.allowMajorVersionUpgrade,
    'applyImmediately': obj.applyImmediately,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'availabilityZone': obj.availabilityZone,
    'backupRetentionPeriod': obj.backupRetentionPeriod,
    'backupWindow': obj.backupWindow,
    'blueGreenUpdate': obj.blueGreenUpdate?.map(y => toJson_InstanceSpecInitProviderBlueGreenUpdate(y)),
    'caCertIdentifier': obj.caCertIdentifier,
    'characterSetName': obj.characterSetName,
    'copyTagsToSnapshot': obj.copyTagsToSnapshot,
    'customIamInstanceProfile': obj.customIamInstanceProfile,
    'customerOwnedIpEnabled': obj.customerOwnedIpEnabled,
    'dbName': obj.dbName,
    'deleteAutomatedBackups': obj.deleteAutomatedBackups,
    'deletionProtection': obj.deletionProtection,
    'domain': obj.domain,
    'domainIamRoleName': obj.domainIamRoleName,
    'enabledCloudwatchLogsExports': obj.enabledCloudwatchLogsExports?.map(y => y),
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'finalSnapshotIdentifier': obj.finalSnapshotIdentifier,
    'iamDatabaseAuthenticationEnabled': obj.iamDatabaseAuthenticationEnabled,
    'instanceClass': obj.instanceClass,
    'iops': obj.iops,
    'licenseModel': obj.licenseModel,
    'maintenanceWindow': obj.maintenanceWindow,
    'manageMasterUserPassword': obj.manageMasterUserPassword,
    'maxAllocatedStorage': obj.maxAllocatedStorage,
    'monitoringInterval': obj.monitoringInterval,
    'multiAz': obj.multiAz,
    'name': obj.name,
    'ncharCharacterSetName': obj.ncharCharacterSetName,
    'networkType': obj.networkType,
    'optionGroupName': obj.optionGroupName,
    'parameterGroupName': obj.parameterGroupName,
    'performanceInsightsEnabled': obj.performanceInsightsEnabled,
    'performanceInsightsKmsKeyId': obj.performanceInsightsKmsKeyId,
    'performanceInsightsRetentionPeriod': obj.performanceInsightsRetentionPeriod,
    'port': obj.port,
    'publiclyAccessible': obj.publiclyAccessible,
    'replicaMode': obj.replicaMode,
    'restoreToPointInTime': obj.restoreToPointInTime?.map(y => toJson_InstanceSpecInitProviderRestoreToPointInTime(y)),
    's3Import': obj.s3Import?.map(y => toJson_InstanceSpecInitProviderS3Import(y)),
    'securityGroupNames': obj.securityGroupNames?.map(y => y),
    'skipFinalSnapshot': obj.skipFinalSnapshot,
    'snapshotIdentifier': obj.snapshotIdentifier,
    'storageEncrypted': obj.storageEncrypted,
    'storageThroughput': obj.storageThroughput,
    'storageType': obj.storageType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timezone': obj.timezone,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InstanceSpecManagementPolicies
 */
export enum InstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceSpecProviderConfigRef
 */
export interface InstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRef(obj: InstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceSpecPublishConnectionDetailsTo
 */
export interface InstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsTo(obj: InstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceSpecWriteConnectionSecretToRef
 */
export interface InstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecWriteConnectionSecretToRef(obj: InstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderBlueGreenUpdate
 */
export interface InstanceSpecForProviderBlueGreenUpdate {
  /**
   * Enables [low-downtime updates](#Low-Downtime Updates) when true. Default is false.
   *
   * @default false.
   * @schema InstanceSpecForProviderBlueGreenUpdate#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'InstanceSpecForProviderBlueGreenUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderBlueGreenUpdate(obj: InstanceSpecForProviderBlueGreenUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a SubnetGroup to populate dbSubnetGroupName.
 *
 * @schema InstanceSpecForProviderDbSubnetGroupNameRef
 */
export interface InstanceSpecForProviderDbSubnetGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderDbSubnetGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderDbSubnetGroupNameRef#policy
   */
  readonly policy?: InstanceSpecForProviderDbSubnetGroupNameRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDbSubnetGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDbSubnetGroupNameRef(obj: InstanceSpecForProviderDbSubnetGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderDbSubnetGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a SubnetGroup to populate dbSubnetGroupName.
 *
 * @schema InstanceSpecForProviderDbSubnetGroupNameSelector
 */
export interface InstanceSpecForProviderDbSubnetGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderDbSubnetGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderDbSubnetGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderDbSubnetGroupNameSelector#policy
   */
  readonly policy?: InstanceSpecForProviderDbSubnetGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDbSubnetGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDbSubnetGroupNameSelector(obj: InstanceSpecForProviderDbSubnetGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderDbSubnetGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema InstanceSpecForProviderKmsKeyIdRef
 */
export interface InstanceSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: InstanceSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderKmsKeyIdRef(obj: InstanceSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema InstanceSpecForProviderKmsKeyIdSelector
 */
export interface InstanceSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: InstanceSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderKmsKeyIdSelector(obj: InstanceSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate masterUserSecretKmsKeyId.
 *
 * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdRef
 */
export interface InstanceSpecForProviderMasterUserSecretKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdRef#policy
   */
  readonly policy?: InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMasterUserSecretKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMasterUserSecretKmsKeyIdRef(obj: InstanceSpecForProviderMasterUserSecretKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate masterUserSecretKmsKeyId.
 *
 * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdSelector
 */
export interface InstanceSpecForProviderMasterUserSecretKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdSelector#policy
   */
  readonly policy?: InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMasterUserSecretKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMasterUserSecretKmsKeyIdSelector(obj: InstanceSpecForProviderMasterUserSecretKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate monitoringRoleArn.
 *
 * @schema InstanceSpecForProviderMonitoringRoleArnRef
 */
export interface InstanceSpecForProviderMonitoringRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderMonitoringRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderMonitoringRoleArnRef#policy
   */
  readonly policy?: InstanceSpecForProviderMonitoringRoleArnRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMonitoringRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMonitoringRoleArnRef(obj: InstanceSpecForProviderMonitoringRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderMonitoringRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate monitoringRoleArn.
 *
 * @schema InstanceSpecForProviderMonitoringRoleArnSelector
 */
export interface InstanceSpecForProviderMonitoringRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderMonitoringRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderMonitoringRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderMonitoringRoleArnSelector#policy
   */
  readonly policy?: InstanceSpecForProviderMonitoringRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMonitoringRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMonitoringRoleArnSelector(obj: InstanceSpecForProviderMonitoringRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderMonitoringRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Cannot be set if manage_master_user_password is set to true. Password for the master DB user. If you set autoGeneratePassword to true, the Secret referenced here will be created or updated with generated password if it does not already contain one.
 *
 * @schema InstanceSpecForProviderPasswordSecretRef
 */
export interface InstanceSpecForProviderPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema InstanceSpecForProviderPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema InstanceSpecForProviderPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceSpecForProviderPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderPasswordSecretRef(obj: InstanceSpecForProviderPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in rds to populate replicateSourceDb.
 *
 * @schema InstanceSpecForProviderReplicateSourceDbRef
 */
export interface InstanceSpecForProviderReplicateSourceDbRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderReplicateSourceDbRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderReplicateSourceDbRef#policy
   */
  readonly policy?: InstanceSpecForProviderReplicateSourceDbRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderReplicateSourceDbRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderReplicateSourceDbRef(obj: InstanceSpecForProviderReplicateSourceDbRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderReplicateSourceDbRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in rds to populate replicateSourceDb.
 *
 * @schema InstanceSpecForProviderReplicateSourceDbSelector
 */
export interface InstanceSpecForProviderReplicateSourceDbSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderReplicateSourceDbSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderReplicateSourceDbSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderReplicateSourceDbSelector#policy
   */
  readonly policy?: InstanceSpecForProviderReplicateSourceDbSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderReplicateSourceDbSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderReplicateSourceDbSelector(obj: InstanceSpecForProviderReplicateSourceDbSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderReplicateSourceDbSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderRestoreToPointInTime
 */
export interface InstanceSpecForProviderRestoreToPointInTime {
  /**
   * The date and time to restore from. Value must be a time in Universal Coordinated Time (UTC) format and must be before the latest restorable time for the DB instance. Cannot be specified with use_latest_restorable_time.
   *
   * @schema InstanceSpecForProviderRestoreToPointInTime#restoreTime
   */
  readonly restoreTime?: string;

  /**
   * The ARN of the automated backup from which to restore. Required if source_db_instance_identifier or source_dbi_resource_id is not specified.
   *
   * @schema InstanceSpecForProviderRestoreToPointInTime#sourceDbInstanceAutomatedBackupsArn
   */
  readonly sourceDbInstanceAutomatedBackupsArn?: string;

  /**
   * The identifier of the source DB instance from which to restore. Must match the identifier of an existing DB instance. Required if source_db_instance_automated_backups_arn or source_dbi_resource_id is not specified.
   *
   * @schema InstanceSpecForProviderRestoreToPointInTime#sourceDbInstanceIdentifier
   */
  readonly sourceDbInstanceIdentifier?: string;

  /**
   * The resource ID of the source DB instance from which to restore. Required if source_db_instance_identifier or source_db_instance_automated_backups_arn is not specified.
   *
   * @schema InstanceSpecForProviderRestoreToPointInTime#sourceDbiResourceId
   */
  readonly sourceDbiResourceId?: string;

  /**
   * A boolean value that indicates whether the DB instance is restored from the latest backup time. Defaults to false. Cannot be specified with restore_time.
   *
   * @default false. Cannot be specified with restore_time.
   * @schema InstanceSpecForProviderRestoreToPointInTime#useLatestRestorableTime
   */
  readonly useLatestRestorableTime?: boolean;

}

/**
 * Converts an object of type 'InstanceSpecForProviderRestoreToPointInTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderRestoreToPointInTime(obj: InstanceSpecForProviderRestoreToPointInTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'restoreTime': obj.restoreTime,
    'sourceDbInstanceAutomatedBackupsArn': obj.sourceDbInstanceAutomatedBackupsArn,
    'sourceDbInstanceIdentifier': obj.sourceDbInstanceIdentifier,
    'sourceDbiResourceId': obj.sourceDbiResourceId,
    'useLatestRestorableTime': obj.useLatestRestorableTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderS3Import
 */
export interface InstanceSpecForProviderS3Import {
  /**
   * The bucket name where your backup is stored
   *
   * @schema InstanceSpecForProviderS3Import#bucketName
   */
  readonly bucketName?: string;

  /**
   * Can be blank, but is the path to your backup
   *
   * @schema InstanceSpecForProviderS3Import#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * Role applied to load the data.
   *
   * @schema InstanceSpecForProviderS3Import#ingestionRole
   */
  readonly ingestionRole?: string;

  /**
   * Source engine for the backup
   *
   * @schema InstanceSpecForProviderS3Import#sourceEngine
   */
  readonly sourceEngine?: string;

  /**
   * Version of the source engine used to make the backup
   *
   * @schema InstanceSpecForProviderS3Import#sourceEngineVersion
   */
  readonly sourceEngineVersion?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderS3Import' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderS3Import(obj: InstanceSpecForProviderS3Import | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    'ingestionRole': obj.ingestionRole,
    'sourceEngine': obj.sourceEngine,
    'sourceEngineVersion': obj.sourceEngineVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema InstanceSpecForProviderVpcSecurityGroupIdRefs
 */
export interface InstanceSpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: InstanceSpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderVpcSecurityGroupIdRefs(obj: InstanceSpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
 *
 * @schema InstanceSpecForProviderVpcSecurityGroupIdSelector
 */
export interface InstanceSpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceSpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceSpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceSpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceSpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderVpcSecurityGroupIdSelector(obj: InstanceSpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderBlueGreenUpdate
 */
export interface InstanceSpecInitProviderBlueGreenUpdate {
  /**
   * Enables [low-downtime updates](#Low-Downtime Updates) when true. Default is false.
   *
   * @default false.
   * @schema InstanceSpecInitProviderBlueGreenUpdate#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderBlueGreenUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderBlueGreenUpdate(obj: InstanceSpecInitProviderBlueGreenUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderRestoreToPointInTime
 */
export interface InstanceSpecInitProviderRestoreToPointInTime {
  /**
   * The date and time to restore from. Value must be a time in Universal Coordinated Time (UTC) format and must be before the latest restorable time for the DB instance. Cannot be specified with use_latest_restorable_time.
   *
   * @schema InstanceSpecInitProviderRestoreToPointInTime#restoreTime
   */
  readonly restoreTime?: string;

  /**
   * The ARN of the automated backup from which to restore. Required if source_db_instance_identifier or source_dbi_resource_id is not specified.
   *
   * @schema InstanceSpecInitProviderRestoreToPointInTime#sourceDbInstanceAutomatedBackupsArn
   */
  readonly sourceDbInstanceAutomatedBackupsArn?: string;

  /**
   * The identifier of the source DB instance from which to restore. Must match the identifier of an existing DB instance. Required if source_db_instance_automated_backups_arn or source_dbi_resource_id is not specified.
   *
   * @schema InstanceSpecInitProviderRestoreToPointInTime#sourceDbInstanceIdentifier
   */
  readonly sourceDbInstanceIdentifier?: string;

  /**
   * The resource ID of the source DB instance from which to restore. Required if source_db_instance_identifier or source_db_instance_automated_backups_arn is not specified.
   *
   * @schema InstanceSpecInitProviderRestoreToPointInTime#sourceDbiResourceId
   */
  readonly sourceDbiResourceId?: string;

  /**
   * A boolean value that indicates whether the DB instance is restored from the latest backup time. Defaults to false. Cannot be specified with restore_time.
   *
   * @default false. Cannot be specified with restore_time.
   * @schema InstanceSpecInitProviderRestoreToPointInTime#useLatestRestorableTime
   */
  readonly useLatestRestorableTime?: boolean;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderRestoreToPointInTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderRestoreToPointInTime(obj: InstanceSpecInitProviderRestoreToPointInTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'restoreTime': obj.restoreTime,
    'sourceDbInstanceAutomatedBackupsArn': obj.sourceDbInstanceAutomatedBackupsArn,
    'sourceDbInstanceIdentifier': obj.sourceDbInstanceIdentifier,
    'sourceDbiResourceId': obj.sourceDbiResourceId,
    'useLatestRestorableTime': obj.useLatestRestorableTime,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecInitProviderS3Import
 */
export interface InstanceSpecInitProviderS3Import {
  /**
   * The bucket name where your backup is stored
   *
   * @schema InstanceSpecInitProviderS3Import#bucketName
   */
  readonly bucketName?: string;

  /**
   * Can be blank, but is the path to your backup
   *
   * @schema InstanceSpecInitProviderS3Import#bucketPrefix
   */
  readonly bucketPrefix?: string;

  /**
   * Role applied to load the data.
   *
   * @schema InstanceSpecInitProviderS3Import#ingestionRole
   */
  readonly ingestionRole?: string;

  /**
   * Source engine for the backup
   *
   * @schema InstanceSpecInitProviderS3Import#sourceEngine
   */
  readonly sourceEngine?: string;

  /**
   * Version of the source engine used to make the backup
   *
   * @schema InstanceSpecInitProviderS3Import#sourceEngineVersion
   */
  readonly sourceEngineVersion?: string;

}

/**
 * Converts an object of type 'InstanceSpecInitProviderS3Import' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecInitProviderS3Import(obj: InstanceSpecInitProviderS3Import | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketPrefix': obj.bucketPrefix,
    'ingestionRole': obj.ingestionRole,
    'sourceEngine': obj.sourceEngine,
    'sourceEngineVersion': obj.sourceEngineVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderConfigRefPolicy
 */
export interface InstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRefPolicy(obj: InstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj: InstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj: InstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderDbSubnetGroupNameRefPolicy
 */
export interface InstanceSpecForProviderDbSubnetGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderDbSubnetGroupNameRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderDbSubnetGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderDbSubnetGroupNameRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderDbSubnetGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDbSubnetGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDbSubnetGroupNameRefPolicy(obj: InstanceSpecForProviderDbSubnetGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderDbSubnetGroupNameSelectorPolicy
 */
export interface InstanceSpecForProviderDbSubnetGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderDbSubnetGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderDbSubnetGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderDbSubnetGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderDbSubnetGroupNameSelectorPolicy(obj: InstanceSpecForProviderDbSubnetGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderKmsKeyIdRefPolicy
 */
export interface InstanceSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderKmsKeyIdRefPolicy(obj: InstanceSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface InstanceSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderKmsKeyIdSelectorPolicy(obj: InstanceSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicy
 */
export interface InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicy(obj: InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy
 */
export interface InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy(obj: InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderMonitoringRoleArnRefPolicy
 */
export interface InstanceSpecForProviderMonitoringRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderMonitoringRoleArnRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderMonitoringRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderMonitoringRoleArnRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderMonitoringRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMonitoringRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMonitoringRoleArnRefPolicy(obj: InstanceSpecForProviderMonitoringRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderMonitoringRoleArnSelectorPolicy
 */
export interface InstanceSpecForProviderMonitoringRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderMonitoringRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderMonitoringRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderMonitoringRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderMonitoringRoleArnSelectorPolicy(obj: InstanceSpecForProviderMonitoringRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderReplicateSourceDbRefPolicy
 */
export interface InstanceSpecForProviderReplicateSourceDbRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderReplicateSourceDbRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderReplicateSourceDbRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderReplicateSourceDbRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderReplicateSourceDbRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderReplicateSourceDbRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderReplicateSourceDbRefPolicy(obj: InstanceSpecForProviderReplicateSourceDbRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderReplicateSourceDbSelectorPolicy
 */
export interface InstanceSpecForProviderReplicateSourceDbSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderReplicateSourceDbSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderReplicateSourceDbSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderReplicateSourceDbSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderReplicateSourceDbSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderReplicateSourceDbSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderReplicateSourceDbSelectorPolicy(obj: InstanceSpecForProviderReplicateSourceDbSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface InstanceSpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderVpcSecurityGroupIdRefsPolicy(obj: InstanceSpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolution
 */
export enum InstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolve
 */
export enum InstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderDbSubnetGroupNameRefPolicyResolution
 */
export enum InstanceSpecForProviderDbSubnetGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderDbSubnetGroupNameRefPolicyResolve
 */
export enum InstanceSpecForProviderDbSubnetGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolution
 */
export enum InstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolve
 */
export enum InstanceSpecForProviderDbSubnetGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum InstanceSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum InstanceSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum InstanceSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum InstanceSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolution
 */
export enum InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolve
 */
export enum InstanceSpecForProviderMasterUserSecretKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolution
 */
export enum InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolve
 */
export enum InstanceSpecForProviderMasterUserSecretKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderMonitoringRoleArnRefPolicyResolution
 */
export enum InstanceSpecForProviderMonitoringRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderMonitoringRoleArnRefPolicyResolve
 */
export enum InstanceSpecForProviderMonitoringRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolution
 */
export enum InstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolve
 */
export enum InstanceSpecForProviderMonitoringRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderReplicateSourceDbRefPolicyResolution
 */
export enum InstanceSpecForProviderReplicateSourceDbRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderReplicateSourceDbRefPolicyResolve
 */
export enum InstanceSpecForProviderReplicateSourceDbRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderReplicateSourceDbSelectorPolicyResolution
 */
export enum InstanceSpecForProviderReplicateSourceDbSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderReplicateSourceDbSelectorPolicyResolve
 */
export enum InstanceSpecForProviderReplicateSourceDbSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum InstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum InstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum InstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InstanceRoleAssociation is the Schema for the InstanceRoleAssociations API. Manages an RDS DB Instance association with an IAM Role.
 *
 * @schema InstanceRoleAssociation
 */
export class InstanceRoleAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InstanceRoleAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'InstanceRoleAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "InstanceRoleAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceRoleAssociationProps): any {
    return {
      ...InstanceRoleAssociation.GVK,
      ...toJson_InstanceRoleAssociationProps(props),
    };
  }

  /**
   * Defines a "InstanceRoleAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceRoleAssociationProps) {
    super(scope, id, {
      ...InstanceRoleAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InstanceRoleAssociation.GVK,
      ...toJson_InstanceRoleAssociationProps(resolved),
    };
  }
}

/**
 * InstanceRoleAssociation is the Schema for the InstanceRoleAssociations API. Manages an RDS DB Instance association with an IAM Role.
 *
 * @schema InstanceRoleAssociation
 */
export interface InstanceRoleAssociationProps {
  /**
   * @schema InstanceRoleAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceRoleAssociationSpec defines the desired state of InstanceRoleAssociation
   *
   * @schema InstanceRoleAssociation#spec
   */
  readonly spec: InstanceRoleAssociationSpec;

}

/**
 * Converts an object of type 'InstanceRoleAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationProps(obj: InstanceRoleAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceRoleAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceRoleAssociationSpec defines the desired state of InstanceRoleAssociation
 *
 * @schema InstanceRoleAssociationSpec
 */
export interface InstanceRoleAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceRoleAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceRoleAssociationSpecDeletionPolicy;

  /**
   * @schema InstanceRoleAssociationSpec#forProvider
   */
  readonly forProvider: InstanceRoleAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema InstanceRoleAssociationSpec#initProvider
   */
  readonly initProvider?: InstanceRoleAssociationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InstanceRoleAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: InstanceRoleAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceRoleAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceRoleAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceRoleAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceRoleAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceRoleAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceRoleAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpec(obj: InstanceRoleAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceRoleAssociationSpecForProvider(obj.forProvider),
    'initProvider': toJson_InstanceRoleAssociationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InstanceRoleAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InstanceRoleAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceRoleAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceRoleAssociationSpecDeletionPolicy
 */
export enum InstanceRoleAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceRoleAssociationSpecForProvider
 */
export interface InstanceRoleAssociationSpecForProvider {
  /**
   * DB Instance Identifier to associate with the IAM Role.
   *
   * @schema InstanceRoleAssociationSpecForProvider#dbInstanceIdentifier
   */
  readonly dbInstanceIdentifier?: string;

  /**
   * Reference to a Instance in rds to populate dbInstanceIdentifier.
   *
   * @schema InstanceRoleAssociationSpecForProvider#dbInstanceIdentifierRef
   */
  readonly dbInstanceIdentifierRef?: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef;

  /**
   * Selector for a Instance in rds to populate dbInstanceIdentifier.
   *
   * @schema InstanceRoleAssociationSpecForProvider#dbInstanceIdentifierSelector
   */
  readonly dbInstanceIdentifierSelector?: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector;

  /**
   * Name of the feature for association. This can be found in the AWS documentation relevant to the integration or a full list is available in the SupportedFeatureNames list returned by AWS CLI rds describe-db-engine-versions.
   *
   * @schema InstanceRoleAssociationSpecForProvider#featureName
   */
  readonly featureName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InstanceRoleAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon Resource Name (ARN) of the IAM Role to associate with the DB Instance.
   *
   * @schema InstanceRoleAssociationSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema InstanceRoleAssociationSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: InstanceRoleAssociationSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema InstanceRoleAssociationSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: InstanceRoleAssociationSpecForProviderRoleArnSelector;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecForProvider(obj: InstanceRoleAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbInstanceIdentifier': obj.dbInstanceIdentifier,
    'dbInstanceIdentifierRef': toJson_InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef(obj.dbInstanceIdentifierRef),
    'dbInstanceIdentifierSelector': toJson_InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector(obj.dbInstanceIdentifierSelector),
    'featureName': obj.featureName,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_InstanceRoleAssociationSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_InstanceRoleAssociationSpecForProviderRoleArnSelector(obj.roleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema InstanceRoleAssociationSpecInitProvider
 */
export interface InstanceRoleAssociationSpecInitProvider {
  /**
   * Name of the feature for association. This can be found in the AWS documentation relevant to the integration or a full list is available in the SupportedFeatureNames list returned by AWS CLI rds describe-db-engine-versions.
   *
   * @schema InstanceRoleAssociationSpecInitProvider#featureName
   */
  readonly featureName?: string;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecInitProvider(obj: InstanceRoleAssociationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'featureName': obj.featureName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InstanceRoleAssociationSpecManagementPolicies
 */
export enum InstanceRoleAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceRoleAssociationSpecProviderConfigRef
 */
export interface InstanceRoleAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceRoleAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceRoleAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceRoleAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecProviderConfigRef(obj: InstanceRoleAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceRoleAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceRoleAssociationSpecPublishConnectionDetailsTo
 */
export interface InstanceRoleAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceRoleAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceRoleAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceRoleAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceRoleAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecPublishConnectionDetailsTo(obj: InstanceRoleAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceRoleAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceRoleAssociationSpecWriteConnectionSecretToRef
 */
export interface InstanceRoleAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceRoleAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceRoleAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecWriteConnectionSecretToRef(obj: InstanceRoleAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in rds to populate dbInstanceIdentifier.
 *
 * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef
 */
export interface InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef#policy
   */
  readonly policy?: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef(obj: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in rds to populate dbInstanceIdentifier.
 *
 * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector
 */
export interface InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector#policy
   */
  readonly policy?: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector(obj: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema InstanceRoleAssociationSpecForProviderRoleArnRef
 */
export interface InstanceRoleAssociationSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceRoleAssociationSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceRoleAssociationSpecForProviderRoleArnRef#policy
   */
  readonly policy?: InstanceRoleAssociationSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecForProviderRoleArnRef(obj: InstanceRoleAssociationSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceRoleAssociationSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema InstanceRoleAssociationSpecForProviderRoleArnSelector
 */
export interface InstanceRoleAssociationSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceRoleAssociationSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceRoleAssociationSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceRoleAssociationSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecForProviderRoleArnSelector(obj: InstanceRoleAssociationSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceRoleAssociationSpecProviderConfigRefPolicy
 */
export interface InstanceRoleAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceRoleAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceRoleAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceRoleAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceRoleAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecProviderConfigRefPolicy(obj: InstanceRoleAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef(obj: InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceRoleAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecPublishConnectionDetailsToMetadata(obj: InstanceRoleAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy
 */
export interface InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy#resolution
   */
  readonly resolution?: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy#resolve
   */
  readonly resolve?: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy(obj: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy
 */
export interface InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy(obj: InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceRoleAssociationSpecForProviderRoleArnRefPolicy
 */
export interface InstanceRoleAssociationSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceRoleAssociationSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: InstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceRoleAssociationSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: InstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecForProviderRoleArnRefPolicy(obj: InstanceRoleAssociationSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy
 */
export interface InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy(obj: InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceRoleAssociationSpecProviderConfigRefPolicyResolution
 */
export enum InstanceRoleAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceRoleAssociationSpecProviderConfigRefPolicyResolve
 */
export enum InstanceRoleAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolution
 */
export enum InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolve
 */
export enum InstanceRoleAssociationSpecForProviderDbInstanceIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolution
 */
export enum InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolve
 */
export enum InstanceRoleAssociationSpecForProviderDbInstanceIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolution
 */
export enum InstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolve
 */
export enum InstanceRoleAssociationSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum InstanceRoleAssociationSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceRoleAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OptionGroup is the Schema for the OptionGroups API. Provides an RDS DB option group resource.
 *
 * @schema OptionGroup
 */
export class OptionGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OptionGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'OptionGroup',
  }

  /**
   * Renders a Kubernetes manifest for "OptionGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OptionGroupProps): any {
    return {
      ...OptionGroup.GVK,
      ...toJson_OptionGroupProps(props),
    };
  }

  /**
   * Defines a "OptionGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OptionGroupProps) {
    super(scope, id, {
      ...OptionGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OptionGroup.GVK,
      ...toJson_OptionGroupProps(resolved),
    };
  }
}

/**
 * OptionGroup is the Schema for the OptionGroups API. Provides an RDS DB option group resource.
 *
 * @schema OptionGroup
 */
export interface OptionGroupProps {
  /**
   * @schema OptionGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OptionGroupSpec defines the desired state of OptionGroup
   *
   * @schema OptionGroup#spec
   */
  readonly spec: OptionGroupSpec;

}

/**
 * Converts an object of type 'OptionGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupProps(obj: OptionGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OptionGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OptionGroupSpec defines the desired state of OptionGroup
 *
 * @schema OptionGroupSpec
 */
export interface OptionGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema OptionGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: OptionGroupSpecDeletionPolicy;

  /**
   * @schema OptionGroupSpec#forProvider
   */
  readonly forProvider: OptionGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema OptionGroupSpec#initProvider
   */
  readonly initProvider?: OptionGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema OptionGroupSpec#managementPolicies
   */
  readonly managementPolicies?: OptionGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OptionGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: OptionGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OptionGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OptionGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OptionGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OptionGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OptionGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpec(obj: OptionGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OptionGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_OptionGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_OptionGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_OptionGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OptionGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema OptionGroupSpecDeletionPolicy
 */
export enum OptionGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OptionGroupSpecForProvider
 */
export interface OptionGroupSpecForProvider {
  /**
   * Specifies the name of the engine that this option group should be associated with.
   *
   * @schema OptionGroupSpecForProvider#engineName
   */
  readonly engineName?: string;

  /**
   * Specifies the major version of the engine that this option group should be associated with.
   *
   * @schema OptionGroupSpecForProvider#majorEngineVersion
   */
  readonly majorEngineVersion?: string;

  /**
   * A list of Options to apply.
   *
   * @schema OptionGroupSpecForProvider#option
   */
  readonly option?: OptionGroupSpecForProviderOption[];

  /**
   * The description of the option group.
   *
   * @schema OptionGroupSpecForProvider#optionGroupDescription
   */
  readonly optionGroupDescription?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema OptionGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema OptionGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'OptionGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecForProvider(obj: OptionGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'engineName': obj.engineName,
    'majorEngineVersion': obj.majorEngineVersion,
    'option': obj.option?.map(y => toJson_OptionGroupSpecForProviderOption(y)),
    'optionGroupDescription': obj.optionGroupDescription,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema OptionGroupSpecInitProvider
 */
export interface OptionGroupSpecInitProvider {
  /**
   * Specifies the name of the engine that this option group should be associated with.
   *
   * @schema OptionGroupSpecInitProvider#engineName
   */
  readonly engineName?: string;

  /**
   * Specifies the major version of the engine that this option group should be associated with.
   *
   * @schema OptionGroupSpecInitProvider#majorEngineVersion
   */
  readonly majorEngineVersion?: string;

  /**
   * A list of Options to apply.
   *
   * @schema OptionGroupSpecInitProvider#option
   */
  readonly option?: OptionGroupSpecInitProviderOption[];

  /**
   * The description of the option group.
   *
   * @schema OptionGroupSpecInitProvider#optionGroupDescription
   */
  readonly optionGroupDescription?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema OptionGroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'OptionGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecInitProvider(obj: OptionGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'engineName': obj.engineName,
    'majorEngineVersion': obj.majorEngineVersion,
    'option': obj.option?.map(y => toJson_OptionGroupSpecInitProviderOption(y)),
    'optionGroupDescription': obj.optionGroupDescription,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema OptionGroupSpecManagementPolicies
 */
export enum OptionGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OptionGroupSpecProviderConfigRef
 */
export interface OptionGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OptionGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OptionGroupSpecProviderConfigRef#policy
   */
  readonly policy?: OptionGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OptionGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecProviderConfigRef(obj: OptionGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OptionGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsTo
 */
export interface OptionGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OptionGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OptionGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OptionGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecPublishConnectionDetailsTo(obj: OptionGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OptionGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OptionGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OptionGroupSpecWriteConnectionSecretToRef
 */
export interface OptionGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OptionGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OptionGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OptionGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecWriteConnectionSecretToRef(obj: OptionGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OptionGroupSpecForProviderOption
 */
export interface OptionGroupSpecForProviderOption {
  /**
   * A list of DB Security Groups for which the option is enabled.
   *
   * @schema OptionGroupSpecForProviderOption#dbSecurityGroupMemberships
   */
  readonly dbSecurityGroupMemberships?: string[];

  /**
   * The Name of the Option (e.g., MEMCACHED).
   *
   * @schema OptionGroupSpecForProviderOption#optionName
   */
  readonly optionName?: string;

  /**
   * A list of option settings to apply.
   *
   * @schema OptionGroupSpecForProviderOption#optionSettings
   */
  readonly optionSettings?: OptionGroupSpecForProviderOptionOptionSettings[];

  /**
   * The Port number when connecting to the Option (e.g., 11211).
   *
   * @schema OptionGroupSpecForProviderOption#port
   */
  readonly port?: number;

  /**
   * The version of the option (e.g., 13.1.0.0).
   *
   * @schema OptionGroupSpecForProviderOption#version
   */
  readonly version?: string;

  /**
   * A list of VPC Security Groups for which the option is enabled.
   *
   * @schema OptionGroupSpecForProviderOption#vpcSecurityGroupMemberships
   */
  readonly vpcSecurityGroupMemberships?: string[];

}

/**
 * Converts an object of type 'OptionGroupSpecForProviderOption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecForProviderOption(obj: OptionGroupSpecForProviderOption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbSecurityGroupMemberships': obj.dbSecurityGroupMemberships?.map(y => y),
    'optionName': obj.optionName,
    'optionSettings': obj.optionSettings?.map(y => toJson_OptionGroupSpecForProviderOptionOptionSettings(y)),
    'port': obj.port,
    'version': obj.version,
    'vpcSecurityGroupMemberships': obj.vpcSecurityGroupMemberships?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OptionGroupSpecInitProviderOption
 */
export interface OptionGroupSpecInitProviderOption {
  /**
   * A list of DB Security Groups for which the option is enabled.
   *
   * @schema OptionGroupSpecInitProviderOption#dbSecurityGroupMemberships
   */
  readonly dbSecurityGroupMemberships?: string[];

  /**
   * The Name of the Option (e.g., MEMCACHED).
   *
   * @schema OptionGroupSpecInitProviderOption#optionName
   */
  readonly optionName?: string;

  /**
   * A list of option settings to apply.
   *
   * @schema OptionGroupSpecInitProviderOption#optionSettings
   */
  readonly optionSettings?: OptionGroupSpecInitProviderOptionOptionSettings[];

  /**
   * The Port number when connecting to the Option (e.g., 11211).
   *
   * @schema OptionGroupSpecInitProviderOption#port
   */
  readonly port?: number;

  /**
   * The version of the option (e.g., 13.1.0.0).
   *
   * @schema OptionGroupSpecInitProviderOption#version
   */
  readonly version?: string;

  /**
   * A list of VPC Security Groups for which the option is enabled.
   *
   * @schema OptionGroupSpecInitProviderOption#vpcSecurityGroupMemberships
   */
  readonly vpcSecurityGroupMemberships?: string[];

}

/**
 * Converts an object of type 'OptionGroupSpecInitProviderOption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecInitProviderOption(obj: OptionGroupSpecInitProviderOption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbSecurityGroupMemberships': obj.dbSecurityGroupMemberships?.map(y => y),
    'optionName': obj.optionName,
    'optionSettings': obj.optionSettings?.map(y => toJson_OptionGroupSpecInitProviderOptionOptionSettings(y)),
    'port': obj.port,
    'version': obj.version,
    'vpcSecurityGroupMemberships': obj.vpcSecurityGroupMemberships?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OptionGroupSpecProviderConfigRefPolicy
 */
export interface OptionGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OptionGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OptionGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OptionGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OptionGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OptionGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecProviderConfigRefPolicy(obj: OptionGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface OptionGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OptionGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecPublishConnectionDetailsToConfigRef(obj: OptionGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsToMetadata
 */
export interface OptionGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OptionGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecPublishConnectionDetailsToMetadata(obj: OptionGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OptionGroupSpecForProviderOptionOptionSettings
 */
export interface OptionGroupSpecForProviderOptionOptionSettings {
  /**
   * The name of the option group. Must be lowercase, to match as it is stored in AWS.
   *
   * @schema OptionGroupSpecForProviderOptionOptionSettings#name
   */
  readonly name?: string;

  /**
   * The Value of the setting.
   *
   * @schema OptionGroupSpecForProviderOptionOptionSettings#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'OptionGroupSpecForProviderOptionOptionSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecForProviderOptionOptionSettings(obj: OptionGroupSpecForProviderOptionOptionSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema OptionGroupSpecInitProviderOptionOptionSettings
 */
export interface OptionGroupSpecInitProviderOptionOptionSettings {
  /**
   * The name of the option group. Must be lowercase, to match as it is stored in AWS.
   *
   * @schema OptionGroupSpecInitProviderOptionOptionSettings#name
   */
  readonly name?: string;

  /**
   * The Value of the setting.
   *
   * @schema OptionGroupSpecInitProviderOptionOptionSettings#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'OptionGroupSpecInitProviderOptionOptionSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecInitProviderOptionOptionSettings(obj: OptionGroupSpecInitProviderOptionOptionSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OptionGroupSpecProviderConfigRefPolicyResolution
 */
export enum OptionGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OptionGroupSpecProviderConfigRefPolicyResolve
 */
export enum OptionGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: OptionGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OptionGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ParameterGroup is the Schema for the ParameterGroups API. Provides an RDS DB parameter group resource.
 *
 * @schema ParameterGroup
 */
export class ParameterGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ParameterGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'ParameterGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ParameterGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ParameterGroupProps): any {
    return {
      ...ParameterGroup.GVK,
      ...toJson_ParameterGroupProps(props),
    };
  }

  /**
   * Defines a "ParameterGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ParameterGroupProps) {
    super(scope, id, {
      ...ParameterGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ParameterGroup.GVK,
      ...toJson_ParameterGroupProps(resolved),
    };
  }
}

/**
 * ParameterGroup is the Schema for the ParameterGroups API. Provides an RDS DB parameter group resource.
 *
 * @schema ParameterGroup
 */
export interface ParameterGroupProps {
  /**
   * @schema ParameterGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ParameterGroupSpec defines the desired state of ParameterGroup
   *
   * @schema ParameterGroup#spec
   */
  readonly spec: ParameterGroupSpec;

}

/**
 * Converts an object of type 'ParameterGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupProps(obj: ParameterGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ParameterGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ParameterGroupSpec defines the desired state of ParameterGroup
 *
 * @schema ParameterGroupSpec
 */
export interface ParameterGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ParameterGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: ParameterGroupSpecDeletionPolicy;

  /**
   * @schema ParameterGroupSpec#forProvider
   */
  readonly forProvider: ParameterGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ParameterGroupSpec#initProvider
   */
  readonly initProvider?: ParameterGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ParameterGroupSpec#managementPolicies
   */
  readonly managementPolicies?: ParameterGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ParameterGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: ParameterGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ParameterGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ParameterGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ParameterGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ParameterGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ParameterGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpec(obj: ParameterGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ParameterGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_ParameterGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ParameterGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ParameterGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ParameterGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ParameterGroupSpecDeletionPolicy
 */
export enum ParameterGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ParameterGroupSpecForProvider
 */
export interface ParameterGroupSpecForProvider {
  /**
   * The description of the DB parameter group.
   *
   * @schema ParameterGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The family of the DB parameter group.
   *
   * @schema ParameterGroupSpecForProvider#family
   */
  readonly family?: string;

  /**
   * A list of DB parameters to apply. Note that parameters may differ from a family to an other. Full list of all parameters can be discovered via aws rds describe-db-parameters after initial creation of the group.
   *
   * @schema ParameterGroupSpecForProvider#parameter
   */
  readonly parameter?: ParameterGroupSpecForProviderParameter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ParameterGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ParameterGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ParameterGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecForProvider(obj: ParameterGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'family': obj.family,
    'parameter': obj.parameter?.map(y => toJson_ParameterGroupSpecForProviderParameter(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ParameterGroupSpecInitProvider
 */
export interface ParameterGroupSpecInitProvider {
  /**
   * The description of the DB parameter group.
   *
   * @schema ParameterGroupSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The family of the DB parameter group.
   *
   * @schema ParameterGroupSpecInitProvider#family
   */
  readonly family?: string;

  /**
   * A list of DB parameters to apply. Note that parameters may differ from a family to an other. Full list of all parameters can be discovered via aws rds describe-db-parameters after initial creation of the group.
   *
   * @schema ParameterGroupSpecInitProvider#parameter
   */
  readonly parameter?: ParameterGroupSpecInitProviderParameter[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ParameterGroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ParameterGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecInitProvider(obj: ParameterGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'family': obj.family,
    'parameter': obj.parameter?.map(y => toJson_ParameterGroupSpecInitProviderParameter(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ParameterGroupSpecManagementPolicies
 */
export enum ParameterGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ParameterGroupSpecProviderConfigRef
 */
export interface ParameterGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ParameterGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ParameterGroupSpecProviderConfigRef#policy
   */
  readonly policy?: ParameterGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ParameterGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecProviderConfigRef(obj: ParameterGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ParameterGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsTo
 */
export interface ParameterGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ParameterGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ParameterGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsTo(obj: ParameterGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ParameterGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ParameterGroupSpecWriteConnectionSecretToRef
 */
export interface ParameterGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ParameterGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ParameterGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecWriteConnectionSecretToRef(obj: ParameterGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ParameterGroupSpecForProviderParameter
 */
export interface ParameterGroupSpecForProviderParameter {
  /**
   * "immediate" (default), or "pending-reboot". Some engines can't apply some parameters without a reboot, and you will need to specify "pending-reboot" here.
   *
   * @schema ParameterGroupSpecForProviderParameter#applyMethod
   */
  readonly applyMethod?: string;

  /**
   * The name of the DB parameter group.
   *
   * @schema ParameterGroupSpecForProviderParameter#name
   */
  readonly name?: string;

  /**
   * The value of the DB parameter.
   *
   * @schema ParameterGroupSpecForProviderParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecForProviderParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecForProviderParameter(obj: ParameterGroupSpecForProviderParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyMethod': obj.applyMethod,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ParameterGroupSpecInitProviderParameter
 */
export interface ParameterGroupSpecInitProviderParameter {
  /**
   * "immediate" (default), or "pending-reboot". Some engines can't apply some parameters without a reboot, and you will need to specify "pending-reboot" here.
   *
   * @schema ParameterGroupSpecInitProviderParameter#applyMethod
   */
  readonly applyMethod?: string;

  /**
   * The name of the DB parameter group.
   *
   * @schema ParameterGroupSpecInitProviderParameter#name
   */
  readonly name?: string;

  /**
   * The value of the DB parameter.
   *
   * @schema ParameterGroupSpecInitProviderParameter#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecInitProviderParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecInitProviderParameter(obj: ParameterGroupSpecInitProviderParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyMethod': obj.applyMethod,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ParameterGroupSpecProviderConfigRefPolicy
 */
export interface ParameterGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ParameterGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ParameterGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ParameterGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ParameterGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ParameterGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecProviderConfigRefPolicy(obj: ParameterGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface ParameterGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRef(obj: ParameterGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata
 */
export interface ParameterGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsToMetadata(obj: ParameterGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ParameterGroupSpecProviderConfigRefPolicyResolution
 */
export enum ParameterGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ParameterGroupSpecProviderConfigRefPolicyResolve
 */
export enum ParameterGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Proxy is the Schema for the Proxys API. Provides an RDS DB proxy resource.
 *
 * @schema Proxy
 */
export class Proxy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Proxy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'Proxy',
  }

  /**
   * Renders a Kubernetes manifest for "Proxy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProxyProps): any {
    return {
      ...Proxy.GVK,
      ...toJson_ProxyProps(props),
    };
  }

  /**
   * Defines a "Proxy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProxyProps) {
    super(scope, id, {
      ...Proxy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Proxy.GVK,
      ...toJson_ProxyProps(resolved),
    };
  }
}

/**
 * Proxy is the Schema for the Proxys API. Provides an RDS DB proxy resource.
 *
 * @schema Proxy
 */
export interface ProxyProps {
  /**
   * @schema Proxy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProxySpec defines the desired state of Proxy
   *
   * @schema Proxy#spec
   */
  readonly spec: ProxySpec;

}

/**
 * Converts an object of type 'ProxyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyProps(obj: ProxyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProxySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxySpec defines the desired state of Proxy
 *
 * @schema ProxySpec
 */
export interface ProxySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProxySpec#deletionPolicy
   */
  readonly deletionPolicy?: ProxySpecDeletionPolicy;

  /**
   * @schema ProxySpec#forProvider
   */
  readonly forProvider: ProxySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProxySpec#initProvider
   */
  readonly initProvider?: ProxySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProxySpec#managementPolicies
   */
  readonly managementPolicies?: ProxySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProxySpec#providerConfigRef
   */
  readonly providerConfigRef?: ProxySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProxySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProxySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProxySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProxySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProxySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpec(obj: ProxySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProxySpecForProvider(obj.forProvider),
    'initProvider': toJson_ProxySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProxySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProxySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProxySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProxySpecDeletionPolicy
 */
export enum ProxySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProxySpecForProvider
 */
export interface ProxySpecForProvider {
  /**
   * Configuration block(s) with authorization mechanisms to connect to the associated instances or clusters. Described below.
   *
   * @schema ProxySpecForProvider#auth
   */
  readonly auth?: ProxySpecForProviderAuth[];

  /**
   * Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.
   *
   * @schema ProxySpecForProvider#debugLogging
   */
  readonly debugLogging?: boolean;

  /**
   * The kinds of databases that the proxy can connect to. This value determines which database network protocol the proxy recognizes when it interprets network traffic to and from the database. The engine family applies to MySQL and PostgreSQL for both RDS and Aurora. Valid values are MYSQL and POSTGRESQL.
   *
   * @schema ProxySpecForProvider#engineFamily
   */
  readonly engineFamily?: string;

  /**
   * The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database.
   *
   * @schema ProxySpecForProvider#idleClientTimeout
   */
  readonly idleClientTimeout?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProxySpecForProvider#region
   */
  readonly region: string;

  /**
   * A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy.
   *
   * @schema ProxySpecForProvider#requireTls
   */
  readonly requireTls?: boolean;

  /**
   * The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in AWS Secrets Manager.
   *
   * @schema ProxySpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ProxySpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ProxySpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ProxySpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ProxySpecForProviderRoleArnSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema ProxySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ProxySpecForProvider#vpcSecurityGroupIdRefs
   */
  readonly vpcSecurityGroupIdRefs?: ProxySpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ProxySpecForProvider#vpcSecurityGroupIdSelector
   */
  readonly vpcSecurityGroupIdSelector?: ProxySpecForProviderVpcSecurityGroupIdSelector;

  /**
   * One or more VPC security group IDs to associate with the new proxy.
   *
   * @schema ProxySpecForProvider#vpcSecurityGroupIds
   */
  readonly vpcSecurityGroupIds?: string[];

  /**
   * One or more VPC subnet IDs to associate with the new proxy.
   *
   * @schema ProxySpecForProvider#vpcSubnetIds
   */
  readonly vpcSubnetIds?: string[];

}

/**
 * Converts an object of type 'ProxySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProvider(obj: ProxySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': obj.auth?.map(y => toJson_ProxySpecForProviderAuth(y)),
    'debugLogging': obj.debugLogging,
    'engineFamily': obj.engineFamily,
    'idleClientTimeout': obj.idleClientTimeout,
    'region': obj.region,
    'requireTls': obj.requireTls,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ProxySpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ProxySpecForProviderRoleArnSelector(obj.roleArnSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcSecurityGroupIdRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_ProxySpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIdSelector': toJson_ProxySpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIds': obj.vpcSecurityGroupIds?.map(y => y),
    'vpcSubnetIds': obj.vpcSubnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProxySpecInitProvider
 */
export interface ProxySpecInitProvider {
  /**
   * Configuration block(s) with authorization mechanisms to connect to the associated instances or clusters. Described below.
   *
   * @schema ProxySpecInitProvider#auth
   */
  readonly auth?: ProxySpecInitProviderAuth[];

  /**
   * Whether the proxy includes detailed information about SQL statements in its logs. This information helps you to debug issues involving SQL behavior or the performance and scalability of the proxy connections. The debug information includes the text of SQL statements that you submit through the proxy. Thus, only enable this setting when needed for debugging, and only when you have security measures in place to safeguard any sensitive information that appears in the logs.
   *
   * @schema ProxySpecInitProvider#debugLogging
   */
  readonly debugLogging?: boolean;

  /**
   * The kinds of databases that the proxy can connect to. This value determines which database network protocol the proxy recognizes when it interprets network traffic to and from the database. The engine family applies to MySQL and PostgreSQL for both RDS and Aurora. Valid values are MYSQL and POSTGRESQL.
   *
   * @schema ProxySpecInitProvider#engineFamily
   */
  readonly engineFamily?: string;

  /**
   * The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this value higher or lower than the connection timeout limit for the associated database.
   *
   * @schema ProxySpecInitProvider#idleClientTimeout
   */
  readonly idleClientTimeout?: number;

  /**
   * A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy. By enabling this setting, you can enforce encrypted TLS connections to the proxy.
   *
   * @schema ProxySpecInitProvider#requireTls
   */
  readonly requireTls?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ProxySpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * One or more VPC subnet IDs to associate with the new proxy.
   *
   * @schema ProxySpecInitProvider#vpcSubnetIds
   */
  readonly vpcSubnetIds?: string[];

}

/**
 * Converts an object of type 'ProxySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecInitProvider(obj: ProxySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': obj.auth?.map(y => toJson_ProxySpecInitProviderAuth(y)),
    'debugLogging': obj.debugLogging,
    'engineFamily': obj.engineFamily,
    'idleClientTimeout': obj.idleClientTimeout,
    'requireTls': obj.requireTls,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcSubnetIds': obj.vpcSubnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProxySpecManagementPolicies
 */
export enum ProxySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProxySpecProviderConfigRef
 */
export interface ProxySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxySpecProviderConfigRef#policy
   */
  readonly policy?: ProxySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProxySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecProviderConfigRef(obj: ProxySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProxySpecPublishConnectionDetailsTo
 */
export interface ProxySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProxySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProxySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProxySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProxySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProxySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProxySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecPublishConnectionDetailsTo(obj: ProxySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProxySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProxySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProxySpecWriteConnectionSecretToRef
 */
export interface ProxySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProxySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProxySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProxySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecWriteConnectionSecretToRef(obj: ProxySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProxySpecForProviderAuth
 */
export interface ProxySpecForProviderAuth {
  /**
   * The type of authentication that the proxy uses for connections from the proxy to the underlying database. One of SECRETS.
   *
   * @schema ProxySpecForProviderAuth#authScheme
   */
  readonly authScheme?: string;

  /**
   * The type of authentication the proxy uses for connections from clients. Valid values are MYSQL_NATIVE_PASSWORD, POSTGRES_SCRAM_SHA_256, POSTGRES_MD5, and SQL_SERVER_AUTHENTICATION.
   *
   * @schema ProxySpecForProviderAuth#clientPasswordAuthType
   */
  readonly clientPasswordAuthType?: string;

  /**
   * A user-specified description about the authentication used by a proxy to log in as a specific database user.
   *
   * @schema ProxySpecForProviderAuth#description
   */
  readonly description?: string;

  /**
   * Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. One of DISABLED, REQUIRED.
   *
   * @schema ProxySpecForProviderAuth#iamAuth
   */
  readonly iamAuth?: string;

  /**
   * The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.
   *
   * @schema ProxySpecForProviderAuth#secretArn
   */
  readonly secretArn?: string;

  /**
   * Reference to a Secret in secretsmanager to populate secretArn.
   *
   * @schema ProxySpecForProviderAuth#secretArnRef
   */
  readonly secretArnRef?: ProxySpecForProviderAuthSecretArnRef;

  /**
   * Selector for a Secret in secretsmanager to populate secretArn.
   *
   * @schema ProxySpecForProviderAuth#secretArnSelector
   */
  readonly secretArnSelector?: ProxySpecForProviderAuthSecretArnSelector;

  /**
   * The name of the database user to which the proxy connects.
   *
   * @schema ProxySpecForProviderAuth#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ProxySpecForProviderAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderAuth(obj: ProxySpecForProviderAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authScheme': obj.authScheme,
    'clientPasswordAuthType': obj.clientPasswordAuthType,
    'description': obj.description,
    'iamAuth': obj.iamAuth,
    'secretArn': obj.secretArn,
    'secretArnRef': toJson_ProxySpecForProviderAuthSecretArnRef(obj.secretArnRef),
    'secretArnSelector': toJson_ProxySpecForProviderAuthSecretArnSelector(obj.secretArnSelector),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ProxySpecForProviderRoleArnRef
 */
export interface ProxySpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxySpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxySpecForProviderRoleArnRef#policy
   */
  readonly policy?: ProxySpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ProxySpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderRoleArnRef(obj: ProxySpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxySpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ProxySpecForProviderRoleArnSelector
 */
export interface ProxySpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProxySpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProxySpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProxySpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ProxySpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ProxySpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderRoleArnSelector(obj: ProxySpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProxySpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ProxySpecForProviderVpcSecurityGroupIdRefs
 */
export interface ProxySpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ProxySpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxySpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: ProxySpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ProxySpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderVpcSecurityGroupIdRefs(obj: ProxySpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxySpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
 *
 * @schema ProxySpecForProviderVpcSecurityGroupIdSelector
 */
export interface ProxySpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProxySpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProxySpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProxySpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: ProxySpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ProxySpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderVpcSecurityGroupIdSelector(obj: ProxySpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProxySpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProxySpecInitProviderAuth
 */
export interface ProxySpecInitProviderAuth {
  /**
   * The type of authentication that the proxy uses for connections from the proxy to the underlying database. One of SECRETS.
   *
   * @schema ProxySpecInitProviderAuth#authScheme
   */
  readonly authScheme?: string;

  /**
   * The type of authentication the proxy uses for connections from clients. Valid values are MYSQL_NATIVE_PASSWORD, POSTGRES_SCRAM_SHA_256, POSTGRES_MD5, and SQL_SERVER_AUTHENTICATION.
   *
   * @schema ProxySpecInitProviderAuth#clientPasswordAuthType
   */
  readonly clientPasswordAuthType?: string;

  /**
   * A user-specified description about the authentication used by a proxy to log in as a specific database user.
   *
   * @schema ProxySpecInitProviderAuth#description
   */
  readonly description?: string;

  /**
   * Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. One of DISABLED, REQUIRED.
   *
   * @schema ProxySpecInitProviderAuth#iamAuth
   */
  readonly iamAuth?: string;

  /**
   * The name of the database user to which the proxy connects.
   *
   * @schema ProxySpecInitProviderAuth#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ProxySpecInitProviderAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecInitProviderAuth(obj: ProxySpecInitProviderAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authScheme': obj.authScheme,
    'clientPasswordAuthType': obj.clientPasswordAuthType,
    'description': obj.description,
    'iamAuth': obj.iamAuth,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxySpecProviderConfigRefPolicy
 */
export interface ProxySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProxySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProxySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecProviderConfigRefPolicy(obj: ProxySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProxySpecPublishConnectionDetailsToConfigRef
 */
export interface ProxySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProxySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProxySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecPublishConnectionDetailsToConfigRef(obj: ProxySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProxySpecPublishConnectionDetailsToMetadata
 */
export interface ProxySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProxySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProxySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProxySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProxySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecPublishConnectionDetailsToMetadata(obj: ProxySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretsmanager to populate secretArn.
 *
 * @schema ProxySpecForProviderAuthSecretArnRef
 */
export interface ProxySpecForProviderAuthSecretArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxySpecForProviderAuthSecretArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxySpecForProviderAuthSecretArnRef#policy
   */
  readonly policy?: ProxySpecForProviderAuthSecretArnRefPolicy;

}

/**
 * Converts an object of type 'ProxySpecForProviderAuthSecretArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderAuthSecretArnRef(obj: ProxySpecForProviderAuthSecretArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxySpecForProviderAuthSecretArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretsmanager to populate secretArn.
 *
 * @schema ProxySpecForProviderAuthSecretArnSelector
 */
export interface ProxySpecForProviderAuthSecretArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProxySpecForProviderAuthSecretArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProxySpecForProviderAuthSecretArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProxySpecForProviderAuthSecretArnSelector#policy
   */
  readonly policy?: ProxySpecForProviderAuthSecretArnSelectorPolicy;

}

/**
 * Converts an object of type 'ProxySpecForProviderAuthSecretArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderAuthSecretArnSelector(obj: ProxySpecForProviderAuthSecretArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProxySpecForProviderAuthSecretArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxySpecForProviderRoleArnRefPolicy
 */
export interface ProxySpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxySpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ProxySpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxySpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ProxySpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxySpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderRoleArnRefPolicy(obj: ProxySpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProxySpecForProviderRoleArnSelectorPolicy
 */
export interface ProxySpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxySpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ProxySpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxySpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ProxySpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProxySpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderRoleArnSelectorPolicy(obj: ProxySpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxySpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface ProxySpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxySpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ProxySpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxySpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ProxySpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ProxySpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderVpcSecurityGroupIdRefsPolicy(obj: ProxySpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProxySpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface ProxySpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxySpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ProxySpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxySpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ProxySpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProxySpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: ProxySpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxySpecProviderConfigRefPolicyResolution
 */
export enum ProxySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxySpecProviderConfigRefPolicyResolve
 */
export enum ProxySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProxySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProxySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProxySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProxySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecPublishConnectionDetailsToConfigRefPolicy(obj: ProxySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxySpecForProviderAuthSecretArnRefPolicy
 */
export interface ProxySpecForProviderAuthSecretArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxySpecForProviderAuthSecretArnRefPolicy#resolution
   */
  readonly resolution?: ProxySpecForProviderAuthSecretArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxySpecForProviderAuthSecretArnRefPolicy#resolve
   */
  readonly resolve?: ProxySpecForProviderAuthSecretArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxySpecForProviderAuthSecretArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderAuthSecretArnRefPolicy(obj: ProxySpecForProviderAuthSecretArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProxySpecForProviderAuthSecretArnSelectorPolicy
 */
export interface ProxySpecForProviderAuthSecretArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxySpecForProviderAuthSecretArnSelectorPolicy#resolution
   */
  readonly resolution?: ProxySpecForProviderAuthSecretArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxySpecForProviderAuthSecretArnSelectorPolicy#resolve
   */
  readonly resolve?: ProxySpecForProviderAuthSecretArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProxySpecForProviderAuthSecretArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxySpecForProviderAuthSecretArnSelectorPolicy(obj: ProxySpecForProviderAuthSecretArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxySpecForProviderRoleArnRefPolicyResolution
 */
export enum ProxySpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxySpecForProviderRoleArnRefPolicyResolve
 */
export enum ProxySpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxySpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ProxySpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxySpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ProxySpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxySpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum ProxySpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxySpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum ProxySpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxySpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum ProxySpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxySpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum ProxySpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProxySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProxySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxySpecForProviderAuthSecretArnRefPolicyResolution
 */
export enum ProxySpecForProviderAuthSecretArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxySpecForProviderAuthSecretArnRefPolicyResolve
 */
export enum ProxySpecForProviderAuthSecretArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxySpecForProviderAuthSecretArnSelectorPolicyResolution
 */
export enum ProxySpecForProviderAuthSecretArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxySpecForProviderAuthSecretArnSelectorPolicyResolve
 */
export enum ProxySpecForProviderAuthSecretArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProxyDefaultTargetGroup is the Schema for the ProxyDefaultTargetGroups API. Manage an RDS DB proxy default target group resource.
 *
 * @schema ProxyDefaultTargetGroup
 */
export class ProxyDefaultTargetGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProxyDefaultTargetGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'ProxyDefaultTargetGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ProxyDefaultTargetGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProxyDefaultTargetGroupProps): any {
    return {
      ...ProxyDefaultTargetGroup.GVK,
      ...toJson_ProxyDefaultTargetGroupProps(props),
    };
  }

  /**
   * Defines a "ProxyDefaultTargetGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProxyDefaultTargetGroupProps) {
    super(scope, id, {
      ...ProxyDefaultTargetGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProxyDefaultTargetGroup.GVK,
      ...toJson_ProxyDefaultTargetGroupProps(resolved),
    };
  }
}

/**
 * ProxyDefaultTargetGroup is the Schema for the ProxyDefaultTargetGroups API. Manage an RDS DB proxy default target group resource.
 *
 * @schema ProxyDefaultTargetGroup
 */
export interface ProxyDefaultTargetGroupProps {
  /**
   * @schema ProxyDefaultTargetGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProxyDefaultTargetGroupSpec defines the desired state of ProxyDefaultTargetGroup
   *
   * @schema ProxyDefaultTargetGroup#spec
   */
  readonly spec: ProxyDefaultTargetGroupSpec;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupProps(obj: ProxyDefaultTargetGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProxyDefaultTargetGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyDefaultTargetGroupSpec defines the desired state of ProxyDefaultTargetGroup
 *
 * @schema ProxyDefaultTargetGroupSpec
 */
export interface ProxyDefaultTargetGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProxyDefaultTargetGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProxyDefaultTargetGroupSpecDeletionPolicy;

  /**
   * @schema ProxyDefaultTargetGroupSpec#forProvider
   */
  readonly forProvider: ProxyDefaultTargetGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProxyDefaultTargetGroupSpec#initProvider
   */
  readonly initProvider?: ProxyDefaultTargetGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProxyDefaultTargetGroupSpec#managementPolicies
   */
  readonly managementPolicies?: ProxyDefaultTargetGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProxyDefaultTargetGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProxyDefaultTargetGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProxyDefaultTargetGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProxyDefaultTargetGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProxyDefaultTargetGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProxyDefaultTargetGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpec(obj: ProxyDefaultTargetGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProxyDefaultTargetGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProxyDefaultTargetGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProxyDefaultTargetGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProxyDefaultTargetGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProxyDefaultTargetGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProxyDefaultTargetGroupSpecDeletionPolicy
 */
export enum ProxyDefaultTargetGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProxyDefaultTargetGroupSpecForProvider
 */
export interface ProxyDefaultTargetGroupSpecForProvider {
  /**
   * The settings that determine the size and behavior of the connection pool for the target group.
   *
   * @schema ProxyDefaultTargetGroupSpecForProvider#connectionPoolConfig
   */
  readonly connectionPoolConfig?: ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig[];

  /**
   * Name of the RDS DB Proxy.
   *
   * @schema ProxyDefaultTargetGroupSpecForProvider#dbProxyName
   */
  readonly dbProxyName?: string;

  /**
   * Reference to a Proxy in rds to populate dbProxyName.
   *
   * @schema ProxyDefaultTargetGroupSpecForProvider#dbProxyNameRef
   */
  readonly dbProxyNameRef?: ProxyDefaultTargetGroupSpecForProviderDbProxyNameRef;

  /**
   * Selector for a Proxy in rds to populate dbProxyName.
   *
   * @schema ProxyDefaultTargetGroupSpecForProvider#dbProxyNameSelector
   */
  readonly dbProxyNameSelector?: ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProxyDefaultTargetGroupSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecForProvider(obj: ProxyDefaultTargetGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPoolConfig': obj.connectionPoolConfig?.map(y => toJson_ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig(y)),
    'dbProxyName': obj.dbProxyName,
    'dbProxyNameRef': toJson_ProxyDefaultTargetGroupSpecForProviderDbProxyNameRef(obj.dbProxyNameRef),
    'dbProxyNameSelector': toJson_ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelector(obj.dbProxyNameSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProxyDefaultTargetGroupSpecInitProvider
 */
export interface ProxyDefaultTargetGroupSpecInitProvider {
  /**
   * The settings that determine the size and behavior of the connection pool for the target group.
   *
   * @schema ProxyDefaultTargetGroupSpecInitProvider#connectionPoolConfig
   */
  readonly connectionPoolConfig?: ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig[];

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecInitProvider(obj: ProxyDefaultTargetGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPoolConfig': obj.connectionPoolConfig?.map(y => toJson_ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProxyDefaultTargetGroupSpecManagementPolicies
 */
export enum ProxyDefaultTargetGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProxyDefaultTargetGroupSpecProviderConfigRef
 */
export interface ProxyDefaultTargetGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyDefaultTargetGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyDefaultTargetGroupSpecProviderConfigRef#policy
   */
  readonly policy?: ProxyDefaultTargetGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecProviderConfigRef(obj: ProxyDefaultTargetGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyDefaultTargetGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsTo
 */
export interface ProxyDefaultTargetGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProxyDefaultTargetGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecPublishConnectionDetailsTo(obj: ProxyDefaultTargetGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProxyDefaultTargetGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProxyDefaultTargetGroupSpecWriteConnectionSecretToRef
 */
export interface ProxyDefaultTargetGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProxyDefaultTargetGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProxyDefaultTargetGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecWriteConnectionSecretToRef(obj: ProxyDefaultTargetGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig
 */
export interface ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig {
  /**
   * The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig#connectionBorrowTimeout
   */
  readonly connectionBorrowTimeout?: number;

  /**
   * One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. This setting is empty by default. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig#initQuery
   */
  readonly initQuery?: string;

  /**
   * The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig#maxConnectionsPercent
   */
  readonly maxConnectionsPercent?: number;

  /**
   * Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig#maxIdleConnectionsPercent
   */
  readonly maxIdleConnectionsPercent?: number;

  /**
   * Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Currently, the only allowed value is EXCLUDE_VARIABLE_SETS.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig#sessionPinningFilters
   */
  readonly sessionPinningFilters?: string[];

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig(obj: ProxyDefaultTargetGroupSpecForProviderConnectionPoolConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionBorrowTimeout': obj.connectionBorrowTimeout,
    'initQuery': obj.initQuery,
    'maxConnectionsPercent': obj.maxConnectionsPercent,
    'maxIdleConnectionsPercent': obj.maxIdleConnectionsPercent,
    'sessionPinningFilters': obj.sessionPinningFilters?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Proxy in rds to populate dbProxyName.
 *
 * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameRef
 */
export interface ProxyDefaultTargetGroupSpecForProviderDbProxyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameRef#policy
   */
  readonly policy?: ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicy;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecForProviderDbProxyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecForProviderDbProxyNameRef(obj: ProxyDefaultTargetGroupSpecForProviderDbProxyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Proxy in rds to populate dbProxyName.
 *
 * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelector
 */
export interface ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelector#policy
   */
  readonly policy?: ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicy;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelector(obj: ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig
 */
export interface ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig {
  /**
   * The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the proxy has opened its maximum number of connections and all connections are busy with client sessions.
   *
   * @schema ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig#connectionBorrowTimeout
   */
  readonly connectionBorrowTimeout?: number;

  /**
   * One or more SQL statements for the proxy to run when opening each new database connection. Typically used with SET statements to make sure that each connection has identical settings such as time zone and character set. This setting is empty by default. For multiple statements, use semicolons as the separator. You can also include multiple variables in a single SET statement, such as SET x=1, y=2.
   *
   * @schema ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig#initQuery
   */
  readonly initQuery?: string;

  /**
   * The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group.
   *
   * @schema ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig#maxConnectionsPercent
   */
  readonly maxConnectionsPercent?: number;

  /**
   * Controls how actively the proxy closes idle database connections in the connection pool. A high value enables the proxy to leave a high percentage of idle connections open. A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group.
   *
   * @schema ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig#maxIdleConnectionsPercent
   */
  readonly maxIdleConnectionsPercent?: number;

  /**
   * Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection. Including an item in the list exempts that class of SQL operations from the pinning behavior. Currently, the only allowed value is EXCLUDE_VARIABLE_SETS.
   *
   * @schema ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig#sessionPinningFilters
   */
  readonly sessionPinningFilters?: string[];

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig(obj: ProxyDefaultTargetGroupSpecInitProviderConnectionPoolConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionBorrowTimeout': obj.connectionBorrowTimeout,
    'initQuery': obj.initQuery,
    'maxConnectionsPercent': obj.maxConnectionsPercent,
    'maxIdleConnectionsPercent': obj.maxIdleConnectionsPercent,
    'sessionPinningFilters': obj.sessionPinningFilters?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxyDefaultTargetGroupSpecProviderConfigRefPolicy
 */
export interface ProxyDefaultTargetGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyDefaultTargetGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProxyDefaultTargetGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyDefaultTargetGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProxyDefaultTargetGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecProviderConfigRefPolicy(obj: ProxyDefaultTargetGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRef(obj: ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToMetadata
 */
export interface ProxyDefaultTargetGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecPublishConnectionDetailsToMetadata(obj: ProxyDefaultTargetGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicy
 */
export interface ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicy#resolution
   */
  readonly resolution?: ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicy#resolve
   */
  readonly resolve?: ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicy(obj: ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicy
 */
export interface ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicy#resolution
   */
  readonly resolution?: ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicy#resolve
   */
  readonly resolve?: ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicy(obj: ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyDefaultTargetGroupSpecProviderConfigRefPolicyResolution
 */
export enum ProxyDefaultTargetGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyDefaultTargetGroupSpecProviderConfigRefPolicyResolve
 */
export enum ProxyDefaultTargetGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicyResolution
 */
export enum ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicyResolve
 */
export enum ProxyDefaultTargetGroupSpecForProviderDbProxyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicyResolution
 */
export enum ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicyResolve
 */
export enum ProxyDefaultTargetGroupSpecForProviderDbProxyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProxyDefaultTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProxyEndpoint is the Schema for the ProxyEndpoints API. Provides an RDS DB proxy endpoint resource.
 *
 * @schema ProxyEndpoint
 */
export class ProxyEndpoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProxyEndpoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'ProxyEndpoint',
  }

  /**
   * Renders a Kubernetes manifest for "ProxyEndpoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProxyEndpointProps): any {
    return {
      ...ProxyEndpoint.GVK,
      ...toJson_ProxyEndpointProps(props),
    };
  }

  /**
   * Defines a "ProxyEndpoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProxyEndpointProps) {
    super(scope, id, {
      ...ProxyEndpoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProxyEndpoint.GVK,
      ...toJson_ProxyEndpointProps(resolved),
    };
  }
}

/**
 * ProxyEndpoint is the Schema for the ProxyEndpoints API. Provides an RDS DB proxy endpoint resource.
 *
 * @schema ProxyEndpoint
 */
export interface ProxyEndpointProps {
  /**
   * @schema ProxyEndpoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProxyEndpointSpec defines the desired state of ProxyEndpoint
   *
   * @schema ProxyEndpoint#spec
   */
  readonly spec: ProxyEndpointSpec;

}

/**
 * Converts an object of type 'ProxyEndpointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointProps(obj: ProxyEndpointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProxyEndpointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyEndpointSpec defines the desired state of ProxyEndpoint
 *
 * @schema ProxyEndpointSpec
 */
export interface ProxyEndpointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProxyEndpointSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProxyEndpointSpecDeletionPolicy;

  /**
   * @schema ProxyEndpointSpec#forProvider
   */
  readonly forProvider: ProxyEndpointSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProxyEndpointSpec#initProvider
   */
  readonly initProvider?: ProxyEndpointSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProxyEndpointSpec#managementPolicies
   */
  readonly managementPolicies?: ProxyEndpointSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProxyEndpointSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProxyEndpointSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProxyEndpointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProxyEndpointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProxyEndpointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProxyEndpointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProxyEndpointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpec(obj: ProxyEndpointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProxyEndpointSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProxyEndpointSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProxyEndpointSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProxyEndpointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProxyEndpointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProxyEndpointSpecDeletionPolicy
 */
export enum ProxyEndpointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProxyEndpointSpecForProvider
 */
export interface ProxyEndpointSpecForProvider {
  /**
   * The name of the DB proxy associated with the DB proxy endpoint that you create.
   *
   * @schema ProxyEndpointSpecForProvider#dbProxyName
   */
  readonly dbProxyName?: string;

  /**
   * Reference to a Proxy in rds to populate dbProxyName.
   *
   * @schema ProxyEndpointSpecForProvider#dbProxyNameRef
   */
  readonly dbProxyNameRef?: ProxyEndpointSpecForProviderDbProxyNameRef;

  /**
   * Selector for a Proxy in rds to populate dbProxyName.
   *
   * @schema ProxyEndpointSpecForProvider#dbProxyNameSelector
   */
  readonly dbProxyNameSelector?: ProxyEndpointSpecForProviderDbProxyNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProxyEndpointSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ProxyEndpointSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Indicates whether the DB proxy endpoint can be used for read/write or read-only operations. The default is READ_WRITE. Valid values are READ_WRITE and READ_ONLY.
   *
   * @schema ProxyEndpointSpecForProvider#targetRole
   */
  readonly targetRole?: string;

  /**
   * References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ProxyEndpointSpecForProvider#vpcSecurityGroupIdRefs
   */
  readonly vpcSecurityGroupIdRefs?: ProxyEndpointSpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ProxyEndpointSpecForProvider#vpcSecurityGroupIdSelector
   */
  readonly vpcSecurityGroupIdSelector?: ProxyEndpointSpecForProviderVpcSecurityGroupIdSelector;

  /**
   * One or more VPC security group IDs to associate with the new proxy.
   *
   * @schema ProxyEndpointSpecForProvider#vpcSecurityGroupIds
   */
  readonly vpcSecurityGroupIds?: string[];

  /**
   * One or more VPC subnet IDs to associate with the new proxy.
   *
   * @schema ProxyEndpointSpecForProvider#vpcSubnetIds
   */
  readonly vpcSubnetIds?: string[];

}

/**
 * Converts an object of type 'ProxyEndpointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecForProvider(obj: ProxyEndpointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbProxyName': obj.dbProxyName,
    'dbProxyNameRef': toJson_ProxyEndpointSpecForProviderDbProxyNameRef(obj.dbProxyNameRef),
    'dbProxyNameSelector': toJson_ProxyEndpointSpecForProviderDbProxyNameSelector(obj.dbProxyNameSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetRole': obj.targetRole,
    'vpcSecurityGroupIdRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_ProxyEndpointSpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIdSelector': toJson_ProxyEndpointSpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIds': obj.vpcSecurityGroupIds?.map(y => y),
    'vpcSubnetIds': obj.vpcSubnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProxyEndpointSpecInitProvider
 */
export interface ProxyEndpointSpecInitProvider {
  /**
   * Key-value map of resource tags.
   *
   * @schema ProxyEndpointSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Indicates whether the DB proxy endpoint can be used for read/write or read-only operations. The default is READ_WRITE. Valid values are READ_WRITE and READ_ONLY.
   *
   * @schema ProxyEndpointSpecInitProvider#targetRole
   */
  readonly targetRole?: string;

  /**
   * One or more VPC subnet IDs to associate with the new proxy.
   *
   * @schema ProxyEndpointSpecInitProvider#vpcSubnetIds
   */
  readonly vpcSubnetIds?: string[];

}

/**
 * Converts an object of type 'ProxyEndpointSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecInitProvider(obj: ProxyEndpointSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetRole': obj.targetRole,
    'vpcSubnetIds': obj.vpcSubnetIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProxyEndpointSpecManagementPolicies
 */
export enum ProxyEndpointSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProxyEndpointSpecProviderConfigRef
 */
export interface ProxyEndpointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyEndpointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyEndpointSpecProviderConfigRef#policy
   */
  readonly policy?: ProxyEndpointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProxyEndpointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecProviderConfigRef(obj: ProxyEndpointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyEndpointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProxyEndpointSpecPublishConnectionDetailsTo
 */
export interface ProxyEndpointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProxyEndpointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProxyEndpointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProxyEndpointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProxyEndpointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProxyEndpointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProxyEndpointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecPublishConnectionDetailsTo(obj: ProxyEndpointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProxyEndpointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProxyEndpointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProxyEndpointSpecWriteConnectionSecretToRef
 */
export interface ProxyEndpointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProxyEndpointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProxyEndpointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProxyEndpointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecWriteConnectionSecretToRef(obj: ProxyEndpointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Proxy in rds to populate dbProxyName.
 *
 * @schema ProxyEndpointSpecForProviderDbProxyNameRef
 */
export interface ProxyEndpointSpecForProviderDbProxyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyEndpointSpecForProviderDbProxyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyEndpointSpecForProviderDbProxyNameRef#policy
   */
  readonly policy?: ProxyEndpointSpecForProviderDbProxyNameRefPolicy;

}

/**
 * Converts an object of type 'ProxyEndpointSpecForProviderDbProxyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecForProviderDbProxyNameRef(obj: ProxyEndpointSpecForProviderDbProxyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyEndpointSpecForProviderDbProxyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Proxy in rds to populate dbProxyName.
 *
 * @schema ProxyEndpointSpecForProviderDbProxyNameSelector
 */
export interface ProxyEndpointSpecForProviderDbProxyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProxyEndpointSpecForProviderDbProxyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProxyEndpointSpecForProviderDbProxyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProxyEndpointSpecForProviderDbProxyNameSelector#policy
   */
  readonly policy?: ProxyEndpointSpecForProviderDbProxyNameSelectorPolicy;

}

/**
 * Converts an object of type 'ProxyEndpointSpecForProviderDbProxyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecForProviderDbProxyNameSelector(obj: ProxyEndpointSpecForProviderDbProxyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProxyEndpointSpecForProviderDbProxyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdRefs
 */
export interface ProxyEndpointSpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ProxyEndpointSpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecForProviderVpcSecurityGroupIdRefs(obj: ProxyEndpointSpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
 *
 * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdSelector
 */
export interface ProxyEndpointSpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ProxyEndpointSpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecForProviderVpcSecurityGroupIdSelector(obj: ProxyEndpointSpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxyEndpointSpecProviderConfigRefPolicy
 */
export interface ProxyEndpointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyEndpointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProxyEndpointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyEndpointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProxyEndpointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyEndpointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecProviderConfigRefPolicy(obj: ProxyEndpointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProxyEndpointSpecPublishConnectionDetailsToConfigRef
 */
export interface ProxyEndpointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyEndpointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyEndpointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProxyEndpointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecPublishConnectionDetailsToConfigRef(obj: ProxyEndpointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProxyEndpointSpecPublishConnectionDetailsToMetadata
 */
export interface ProxyEndpointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProxyEndpointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProxyEndpointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProxyEndpointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProxyEndpointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecPublishConnectionDetailsToMetadata(obj: ProxyEndpointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxyEndpointSpecForProviderDbProxyNameRefPolicy
 */
export interface ProxyEndpointSpecForProviderDbProxyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyEndpointSpecForProviderDbProxyNameRefPolicy#resolution
   */
  readonly resolution?: ProxyEndpointSpecForProviderDbProxyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyEndpointSpecForProviderDbProxyNameRefPolicy#resolve
   */
  readonly resolve?: ProxyEndpointSpecForProviderDbProxyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyEndpointSpecForProviderDbProxyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecForProviderDbProxyNameRefPolicy(obj: ProxyEndpointSpecForProviderDbProxyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProxyEndpointSpecForProviderDbProxyNameSelectorPolicy
 */
export interface ProxyEndpointSpecForProviderDbProxyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyEndpointSpecForProviderDbProxyNameSelectorPolicy#resolution
   */
  readonly resolution?: ProxyEndpointSpecForProviderDbProxyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyEndpointSpecForProviderDbProxyNameSelectorPolicy#resolve
   */
  readonly resolve?: ProxyEndpointSpecForProviderDbProxyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProxyEndpointSpecForProviderDbProxyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecForProviderDbProxyNameSelectorPolicy(obj: ProxyEndpointSpecForProviderDbProxyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicy(obj: ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyEndpointSpecProviderConfigRefPolicyResolution
 */
export enum ProxyEndpointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyEndpointSpecProviderConfigRefPolicyResolve
 */
export enum ProxyEndpointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyEndpointSpecForProviderDbProxyNameRefPolicyResolution
 */
export enum ProxyEndpointSpecForProviderDbProxyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyEndpointSpecForProviderDbProxyNameRefPolicyResolve
 */
export enum ProxyEndpointSpecForProviderDbProxyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyEndpointSpecForProviderDbProxyNameSelectorPolicyResolution
 */
export enum ProxyEndpointSpecForProviderDbProxyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyEndpointSpecForProviderDbProxyNameSelectorPolicyResolve
 */
export enum ProxyEndpointSpecForProviderDbProxyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum ProxyEndpointSpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum ProxyEndpointSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProxyEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProxyTarget is the Schema for the ProxyTargets API. Provides an RDS DB proxy target resource.
 *
 * @schema ProxyTarget
 */
export class ProxyTarget extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProxyTarget"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'ProxyTarget',
  }

  /**
   * Renders a Kubernetes manifest for "ProxyTarget".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProxyTargetProps): any {
    return {
      ...ProxyTarget.GVK,
      ...toJson_ProxyTargetProps(props),
    };
  }

  /**
   * Defines a "ProxyTarget" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProxyTargetProps) {
    super(scope, id, {
      ...ProxyTarget.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProxyTarget.GVK,
      ...toJson_ProxyTargetProps(resolved),
    };
  }
}

/**
 * ProxyTarget is the Schema for the ProxyTargets API. Provides an RDS DB proxy target resource.
 *
 * @schema ProxyTarget
 */
export interface ProxyTargetProps {
  /**
   * @schema ProxyTarget#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProxyTargetSpec defines the desired state of ProxyTarget
   *
   * @schema ProxyTarget#spec
   */
  readonly spec: ProxyTargetSpec;

}

/**
 * Converts an object of type 'ProxyTargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetProps(obj: ProxyTargetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProxyTargetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyTargetSpec defines the desired state of ProxyTarget
 *
 * @schema ProxyTargetSpec
 */
export interface ProxyTargetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProxyTargetSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProxyTargetSpecDeletionPolicy;

  /**
   * @schema ProxyTargetSpec#forProvider
   */
  readonly forProvider: ProxyTargetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProxyTargetSpec#initProvider
   */
  readonly initProvider?: ProxyTargetSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProxyTargetSpec#managementPolicies
   */
  readonly managementPolicies?: ProxyTargetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProxyTargetSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProxyTargetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProxyTargetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProxyTargetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProxyTargetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProxyTargetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProxyTargetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpec(obj: ProxyTargetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProxyTargetSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProxyTargetSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProxyTargetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProxyTargetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProxyTargetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProxyTargetSpecDeletionPolicy
 */
export enum ProxyTargetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProxyTargetSpecForProvider
 */
export interface ProxyTargetSpecForProvider {
  /**
   * DB cluster identifier.
   *
   * @schema ProxyTargetSpecForProvider#dbClusterIdentifier
   */
  readonly dbClusterIdentifier?: string;

  /**
   * DB instance identifier.
   *
   * @schema ProxyTargetSpecForProvider#dbInstanceIdentifier
   */
  readonly dbInstanceIdentifier?: string;

  /**
   * Reference to a Instance in rds to populate dbInstanceIdentifier.
   *
   * @schema ProxyTargetSpecForProvider#dbInstanceIdentifierRef
   */
  readonly dbInstanceIdentifierRef?: ProxyTargetSpecForProviderDbInstanceIdentifierRef;

  /**
   * Selector for a Instance in rds to populate dbInstanceIdentifier.
   *
   * @schema ProxyTargetSpecForProvider#dbInstanceIdentifierSelector
   */
  readonly dbInstanceIdentifierSelector?: ProxyTargetSpecForProviderDbInstanceIdentifierSelector;

  /**
   * The name of the DB proxy.
   *
   * @schema ProxyTargetSpecForProvider#dbProxyName
   */
  readonly dbProxyName?: string;

  /**
   * Reference to a Proxy in rds to populate dbProxyName.
   *
   * @schema ProxyTargetSpecForProvider#dbProxyNameRef
   */
  readonly dbProxyNameRef?: ProxyTargetSpecForProviderDbProxyNameRef;

  /**
   * Selector for a Proxy in rds to populate dbProxyName.
   *
   * @schema ProxyTargetSpecForProvider#dbProxyNameSelector
   */
  readonly dbProxyNameSelector?: ProxyTargetSpecForProviderDbProxyNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProxyTargetSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the target group.
   *
   * @schema ProxyTargetSpecForProvider#targetGroupName
   */
  readonly targetGroupName?: string;

}

/**
 * Converts an object of type 'ProxyTargetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecForProvider(obj: ProxyTargetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbClusterIdentifier': obj.dbClusterIdentifier,
    'dbInstanceIdentifier': obj.dbInstanceIdentifier,
    'dbInstanceIdentifierRef': toJson_ProxyTargetSpecForProviderDbInstanceIdentifierRef(obj.dbInstanceIdentifierRef),
    'dbInstanceIdentifierSelector': toJson_ProxyTargetSpecForProviderDbInstanceIdentifierSelector(obj.dbInstanceIdentifierSelector),
    'dbProxyName': obj.dbProxyName,
    'dbProxyNameRef': toJson_ProxyTargetSpecForProviderDbProxyNameRef(obj.dbProxyNameRef),
    'dbProxyNameSelector': toJson_ProxyTargetSpecForProviderDbProxyNameSelector(obj.dbProxyNameSelector),
    'region': obj.region,
    'targetGroupName': obj.targetGroupName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProxyTargetSpecInitProvider
 */
export interface ProxyTargetSpecInitProvider {
  /**
   * DB cluster identifier.
   *
   * @schema ProxyTargetSpecInitProvider#dbClusterIdentifier
   */
  readonly dbClusterIdentifier?: string;

  /**
   * The name of the target group.
   *
   * @schema ProxyTargetSpecInitProvider#targetGroupName
   */
  readonly targetGroupName?: string;

}

/**
 * Converts an object of type 'ProxyTargetSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecInitProvider(obj: ProxyTargetSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbClusterIdentifier': obj.dbClusterIdentifier,
    'targetGroupName': obj.targetGroupName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProxyTargetSpecManagementPolicies
 */
export enum ProxyTargetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProxyTargetSpecProviderConfigRef
 */
export interface ProxyTargetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyTargetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyTargetSpecProviderConfigRef#policy
   */
  readonly policy?: ProxyTargetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProxyTargetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecProviderConfigRef(obj: ProxyTargetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyTargetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProxyTargetSpecPublishConnectionDetailsTo
 */
export interface ProxyTargetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProxyTargetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProxyTargetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProxyTargetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProxyTargetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProxyTargetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProxyTargetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecPublishConnectionDetailsTo(obj: ProxyTargetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProxyTargetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProxyTargetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProxyTargetSpecWriteConnectionSecretToRef
 */
export interface ProxyTargetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProxyTargetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProxyTargetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProxyTargetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecWriteConnectionSecretToRef(obj: ProxyTargetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in rds to populate dbInstanceIdentifier.
 *
 * @schema ProxyTargetSpecForProviderDbInstanceIdentifierRef
 */
export interface ProxyTargetSpecForProviderDbInstanceIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyTargetSpecForProviderDbInstanceIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyTargetSpecForProviderDbInstanceIdentifierRef#policy
   */
  readonly policy?: ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ProxyTargetSpecForProviderDbInstanceIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecForProviderDbInstanceIdentifierRef(obj: ProxyTargetSpecForProviderDbInstanceIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in rds to populate dbInstanceIdentifier.
 *
 * @schema ProxyTargetSpecForProviderDbInstanceIdentifierSelector
 */
export interface ProxyTargetSpecForProviderDbInstanceIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProxyTargetSpecForProviderDbInstanceIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProxyTargetSpecForProviderDbInstanceIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProxyTargetSpecForProviderDbInstanceIdentifierSelector#policy
   */
  readonly policy?: ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ProxyTargetSpecForProviderDbInstanceIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecForProviderDbInstanceIdentifierSelector(obj: ProxyTargetSpecForProviderDbInstanceIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Proxy in rds to populate dbProxyName.
 *
 * @schema ProxyTargetSpecForProviderDbProxyNameRef
 */
export interface ProxyTargetSpecForProviderDbProxyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyTargetSpecForProviderDbProxyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyTargetSpecForProviderDbProxyNameRef#policy
   */
  readonly policy?: ProxyTargetSpecForProviderDbProxyNameRefPolicy;

}

/**
 * Converts an object of type 'ProxyTargetSpecForProviderDbProxyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecForProviderDbProxyNameRef(obj: ProxyTargetSpecForProviderDbProxyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyTargetSpecForProviderDbProxyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Proxy in rds to populate dbProxyName.
 *
 * @schema ProxyTargetSpecForProviderDbProxyNameSelector
 */
export interface ProxyTargetSpecForProviderDbProxyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProxyTargetSpecForProviderDbProxyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProxyTargetSpecForProviderDbProxyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProxyTargetSpecForProviderDbProxyNameSelector#policy
   */
  readonly policy?: ProxyTargetSpecForProviderDbProxyNameSelectorPolicy;

}

/**
 * Converts an object of type 'ProxyTargetSpecForProviderDbProxyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecForProviderDbProxyNameSelector(obj: ProxyTargetSpecForProviderDbProxyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProxyTargetSpecForProviderDbProxyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxyTargetSpecProviderConfigRefPolicy
 */
export interface ProxyTargetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyTargetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProxyTargetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyTargetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProxyTargetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyTargetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecProviderConfigRefPolicy(obj: ProxyTargetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProxyTargetSpecPublishConnectionDetailsToConfigRef
 */
export interface ProxyTargetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProxyTargetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProxyTargetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProxyTargetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecPublishConnectionDetailsToConfigRef(obj: ProxyTargetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProxyTargetSpecPublishConnectionDetailsToMetadata
 */
export interface ProxyTargetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProxyTargetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProxyTargetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProxyTargetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProxyTargetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecPublishConnectionDetailsToMetadata(obj: ProxyTargetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicy
 */
export interface ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicy#resolution
   */
  readonly resolution?: ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicy#resolve
   */
  readonly resolve?: ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicy(obj: ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicy
 */
export interface ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicy(obj: ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProxyTargetSpecForProviderDbProxyNameRefPolicy
 */
export interface ProxyTargetSpecForProviderDbProxyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyTargetSpecForProviderDbProxyNameRefPolicy#resolution
   */
  readonly resolution?: ProxyTargetSpecForProviderDbProxyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyTargetSpecForProviderDbProxyNameRefPolicy#resolve
   */
  readonly resolve?: ProxyTargetSpecForProviderDbProxyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyTargetSpecForProviderDbProxyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecForProviderDbProxyNameRefPolicy(obj: ProxyTargetSpecForProviderDbProxyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProxyTargetSpecForProviderDbProxyNameSelectorPolicy
 */
export interface ProxyTargetSpecForProviderDbProxyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyTargetSpecForProviderDbProxyNameSelectorPolicy#resolution
   */
  readonly resolution?: ProxyTargetSpecForProviderDbProxyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyTargetSpecForProviderDbProxyNameSelectorPolicy#resolve
   */
  readonly resolve?: ProxyTargetSpecForProviderDbProxyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProxyTargetSpecForProviderDbProxyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecForProviderDbProxyNameSelectorPolicy(obj: ProxyTargetSpecForProviderDbProxyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyTargetSpecProviderConfigRefPolicyResolution
 */
export enum ProxyTargetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyTargetSpecProviderConfigRefPolicyResolve
 */
export enum ProxyTargetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicyResolution
 */
export enum ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicyResolve
 */
export enum ProxyTargetSpecForProviderDbInstanceIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicyResolution
 */
export enum ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicyResolve
 */
export enum ProxyTargetSpecForProviderDbInstanceIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyTargetSpecForProviderDbProxyNameRefPolicyResolution
 */
export enum ProxyTargetSpecForProviderDbProxyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyTargetSpecForProviderDbProxyNameRefPolicyResolve
 */
export enum ProxyTargetSpecForProviderDbProxyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyTargetSpecForProviderDbProxyNameSelectorPolicyResolution
 */
export enum ProxyTargetSpecForProviderDbProxyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyTargetSpecForProviderDbProxyNameSelectorPolicyResolve
 */
export enum ProxyTargetSpecForProviderDbProxyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProxyTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Snapshot is the Schema for the Snapshots API. Manages an RDS database instance snapshot.
 *
 * @schema Snapshot
 */
export class Snapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Snapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'Snapshot',
  }

  /**
   * Renders a Kubernetes manifest for "Snapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SnapshotProps): any {
    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(props),
    };
  }

  /**
   * Defines a "Snapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SnapshotProps) {
    super(scope, id, {
      ...Snapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(resolved),
    };
  }
}

/**
 * Snapshot is the Schema for the Snapshots API. Manages an RDS database instance snapshot.
 *
 * @schema Snapshot
 */
export interface SnapshotProps {
  /**
   * @schema Snapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SnapshotSpec defines the desired state of Snapshot
   *
   * @schema Snapshot#spec
   */
  readonly spec: SnapshotSpec;

}

/**
 * Converts an object of type 'SnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotProps(obj: SnapshotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SnapshotSpec defines the desired state of Snapshot
 *
 * @schema SnapshotSpec
 */
export interface SnapshotSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SnapshotSpec#deletionPolicy
   */
  readonly deletionPolicy?: SnapshotSpecDeletionPolicy;

  /**
   * @schema SnapshotSpec#forProvider
   */
  readonly forProvider: SnapshotSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SnapshotSpec#initProvider
   */
  readonly initProvider?: SnapshotSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SnapshotSpec#managementPolicies
   */
  readonly managementPolicies?: SnapshotSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SnapshotSpec#providerConfigRef
   */
  readonly providerConfigRef?: SnapshotSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SnapshotSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SnapshotSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SnapshotSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SnapshotSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpec(obj: SnapshotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SnapshotSpecForProvider(obj.forProvider),
    'initProvider': toJson_SnapshotSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SnapshotSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SnapshotSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SnapshotSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SnapshotSpecDeletionPolicy
 */
export enum SnapshotSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SnapshotSpecForProvider
 */
export interface SnapshotSpecForProvider {
  /**
   * The DB Instance Identifier from which to take the snapshot.
   *
   * @schema SnapshotSpecForProvider#dbInstanceIdentifier
   */
  readonly dbInstanceIdentifier?: string;

  /**
   * Reference to a Instance in rds to populate dbInstanceIdentifier.
   *
   * @schema SnapshotSpecForProvider#dbInstanceIdentifierRef
   */
  readonly dbInstanceIdentifierRef?: SnapshotSpecForProviderDbInstanceIdentifierRef;

  /**
   * Selector for a Instance in rds to populate dbInstanceIdentifier.
   *
   * @schema SnapshotSpecForProvider#dbInstanceIdentifierSelector
   */
  readonly dbInstanceIdentifierSelector?: SnapshotSpecForProviderDbInstanceIdentifierSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SnapshotSpecForProvider#region
   */
  readonly region: string;

  /**
   * List of AWS Account ids to share snapshot with, use all to make snaphot public.
   *
   * @schema SnapshotSpecForProvider#sharedAccounts
   */
  readonly sharedAccounts?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema SnapshotSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SnapshotSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProvider(obj: SnapshotSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbInstanceIdentifier': obj.dbInstanceIdentifier,
    'dbInstanceIdentifierRef': toJson_SnapshotSpecForProviderDbInstanceIdentifierRef(obj.dbInstanceIdentifierRef),
    'dbInstanceIdentifierSelector': toJson_SnapshotSpecForProviderDbInstanceIdentifierSelector(obj.dbInstanceIdentifierSelector),
    'region': obj.region,
    'sharedAccounts': obj.sharedAccounts?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SnapshotSpecInitProvider
 */
export interface SnapshotSpecInitProvider {
  /**
   * List of AWS Account ids to share snapshot with, use all to make snaphot public.
   *
   * @schema SnapshotSpecInitProvider#sharedAccounts
   */
  readonly sharedAccounts?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema SnapshotSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SnapshotSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecInitProvider(obj: SnapshotSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sharedAccounts': obj.sharedAccounts?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SnapshotSpecManagementPolicies
 */
export enum SnapshotSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SnapshotSpecProviderConfigRef
 */
export interface SnapshotSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotSpecProviderConfigRef#policy
   */
  readonly policy?: SnapshotSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecProviderConfigRef(obj: SnapshotSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SnapshotSpecPublishConnectionDetailsTo
 */
export interface SnapshotSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SnapshotSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SnapshotSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SnapshotSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SnapshotSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SnapshotSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsTo(obj: SnapshotSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SnapshotSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SnapshotSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SnapshotSpecWriteConnectionSecretToRef
 */
export interface SnapshotSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SnapshotSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SnapshotSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SnapshotSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecWriteConnectionSecretToRef(obj: SnapshotSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance in rds to populate dbInstanceIdentifier.
 *
 * @schema SnapshotSpecForProviderDbInstanceIdentifierRef
 */
export interface SnapshotSpecForProviderDbInstanceIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotSpecForProviderDbInstanceIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotSpecForProviderDbInstanceIdentifierRef#policy
   */
  readonly policy?: SnapshotSpecForProviderDbInstanceIdentifierRefPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderDbInstanceIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderDbInstanceIdentifierRef(obj: SnapshotSpecForProviderDbInstanceIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotSpecForProviderDbInstanceIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance in rds to populate dbInstanceIdentifier.
 *
 * @schema SnapshotSpecForProviderDbInstanceIdentifierSelector
 */
export interface SnapshotSpecForProviderDbInstanceIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SnapshotSpecForProviderDbInstanceIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SnapshotSpecForProviderDbInstanceIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SnapshotSpecForProviderDbInstanceIdentifierSelector#policy
   */
  readonly policy?: SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderDbInstanceIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderDbInstanceIdentifierSelector(obj: SnapshotSpecForProviderDbInstanceIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotSpecProviderConfigRefPolicy
 */
export interface SnapshotSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecProviderConfigRefPolicy(obj: SnapshotSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRef
 */
export interface SnapshotSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SnapshotSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsToConfigRef(obj: SnapshotSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToMetadata
 */
export interface SnapshotSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsToMetadata(obj: SnapshotSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotSpecForProviderDbInstanceIdentifierRefPolicy
 */
export interface SnapshotSpecForProviderDbInstanceIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecForProviderDbInstanceIdentifierRefPolicy#resolution
   */
  readonly resolution?: SnapshotSpecForProviderDbInstanceIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecForProviderDbInstanceIdentifierRefPolicy#resolve
   */
  readonly resolve?: SnapshotSpecForProviderDbInstanceIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderDbInstanceIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderDbInstanceIdentifierRefPolicy(obj: SnapshotSpecForProviderDbInstanceIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicy
 */
export interface SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicy(obj: SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecProviderConfigRefPolicyResolution
 */
export enum SnapshotSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecProviderConfigRefPolicyResolve
 */
export enum SnapshotSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SnapshotSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj: SnapshotSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecForProviderDbInstanceIdentifierRefPolicyResolution
 */
export enum SnapshotSpecForProviderDbInstanceIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecForProviderDbInstanceIdentifierRefPolicyResolve
 */
export enum SnapshotSpecForProviderDbInstanceIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicyResolution
 */
export enum SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicyResolve
 */
export enum SnapshotSpecForProviderDbInstanceIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SubnetGroup is the Schema for the SubnetGroups API. Provides an RDS DB subnet group resource.
 *
 * @schema SubnetGroup
 */
export class SubnetGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SubnetGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rds.aws.upbound.io/v1beta1',
    kind: 'SubnetGroup',
  }

  /**
   * Renders a Kubernetes manifest for "SubnetGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubnetGroupProps): any {
    return {
      ...SubnetGroup.GVK,
      ...toJson_SubnetGroupProps(props),
    };
  }

  /**
   * Defines a "SubnetGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubnetGroupProps) {
    super(scope, id, {
      ...SubnetGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SubnetGroup.GVK,
      ...toJson_SubnetGroupProps(resolved),
    };
  }
}

/**
 * SubnetGroup is the Schema for the SubnetGroups API. Provides an RDS DB subnet group resource.
 *
 * @schema SubnetGroup
 */
export interface SubnetGroupProps {
  /**
   * @schema SubnetGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SubnetGroupSpec defines the desired state of SubnetGroup
   *
   * @schema SubnetGroup#spec
   */
  readonly spec: SubnetGroupSpec;

}

/**
 * Converts an object of type 'SubnetGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupProps(obj: SubnetGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubnetGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetGroupSpec defines the desired state of SubnetGroup
 *
 * @schema SubnetGroupSpec
 */
export interface SubnetGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SubnetGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: SubnetGroupSpecDeletionPolicy;

  /**
   * @schema SubnetGroupSpec#forProvider
   */
  readonly forProvider: SubnetGroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SubnetGroupSpec#initProvider
   */
  readonly initProvider?: SubnetGroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SubnetGroupSpec#managementPolicies
   */
  readonly managementPolicies?: SubnetGroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SubnetGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: SubnetGroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SubnetGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SubnetGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SubnetGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubnetGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SubnetGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpec(obj: SubnetGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubnetGroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_SubnetGroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SubnetGroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SubnetGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SubnetGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SubnetGroupSpecDeletionPolicy
 */
export enum SubnetGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SubnetGroupSpecForProvider
 */
export interface SubnetGroupSpecForProvider {
  /**
   * The description of the DB subnet group.
   *
   * @schema SubnetGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SubnetGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema SubnetGroupSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: SubnetGroupSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema SubnetGroupSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: SubnetGroupSpecForProviderSubnetIdSelector;

  /**
   * A list of VPC subnet IDs.
   *
   * @schema SubnetGroupSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema SubnetGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubnetGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProvider(obj: SubnetGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'region': obj.region,
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_SubnetGroupSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_SubnetGroupSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SubnetGroupSpecInitProvider
 */
export interface SubnetGroupSpecInitProvider {
  /**
   * The description of the DB subnet group.
   *
   * @schema SubnetGroupSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema SubnetGroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubnetGroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecInitProvider(obj: SubnetGroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SubnetGroupSpecManagementPolicies
 */
export enum SubnetGroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SubnetGroupSpecProviderConfigRef
 */
export interface SubnetGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecProviderConfigRef#policy
   */
  readonly policy?: SubnetGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderConfigRef(obj: SubnetGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsTo
 */
export interface SubnetGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SubnetGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SubnetGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsTo(obj: SubnetGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SubnetGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SubnetGroupSpecWriteConnectionSecretToRef
 */
export interface SubnetGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubnetGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubnetGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecWriteConnectionSecretToRef(obj: SubnetGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefs
 */
export interface SubnetGroupSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: SubnetGroupSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdRefs(obj: SubnetGroupSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelector
 */
export interface SubnetGroupSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: SubnetGroupSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdSelector(obj: SubnetGroupSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetGroupSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicy
 */
export interface SubnetGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderConfigRefPolicy(obj: SubnetGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface SubnetGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRef(obj: SubnetGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata
 */
export interface SubnetGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToMetadata(obj: SubnetGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicy
 */
export interface SubnetGroupSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdRefsPolicy(obj: SubnetGroupSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicy
 */
export interface SubnetGroupSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdSelectorPolicy(obj: SubnetGroupSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicyResolution
 */
export enum SubnetGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicyResolve
 */
export enum SubnetGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum SubnetGroupSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum SubnetGroupSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

