// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CatalogDatabase is the Schema for the CatalogDatabases API. Provides a Glue Catalog Database.
 *
 * @schema CatalogDatabase
 */
export class CatalogDatabase extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CatalogDatabase"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'CatalogDatabase',
  }

  /**
   * Renders a Kubernetes manifest for "CatalogDatabase".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CatalogDatabaseProps): any {
    return {
      ...CatalogDatabase.GVK,
      ...toJson_CatalogDatabaseProps(props),
    };
  }

  /**
   * Defines a "CatalogDatabase" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CatalogDatabaseProps) {
    super(scope, id, {
      ...CatalogDatabase.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CatalogDatabase.GVK,
      ...toJson_CatalogDatabaseProps(resolved),
    };
  }
}

/**
 * CatalogDatabase is the Schema for the CatalogDatabases API. Provides a Glue Catalog Database.
 *
 * @schema CatalogDatabase
 */
export interface CatalogDatabaseProps {
  /**
   * @schema CatalogDatabase#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CatalogDatabaseSpec defines the desired state of CatalogDatabase
   *
   * @schema CatalogDatabase#spec
   */
  readonly spec: CatalogDatabaseSpec;

}

/**
 * Converts an object of type 'CatalogDatabaseProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseProps(obj: CatalogDatabaseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CatalogDatabaseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CatalogDatabaseSpec defines the desired state of CatalogDatabase
 *
 * @schema CatalogDatabaseSpec
 */
export interface CatalogDatabaseSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CatalogDatabaseSpec#deletionPolicy
   */
  readonly deletionPolicy?: CatalogDatabaseSpecDeletionPolicy;

  /**
   * @schema CatalogDatabaseSpec#forProvider
   */
  readonly forProvider: CatalogDatabaseSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CatalogDatabaseSpec#initProvider
   */
  readonly initProvider?: CatalogDatabaseSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CatalogDatabaseSpec#managementPolicies
   */
  readonly managementPolicies?: CatalogDatabaseSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CatalogDatabaseSpec#providerConfigRef
   */
  readonly providerConfigRef?: CatalogDatabaseSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CatalogDatabaseSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CatalogDatabaseSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CatalogDatabaseSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CatalogDatabaseSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CatalogDatabaseSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpec(obj: CatalogDatabaseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CatalogDatabaseSpecForProvider(obj.forProvider),
    'initProvider': toJson_CatalogDatabaseSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CatalogDatabaseSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CatalogDatabaseSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CatalogDatabaseSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CatalogDatabaseSpecDeletionPolicy
 */
export enum CatalogDatabaseSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CatalogDatabaseSpecForProvider
 */
export interface CatalogDatabaseSpecForProvider {
  /**
   * ID of the Glue Catalog to create the database in. If omitted, this defaults to the AWS Account ID.
   *
   * @schema CatalogDatabaseSpecForProvider#catalogId
   */
  readonly catalogId: string;

  /**
   * Creates a set of default permissions on the table for principals. See create_table_default_permission below.
   *
   * @schema CatalogDatabaseSpecForProvider#createTableDefaultPermission
   */
  readonly createTableDefaultPermission?: CatalogDatabaseSpecForProviderCreateTableDefaultPermission[];

  /**
   * Description of the database.
   *
   * @schema CatalogDatabaseSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Location of the database (for example, an HDFS path).
   *
   * @schema CatalogDatabaseSpecForProvider#locationUri
   */
  readonly locationUri?: string;

  /**
   * List of key-value pairs that define parameters and properties of the database.
   *
   * @schema CatalogDatabaseSpecForProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CatalogDatabaseSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema CatalogDatabaseSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block for a target database for resource linking. See target_database below.
   *
   * @schema CatalogDatabaseSpecForProvider#targetDatabase
   */
  readonly targetDatabase?: CatalogDatabaseSpecForProviderTargetDatabase[];

}

/**
 * Converts an object of type 'CatalogDatabaseSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecForProvider(obj: CatalogDatabaseSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'createTableDefaultPermission': obj.createTableDefaultPermission?.map(y => toJson_CatalogDatabaseSpecForProviderCreateTableDefaultPermission(y)),
    'description': obj.description,
    'locationUri': obj.locationUri,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetDatabase': obj.targetDatabase?.map(y => toJson_CatalogDatabaseSpecForProviderTargetDatabase(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CatalogDatabaseSpecInitProvider
 */
export interface CatalogDatabaseSpecInitProvider {
  /**
   * Creates a set of default permissions on the table for principals. See create_table_default_permission below.
   *
   * @schema CatalogDatabaseSpecInitProvider#createTableDefaultPermission
   */
  readonly createTableDefaultPermission?: CatalogDatabaseSpecInitProviderCreateTableDefaultPermission[];

  /**
   * Description of the database.
   *
   * @schema CatalogDatabaseSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Location of the database (for example, an HDFS path).
   *
   * @schema CatalogDatabaseSpecInitProvider#locationUri
   */
  readonly locationUri?: string;

  /**
   * List of key-value pairs that define parameters and properties of the database.
   *
   * @schema CatalogDatabaseSpecInitProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Key-value map of resource tags.
   *
   * @schema CatalogDatabaseSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block for a target database for resource linking. See target_database below.
   *
   * @schema CatalogDatabaseSpecInitProvider#targetDatabase
   */
  readonly targetDatabase?: CatalogDatabaseSpecInitProviderTargetDatabase[];

}

/**
 * Converts an object of type 'CatalogDatabaseSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecInitProvider(obj: CatalogDatabaseSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createTableDefaultPermission': obj.createTableDefaultPermission?.map(y => toJson_CatalogDatabaseSpecInitProviderCreateTableDefaultPermission(y)),
    'description': obj.description,
    'locationUri': obj.locationUri,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetDatabase': obj.targetDatabase?.map(y => toJson_CatalogDatabaseSpecInitProviderTargetDatabase(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CatalogDatabaseSpecManagementPolicies
 */
export enum CatalogDatabaseSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CatalogDatabaseSpecProviderConfigRef
 */
export interface CatalogDatabaseSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CatalogDatabaseSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CatalogDatabaseSpecProviderConfigRef#policy
   */
  readonly policy?: CatalogDatabaseSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CatalogDatabaseSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecProviderConfigRef(obj: CatalogDatabaseSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CatalogDatabaseSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CatalogDatabaseSpecPublishConnectionDetailsTo
 */
export interface CatalogDatabaseSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CatalogDatabaseSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CatalogDatabaseSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CatalogDatabaseSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CatalogDatabaseSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CatalogDatabaseSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CatalogDatabaseSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecPublishConnectionDetailsTo(obj: CatalogDatabaseSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CatalogDatabaseSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CatalogDatabaseSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CatalogDatabaseSpecWriteConnectionSecretToRef
 */
export interface CatalogDatabaseSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CatalogDatabaseSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CatalogDatabaseSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CatalogDatabaseSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecWriteConnectionSecretToRef(obj: CatalogDatabaseSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogDatabaseSpecForProviderCreateTableDefaultPermission
 */
export interface CatalogDatabaseSpecForProviderCreateTableDefaultPermission {
  /**
   * The permissions that are granted to the principal.
   *
   * @schema CatalogDatabaseSpecForProviderCreateTableDefaultPermission#permissions
   */
  readonly permissions?: string[];

  /**
   * The principal who is granted permissions.. See principal below.
   *
   * @schema CatalogDatabaseSpecForProviderCreateTableDefaultPermission#principal
   */
  readonly principal?: CatalogDatabaseSpecForProviderCreateTableDefaultPermissionPrincipal[];

}

/**
 * Converts an object of type 'CatalogDatabaseSpecForProviderCreateTableDefaultPermission' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecForProviderCreateTableDefaultPermission(obj: CatalogDatabaseSpecForProviderCreateTableDefaultPermission | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'permissions': obj.permissions?.map(y => y),
    'principal': obj.principal?.map(y => toJson_CatalogDatabaseSpecForProviderCreateTableDefaultPermissionPrincipal(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogDatabaseSpecForProviderTargetDatabase
 */
export interface CatalogDatabaseSpecForProviderTargetDatabase {
  /**
   * ID of the Data Catalog in which the database resides.
   *
   * @schema CatalogDatabaseSpecForProviderTargetDatabase#catalogId
   */
  readonly catalogId: string;

  /**
   * Name of the catalog database.
   *
   * @schema CatalogDatabaseSpecForProviderTargetDatabase#databaseName
   */
  readonly databaseName?: string;

}

/**
 * Converts an object of type 'CatalogDatabaseSpecForProviderTargetDatabase' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecForProviderTargetDatabase(obj: CatalogDatabaseSpecForProviderTargetDatabase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'databaseName': obj.databaseName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogDatabaseSpecInitProviderCreateTableDefaultPermission
 */
export interface CatalogDatabaseSpecInitProviderCreateTableDefaultPermission {
  /**
   * The permissions that are granted to the principal.
   *
   * @schema CatalogDatabaseSpecInitProviderCreateTableDefaultPermission#permissions
   */
  readonly permissions?: string[];

  /**
   * The principal who is granted permissions.. See principal below.
   *
   * @schema CatalogDatabaseSpecInitProviderCreateTableDefaultPermission#principal
   */
  readonly principal?: CatalogDatabaseSpecInitProviderCreateTableDefaultPermissionPrincipal[];

}

/**
 * Converts an object of type 'CatalogDatabaseSpecInitProviderCreateTableDefaultPermission' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecInitProviderCreateTableDefaultPermission(obj: CatalogDatabaseSpecInitProviderCreateTableDefaultPermission | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'permissions': obj.permissions?.map(y => y),
    'principal': obj.principal?.map(y => toJson_CatalogDatabaseSpecInitProviderCreateTableDefaultPermissionPrincipal(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogDatabaseSpecInitProviderTargetDatabase
 */
export interface CatalogDatabaseSpecInitProviderTargetDatabase {
  /**
   * Name of the catalog database.
   *
   * @schema CatalogDatabaseSpecInitProviderTargetDatabase#databaseName
   */
  readonly databaseName?: string;

}

/**
 * Converts an object of type 'CatalogDatabaseSpecInitProviderTargetDatabase' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecInitProviderTargetDatabase(obj: CatalogDatabaseSpecInitProviderTargetDatabase | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseName': obj.databaseName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CatalogDatabaseSpecProviderConfigRefPolicy
 */
export interface CatalogDatabaseSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CatalogDatabaseSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CatalogDatabaseSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CatalogDatabaseSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CatalogDatabaseSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CatalogDatabaseSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecProviderConfigRefPolicy(obj: CatalogDatabaseSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CatalogDatabaseSpecPublishConnectionDetailsToConfigRef
 */
export interface CatalogDatabaseSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CatalogDatabaseSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CatalogDatabaseSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CatalogDatabaseSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecPublishConnectionDetailsToConfigRef(obj: CatalogDatabaseSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CatalogDatabaseSpecPublishConnectionDetailsToMetadata
 */
export interface CatalogDatabaseSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CatalogDatabaseSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CatalogDatabaseSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CatalogDatabaseSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CatalogDatabaseSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecPublishConnectionDetailsToMetadata(obj: CatalogDatabaseSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogDatabaseSpecForProviderCreateTableDefaultPermissionPrincipal
 */
export interface CatalogDatabaseSpecForProviderCreateTableDefaultPermissionPrincipal {
  /**
   * An identifier for the Lake Formation principal.
   *
   * @schema CatalogDatabaseSpecForProviderCreateTableDefaultPermissionPrincipal#dataLakePrincipalIdentifier
   */
  readonly dataLakePrincipalIdentifier?: string;

}

/**
 * Converts an object of type 'CatalogDatabaseSpecForProviderCreateTableDefaultPermissionPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecForProviderCreateTableDefaultPermissionPrincipal(obj: CatalogDatabaseSpecForProviderCreateTableDefaultPermissionPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataLakePrincipalIdentifier': obj.dataLakePrincipalIdentifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogDatabaseSpecInitProviderCreateTableDefaultPermissionPrincipal
 */
export interface CatalogDatabaseSpecInitProviderCreateTableDefaultPermissionPrincipal {
  /**
   * An identifier for the Lake Formation principal.
   *
   * @schema CatalogDatabaseSpecInitProviderCreateTableDefaultPermissionPrincipal#dataLakePrincipalIdentifier
   */
  readonly dataLakePrincipalIdentifier?: string;

}

/**
 * Converts an object of type 'CatalogDatabaseSpecInitProviderCreateTableDefaultPermissionPrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecInitProviderCreateTableDefaultPermissionPrincipal(obj: CatalogDatabaseSpecInitProviderCreateTableDefaultPermissionPrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataLakePrincipalIdentifier': obj.dataLakePrincipalIdentifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CatalogDatabaseSpecProviderConfigRefPolicyResolution
 */
export enum CatalogDatabaseSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CatalogDatabaseSpecProviderConfigRefPolicyResolve
 */
export enum CatalogDatabaseSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicy(obj: CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CatalogDatabaseSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CatalogTable is the Schema for the CatalogTables API. Provides a Glue Catalog Table.
 *
 * @schema CatalogTable
 */
export class CatalogTable extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CatalogTable"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'CatalogTable',
  }

  /**
   * Renders a Kubernetes manifest for "CatalogTable".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CatalogTableProps): any {
    return {
      ...CatalogTable.GVK,
      ...toJson_CatalogTableProps(props),
    };
  }

  /**
   * Defines a "CatalogTable" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CatalogTableProps) {
    super(scope, id, {
      ...CatalogTable.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CatalogTable.GVK,
      ...toJson_CatalogTableProps(resolved),
    };
  }
}

/**
 * CatalogTable is the Schema for the CatalogTables API. Provides a Glue Catalog Table.
 *
 * @schema CatalogTable
 */
export interface CatalogTableProps {
  /**
   * @schema CatalogTable#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CatalogTableSpec defines the desired state of CatalogTable
   *
   * @schema CatalogTable#spec
   */
  readonly spec: CatalogTableSpec;

}

/**
 * Converts an object of type 'CatalogTableProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableProps(obj: CatalogTableProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CatalogTableSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CatalogTableSpec defines the desired state of CatalogTable
 *
 * @schema CatalogTableSpec
 */
export interface CatalogTableSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CatalogTableSpec#deletionPolicy
   */
  readonly deletionPolicy?: CatalogTableSpecDeletionPolicy;

  /**
   * @schema CatalogTableSpec#forProvider
   */
  readonly forProvider: CatalogTableSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CatalogTableSpec#initProvider
   */
  readonly initProvider?: CatalogTableSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CatalogTableSpec#managementPolicies
   */
  readonly managementPolicies?: CatalogTableSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CatalogTableSpec#providerConfigRef
   */
  readonly providerConfigRef?: CatalogTableSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CatalogTableSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CatalogTableSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CatalogTableSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CatalogTableSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CatalogTableSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpec(obj: CatalogTableSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CatalogTableSpecForProvider(obj.forProvider),
    'initProvider': toJson_CatalogTableSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CatalogTableSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CatalogTableSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CatalogTableSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CatalogTableSpecDeletionPolicy
 */
export enum CatalogTableSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CatalogTableSpecForProvider
 */
export interface CatalogTableSpecForProvider {
  /**
   * ID of the Glue Catalog and database to create the table in. If omitted, this defaults to the AWS Account ID plus the database name.
   *
   * @schema CatalogTableSpecForProvider#catalogId
   */
  readonly catalogId: string;

  /**
   * Name of the metadata database where the table metadata resides. For Hive compatibility, this must be all lowercase.
   *
   * @schema CatalogTableSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * Reference to a CatalogDatabase in glue to populate databaseName.
   *
   * @schema CatalogTableSpecForProvider#databaseNameRef
   */
  readonly databaseNameRef?: CatalogTableSpecForProviderDatabaseNameRef;

  /**
   * Selector for a CatalogDatabase in glue to populate databaseName.
   *
   * @schema CatalogTableSpecForProvider#databaseNameSelector
   */
  readonly databaseNameSelector?: CatalogTableSpecForProviderDatabaseNameSelector;

  /**
   * Description of the table.
   *
   * @schema CatalogTableSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Owner of the table.
   *
   * @schema CatalogTableSpecForProvider#owner
   */
  readonly owner?: string;

  /**
   * Properties associated with this table, as a list of key-value pairs.
   *
   * @schema CatalogTableSpecForProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Configuration block for a maximum of 3 partition indexes. See partition_index below.
   *
   * @schema CatalogTableSpecForProvider#partitionIndex
   */
  readonly partitionIndex?: CatalogTableSpecForProviderPartitionIndex[];

  /**
   * Configuration block of columns by which the table is partitioned. Only primitive types are supported as partition keys. See partition_keys below.
   *
   * @schema CatalogTableSpecForProvider#partitionKeys
   */
  readonly partitionKeys?: CatalogTableSpecForProviderPartitionKeys[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CatalogTableSpecForProvider#region
   */
  readonly region: string;

  /**
   * Retention time for this table.
   *
   * @schema CatalogTableSpecForProvider#retention
   */
  readonly retention?: number;

  /**
   * Configuration block for information about the physical storage of this table. For more information, refer to the Glue Developer Guide. See storage_descriptor below.
   *
   * @schema CatalogTableSpecForProvider#storageDescriptor
   */
  readonly storageDescriptor?: CatalogTableSpecForProviderStorageDescriptor[];

  /**
   * Type of this table (EXTERNAL_TABLE, VIRTUAL_VIEW, etc.). While optional, some Athena DDL queries such as ALTER TABLE and SHOW CREATE TABLE will fail if this argument is empty.
   *
   * @schema CatalogTableSpecForProvider#tableType
   */
  readonly tableType?: string;

  /**
   * Configuration block of a target table for resource linking. See target_table below.
   *
   * @schema CatalogTableSpecForProvider#targetTable
   */
  readonly targetTable?: CatalogTableSpecForProviderTargetTable[];

  /**
   * If the table is a view, the expanded text of the view; otherwise null.
   *
   * @schema CatalogTableSpecForProvider#viewExpandedText
   */
  readonly viewExpandedText?: string;

  /**
   * If the table is a view, the original text of the view; otherwise null.
   *
   * @schema CatalogTableSpecForProvider#viewOriginalText
   */
  readonly viewOriginalText?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProvider(obj: CatalogTableSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'databaseName': obj.databaseName,
    'databaseNameRef': toJson_CatalogTableSpecForProviderDatabaseNameRef(obj.databaseNameRef),
    'databaseNameSelector': toJson_CatalogTableSpecForProviderDatabaseNameSelector(obj.databaseNameSelector),
    'description': obj.description,
    'owner': obj.owner,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'partitionIndex': obj.partitionIndex?.map(y => toJson_CatalogTableSpecForProviderPartitionIndex(y)),
    'partitionKeys': obj.partitionKeys?.map(y => toJson_CatalogTableSpecForProviderPartitionKeys(y)),
    'region': obj.region,
    'retention': obj.retention,
    'storageDescriptor': obj.storageDescriptor?.map(y => toJson_CatalogTableSpecForProviderStorageDescriptor(y)),
    'tableType': obj.tableType,
    'targetTable': obj.targetTable?.map(y => toJson_CatalogTableSpecForProviderTargetTable(y)),
    'viewExpandedText': obj.viewExpandedText,
    'viewOriginalText': obj.viewOriginalText,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CatalogTableSpecInitProvider
 */
export interface CatalogTableSpecInitProvider {
  /**
   * Description of the table.
   *
   * @schema CatalogTableSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Owner of the table.
   *
   * @schema CatalogTableSpecInitProvider#owner
   */
  readonly owner?: string;

  /**
   * Properties associated with this table, as a list of key-value pairs.
   *
   * @schema CatalogTableSpecInitProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Configuration block for a maximum of 3 partition indexes. See partition_index below.
   *
   * @schema CatalogTableSpecInitProvider#partitionIndex
   */
  readonly partitionIndex?: CatalogTableSpecInitProviderPartitionIndex[];

  /**
   * Configuration block of columns by which the table is partitioned. Only primitive types are supported as partition keys. See partition_keys below.
   *
   * @schema CatalogTableSpecInitProvider#partitionKeys
   */
  readonly partitionKeys?: CatalogTableSpecInitProviderPartitionKeys[];

  /**
   * Retention time for this table.
   *
   * @schema CatalogTableSpecInitProvider#retention
   */
  readonly retention?: number;

  /**
   * Configuration block for information about the physical storage of this table. For more information, refer to the Glue Developer Guide. See storage_descriptor below.
   *
   * @schema CatalogTableSpecInitProvider#storageDescriptor
   */
  readonly storageDescriptor?: CatalogTableSpecInitProviderStorageDescriptor[];

  /**
   * Type of this table (EXTERNAL_TABLE, VIRTUAL_VIEW, etc.). While optional, some Athena DDL queries such as ALTER TABLE and SHOW CREATE TABLE will fail if this argument is empty.
   *
   * @schema CatalogTableSpecInitProvider#tableType
   */
  readonly tableType?: string;

  /**
   * Configuration block of a target table for resource linking. See target_table below.
   *
   * @schema CatalogTableSpecInitProvider#targetTable
   */
  readonly targetTable?: CatalogTableSpecInitProviderTargetTable[];

  /**
   * If the table is a view, the expanded text of the view; otherwise null.
   *
   * @schema CatalogTableSpecInitProvider#viewExpandedText
   */
  readonly viewExpandedText?: string;

  /**
   * If the table is a view, the original text of the view; otherwise null.
   *
   * @schema CatalogTableSpecInitProvider#viewOriginalText
   */
  readonly viewOriginalText?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecInitProvider(obj: CatalogTableSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'owner': obj.owner,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'partitionIndex': obj.partitionIndex?.map(y => toJson_CatalogTableSpecInitProviderPartitionIndex(y)),
    'partitionKeys': obj.partitionKeys?.map(y => toJson_CatalogTableSpecInitProviderPartitionKeys(y)),
    'retention': obj.retention,
    'storageDescriptor': obj.storageDescriptor?.map(y => toJson_CatalogTableSpecInitProviderStorageDescriptor(y)),
    'tableType': obj.tableType,
    'targetTable': obj.targetTable?.map(y => toJson_CatalogTableSpecInitProviderTargetTable(y)),
    'viewExpandedText': obj.viewExpandedText,
    'viewOriginalText': obj.viewOriginalText,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CatalogTableSpecManagementPolicies
 */
export enum CatalogTableSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CatalogTableSpecProviderConfigRef
 */
export interface CatalogTableSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CatalogTableSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CatalogTableSpecProviderConfigRef#policy
   */
  readonly policy?: CatalogTableSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CatalogTableSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecProviderConfigRef(obj: CatalogTableSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CatalogTableSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CatalogTableSpecPublishConnectionDetailsTo
 */
export interface CatalogTableSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CatalogTableSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CatalogTableSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CatalogTableSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CatalogTableSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CatalogTableSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CatalogTableSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecPublishConnectionDetailsTo(obj: CatalogTableSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CatalogTableSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CatalogTableSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CatalogTableSpecWriteConnectionSecretToRef
 */
export interface CatalogTableSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CatalogTableSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CatalogTableSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CatalogTableSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecWriteConnectionSecretToRef(obj: CatalogTableSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CatalogDatabase in glue to populate databaseName.
 *
 * @schema CatalogTableSpecForProviderDatabaseNameRef
 */
export interface CatalogTableSpecForProviderDatabaseNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CatalogTableSpecForProviderDatabaseNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CatalogTableSpecForProviderDatabaseNameRef#policy
   */
  readonly policy?: CatalogTableSpecForProviderDatabaseNameRefPolicy;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderDatabaseNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderDatabaseNameRef(obj: CatalogTableSpecForProviderDatabaseNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CatalogTableSpecForProviderDatabaseNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CatalogDatabase in glue to populate databaseName.
 *
 * @schema CatalogTableSpecForProviderDatabaseNameSelector
 */
export interface CatalogTableSpecForProviderDatabaseNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CatalogTableSpecForProviderDatabaseNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CatalogTableSpecForProviderDatabaseNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CatalogTableSpecForProviderDatabaseNameSelector#policy
   */
  readonly policy?: CatalogTableSpecForProviderDatabaseNameSelectorPolicy;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderDatabaseNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderDatabaseNameSelector(obj: CatalogTableSpecForProviderDatabaseNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CatalogTableSpecForProviderDatabaseNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecForProviderPartitionIndex
 */
export interface CatalogTableSpecForProviderPartitionIndex {
  /**
   * Name of the partition index.
   *
   * @schema CatalogTableSpecForProviderPartitionIndex#indexName
   */
  readonly indexName?: string;

  /**
   * Keys for the partition index.
   *
   * @schema CatalogTableSpecForProviderPartitionIndex#keys
   */
  readonly keys?: string[];

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderPartitionIndex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderPartitionIndex(obj: CatalogTableSpecForProviderPartitionIndex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'indexName': obj.indexName,
    'keys': obj.keys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecForProviderPartitionKeys
 */
export interface CatalogTableSpecForProviderPartitionKeys {
  /**
   * Free-form text comment.
   *
   * @schema CatalogTableSpecForProviderPartitionKeys#comment
   */
  readonly comment?: string;

  /**
   * Name of the Partition Key.
   *
   * @schema CatalogTableSpecForProviderPartitionKeys#name
   */
  readonly name?: string;

  /**
   * Datatype of data in the Partition Key.
   *
   * @schema CatalogTableSpecForProviderPartitionKeys#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderPartitionKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderPartitionKeys(obj: CatalogTableSpecForProviderPartitionKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecForProviderStorageDescriptor
 */
export interface CatalogTableSpecForProviderStorageDescriptor {
  /**
   * List of reducer grouping columns, clustering columns, and bucketing columns in the table.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#bucketColumns
   */
  readonly bucketColumns?: string[];

  /**
   * Configuration block for columns in the table. See columns below.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#columns
   */
  readonly columns?: CatalogTableSpecForProviderStorageDescriptorColumns[];

  /**
   * Whether the data in the table is compressed.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#compressed
   */
  readonly compressed?: boolean;

  /**
   * Input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#inputFormat
   */
  readonly inputFormat?: string;

  /**
   * Physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#location
   */
  readonly location?: string;

  /**
   * Must be specified if the table contains any dimension columns.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#numberOfBuckets
   */
  readonly numberOfBuckets?: number;

  /**
   * Output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#outputFormat
   */
  readonly outputFormat?: string;

  /**
   * User-supplied properties in key-value form.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Object that references a schema stored in the AWS Glue Schema Registry. When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference. See Schema Reference below.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#schemaReference
   */
  readonly schemaReference?: CatalogTableSpecForProviderStorageDescriptorSchemaReference[];

  /**
   * Configuration block for serialization and deserialization ("SerDe") information. See ser_de_info below.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#serDeInfo
   */
  readonly serDeInfo?: CatalogTableSpecForProviderStorageDescriptorSerDeInfo[];

  /**
   * Configuration block with information about values that appear very frequently in a column (skewed values). See skewed_info below.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#skewedInfo
   */
  readonly skewedInfo?: CatalogTableSpecForProviderStorageDescriptorSkewedInfo[];

  /**
   * Configuration block for the sort order of each bucket in the table. See sort_columns below.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#sortColumns
   */
  readonly sortColumns?: CatalogTableSpecForProviderStorageDescriptorSortColumns[];

  /**
   * Whether the table data is stored in subdirectories.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptor#storedAsSubDirectories
   */
  readonly storedAsSubDirectories?: boolean;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderStorageDescriptor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderStorageDescriptor(obj: CatalogTableSpecForProviderStorageDescriptor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketColumns': obj.bucketColumns?.map(y => y),
    'columns': obj.columns?.map(y => toJson_CatalogTableSpecForProviderStorageDescriptorColumns(y)),
    'compressed': obj.compressed,
    'inputFormat': obj.inputFormat,
    'location': obj.location,
    'numberOfBuckets': obj.numberOfBuckets,
    'outputFormat': obj.outputFormat,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'schemaReference': obj.schemaReference?.map(y => toJson_CatalogTableSpecForProviderStorageDescriptorSchemaReference(y)),
    'serDeInfo': obj.serDeInfo?.map(y => toJson_CatalogTableSpecForProviderStorageDescriptorSerDeInfo(y)),
    'skewedInfo': obj.skewedInfo?.map(y => toJson_CatalogTableSpecForProviderStorageDescriptorSkewedInfo(y)),
    'sortColumns': obj.sortColumns?.map(y => toJson_CatalogTableSpecForProviderStorageDescriptorSortColumns(y)),
    'storedAsSubDirectories': obj.storedAsSubDirectories,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecForProviderTargetTable
 */
export interface CatalogTableSpecForProviderTargetTable {
  /**
   * ID of the Data Catalog in which the table resides.
   *
   * @schema CatalogTableSpecForProviderTargetTable#catalogId
   */
  readonly catalogId: string;

  /**
   * Name of the catalog database that contains the target table.
   *
   * @schema CatalogTableSpecForProviderTargetTable#databaseName
   */
  readonly databaseName: string;

  /**
   * Name of the target table.
   *
   * @schema CatalogTableSpecForProviderTargetTable#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderTargetTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderTargetTable(obj: CatalogTableSpecForProviderTargetTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'databaseName': obj.databaseName,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecInitProviderPartitionIndex
 */
export interface CatalogTableSpecInitProviderPartitionIndex {
  /**
   * Name of the partition index.
   *
   * @schema CatalogTableSpecInitProviderPartitionIndex#indexName
   */
  readonly indexName?: string;

  /**
   * Keys for the partition index.
   *
   * @schema CatalogTableSpecInitProviderPartitionIndex#keys
   */
  readonly keys?: string[];

}

/**
 * Converts an object of type 'CatalogTableSpecInitProviderPartitionIndex' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecInitProviderPartitionIndex(obj: CatalogTableSpecInitProviderPartitionIndex | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'indexName': obj.indexName,
    'keys': obj.keys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecInitProviderPartitionKeys
 */
export interface CatalogTableSpecInitProviderPartitionKeys {
  /**
   * Free-form text comment.
   *
   * @schema CatalogTableSpecInitProviderPartitionKeys#comment
   */
  readonly comment?: string;

  /**
   * Name of the Partition Key.
   *
   * @schema CatalogTableSpecInitProviderPartitionKeys#name
   */
  readonly name?: string;

  /**
   * Datatype of data in the Partition Key.
   *
   * @schema CatalogTableSpecInitProviderPartitionKeys#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecInitProviderPartitionKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecInitProviderPartitionKeys(obj: CatalogTableSpecInitProviderPartitionKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecInitProviderStorageDescriptor
 */
export interface CatalogTableSpecInitProviderStorageDescriptor {
  /**
   * List of reducer grouping columns, clustering columns, and bucketing columns in the table.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#bucketColumns
   */
  readonly bucketColumns?: string[];

  /**
   * Configuration block for columns in the table. See columns below.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#columns
   */
  readonly columns?: CatalogTableSpecInitProviderStorageDescriptorColumns[];

  /**
   * Whether the data in the table is compressed.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#compressed
   */
  readonly compressed?: boolean;

  /**
   * Input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#inputFormat
   */
  readonly inputFormat?: string;

  /**
   * Physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#location
   */
  readonly location?: string;

  /**
   * Must be specified if the table contains any dimension columns.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#numberOfBuckets
   */
  readonly numberOfBuckets?: number;

  /**
   * Output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#outputFormat
   */
  readonly outputFormat?: string;

  /**
   * User-supplied properties in key-value form.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Object that references a schema stored in the AWS Glue Schema Registry. When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference. See Schema Reference below.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#schemaReference
   */
  readonly schemaReference?: CatalogTableSpecInitProviderStorageDescriptorSchemaReference[];

  /**
   * Configuration block for serialization and deserialization ("SerDe") information. See ser_de_info below.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#serDeInfo
   */
  readonly serDeInfo?: CatalogTableSpecInitProviderStorageDescriptorSerDeInfo[];

  /**
   * Configuration block with information about values that appear very frequently in a column (skewed values). See skewed_info below.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#skewedInfo
   */
  readonly skewedInfo?: CatalogTableSpecInitProviderStorageDescriptorSkewedInfo[];

  /**
   * Configuration block for the sort order of each bucket in the table. See sort_columns below.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#sortColumns
   */
  readonly sortColumns?: CatalogTableSpecInitProviderStorageDescriptorSortColumns[];

  /**
   * Whether the table data is stored in subdirectories.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptor#storedAsSubDirectories
   */
  readonly storedAsSubDirectories?: boolean;

}

/**
 * Converts an object of type 'CatalogTableSpecInitProviderStorageDescriptor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecInitProviderStorageDescriptor(obj: CatalogTableSpecInitProviderStorageDescriptor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketColumns': obj.bucketColumns?.map(y => y),
    'columns': obj.columns?.map(y => toJson_CatalogTableSpecInitProviderStorageDescriptorColumns(y)),
    'compressed': obj.compressed,
    'inputFormat': obj.inputFormat,
    'location': obj.location,
    'numberOfBuckets': obj.numberOfBuckets,
    'outputFormat': obj.outputFormat,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'schemaReference': obj.schemaReference?.map(y => toJson_CatalogTableSpecInitProviderStorageDescriptorSchemaReference(y)),
    'serDeInfo': obj.serDeInfo?.map(y => toJson_CatalogTableSpecInitProviderStorageDescriptorSerDeInfo(y)),
    'skewedInfo': obj.skewedInfo?.map(y => toJson_CatalogTableSpecInitProviderStorageDescriptorSkewedInfo(y)),
    'sortColumns': obj.sortColumns?.map(y => toJson_CatalogTableSpecInitProviderStorageDescriptorSortColumns(y)),
    'storedAsSubDirectories': obj.storedAsSubDirectories,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecInitProviderTargetTable
 */
export interface CatalogTableSpecInitProviderTargetTable {
  /**
   * Name of the target table.
   *
   * @schema CatalogTableSpecInitProviderTargetTable#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecInitProviderTargetTable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecInitProviderTargetTable(obj: CatalogTableSpecInitProviderTargetTable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CatalogTableSpecProviderConfigRefPolicy
 */
export interface CatalogTableSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CatalogTableSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CatalogTableSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CatalogTableSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CatalogTableSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CatalogTableSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecProviderConfigRefPolicy(obj: CatalogTableSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CatalogTableSpecPublishConnectionDetailsToConfigRef
 */
export interface CatalogTableSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CatalogTableSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CatalogTableSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CatalogTableSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CatalogTableSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecPublishConnectionDetailsToConfigRef(obj: CatalogTableSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CatalogTableSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CatalogTableSpecPublishConnectionDetailsToMetadata
 */
export interface CatalogTableSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CatalogTableSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CatalogTableSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CatalogTableSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecPublishConnectionDetailsToMetadata(obj: CatalogTableSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CatalogTableSpecForProviderDatabaseNameRefPolicy
 */
export interface CatalogTableSpecForProviderDatabaseNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CatalogTableSpecForProviderDatabaseNameRefPolicy#resolution
   */
  readonly resolution?: CatalogTableSpecForProviderDatabaseNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CatalogTableSpecForProviderDatabaseNameRefPolicy#resolve
   */
  readonly resolve?: CatalogTableSpecForProviderDatabaseNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderDatabaseNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderDatabaseNameRefPolicy(obj: CatalogTableSpecForProviderDatabaseNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CatalogTableSpecForProviderDatabaseNameSelectorPolicy
 */
export interface CatalogTableSpecForProviderDatabaseNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CatalogTableSpecForProviderDatabaseNameSelectorPolicy#resolution
   */
  readonly resolution?: CatalogTableSpecForProviderDatabaseNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CatalogTableSpecForProviderDatabaseNameSelectorPolicy#resolve
   */
  readonly resolve?: CatalogTableSpecForProviderDatabaseNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderDatabaseNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderDatabaseNameSelectorPolicy(obj: CatalogTableSpecForProviderDatabaseNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecForProviderStorageDescriptorColumns
 */
export interface CatalogTableSpecForProviderStorageDescriptorColumns {
  /**
   * Free-form text comment.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorColumns#comment
   */
  readonly comment?: string;

  /**
   * Name of the Column.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorColumns#name
   */
  readonly name?: string;

  /**
   * Key-value pairs defining properties associated with the column.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorColumns#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Datatype of data in the Column.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorColumns#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderStorageDescriptorColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderStorageDescriptorColumns(obj: CatalogTableSpecForProviderStorageDescriptorColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecForProviderStorageDescriptorSchemaReference
 */
export interface CatalogTableSpecForProviderStorageDescriptorSchemaReference {
  /**
   * Configuration block that contains schema identity fields. Either this or the schema_version_id has to be provided. See schema_id below.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSchemaReference#schemaId
   */
  readonly schemaId?: CatalogTableSpecForProviderStorageDescriptorSchemaReferenceSchemaId[];

  /**
   * Unique ID assigned to a version of the schema. Either this or the schema_id has to be provided.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSchemaReference#schemaVersionId
   */
  readonly schemaVersionId?: string;

  /**
   * Version number of the schema.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSchemaReference#schemaVersionNumber
   */
  readonly schemaVersionNumber?: number;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderStorageDescriptorSchemaReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderStorageDescriptorSchemaReference(obj: CatalogTableSpecForProviderStorageDescriptorSchemaReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'schemaId': obj.schemaId?.map(y => toJson_CatalogTableSpecForProviderStorageDescriptorSchemaReferenceSchemaId(y)),
    'schemaVersionId': obj.schemaVersionId,
    'schemaVersionNumber': obj.schemaVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecForProviderStorageDescriptorSerDeInfo
 */
export interface CatalogTableSpecForProviderStorageDescriptorSerDeInfo {
  /**
   * Name of the SerDe.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSerDeInfo#name
   */
  readonly name?: string;

  /**
   * Map of initialization parameters for the SerDe, in key-value form.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSerDeInfo#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Usually the class that implements the SerDe. An example is org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSerDeInfo#serializationLibrary
   */
  readonly serializationLibrary?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderStorageDescriptorSerDeInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderStorageDescriptorSerDeInfo(obj: CatalogTableSpecForProviderStorageDescriptorSerDeInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serializationLibrary': obj.serializationLibrary,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecForProviderStorageDescriptorSkewedInfo
 */
export interface CatalogTableSpecForProviderStorageDescriptorSkewedInfo {
  /**
   * List of names of columns that contain skewed values.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSkewedInfo#skewedColumnNames
   */
  readonly skewedColumnNames?: string[];

  /**
   * List of values that appear so frequently as to be considered skewed.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSkewedInfo#skewedColumnValueLocationMaps
   */
  readonly skewedColumnValueLocationMaps?: { [key: string]: string };

  /**
   * Map of skewed values to the columns that contain them.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSkewedInfo#skewedColumnValues
   */
  readonly skewedColumnValues?: string[];

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderStorageDescriptorSkewedInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderStorageDescriptorSkewedInfo(obj: CatalogTableSpecForProviderStorageDescriptorSkewedInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'skewedColumnNames': obj.skewedColumnNames?.map(y => y),
    'skewedColumnValueLocationMaps': ((obj.skewedColumnValueLocationMaps) === undefined) ? undefined : (Object.entries(obj.skewedColumnValueLocationMaps).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'skewedColumnValues': obj.skewedColumnValues?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecForProviderStorageDescriptorSortColumns
 */
export interface CatalogTableSpecForProviderStorageDescriptorSortColumns {
  /**
   * Name of the column.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSortColumns#column
   */
  readonly column?: string;

  /**
   * Whether the column is sorted in ascending (1) or descending order (0).
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSortColumns#sortOrder
   */
  readonly sortOrder?: number;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderStorageDescriptorSortColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderStorageDescriptorSortColumns(obj: CatalogTableSpecForProviderStorageDescriptorSortColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'column': obj.column,
    'sortOrder': obj.sortOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecInitProviderStorageDescriptorColumns
 */
export interface CatalogTableSpecInitProviderStorageDescriptorColumns {
  /**
   * Free-form text comment.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorColumns#comment
   */
  readonly comment?: string;

  /**
   * Name of the Column.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorColumns#name
   */
  readonly name?: string;

  /**
   * Key-value pairs defining properties associated with the column.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorColumns#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Datatype of data in the Column.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorColumns#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecInitProviderStorageDescriptorColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecInitProviderStorageDescriptorColumns(obj: CatalogTableSpecInitProviderStorageDescriptorColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecInitProviderStorageDescriptorSchemaReference
 */
export interface CatalogTableSpecInitProviderStorageDescriptorSchemaReference {
  /**
   * Configuration block that contains schema identity fields. Either this or the schema_version_id has to be provided. See schema_id below.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSchemaReference#schemaId
   */
  readonly schemaId?: CatalogTableSpecInitProviderStorageDescriptorSchemaReferenceSchemaId[];

  /**
   * Unique ID assigned to a version of the schema. Either this or the schema_id has to be provided.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSchemaReference#schemaVersionId
   */
  readonly schemaVersionId?: string;

  /**
   * Version number of the schema.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSchemaReference#schemaVersionNumber
   */
  readonly schemaVersionNumber?: number;

}

/**
 * Converts an object of type 'CatalogTableSpecInitProviderStorageDescriptorSchemaReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecInitProviderStorageDescriptorSchemaReference(obj: CatalogTableSpecInitProviderStorageDescriptorSchemaReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'schemaId': obj.schemaId?.map(y => toJson_CatalogTableSpecInitProviderStorageDescriptorSchemaReferenceSchemaId(y)),
    'schemaVersionId': obj.schemaVersionId,
    'schemaVersionNumber': obj.schemaVersionNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecInitProviderStorageDescriptorSerDeInfo
 */
export interface CatalogTableSpecInitProviderStorageDescriptorSerDeInfo {
  /**
   * Name of the SerDe.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSerDeInfo#name
   */
  readonly name?: string;

  /**
   * Map of initialization parameters for the SerDe, in key-value form.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSerDeInfo#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Usually the class that implements the SerDe. An example is org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSerDeInfo#serializationLibrary
   */
  readonly serializationLibrary?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecInitProviderStorageDescriptorSerDeInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecInitProviderStorageDescriptorSerDeInfo(obj: CatalogTableSpecInitProviderStorageDescriptorSerDeInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serializationLibrary': obj.serializationLibrary,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecInitProviderStorageDescriptorSkewedInfo
 */
export interface CatalogTableSpecInitProviderStorageDescriptorSkewedInfo {
  /**
   * List of names of columns that contain skewed values.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSkewedInfo#skewedColumnNames
   */
  readonly skewedColumnNames?: string[];

  /**
   * List of values that appear so frequently as to be considered skewed.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSkewedInfo#skewedColumnValueLocationMaps
   */
  readonly skewedColumnValueLocationMaps?: { [key: string]: string };

  /**
   * Map of skewed values to the columns that contain them.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSkewedInfo#skewedColumnValues
   */
  readonly skewedColumnValues?: string[];

}

/**
 * Converts an object of type 'CatalogTableSpecInitProviderStorageDescriptorSkewedInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecInitProviderStorageDescriptorSkewedInfo(obj: CatalogTableSpecInitProviderStorageDescriptorSkewedInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'skewedColumnNames': obj.skewedColumnNames?.map(y => y),
    'skewedColumnValueLocationMaps': ((obj.skewedColumnValueLocationMaps) === undefined) ? undefined : (Object.entries(obj.skewedColumnValueLocationMaps).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'skewedColumnValues': obj.skewedColumnValues?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecInitProviderStorageDescriptorSortColumns
 */
export interface CatalogTableSpecInitProviderStorageDescriptorSortColumns {
  /**
   * Name of the column.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSortColumns#column
   */
  readonly column?: string;

  /**
   * Whether the column is sorted in ascending (1) or descending order (0).
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSortColumns#sortOrder
   */
  readonly sortOrder?: number;

}

/**
 * Converts an object of type 'CatalogTableSpecInitProviderStorageDescriptorSortColumns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecInitProviderStorageDescriptorSortColumns(obj: CatalogTableSpecInitProviderStorageDescriptorSortColumns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'column': obj.column,
    'sortOrder': obj.sortOrder,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CatalogTableSpecProviderConfigRefPolicyResolution
 */
export enum CatalogTableSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CatalogTableSpecProviderConfigRefPolicyResolve
 */
export enum CatalogTableSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CatalogTableSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CatalogTableSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CatalogTableSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CatalogTableSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CatalogTableSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CatalogTableSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CatalogTableSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecPublishConnectionDetailsToConfigRefPolicy(obj: CatalogTableSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CatalogTableSpecForProviderDatabaseNameRefPolicyResolution
 */
export enum CatalogTableSpecForProviderDatabaseNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CatalogTableSpecForProviderDatabaseNameRefPolicyResolve
 */
export enum CatalogTableSpecForProviderDatabaseNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CatalogTableSpecForProviderDatabaseNameSelectorPolicyResolution
 */
export enum CatalogTableSpecForProviderDatabaseNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CatalogTableSpecForProviderDatabaseNameSelectorPolicyResolve
 */
export enum CatalogTableSpecForProviderDatabaseNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema CatalogTableSpecForProviderStorageDescriptorSchemaReferenceSchemaId
 */
export interface CatalogTableSpecForProviderStorageDescriptorSchemaReferenceSchemaId {
  /**
   * Name of the schema registry that contains the schema. Must be provided when schema_name is specified and conflicts with schema_arn.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSchemaReferenceSchemaId#registryName
   */
  readonly registryName?: string;

  /**
   * ARN of the schema. One of schema_arn or schema_name has to be provided.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSchemaReferenceSchemaId#schemaArn
   */
  readonly schemaArn?: string;

  /**
   * Name of the schema. One of schema_arn or schema_name has to be provided.
   *
   * @schema CatalogTableSpecForProviderStorageDescriptorSchemaReferenceSchemaId#schemaName
   */
  readonly schemaName?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecForProviderStorageDescriptorSchemaReferenceSchemaId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecForProviderStorageDescriptorSchemaReferenceSchemaId(obj: CatalogTableSpecForProviderStorageDescriptorSchemaReferenceSchemaId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'registryName': obj.registryName,
    'schemaArn': obj.schemaArn,
    'schemaName': obj.schemaName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CatalogTableSpecInitProviderStorageDescriptorSchemaReferenceSchemaId
 */
export interface CatalogTableSpecInitProviderStorageDescriptorSchemaReferenceSchemaId {
  /**
   * Name of the schema registry that contains the schema. Must be provided when schema_name is specified and conflicts with schema_arn.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSchemaReferenceSchemaId#registryName
   */
  readonly registryName?: string;

  /**
   * ARN of the schema. One of schema_arn or schema_name has to be provided.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSchemaReferenceSchemaId#schemaArn
   */
  readonly schemaArn?: string;

  /**
   * Name of the schema. One of schema_arn or schema_name has to be provided.
   *
   * @schema CatalogTableSpecInitProviderStorageDescriptorSchemaReferenceSchemaId#schemaName
   */
  readonly schemaName?: string;

}

/**
 * Converts an object of type 'CatalogTableSpecInitProviderStorageDescriptorSchemaReferenceSchemaId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CatalogTableSpecInitProviderStorageDescriptorSchemaReferenceSchemaId(obj: CatalogTableSpecInitProviderStorageDescriptorSchemaReferenceSchemaId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'registryName': obj.registryName,
    'schemaArn': obj.schemaArn,
    'schemaName': obj.schemaName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CatalogTableSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CatalogTableSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CatalogTableSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CatalogTableSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Classifier is the Schema for the Classifiers API. Provides an Glue Classifier resource.
 *
 * @schema Classifier
 */
export class Classifier extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Classifier"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'Classifier',
  }

  /**
   * Renders a Kubernetes manifest for "Classifier".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClassifierProps): any {
    return {
      ...Classifier.GVK,
      ...toJson_ClassifierProps(props),
    };
  }

  /**
   * Defines a "Classifier" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClassifierProps) {
    super(scope, id, {
      ...Classifier.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Classifier.GVK,
      ...toJson_ClassifierProps(resolved),
    };
  }
}

/**
 * Classifier is the Schema for the Classifiers API. Provides an Glue Classifier resource.
 *
 * @schema Classifier
 */
export interface ClassifierProps {
  /**
   * @schema Classifier#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClassifierSpec defines the desired state of Classifier
   *
   * @schema Classifier#spec
   */
  readonly spec: ClassifierSpec;

}

/**
 * Converts an object of type 'ClassifierProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierProps(obj: ClassifierProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClassifierSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClassifierSpec defines the desired state of Classifier
 *
 * @schema ClassifierSpec
 */
export interface ClassifierSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClassifierSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClassifierSpecDeletionPolicy;

  /**
   * @schema ClassifierSpec#forProvider
   */
  readonly forProvider: ClassifierSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClassifierSpec#initProvider
   */
  readonly initProvider?: ClassifierSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClassifierSpec#managementPolicies
   */
  readonly managementPolicies?: ClassifierSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClassifierSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClassifierSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClassifierSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClassifierSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClassifierSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClassifierSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClassifierSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpec(obj: ClassifierSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClassifierSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClassifierSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClassifierSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClassifierSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClassifierSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClassifierSpecDeletionPolicy
 */
export enum ClassifierSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClassifierSpecForProvider
 */
export interface ClassifierSpecForProvider {
  /**
   * A classifier for Csv content. Defined below.
   *
   * @schema ClassifierSpecForProvider#csvClassifier
   */
  readonly csvClassifier?: ClassifierSpecForProviderCsvClassifier[];

  /**
   *   A classifier that uses grok patterns. Defined below.
   *
   * @schema ClassifierSpecForProvider#grokClassifier
   */
  readonly grokClassifier?: ClassifierSpecForProviderGrokClassifier[];

  /**
   *   A classifier for JSON content. Defined below.
   *
   * @schema ClassifierSpecForProvider#jsonClassifier
   */
  readonly jsonClassifier?: ClassifierSpecForProviderJsonClassifier[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClassifierSpecForProvider#region
   */
  readonly region: string;

  /**
   *   A classifier for XML content. Defined below.
   *
   * @schema ClassifierSpecForProvider#xmlClassifier
   */
  readonly xmlClassifier?: ClassifierSpecForProviderXmlClassifier[];

}

/**
 * Converts an object of type 'ClassifierSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecForProvider(obj: ClassifierSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csvClassifier': obj.csvClassifier?.map(y => toJson_ClassifierSpecForProviderCsvClassifier(y)),
    'grokClassifier': obj.grokClassifier?.map(y => toJson_ClassifierSpecForProviderGrokClassifier(y)),
    'jsonClassifier': obj.jsonClassifier?.map(y => toJson_ClassifierSpecForProviderJsonClassifier(y)),
    'region': obj.region,
    'xmlClassifier': obj.xmlClassifier?.map(y => toJson_ClassifierSpecForProviderXmlClassifier(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClassifierSpecInitProvider
 */
export interface ClassifierSpecInitProvider {
  /**
   * A classifier for Csv content. Defined below.
   *
   * @schema ClassifierSpecInitProvider#csvClassifier
   */
  readonly csvClassifier?: ClassifierSpecInitProviderCsvClassifier[];

  /**
   *   A classifier that uses grok patterns. Defined below.
   *
   * @schema ClassifierSpecInitProvider#grokClassifier
   */
  readonly grokClassifier?: ClassifierSpecInitProviderGrokClassifier[];

  /**
   *   A classifier for JSON content. Defined below.
   *
   * @schema ClassifierSpecInitProvider#jsonClassifier
   */
  readonly jsonClassifier?: ClassifierSpecInitProviderJsonClassifier[];

  /**
   *   A classifier for XML content. Defined below.
   *
   * @schema ClassifierSpecInitProvider#xmlClassifier
   */
  readonly xmlClassifier?: ClassifierSpecInitProviderXmlClassifier[];

}

/**
 * Converts an object of type 'ClassifierSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecInitProvider(obj: ClassifierSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'csvClassifier': obj.csvClassifier?.map(y => toJson_ClassifierSpecInitProviderCsvClassifier(y)),
    'grokClassifier': obj.grokClassifier?.map(y => toJson_ClassifierSpecInitProviderGrokClassifier(y)),
    'jsonClassifier': obj.jsonClassifier?.map(y => toJson_ClassifierSpecInitProviderJsonClassifier(y)),
    'xmlClassifier': obj.xmlClassifier?.map(y => toJson_ClassifierSpecInitProviderXmlClassifier(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClassifierSpecManagementPolicies
 */
export enum ClassifierSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClassifierSpecProviderConfigRef
 */
export interface ClassifierSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClassifierSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClassifierSpecProviderConfigRef#policy
   */
  readonly policy?: ClassifierSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClassifierSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecProviderConfigRef(obj: ClassifierSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClassifierSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClassifierSpecPublishConnectionDetailsTo
 */
export interface ClassifierSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClassifierSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClassifierSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClassifierSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClassifierSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClassifierSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClassifierSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecPublishConnectionDetailsTo(obj: ClassifierSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClassifierSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClassifierSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClassifierSpecWriteConnectionSecretToRef
 */
export interface ClassifierSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClassifierSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClassifierSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClassifierSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecWriteConnectionSecretToRef(obj: ClassifierSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassifierSpecForProviderCsvClassifier
 */
export interface ClassifierSpecForProviderCsvClassifier {
  /**
   * Enables the processing of files that contain only one column.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#allowSingleColumn
   */
  readonly allowSingleColumn?: boolean;

  /**
   * Indicates whether the CSV file contains a header. This can be one of "ABSENT", "PRESENT", or "UNKNOWN".
   *
   * @schema ClassifierSpecForProviderCsvClassifier#containsHeader
   */
  readonly containsHeader?: string;

  /**
   * A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#customDatatypeConfigured
   */
  readonly customDatatypeConfigured?: boolean;

  /**
   * A list of supported custom datatypes. Valid values are BINARY, BOOLEAN, DATE, DECIMAL, DOUBLE, FLOAT, INT, LONG, SHORT, STRING, TIMESTAMP.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#customDatatypes
   */
  readonly customDatatypes?: string[];

  /**
   * The delimiter used in the Csv to separate columns.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#delimiter
   */
  readonly delimiter?: string;

  /**
   * Specifies whether to trim column values.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#disableValueTrimming
   */
  readonly disableValueTrimming?: boolean;

  /**
   * A list of strings representing column names.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#header
   */
  readonly header?: string[];

  /**
   * A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
   *
   * @schema ClassifierSpecForProviderCsvClassifier#quoteSymbol
   */
  readonly quoteSymbol?: string;

}

/**
 * Converts an object of type 'ClassifierSpecForProviderCsvClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecForProviderCsvClassifier(obj: ClassifierSpecForProviderCsvClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowSingleColumn': obj.allowSingleColumn,
    'containsHeader': obj.containsHeader,
    'customDatatypeConfigured': obj.customDatatypeConfigured,
    'customDatatypes': obj.customDatatypes?.map(y => y),
    'delimiter': obj.delimiter,
    'disableValueTrimming': obj.disableValueTrimming,
    'header': obj.header?.map(y => y),
    'quoteSymbol': obj.quoteSymbol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassifierSpecForProviderGrokClassifier
 */
export interface ClassifierSpecForProviderGrokClassifier {
  /**
   * An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
   *
   * @schema ClassifierSpecForProviderGrokClassifier#classification
   */
  readonly classification?: string;

  /**
   * Custom grok patterns used by this classifier.
   *
   * @schema ClassifierSpecForProviderGrokClassifier#customPatterns
   */
  readonly customPatterns?: string;

  /**
   * The grok pattern used by this classifier.
   *
   * @schema ClassifierSpecForProviderGrokClassifier#grokPattern
   */
  readonly grokPattern?: string;

}

/**
 * Converts an object of type 'ClassifierSpecForProviderGrokClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecForProviderGrokClassifier(obj: ClassifierSpecForProviderGrokClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classification': obj.classification,
    'customPatterns': obj.customPatterns,
    'grokPattern': obj.grokPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassifierSpecForProviderJsonClassifier
 */
export interface ClassifierSpecForProviderJsonClassifier {
  /**
   * A JsonPath string defining the JSON data for the classifier to classify. AWS Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers.
   *
   * @schema ClassifierSpecForProviderJsonClassifier#jsonPath
   */
  readonly jsonPath?: string;

}

/**
 * Converts an object of type 'ClassifierSpecForProviderJsonClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecForProviderJsonClassifier(obj: ClassifierSpecForProviderJsonClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassifierSpecForProviderXmlClassifier
 */
export interface ClassifierSpecForProviderXmlClassifier {
  /**
   * An identifier of the data format that the classifier matches.
   *
   * @schema ClassifierSpecForProviderXmlClassifier#classification
   */
  readonly classification?: string;

  /**
   * The XML tag designating the element that contains each record in an XML document being parsed. Note that this cannot identify a self-closing element (closed by />). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <row item_a="A" item_b="B"></row> is okay, but <row item_a="A" item_b="B" /> is not).
   *
   * @schema ClassifierSpecForProviderXmlClassifier#rowTag
   */
  readonly rowTag?: string;

}

/**
 * Converts an object of type 'ClassifierSpecForProviderXmlClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecForProviderXmlClassifier(obj: ClassifierSpecForProviderXmlClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classification': obj.classification,
    'rowTag': obj.rowTag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassifierSpecInitProviderCsvClassifier
 */
export interface ClassifierSpecInitProviderCsvClassifier {
  /**
   * Enables the processing of files that contain only one column.
   *
   * @schema ClassifierSpecInitProviderCsvClassifier#allowSingleColumn
   */
  readonly allowSingleColumn?: boolean;

  /**
   * Indicates whether the CSV file contains a header. This can be one of "ABSENT", "PRESENT", or "UNKNOWN".
   *
   * @schema ClassifierSpecInitProviderCsvClassifier#containsHeader
   */
  readonly containsHeader?: string;

  /**
   * A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
   *
   * @schema ClassifierSpecInitProviderCsvClassifier#customDatatypeConfigured
   */
  readonly customDatatypeConfigured?: boolean;

  /**
   * A list of supported custom datatypes. Valid values are BINARY, BOOLEAN, DATE, DECIMAL, DOUBLE, FLOAT, INT, LONG, SHORT, STRING, TIMESTAMP.
   *
   * @schema ClassifierSpecInitProviderCsvClassifier#customDatatypes
   */
  readonly customDatatypes?: string[];

  /**
   * The delimiter used in the Csv to separate columns.
   *
   * @schema ClassifierSpecInitProviderCsvClassifier#delimiter
   */
  readonly delimiter?: string;

  /**
   * Specifies whether to trim column values.
   *
   * @schema ClassifierSpecInitProviderCsvClassifier#disableValueTrimming
   */
  readonly disableValueTrimming?: boolean;

  /**
   * A list of strings representing column names.
   *
   * @schema ClassifierSpecInitProviderCsvClassifier#header
   */
  readonly header?: string[];

  /**
   * A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
   *
   * @schema ClassifierSpecInitProviderCsvClassifier#quoteSymbol
   */
  readonly quoteSymbol?: string;

}

/**
 * Converts an object of type 'ClassifierSpecInitProviderCsvClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecInitProviderCsvClassifier(obj: ClassifierSpecInitProviderCsvClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowSingleColumn': obj.allowSingleColumn,
    'containsHeader': obj.containsHeader,
    'customDatatypeConfigured': obj.customDatatypeConfigured,
    'customDatatypes': obj.customDatatypes?.map(y => y),
    'delimiter': obj.delimiter,
    'disableValueTrimming': obj.disableValueTrimming,
    'header': obj.header?.map(y => y),
    'quoteSymbol': obj.quoteSymbol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassifierSpecInitProviderGrokClassifier
 */
export interface ClassifierSpecInitProviderGrokClassifier {
  /**
   * An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
   *
   * @schema ClassifierSpecInitProviderGrokClassifier#classification
   */
  readonly classification?: string;

  /**
   * Custom grok patterns used by this classifier.
   *
   * @schema ClassifierSpecInitProviderGrokClassifier#customPatterns
   */
  readonly customPatterns?: string;

  /**
   * The grok pattern used by this classifier.
   *
   * @schema ClassifierSpecInitProviderGrokClassifier#grokPattern
   */
  readonly grokPattern?: string;

}

/**
 * Converts an object of type 'ClassifierSpecInitProviderGrokClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecInitProviderGrokClassifier(obj: ClassifierSpecInitProviderGrokClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classification': obj.classification,
    'customPatterns': obj.customPatterns,
    'grokPattern': obj.grokPattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassifierSpecInitProviderJsonClassifier
 */
export interface ClassifierSpecInitProviderJsonClassifier {
  /**
   * A JsonPath string defining the JSON data for the classifier to classify. AWS Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers.
   *
   * @schema ClassifierSpecInitProviderJsonClassifier#jsonPath
   */
  readonly jsonPath?: string;

}

/**
 * Converts an object of type 'ClassifierSpecInitProviderJsonClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecInitProviderJsonClassifier(obj: ClassifierSpecInitProviderJsonClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClassifierSpecInitProviderXmlClassifier
 */
export interface ClassifierSpecInitProviderXmlClassifier {
  /**
   * An identifier of the data format that the classifier matches.
   *
   * @schema ClassifierSpecInitProviderXmlClassifier#classification
   */
  readonly classification?: string;

  /**
   * The XML tag designating the element that contains each record in an XML document being parsed. Note that this cannot identify a self-closing element (closed by />). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, <row item_a="A" item_b="B"></row> is okay, but <row item_a="A" item_b="B" /> is not).
   *
   * @schema ClassifierSpecInitProviderXmlClassifier#rowTag
   */
  readonly rowTag?: string;

}

/**
 * Converts an object of type 'ClassifierSpecInitProviderXmlClassifier' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecInitProviderXmlClassifier(obj: ClassifierSpecInitProviderXmlClassifier | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classification': obj.classification,
    'rowTag': obj.rowTag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClassifierSpecProviderConfigRefPolicy
 */
export interface ClassifierSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClassifierSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClassifierSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClassifierSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClassifierSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClassifierSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecProviderConfigRefPolicy(obj: ClassifierSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClassifierSpecPublishConnectionDetailsToConfigRef
 */
export interface ClassifierSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClassifierSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClassifierSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecPublishConnectionDetailsToConfigRef(obj: ClassifierSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClassifierSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClassifierSpecPublishConnectionDetailsToMetadata
 */
export interface ClassifierSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClassifierSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecPublishConnectionDetailsToMetadata(obj: ClassifierSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClassifierSpecProviderConfigRefPolicyResolution
 */
export enum ClassifierSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClassifierSpecProviderConfigRefPolicyResolve
 */
export enum ClassifierSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClassifierSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClassifierSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClassifierSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClassifierSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClassifierSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClassifierSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClassifierSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Connection is the Schema for the Connections API. Provides an Glue Connection resource.
 *
 * @schema Connection
 */
export class Connection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Connection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'Connection',
  }

  /**
   * Renders a Kubernetes manifest for "Connection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConnectionProps): any {
    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(props),
    };
  }

  /**
   * Defines a "Connection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConnectionProps) {
    super(scope, id, {
      ...Connection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(resolved),
    };
  }
}

/**
 * Connection is the Schema for the Connections API. Provides an Glue Connection resource.
 *
 * @schema Connection
 */
export interface ConnectionProps {
  /**
   * @schema Connection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConnectionSpec defines the desired state of Connection
   *
   * @schema Connection#spec
   */
  readonly spec: ConnectionSpec;

}

/**
 * Converts an object of type 'ConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProps(obj: ConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionSpec defines the desired state of Connection
 *
 * @schema ConnectionSpec
 */
export interface ConnectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConnectionSpecDeletionPolicy;

  /**
   * @schema ConnectionSpec#forProvider
   */
  readonly forProvider: ConnectionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ConnectionSpec#initProvider
   */
  readonly initProvider?: ConnectionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ConnectionSpec#managementPolicies
   */
  readonly managementPolicies?: ConnectionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConnectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConnectionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConnectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConnectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConnectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConnectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpec(obj: ConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConnectionSpecForProvider(obj.forProvider),
    'initProvider': toJson_ConnectionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ConnectionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ConnectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConnectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectionSpecDeletionPolicy
 */
export enum ConnectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConnectionSpecForProvider
 */
export interface ConnectionSpecForProvider {
  /**
   *   The ID of the Data Catalog in which to create the connection. If none is supplied, the AWS account ID is used by default.
   *
   * @schema ConnectionSpecForProvider#catalogId
   */
  readonly catalogId: string;

  /**
   * value pairs used as parameters for this connection.
   *
   * @schema ConnectionSpecForProvider#connectionPropertiesSecretRef
   */
  readonly connectionPropertiesSecretRef?: ConnectionSpecForProviderConnectionPropertiesSecretRef;

  /**
   *   The type of the connection. Supported are: CUSTOM, JDBC, KAFKA, MARKETPLACE, MONGODB, and NETWORK. Defaults to JBDC.
   *
   * @default JBDC.
   * @schema ConnectionSpecForProvider#connectionType
   */
  readonly connectionType?: string;

  /**
   *   Description of the connection.
   *
   * @schema ConnectionSpecForProvider#description
   */
  readonly description?: string;

  /**
   *   A list of criteria that can be used in selecting this connection.
   *
   * @schema ConnectionSpecForProvider#matchCriteria
   */
  readonly matchCriteria?: string[];

  /**
   * A map of physical connection requirements, such as VPC and SecurityGroup. Defined below.
   *
   * @schema ConnectionSpecForProvider#physicalConnectionRequirements
   */
  readonly physicalConnectionRequirements?: ConnectionSpecForProviderPhysicalConnectionRequirements[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConnectionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ConnectionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConnectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProvider(obj: ConnectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'connectionPropertiesSecretRef': toJson_ConnectionSpecForProviderConnectionPropertiesSecretRef(obj.connectionPropertiesSecretRef),
    'connectionType': obj.connectionType,
    'description': obj.description,
    'matchCriteria': obj.matchCriteria?.map(y => y),
    'physicalConnectionRequirements': obj.physicalConnectionRequirements?.map(y => toJson_ConnectionSpecForProviderPhysicalConnectionRequirements(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ConnectionSpecInitProvider
 */
export interface ConnectionSpecInitProvider {
  /**
   *   The type of the connection. Supported are: CUSTOM, JDBC, KAFKA, MARKETPLACE, MONGODB, and NETWORK. Defaults to JBDC.
   *
   * @default JBDC.
   * @schema ConnectionSpecInitProvider#connectionType
   */
  readonly connectionType?: string;

  /**
   *   Description of the connection.
   *
   * @schema ConnectionSpecInitProvider#description
   */
  readonly description?: string;

  /**
   *   A list of criteria that can be used in selecting this connection.
   *
   * @schema ConnectionSpecInitProvider#matchCriteria
   */
  readonly matchCriteria?: string[];

  /**
   * A map of physical connection requirements, such as VPC and SecurityGroup. Defined below.
   *
   * @schema ConnectionSpecInitProvider#physicalConnectionRequirements
   */
  readonly physicalConnectionRequirements?: ConnectionSpecInitProviderPhysicalConnectionRequirements[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ConnectionSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConnectionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecInitProvider(obj: ConnectionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionType': obj.connectionType,
    'description': obj.description,
    'matchCriteria': obj.matchCriteria?.map(y => y),
    'physicalConnectionRequirements': obj.physicalConnectionRequirements?.map(y => toJson_ConnectionSpecInitProviderPhysicalConnectionRequirements(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ConnectionSpecManagementPolicies
 */
export enum ConnectionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConnectionSpecProviderConfigRef
 */
export interface ConnectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecProviderConfigRef#policy
   */
  readonly policy?: ConnectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRef(obj: ConnectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConnectionSpecPublishConnectionDetailsTo
 */
export interface ConnectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConnectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConnectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsTo(obj: ConnectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConnectionSpecWriteConnectionSecretToRef
 */
export interface ConnectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecWriteConnectionSecretToRef(obj: ConnectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * value pairs used as parameters for this connection.
 *
 * @schema ConnectionSpecForProviderConnectionPropertiesSecretRef
 */
export interface ConnectionSpecForProviderConnectionPropertiesSecretRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecForProviderConnectionPropertiesSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecForProviderConnectionPropertiesSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectionPropertiesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectionPropertiesSecretRef(obj: ConnectionSpecForProviderConnectionPropertiesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirements
 */
export interface ConnectionSpecForProviderPhysicalConnectionRequirements {
  /**
   * The availability zone of the connection. This field is redundant and implied by subnet_id, but is currently an api requirement.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirements#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * Reference to a Subnet in ec2 to populate availabilityZone.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirements#availabilityZoneRef
   */
  readonly availabilityZoneRef?: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRef;

  /**
   * Selector for a Subnet in ec2 to populate availabilityZone.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirements#availabilityZoneSelector
   */
  readonly availabilityZoneSelector?: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelector;

  /**
   * The security group ID list used by the connection.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirements#securityGroupIdList
   */
  readonly securityGroupIdList?: string[];

  /**
   * The subnet ID used by the connection.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirements#subnetId
   */
  readonly subnetId?: string;

  /**
   * Reference to a Subnet in ec2 to populate subnetId.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirements#subnetIdRef
   */
  readonly subnetIdRef?: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRef;

  /**
   * Selector for a Subnet in ec2 to populate subnetId.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirements#subnetIdSelector
   */
  readonly subnetIdSelector?: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelector;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderPhysicalConnectionRequirements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderPhysicalConnectionRequirements(obj: ConnectionSpecForProviderPhysicalConnectionRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZone': obj.availabilityZone,
    'availabilityZoneRef': toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRef(obj.availabilityZoneRef),
    'availabilityZoneSelector': toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelector(obj.availabilityZoneSelector),
    'securityGroupIdList': obj.securityGroupIdList?.map(y => y),
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelector(obj.subnetIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectionSpecInitProviderPhysicalConnectionRequirements
 */
export interface ConnectionSpecInitProviderPhysicalConnectionRequirements {
  /**
   * The security group ID list used by the connection.
   *
   * @schema ConnectionSpecInitProviderPhysicalConnectionRequirements#securityGroupIdList
   */
  readonly securityGroupIdList?: string[];

}

/**
 * Converts an object of type 'ConnectionSpecInitProviderPhysicalConnectionRequirements' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecInitProviderPhysicalConnectionRequirements(obj: ConnectionSpecInitProviderPhysicalConnectionRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIdList': obj.securityGroupIdList?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecProviderConfigRefPolicy
 */
export interface ConnectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRefPolicy(obj: ConnectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRef
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj: ConnectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToMetadata
 */
export interface ConnectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj: ConnectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate availabilityZone.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRef
 */
export interface ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRef#policy
   */
  readonly policy?: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRef(obj: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate availabilityZone.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelector
 */
export interface ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelector#policy
   */
  readonly policy?: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelector(obj: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate subnetId.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRef
 */
export interface ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRef#policy
   */
  readonly policy?: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRef(obj: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate subnetId.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelector
 */
export interface ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelector#policy
   */
  readonly policy?: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelector(obj: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolution
 */
export enum ConnectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolve
 */
export enum ConnectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicy
 */
export interface ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicy(obj: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicy
 */
export interface ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicy(obj: ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicy
 */
export interface ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicy(obj: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicy
 */
export interface ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicy(obj: ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicyResolution
 */
export enum ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicyResolve
 */
export enum ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicyResolution
 */
export enum ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicyResolve
 */
export enum ConnectionSpecForProviderPhysicalConnectionRequirementsAvailabilityZoneSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicyResolution
 */
export enum ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicyResolve
 */
export enum ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolution
 */
export enum ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolve
 */
export enum ConnectionSpecForProviderPhysicalConnectionRequirementsSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Crawler is the Schema for the Crawlers API. Manages a Glue Crawler
 *
 * @schema Crawler
 */
export class Crawler extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Crawler"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'Crawler',
  }

  /**
   * Renders a Kubernetes manifest for "Crawler".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CrawlerProps): any {
    return {
      ...Crawler.GVK,
      ...toJson_CrawlerProps(props),
    };
  }

  /**
   * Defines a "Crawler" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CrawlerProps) {
    super(scope, id, {
      ...Crawler.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Crawler.GVK,
      ...toJson_CrawlerProps(resolved),
    };
  }
}

/**
 * Crawler is the Schema for the Crawlers API. Manages a Glue Crawler
 *
 * @schema Crawler
 */
export interface CrawlerProps {
  /**
   * @schema Crawler#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CrawlerSpec defines the desired state of Crawler
   *
   * @schema Crawler#spec
   */
  readonly spec: CrawlerSpec;

}

/**
 * Converts an object of type 'CrawlerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerProps(obj: CrawlerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CrawlerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CrawlerSpec defines the desired state of Crawler
 *
 * @schema CrawlerSpec
 */
export interface CrawlerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CrawlerSpec#deletionPolicy
   */
  readonly deletionPolicy?: CrawlerSpecDeletionPolicy;

  /**
   * @schema CrawlerSpec#forProvider
   */
  readonly forProvider: CrawlerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CrawlerSpec#initProvider
   */
  readonly initProvider?: CrawlerSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CrawlerSpec#managementPolicies
   */
  readonly managementPolicies?: CrawlerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CrawlerSpec#providerConfigRef
   */
  readonly providerConfigRef?: CrawlerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CrawlerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CrawlerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CrawlerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CrawlerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CrawlerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpec(obj: CrawlerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CrawlerSpecForProvider(obj.forProvider),
    'initProvider': toJson_CrawlerSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CrawlerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CrawlerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CrawlerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CrawlerSpecDeletionPolicy
 */
export enum CrawlerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CrawlerSpecForProvider
 */
export interface CrawlerSpecForProvider {
  /**
   * @schema CrawlerSpecForProvider#catalogTarget
   */
  readonly catalogTarget?: CrawlerSpecForProviderCatalogTarget[];

  /**
   * List of custom classifiers. By default, all AWS classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
   *
   * @schema CrawlerSpecForProvider#classifiers
   */
  readonly classifiers?: string[];

  /**
   * JSON string of configuration information. For more details see Setting Crawler Configuration Options.
   *
   * @schema CrawlerSpecForProvider#configuration
   */
  readonly configuration?: string;

  /**
   * Glue database where results are written.
   *
   * @schema CrawlerSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * Reference to a CatalogDatabase in glue to populate databaseName.
   *
   * @schema CrawlerSpecForProvider#databaseNameRef
   */
  readonly databaseNameRef?: CrawlerSpecForProviderDatabaseNameRef;

  /**
   * Selector for a CatalogDatabase in glue to populate databaseName.
   *
   * @schema CrawlerSpecForProvider#databaseNameSelector
   */
  readonly databaseNameSelector?: CrawlerSpecForProviderDatabaseNameSelector;

  /**
   * @schema CrawlerSpecForProvider#deltaTarget
   */
  readonly deltaTarget?: CrawlerSpecForProviderDeltaTarget[];

  /**
   * Description of the crawler.
   *
   * @schema CrawlerSpecForProvider#description
   */
  readonly description?: string;

  /**
   * List of nested DynamoDB target arguments. See Dynamodb Target below.
   *
   * @schema CrawlerSpecForProvider#dynamodbTarget
   */
  readonly dynamodbTarget?: CrawlerSpecForProviderDynamodbTarget[];

  /**
   * List of nested JBDC target arguments. See JDBC Target below.
   *
   * @schema CrawlerSpecForProvider#jdbcTarget
   */
  readonly jdbcTarget?: CrawlerSpecForProviderJdbcTarget[];

  /**
   * Specifies Lake Formation configuration settings for the crawler. See Lake Formation Configuration below.
   *
   * @schema CrawlerSpecForProvider#lakeFormationConfiguration
   */
  readonly lakeFormationConfiguration?: CrawlerSpecForProviderLakeFormationConfiguration[];

  /**
   * Specifies data lineage configuration settings for the crawler. See Lineage Configuration below.
   *
   * @schema CrawlerSpecForProvider#lineageConfiguration
   */
  readonly lineageConfiguration?: CrawlerSpecForProviderLineageConfiguration[];

  /**
   * List nested MongoDB target arguments. See MongoDB Target below.
   *
   * @schema CrawlerSpecForProvider#mongodbTarget
   */
  readonly mongodbTarget?: CrawlerSpecForProviderMongodbTarget[];

  /**
   * A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.. See Recrawl Policy below.
   *
   * @schema CrawlerSpecForProvider#recrawlPolicy
   */
  readonly recrawlPolicy?: CrawlerSpecForProviderRecrawlPolicy[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CrawlerSpecForProvider#region
   */
  readonly region: string;

  /**
   * The IAM role friendly name (including path without leading slash), or ARN of an IAM role, used by the crawler to access other resources.
   *
   * @schema CrawlerSpecForProvider#role
   */
  readonly role?: string;

  /**
   * Reference to a Role in iam to populate role.
   *
   * @schema CrawlerSpecForProvider#roleRef
   */
  readonly roleRef?: CrawlerSpecForProviderRoleRef;

  /**
   * Selector for a Role in iam to populate role.
   *
   * @schema CrawlerSpecForProvider#roleSelector
   */
  readonly roleSelector?: CrawlerSpecForProviderRoleSelector;

  /**
   * List nested Amazon S3 target arguments. See S3 Target below.
   *
   * @schema CrawlerSpecForProvider#s3Target
   */
  readonly s3Target?: CrawlerSpecForProviderS3Target[];

  /**
   * Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
   *
   * @schema CrawlerSpecForProvider#schedule
   */
  readonly schedule?: string;

  /**
   * Policy for the crawler's update and deletion behavior. See Schema Change Policy below.
   *
   * @schema CrawlerSpecForProvider#schemaChangePolicy
   */
  readonly schemaChangePolicy?: CrawlerSpecForProviderSchemaChangePolicy[];

  /**
   * The name of Security Configuration to be used by the crawler
   *
   * @schema CrawlerSpecForProvider#securityConfiguration
   */
  readonly securityConfiguration?: string;

  /**
   * The table prefix used for catalog tables that are created.
   *
   * @schema CrawlerSpecForProvider#tablePrefix
   */
  readonly tablePrefix?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema CrawlerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CrawlerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProvider(obj: CrawlerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogTarget': obj.catalogTarget?.map(y => toJson_CrawlerSpecForProviderCatalogTarget(y)),
    'classifiers': obj.classifiers?.map(y => y),
    'configuration': obj.configuration,
    'databaseName': obj.databaseName,
    'databaseNameRef': toJson_CrawlerSpecForProviderDatabaseNameRef(obj.databaseNameRef),
    'databaseNameSelector': toJson_CrawlerSpecForProviderDatabaseNameSelector(obj.databaseNameSelector),
    'deltaTarget': obj.deltaTarget?.map(y => toJson_CrawlerSpecForProviderDeltaTarget(y)),
    'description': obj.description,
    'dynamodbTarget': obj.dynamodbTarget?.map(y => toJson_CrawlerSpecForProviderDynamodbTarget(y)),
    'jdbcTarget': obj.jdbcTarget?.map(y => toJson_CrawlerSpecForProviderJdbcTarget(y)),
    'lakeFormationConfiguration': obj.lakeFormationConfiguration?.map(y => toJson_CrawlerSpecForProviderLakeFormationConfiguration(y)),
    'lineageConfiguration': obj.lineageConfiguration?.map(y => toJson_CrawlerSpecForProviderLineageConfiguration(y)),
    'mongodbTarget': obj.mongodbTarget?.map(y => toJson_CrawlerSpecForProviderMongodbTarget(y)),
    'recrawlPolicy': obj.recrawlPolicy?.map(y => toJson_CrawlerSpecForProviderRecrawlPolicy(y)),
    'region': obj.region,
    'role': obj.role,
    'roleRef': toJson_CrawlerSpecForProviderRoleRef(obj.roleRef),
    'roleSelector': toJson_CrawlerSpecForProviderRoleSelector(obj.roleSelector),
    's3Target': obj.s3Target?.map(y => toJson_CrawlerSpecForProviderS3Target(y)),
    'schedule': obj.schedule,
    'schemaChangePolicy': obj.schemaChangePolicy?.map(y => toJson_CrawlerSpecForProviderSchemaChangePolicy(y)),
    'securityConfiguration': obj.securityConfiguration,
    'tablePrefix': obj.tablePrefix,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CrawlerSpecInitProvider
 */
export interface CrawlerSpecInitProvider {
  /**
   * @schema CrawlerSpecInitProvider#catalogTarget
   */
  readonly catalogTarget?: CrawlerSpecInitProviderCatalogTarget[];

  /**
   * List of custom classifiers. By default, all AWS classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
   *
   * @schema CrawlerSpecInitProvider#classifiers
   */
  readonly classifiers?: string[];

  /**
   * JSON string of configuration information. For more details see Setting Crawler Configuration Options.
   *
   * @schema CrawlerSpecInitProvider#configuration
   */
  readonly configuration?: string;

  /**
   * @schema CrawlerSpecInitProvider#deltaTarget
   */
  readonly deltaTarget?: CrawlerSpecInitProviderDeltaTarget[];

  /**
   * Description of the crawler.
   *
   * @schema CrawlerSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * List of nested DynamoDB target arguments. See Dynamodb Target below.
   *
   * @schema CrawlerSpecInitProvider#dynamodbTarget
   */
  readonly dynamodbTarget?: CrawlerSpecInitProviderDynamodbTarget[];

  /**
   * List of nested JBDC target arguments. See JDBC Target below.
   *
   * @schema CrawlerSpecInitProvider#jdbcTarget
   */
  readonly jdbcTarget?: CrawlerSpecInitProviderJdbcTarget[];

  /**
   * Specifies Lake Formation configuration settings for the crawler. See Lake Formation Configuration below.
   *
   * @schema CrawlerSpecInitProvider#lakeFormationConfiguration
   */
  readonly lakeFormationConfiguration?: CrawlerSpecInitProviderLakeFormationConfiguration[];

  /**
   * Specifies data lineage configuration settings for the crawler. See Lineage Configuration below.
   *
   * @schema CrawlerSpecInitProvider#lineageConfiguration
   */
  readonly lineageConfiguration?: CrawlerSpecInitProviderLineageConfiguration[];

  /**
   * List nested MongoDB target arguments. See MongoDB Target below.
   *
   * @schema CrawlerSpecInitProvider#mongodbTarget
   */
  readonly mongodbTarget?: CrawlerSpecInitProviderMongodbTarget[];

  /**
   * A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.. See Recrawl Policy below.
   *
   * @schema CrawlerSpecInitProvider#recrawlPolicy
   */
  readonly recrawlPolicy?: CrawlerSpecInitProviderRecrawlPolicy[];

  /**
   * List nested Amazon S3 target arguments. See S3 Target below.
   *
   * @schema CrawlerSpecInitProvider#s3Target
   */
  readonly s3Target?: CrawlerSpecInitProviderS3Target[];

  /**
   * Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
   *
   * @schema CrawlerSpecInitProvider#schedule
   */
  readonly schedule?: string;

  /**
   * Policy for the crawler's update and deletion behavior. See Schema Change Policy below.
   *
   * @schema CrawlerSpecInitProvider#schemaChangePolicy
   */
  readonly schemaChangePolicy?: CrawlerSpecInitProviderSchemaChangePolicy[];

  /**
   * The name of Security Configuration to be used by the crawler
   *
   * @schema CrawlerSpecInitProvider#securityConfiguration
   */
  readonly securityConfiguration?: string;

  /**
   * The table prefix used for catalog tables that are created.
   *
   * @schema CrawlerSpecInitProvider#tablePrefix
   */
  readonly tablePrefix?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema CrawlerSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CrawlerSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecInitProvider(obj: CrawlerSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogTarget': obj.catalogTarget?.map(y => toJson_CrawlerSpecInitProviderCatalogTarget(y)),
    'classifiers': obj.classifiers?.map(y => y),
    'configuration': obj.configuration,
    'deltaTarget': obj.deltaTarget?.map(y => toJson_CrawlerSpecInitProviderDeltaTarget(y)),
    'description': obj.description,
    'dynamodbTarget': obj.dynamodbTarget?.map(y => toJson_CrawlerSpecInitProviderDynamodbTarget(y)),
    'jdbcTarget': obj.jdbcTarget?.map(y => toJson_CrawlerSpecInitProviderJdbcTarget(y)),
    'lakeFormationConfiguration': obj.lakeFormationConfiguration?.map(y => toJson_CrawlerSpecInitProviderLakeFormationConfiguration(y)),
    'lineageConfiguration': obj.lineageConfiguration?.map(y => toJson_CrawlerSpecInitProviderLineageConfiguration(y)),
    'mongodbTarget': obj.mongodbTarget?.map(y => toJson_CrawlerSpecInitProviderMongodbTarget(y)),
    'recrawlPolicy': obj.recrawlPolicy?.map(y => toJson_CrawlerSpecInitProviderRecrawlPolicy(y)),
    's3Target': obj.s3Target?.map(y => toJson_CrawlerSpecInitProviderS3Target(y)),
    'schedule': obj.schedule,
    'schemaChangePolicy': obj.schemaChangePolicy?.map(y => toJson_CrawlerSpecInitProviderSchemaChangePolicy(y)),
    'securityConfiguration': obj.securityConfiguration,
    'tablePrefix': obj.tablePrefix,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CrawlerSpecManagementPolicies
 */
export enum CrawlerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CrawlerSpecProviderConfigRef
 */
export interface CrawlerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecProviderConfigRef#policy
   */
  readonly policy?: CrawlerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecProviderConfigRef(obj: CrawlerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CrawlerSpecPublishConnectionDetailsTo
 */
export interface CrawlerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CrawlerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CrawlerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CrawlerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CrawlerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CrawlerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CrawlerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecPublishConnectionDetailsTo(obj: CrawlerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CrawlerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CrawlerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CrawlerSpecWriteConnectionSecretToRef
 */
export interface CrawlerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CrawlerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CrawlerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CrawlerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecWriteConnectionSecretToRef(obj: CrawlerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecForProviderCatalogTarget
 */
export interface CrawlerSpecForProviderCatalogTarget {
  /**
   * The name of the connection to use to connect to the JDBC target.
   *
   * @schema CrawlerSpecForProviderCatalogTarget#connectionName
   */
  readonly connectionName?: string;

  /**
   * Glue database where results are written.
   *
   * @schema CrawlerSpecForProviderCatalogTarget#databaseName
   */
  readonly databaseName?: string;

  /**
   * Reference to a CatalogDatabase in glue to populate databaseName.
   *
   * @schema CrawlerSpecForProviderCatalogTarget#databaseNameRef
   */
  readonly databaseNameRef?: CrawlerSpecForProviderCatalogTargetDatabaseNameRef;

  /**
   * Selector for a CatalogDatabase in glue to populate databaseName.
   *
   * @schema CrawlerSpecForProviderCatalogTarget#databaseNameSelector
   */
  readonly databaseNameSelector?: CrawlerSpecForProviderCatalogTargetDatabaseNameSelector;

  /**
   * The ARN of the dead-letter SQS queue.
   *
   * @schema CrawlerSpecForProviderCatalogTarget#dlqEventQueueArn
   */
  readonly dlqEventQueueArn?: string;

  /**
   * The ARN of the SQS queue to receive S3 notifications from.
   *
   * @schema CrawlerSpecForProviderCatalogTarget#eventQueueArn
   */
  readonly eventQueueArn?: string;

  /**
   * A list of catalog tables to be synchronized.
   *
   * @schema CrawlerSpecForProviderCatalogTarget#tables
   */
  readonly tables?: string[];

}

/**
 * Converts an object of type 'CrawlerSpecForProviderCatalogTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderCatalogTarget(obj: CrawlerSpecForProviderCatalogTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'databaseName': obj.databaseName,
    'databaseNameRef': toJson_CrawlerSpecForProviderCatalogTargetDatabaseNameRef(obj.databaseNameRef),
    'databaseNameSelector': toJson_CrawlerSpecForProviderCatalogTargetDatabaseNameSelector(obj.databaseNameSelector),
    'dlqEventQueueArn': obj.dlqEventQueueArn,
    'eventQueueArn': obj.eventQueueArn,
    'tables': obj.tables?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CatalogDatabase in glue to populate databaseName.
 *
 * @schema CrawlerSpecForProviderDatabaseNameRef
 */
export interface CrawlerSpecForProviderDatabaseNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderDatabaseNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderDatabaseNameRef#policy
   */
  readonly policy?: CrawlerSpecForProviderDatabaseNameRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderDatabaseNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderDatabaseNameRef(obj: CrawlerSpecForProviderDatabaseNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderDatabaseNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CatalogDatabase in glue to populate databaseName.
 *
 * @schema CrawlerSpecForProviderDatabaseNameSelector
 */
export interface CrawlerSpecForProviderDatabaseNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderDatabaseNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderDatabaseNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderDatabaseNameSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderDatabaseNameSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderDatabaseNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderDatabaseNameSelector(obj: CrawlerSpecForProviderDatabaseNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderDatabaseNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecForProviderDeltaTarget
 */
export interface CrawlerSpecForProviderDeltaTarget {
  /**
   * The name of the connection to use to connect to the JDBC target.
   *
   * @schema CrawlerSpecForProviderDeltaTarget#connectionName
   */
  readonly connectionName?: string;

  /**
   * Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.
   *
   * @schema CrawlerSpecForProviderDeltaTarget#createNativeDeltaTable
   */
  readonly createNativeDeltaTable?: boolean;

  /**
   * A list of the Amazon S3 paths to the Delta tables.
   *
   * @schema CrawlerSpecForProviderDeltaTarget#deltaTables
   */
  readonly deltaTables?: string[];

  /**
   * Specifies whether to write the manifest files to the Delta table path.
   *
   * @schema CrawlerSpecForProviderDeltaTarget#writeManifest
   */
  readonly writeManifest?: boolean;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderDeltaTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderDeltaTarget(obj: CrawlerSpecForProviderDeltaTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'createNativeDeltaTable': obj.createNativeDeltaTable,
    'deltaTables': obj.deltaTables?.map(y => y),
    'writeManifest': obj.writeManifest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecForProviderDynamodbTarget
 */
export interface CrawlerSpecForProviderDynamodbTarget {
  /**
   * The name of the DynamoDB table to crawl.
   *
   * @schema CrawlerSpecForProviderDynamodbTarget#path
   */
  readonly path?: string;

  /**
   * Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to true.
   *
   * @schema CrawlerSpecForProviderDynamodbTarget#scanAll
   */
  readonly scanAll?: boolean;

  /**
   * The percentage of the configured read capacity units to use by the AWS Glue crawler. The valid values are null or a value between 0.1 to 1.5.
   *
   * @schema CrawlerSpecForProviderDynamodbTarget#scanRate
   */
  readonly scanRate?: number;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderDynamodbTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderDynamodbTarget(obj: CrawlerSpecForProviderDynamodbTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'scanAll': obj.scanAll,
    'scanRate': obj.scanRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecForProviderJdbcTarget
 */
export interface CrawlerSpecForProviderJdbcTarget {
  /**
   * The name of the connection to use to connect to the JDBC target.
   *
   * @schema CrawlerSpecForProviderJdbcTarget#connectionName
   */
  readonly connectionName?: string;

  /**
   * Reference to a Connection in glue to populate connectionName.
   *
   * @schema CrawlerSpecForProviderJdbcTarget#connectionNameRef
   */
  readonly connectionNameRef?: CrawlerSpecForProviderJdbcTargetConnectionNameRef;

  /**
   * Selector for a Connection in glue to populate connectionName.
   *
   * @schema CrawlerSpecForProviderJdbcTarget#connectionNameSelector
   */
  readonly connectionNameSelector?: CrawlerSpecForProviderJdbcTargetConnectionNameSelector;

  /**
   * Specify a value of RAWTYPES or COMMENTS to enable additional metadata intable responses. RAWTYPES provides the native-level datatype. COMMENTS provides comments associated with a column or table in the database.
   *
   * @schema CrawlerSpecForProviderJdbcTarget#enableAdditionalMetadata
   */
  readonly enableAdditionalMetadata?: string[];

  /**
   * A list of glob patterns used to exclude from the crawl.
   *
   * @schema CrawlerSpecForProviderJdbcTarget#exclusions
   */
  readonly exclusions?: string[];

  /**
   * The name of the DynamoDB table to crawl.
   *
   * @schema CrawlerSpecForProviderJdbcTarget#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderJdbcTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderJdbcTarget(obj: CrawlerSpecForProviderJdbcTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'connectionNameRef': toJson_CrawlerSpecForProviderJdbcTargetConnectionNameRef(obj.connectionNameRef),
    'connectionNameSelector': toJson_CrawlerSpecForProviderJdbcTargetConnectionNameSelector(obj.connectionNameSelector),
    'enableAdditionalMetadata': obj.enableAdditionalMetadata?.map(y => y),
    'exclusions': obj.exclusions?.map(y => y),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecForProviderLakeFormationConfiguration
 */
export interface CrawlerSpecForProviderLakeFormationConfiguration {
  /**
   * Required for cross account crawls. For same account crawls as the target data, this can omitted.
   *
   * @schema CrawlerSpecForProviderLakeFormationConfiguration#accountId
   */
  readonly accountId?: string;

  /**
   * Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.
   *
   * @schema CrawlerSpecForProviderLakeFormationConfiguration#useLakeFormationCredentials
   */
  readonly useLakeFormationCredentials?: boolean;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderLakeFormationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderLakeFormationConfiguration(obj: CrawlerSpecForProviderLakeFormationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'useLakeFormationCredentials': obj.useLakeFormationCredentials,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecForProviderLineageConfiguration
 */
export interface CrawlerSpecForProviderLineageConfiguration {
  /**
   * Specifies whether data lineage is enabled for the crawler. Valid values are: ENABLE and DISABLE. Default value is Disable.
   *
   * @schema CrawlerSpecForProviderLineageConfiguration#crawlerLineageSettings
   */
  readonly crawlerLineageSettings?: string;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderLineageConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderLineageConfiguration(obj: CrawlerSpecForProviderLineageConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crawlerLineageSettings': obj.crawlerLineageSettings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecForProviderMongodbTarget
 */
export interface CrawlerSpecForProviderMongodbTarget {
  /**
   * The name of the connection to use to connect to the JDBC target.
   *
   * @schema CrawlerSpecForProviderMongodbTarget#connectionName
   */
  readonly connectionName?: string;

  /**
   * Reference to a Connection in glue to populate connectionName.
   *
   * @schema CrawlerSpecForProviderMongodbTarget#connectionNameRef
   */
  readonly connectionNameRef?: CrawlerSpecForProviderMongodbTargetConnectionNameRef;

  /**
   * Selector for a Connection in glue to populate connectionName.
   *
   * @schema CrawlerSpecForProviderMongodbTarget#connectionNameSelector
   */
  readonly connectionNameSelector?: CrawlerSpecForProviderMongodbTargetConnectionNameSelector;

  /**
   * The name of the DynamoDB table to crawl.
   *
   * @schema CrawlerSpecForProviderMongodbTarget#path
   */
  readonly path?: string;

  /**
   * Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to true.
   *
   * @schema CrawlerSpecForProviderMongodbTarget#scanAll
   */
  readonly scanAll?: boolean;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderMongodbTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderMongodbTarget(obj: CrawlerSpecForProviderMongodbTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'connectionNameRef': toJson_CrawlerSpecForProviderMongodbTargetConnectionNameRef(obj.connectionNameRef),
    'connectionNameSelector': toJson_CrawlerSpecForProviderMongodbTargetConnectionNameSelector(obj.connectionNameSelector),
    'path': obj.path,
    'scanAll': obj.scanAll,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecForProviderRecrawlPolicy
 */
export interface CrawlerSpecForProviderRecrawlPolicy {
  /**
   * Specifies whether to crawl the entire dataset again, crawl only folders that were added since the last crawler run, or crawl what S3 notifies the crawler of via SQS. Valid Values are: CRAWL_EVENT_MODE, CRAWL_EVERYTHING and CRAWL_NEW_FOLDERS_ONLY. Default value is CRAWL_EVERYTHING.
   *
   * @schema CrawlerSpecForProviderRecrawlPolicy#recrawlBehavior
   */
  readonly recrawlBehavior?: string;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderRecrawlPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderRecrawlPolicy(obj: CrawlerSpecForProviderRecrawlPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recrawlBehavior': obj.recrawlBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate role.
 *
 * @schema CrawlerSpecForProviderRoleRef
 */
export interface CrawlerSpecForProviderRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderRoleRef#policy
   */
  readonly policy?: CrawlerSpecForProviderRoleRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderRoleRef(obj: CrawlerSpecForProviderRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate role.
 *
 * @schema CrawlerSpecForProviderRoleSelector
 */
export interface CrawlerSpecForProviderRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderRoleSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderRoleSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderRoleSelector(obj: CrawlerSpecForProviderRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecForProviderS3Target
 */
export interface CrawlerSpecForProviderS3Target {
  /**
   * The name of the connection to use to connect to the JDBC target.
   *
   * @schema CrawlerSpecForProviderS3Target#connectionName
   */
  readonly connectionName?: string;

  /**
   * The ARN of the dead-letter SQS queue.
   *
   * @schema CrawlerSpecForProviderS3Target#dlqEventQueueArn
   */
  readonly dlqEventQueueArn?: string;

  /**
   * The ARN of the SQS queue to receive S3 notifications from.
   *
   * @schema CrawlerSpecForProviderS3Target#eventQueueArn
   */
  readonly eventQueueArn?: string;

  /**
   * A list of glob patterns used to exclude from the crawl.
   *
   * @schema CrawlerSpecForProviderS3Target#exclusions
   */
  readonly exclusions?: string[];

  /**
   * The name of the DynamoDB table to crawl.
   *
   * @schema CrawlerSpecForProviderS3Target#path
   */
  readonly path?: string;

  /**
   * Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
   *
   * @schema CrawlerSpecForProviderS3Target#sampleSize
   */
  readonly sampleSize?: number;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderS3Target' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderS3Target(obj: CrawlerSpecForProviderS3Target | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'dlqEventQueueArn': obj.dlqEventQueueArn,
    'eventQueueArn': obj.eventQueueArn,
    'exclusions': obj.exclusions?.map(y => y),
    'path': obj.path,
    'sampleSize': obj.sampleSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecForProviderSchemaChangePolicy
 */
export interface CrawlerSpecForProviderSchemaChangePolicy {
  /**
   * The deletion behavior when the crawler finds a deleted object. Valid values: LOG, DELETE_FROM_DATABASE, or DEPRECATE_IN_DATABASE. Defaults to DEPRECATE_IN_DATABASE.
   *
   * @default DEPRECATE_IN_DATABASE.
   * @schema CrawlerSpecForProviderSchemaChangePolicy#deleteBehavior
   */
  readonly deleteBehavior?: string;

  /**
   * The update behavior when the crawler finds a changed schema. Valid values: LOG or UPDATE_IN_DATABASE. Defaults to UPDATE_IN_DATABASE.
   *
   * @default UPDATE_IN_DATABASE.
   * @schema CrawlerSpecForProviderSchemaChangePolicy#updateBehavior
   */
  readonly updateBehavior?: string;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderSchemaChangePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderSchemaChangePolicy(obj: CrawlerSpecForProviderSchemaChangePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteBehavior': obj.deleteBehavior,
    'updateBehavior': obj.updateBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecInitProviderCatalogTarget
 */
export interface CrawlerSpecInitProviderCatalogTarget {
  /**
   * The name of the connection to use to connect to the JDBC target.
   *
   * @schema CrawlerSpecInitProviderCatalogTarget#connectionName
   */
  readonly connectionName?: string;

  /**
   * The ARN of the dead-letter SQS queue.
   *
   * @schema CrawlerSpecInitProviderCatalogTarget#dlqEventQueueArn
   */
  readonly dlqEventQueueArn?: string;

  /**
   * The ARN of the SQS queue to receive S3 notifications from.
   *
   * @schema CrawlerSpecInitProviderCatalogTarget#eventQueueArn
   */
  readonly eventQueueArn?: string;

  /**
   * A list of catalog tables to be synchronized.
   *
   * @schema CrawlerSpecInitProviderCatalogTarget#tables
   */
  readonly tables?: string[];

}

/**
 * Converts an object of type 'CrawlerSpecInitProviderCatalogTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecInitProviderCatalogTarget(obj: CrawlerSpecInitProviderCatalogTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'dlqEventQueueArn': obj.dlqEventQueueArn,
    'eventQueueArn': obj.eventQueueArn,
    'tables': obj.tables?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecInitProviderDeltaTarget
 */
export interface CrawlerSpecInitProviderDeltaTarget {
  /**
   * The name of the connection to use to connect to the JDBC target.
   *
   * @schema CrawlerSpecInitProviderDeltaTarget#connectionName
   */
  readonly connectionName?: string;

  /**
   * Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.
   *
   * @schema CrawlerSpecInitProviderDeltaTarget#createNativeDeltaTable
   */
  readonly createNativeDeltaTable?: boolean;

  /**
   * A list of the Amazon S3 paths to the Delta tables.
   *
   * @schema CrawlerSpecInitProviderDeltaTarget#deltaTables
   */
  readonly deltaTables?: string[];

  /**
   * Specifies whether to write the manifest files to the Delta table path.
   *
   * @schema CrawlerSpecInitProviderDeltaTarget#writeManifest
   */
  readonly writeManifest?: boolean;

}

/**
 * Converts an object of type 'CrawlerSpecInitProviderDeltaTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecInitProviderDeltaTarget(obj: CrawlerSpecInitProviderDeltaTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'createNativeDeltaTable': obj.createNativeDeltaTable,
    'deltaTables': obj.deltaTables?.map(y => y),
    'writeManifest': obj.writeManifest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecInitProviderDynamodbTarget
 */
export interface CrawlerSpecInitProviderDynamodbTarget {
  /**
   * The name of the DynamoDB table to crawl.
   *
   * @schema CrawlerSpecInitProviderDynamodbTarget#path
   */
  readonly path?: string;

  /**
   * Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to true.
   *
   * @schema CrawlerSpecInitProviderDynamodbTarget#scanAll
   */
  readonly scanAll?: boolean;

  /**
   * The percentage of the configured read capacity units to use by the AWS Glue crawler. The valid values are null or a value between 0.1 to 1.5.
   *
   * @schema CrawlerSpecInitProviderDynamodbTarget#scanRate
   */
  readonly scanRate?: number;

}

/**
 * Converts an object of type 'CrawlerSpecInitProviderDynamodbTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecInitProviderDynamodbTarget(obj: CrawlerSpecInitProviderDynamodbTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'scanAll': obj.scanAll,
    'scanRate': obj.scanRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecInitProviderJdbcTarget
 */
export interface CrawlerSpecInitProviderJdbcTarget {
  /**
   * Specify a value of RAWTYPES or COMMENTS to enable additional metadata intable responses. RAWTYPES provides the native-level datatype. COMMENTS provides comments associated with a column or table in the database.
   *
   * @schema CrawlerSpecInitProviderJdbcTarget#enableAdditionalMetadata
   */
  readonly enableAdditionalMetadata?: string[];

  /**
   * A list of glob patterns used to exclude from the crawl.
   *
   * @schema CrawlerSpecInitProviderJdbcTarget#exclusions
   */
  readonly exclusions?: string[];

  /**
   * The name of the DynamoDB table to crawl.
   *
   * @schema CrawlerSpecInitProviderJdbcTarget#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'CrawlerSpecInitProviderJdbcTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecInitProviderJdbcTarget(obj: CrawlerSpecInitProviderJdbcTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableAdditionalMetadata': obj.enableAdditionalMetadata?.map(y => y),
    'exclusions': obj.exclusions?.map(y => y),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecInitProviderLakeFormationConfiguration
 */
export interface CrawlerSpecInitProviderLakeFormationConfiguration {
  /**
   * Required for cross account crawls. For same account crawls as the target data, this can omitted.
   *
   * @schema CrawlerSpecInitProviderLakeFormationConfiguration#accountId
   */
  readonly accountId?: string;

  /**
   * Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.
   *
   * @schema CrawlerSpecInitProviderLakeFormationConfiguration#useLakeFormationCredentials
   */
  readonly useLakeFormationCredentials?: boolean;

}

/**
 * Converts an object of type 'CrawlerSpecInitProviderLakeFormationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecInitProviderLakeFormationConfiguration(obj: CrawlerSpecInitProviderLakeFormationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'useLakeFormationCredentials': obj.useLakeFormationCredentials,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecInitProviderLineageConfiguration
 */
export interface CrawlerSpecInitProviderLineageConfiguration {
  /**
   * Specifies whether data lineage is enabled for the crawler. Valid values are: ENABLE and DISABLE. Default value is Disable.
   *
   * @schema CrawlerSpecInitProviderLineageConfiguration#crawlerLineageSettings
   */
  readonly crawlerLineageSettings?: string;

}

/**
 * Converts an object of type 'CrawlerSpecInitProviderLineageConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecInitProviderLineageConfiguration(obj: CrawlerSpecInitProviderLineageConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crawlerLineageSettings': obj.crawlerLineageSettings,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecInitProviderMongodbTarget
 */
export interface CrawlerSpecInitProviderMongodbTarget {
  /**
   * The name of the DynamoDB table to crawl.
   *
   * @schema CrawlerSpecInitProviderMongodbTarget#path
   */
  readonly path?: string;

  /**
   * Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table.  defaults to true.
   *
   * @schema CrawlerSpecInitProviderMongodbTarget#scanAll
   */
  readonly scanAll?: boolean;

}

/**
 * Converts an object of type 'CrawlerSpecInitProviderMongodbTarget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecInitProviderMongodbTarget(obj: CrawlerSpecInitProviderMongodbTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'scanAll': obj.scanAll,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecInitProviderRecrawlPolicy
 */
export interface CrawlerSpecInitProviderRecrawlPolicy {
  /**
   * Specifies whether to crawl the entire dataset again, crawl only folders that were added since the last crawler run, or crawl what S3 notifies the crawler of via SQS. Valid Values are: CRAWL_EVENT_MODE, CRAWL_EVERYTHING and CRAWL_NEW_FOLDERS_ONLY. Default value is CRAWL_EVERYTHING.
   *
   * @schema CrawlerSpecInitProviderRecrawlPolicy#recrawlBehavior
   */
  readonly recrawlBehavior?: string;

}

/**
 * Converts an object of type 'CrawlerSpecInitProviderRecrawlPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecInitProviderRecrawlPolicy(obj: CrawlerSpecInitProviderRecrawlPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recrawlBehavior': obj.recrawlBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecInitProviderS3Target
 */
export interface CrawlerSpecInitProviderS3Target {
  /**
   * The name of the connection to use to connect to the JDBC target.
   *
   * @schema CrawlerSpecInitProviderS3Target#connectionName
   */
  readonly connectionName?: string;

  /**
   * The ARN of the dead-letter SQS queue.
   *
   * @schema CrawlerSpecInitProviderS3Target#dlqEventQueueArn
   */
  readonly dlqEventQueueArn?: string;

  /**
   * The ARN of the SQS queue to receive S3 notifications from.
   *
   * @schema CrawlerSpecInitProviderS3Target#eventQueueArn
   */
  readonly eventQueueArn?: string;

  /**
   * A list of glob patterns used to exclude from the crawl.
   *
   * @schema CrawlerSpecInitProviderS3Target#exclusions
   */
  readonly exclusions?: string[];

  /**
   * The name of the DynamoDB table to crawl.
   *
   * @schema CrawlerSpecInitProviderS3Target#path
   */
  readonly path?: string;

  /**
   * Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
   *
   * @schema CrawlerSpecInitProviderS3Target#sampleSize
   */
  readonly sampleSize?: number;

}

/**
 * Converts an object of type 'CrawlerSpecInitProviderS3Target' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecInitProviderS3Target(obj: CrawlerSpecInitProviderS3Target | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionName': obj.connectionName,
    'dlqEventQueueArn': obj.dlqEventQueueArn,
    'eventQueueArn': obj.eventQueueArn,
    'exclusions': obj.exclusions?.map(y => y),
    'path': obj.path,
    'sampleSize': obj.sampleSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CrawlerSpecInitProviderSchemaChangePolicy
 */
export interface CrawlerSpecInitProviderSchemaChangePolicy {
  /**
   * The deletion behavior when the crawler finds a deleted object. Valid values: LOG, DELETE_FROM_DATABASE, or DEPRECATE_IN_DATABASE. Defaults to DEPRECATE_IN_DATABASE.
   *
   * @default DEPRECATE_IN_DATABASE.
   * @schema CrawlerSpecInitProviderSchemaChangePolicy#deleteBehavior
   */
  readonly deleteBehavior?: string;

  /**
   * The update behavior when the crawler finds a changed schema. Valid values: LOG or UPDATE_IN_DATABASE. Defaults to UPDATE_IN_DATABASE.
   *
   * @default UPDATE_IN_DATABASE.
   * @schema CrawlerSpecInitProviderSchemaChangePolicy#updateBehavior
   */
  readonly updateBehavior?: string;

}

/**
 * Converts an object of type 'CrawlerSpecInitProviderSchemaChangePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecInitProviderSchemaChangePolicy(obj: CrawlerSpecInitProviderSchemaChangePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteBehavior': obj.deleteBehavior,
    'updateBehavior': obj.updateBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecProviderConfigRefPolicy
 */
export interface CrawlerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecProviderConfigRefPolicy(obj: CrawlerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CrawlerSpecPublishConnectionDetailsToConfigRef
 */
export interface CrawlerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CrawlerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecPublishConnectionDetailsToConfigRef(obj: CrawlerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CrawlerSpecPublishConnectionDetailsToMetadata
 */
export interface CrawlerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CrawlerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecPublishConnectionDetailsToMetadata(obj: CrawlerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CatalogDatabase in glue to populate databaseName.
 *
 * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameRef
 */
export interface CrawlerSpecForProviderCatalogTargetDatabaseNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameRef#policy
   */
  readonly policy?: CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderCatalogTargetDatabaseNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderCatalogTargetDatabaseNameRef(obj: CrawlerSpecForProviderCatalogTargetDatabaseNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CatalogDatabase in glue to populate databaseName.
 *
 * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameSelector
 */
export interface CrawlerSpecForProviderCatalogTargetDatabaseNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderCatalogTargetDatabaseNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderCatalogTargetDatabaseNameSelector(obj: CrawlerSpecForProviderCatalogTargetDatabaseNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderDatabaseNameRefPolicy
 */
export interface CrawlerSpecForProviderDatabaseNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderDatabaseNameRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderDatabaseNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderDatabaseNameRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderDatabaseNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderDatabaseNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderDatabaseNameRefPolicy(obj: CrawlerSpecForProviderDatabaseNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderDatabaseNameSelectorPolicy
 */
export interface CrawlerSpecForProviderDatabaseNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderDatabaseNameSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderDatabaseNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderDatabaseNameSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderDatabaseNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderDatabaseNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderDatabaseNameSelectorPolicy(obj: CrawlerSpecForProviderDatabaseNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection in glue to populate connectionName.
 *
 * @schema CrawlerSpecForProviderJdbcTargetConnectionNameRef
 */
export interface CrawlerSpecForProviderJdbcTargetConnectionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderJdbcTargetConnectionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderJdbcTargetConnectionNameRef#policy
   */
  readonly policy?: CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderJdbcTargetConnectionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderJdbcTargetConnectionNameRef(obj: CrawlerSpecForProviderJdbcTargetConnectionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection in glue to populate connectionName.
 *
 * @schema CrawlerSpecForProviderJdbcTargetConnectionNameSelector
 */
export interface CrawlerSpecForProviderJdbcTargetConnectionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderJdbcTargetConnectionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderJdbcTargetConnectionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderJdbcTargetConnectionNameSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderJdbcTargetConnectionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderJdbcTargetConnectionNameSelector(obj: CrawlerSpecForProviderJdbcTargetConnectionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection in glue to populate connectionName.
 *
 * @schema CrawlerSpecForProviderMongodbTargetConnectionNameRef
 */
export interface CrawlerSpecForProviderMongodbTargetConnectionNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CrawlerSpecForProviderMongodbTargetConnectionNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CrawlerSpecForProviderMongodbTargetConnectionNameRef#policy
   */
  readonly policy?: CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderMongodbTargetConnectionNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderMongodbTargetConnectionNameRef(obj: CrawlerSpecForProviderMongodbTargetConnectionNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection in glue to populate connectionName.
 *
 * @schema CrawlerSpecForProviderMongodbTargetConnectionNameSelector
 */
export interface CrawlerSpecForProviderMongodbTargetConnectionNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CrawlerSpecForProviderMongodbTargetConnectionNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CrawlerSpecForProviderMongodbTargetConnectionNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CrawlerSpecForProviderMongodbTargetConnectionNameSelector#policy
   */
  readonly policy?: CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicy;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderMongodbTargetConnectionNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderMongodbTargetConnectionNameSelector(obj: CrawlerSpecForProviderMongodbTargetConnectionNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderRoleRefPolicy
 */
export interface CrawlerSpecForProviderRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderRoleRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderRoleRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderRoleRefPolicy(obj: CrawlerSpecForProviderRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderRoleSelectorPolicy
 */
export interface CrawlerSpecForProviderRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderRoleSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderRoleSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderRoleSelectorPolicy(obj: CrawlerSpecForProviderRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecProviderConfigRefPolicyResolution
 */
export enum CrawlerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecProviderConfigRefPolicyResolve
 */
export enum CrawlerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CrawlerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecPublishConnectionDetailsToConfigRefPolicy(obj: CrawlerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicy
 */
export interface CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicy(obj: CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicy
 */
export interface CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicy(obj: CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderDatabaseNameRefPolicyResolution
 */
export enum CrawlerSpecForProviderDatabaseNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderDatabaseNameRefPolicyResolve
 */
export enum CrawlerSpecForProviderDatabaseNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderDatabaseNameSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderDatabaseNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderDatabaseNameSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderDatabaseNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicy
 */
export interface CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicy(obj: CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicy
 */
export interface CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicy(obj: CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicy
 */
export interface CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicy(obj: CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicy
 */
export interface CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicy#resolution
   */
  readonly resolution?: CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicy#resolve
   */
  readonly resolve?: CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicy(obj: CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderRoleRefPolicyResolution
 */
export enum CrawlerSpecForProviderRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderRoleRefPolicyResolve
 */
export enum CrawlerSpecForProviderRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderRoleSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderRoleSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CrawlerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicyResolution
 */
export enum CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicyResolve
 */
export enum CrawlerSpecForProviderCatalogTargetDatabaseNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderCatalogTargetDatabaseNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicyResolution
 */
export enum CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicyResolve
 */
export enum CrawlerSpecForProviderJdbcTargetConnectionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderJdbcTargetConnectionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicyResolution
 */
export enum CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicyResolve
 */
export enum CrawlerSpecForProviderMongodbTargetConnectionNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicyResolution
 */
export enum CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicyResolve
 */
export enum CrawlerSpecForProviderMongodbTargetConnectionNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DataCatalogEncryptionSettings is the Schema for the DataCatalogEncryptionSettingss API. Provides a Glue Data Catalog Encryption Settings resource.
 *
 * @schema DataCatalogEncryptionSettings
 */
export class DataCatalogEncryptionSettings extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DataCatalogEncryptionSettings"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'DataCatalogEncryptionSettings',
  }

  /**
   * Renders a Kubernetes manifest for "DataCatalogEncryptionSettings".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DataCatalogEncryptionSettingsProps): any {
    return {
      ...DataCatalogEncryptionSettings.GVK,
      ...toJson_DataCatalogEncryptionSettingsProps(props),
    };
  }

  /**
   * Defines a "DataCatalogEncryptionSettings" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DataCatalogEncryptionSettingsProps) {
    super(scope, id, {
      ...DataCatalogEncryptionSettings.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DataCatalogEncryptionSettings.GVK,
      ...toJson_DataCatalogEncryptionSettingsProps(resolved),
    };
  }
}

/**
 * DataCatalogEncryptionSettings is the Schema for the DataCatalogEncryptionSettingss API. Provides a Glue Data Catalog Encryption Settings resource.
 *
 * @schema DataCatalogEncryptionSettings
 */
export interface DataCatalogEncryptionSettingsProps {
  /**
   * @schema DataCatalogEncryptionSettings#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DataCatalogEncryptionSettingsSpec defines the desired state of DataCatalogEncryptionSettings
   *
   * @schema DataCatalogEncryptionSettings#spec
   */
  readonly spec: DataCatalogEncryptionSettingsSpec;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsProps(obj: DataCatalogEncryptionSettingsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DataCatalogEncryptionSettingsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DataCatalogEncryptionSettingsSpec defines the desired state of DataCatalogEncryptionSettings
 *
 * @schema DataCatalogEncryptionSettingsSpec
 */
export interface DataCatalogEncryptionSettingsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DataCatalogEncryptionSettingsSpec#deletionPolicy
   */
  readonly deletionPolicy?: DataCatalogEncryptionSettingsSpecDeletionPolicy;

  /**
   * @schema DataCatalogEncryptionSettingsSpec#forProvider
   */
  readonly forProvider: DataCatalogEncryptionSettingsSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DataCatalogEncryptionSettingsSpec#initProvider
   */
  readonly initProvider?: DataCatalogEncryptionSettingsSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DataCatalogEncryptionSettingsSpec#managementPolicies
   */
  readonly managementPolicies?: DataCatalogEncryptionSettingsSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DataCatalogEncryptionSettingsSpec#providerConfigRef
   */
  readonly providerConfigRef?: DataCatalogEncryptionSettingsSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DataCatalogEncryptionSettingsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DataCatalogEncryptionSettingsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DataCatalogEncryptionSettingsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DataCatalogEncryptionSettingsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpec(obj: DataCatalogEncryptionSettingsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DataCatalogEncryptionSettingsSpecForProvider(obj.forProvider),
    'initProvider': toJson_DataCatalogEncryptionSettingsSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DataCatalogEncryptionSettingsSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DataCatalogEncryptionSettingsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DataCatalogEncryptionSettingsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DataCatalogEncryptionSettingsSpecDeletionPolicy
 */
export enum DataCatalogEncryptionSettingsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DataCatalogEncryptionSettingsSpecForProvider
 */
export interface DataCatalogEncryptionSettingsSpecForProvider {
  /**
   *   The ID of the Data Catalog to set the security configuration for. If none is provided, the AWS account ID is used by default.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProvider#catalogId
   */
  readonly catalogId?: string;

  /**
   *   The security configuration to set. see Data Catalog Encryption Settings.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProvider#dataCatalogEncryptionSettings
   */
  readonly dataCatalogEncryptionSettings?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettings[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProvider(obj: DataCatalogEncryptionSettingsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'dataCatalogEncryptionSettings': obj.dataCatalogEncryptionSettings?.map(y => toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettings(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DataCatalogEncryptionSettingsSpecInitProvider
 */
export interface DataCatalogEncryptionSettingsSpecInitProvider {
  /**
   *   The ID of the Data Catalog to set the security configuration for. If none is provided, the AWS account ID is used by default.
   *
   * @schema DataCatalogEncryptionSettingsSpecInitProvider#catalogId
   */
  readonly catalogId?: string;

  /**
   *   The security configuration to set. see Data Catalog Encryption Settings.
   *
   * @schema DataCatalogEncryptionSettingsSpecInitProvider#dataCatalogEncryptionSettings
   */
  readonly dataCatalogEncryptionSettings?: DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettings[];

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecInitProvider(obj: DataCatalogEncryptionSettingsSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'dataCatalogEncryptionSettings': obj.dataCatalogEncryptionSettings?.map(y => toJson_DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DataCatalogEncryptionSettingsSpecManagementPolicies
 */
export enum DataCatalogEncryptionSettingsSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DataCatalogEncryptionSettingsSpecProviderConfigRef
 */
export interface DataCatalogEncryptionSettingsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataCatalogEncryptionSettingsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataCatalogEncryptionSettingsSpecProviderConfigRef#policy
   */
  readonly policy?: DataCatalogEncryptionSettingsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecProviderConfigRef(obj: DataCatalogEncryptionSettingsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataCatalogEncryptionSettingsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsTo
 */
export interface DataCatalogEncryptionSettingsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecPublishConnectionDetailsTo(obj: DataCatalogEncryptionSettingsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DataCatalogEncryptionSettingsSpecWriteConnectionSecretToRef
 */
export interface DataCatalogEncryptionSettingsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DataCatalogEncryptionSettingsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DataCatalogEncryptionSettingsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecWriteConnectionSecretToRef(obj: DataCatalogEncryptionSettingsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettings
 */
export interface DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettings {
  /**
   * When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption. see Connection Password Encryption.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettings#connectionPasswordEncryption
   */
  readonly connectionPasswordEncryption?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption[];

  /**
   * Specifies the encryption-at-rest configuration for the Data Catalog. see Encryption At Rest.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettings#encryptionAtRest
   */
  readonly encryptionAtRest?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRest[];

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettings(obj: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPasswordEncryption': obj.connectionPasswordEncryption?.map(y => toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption(y)),
    'encryptionAtRest': obj.encryptionAtRest?.map(y => toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettings
 */
export interface DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettings {
  /**
   * When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption. see Connection Password Encryption.
   *
   * @schema DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettings#connectionPasswordEncryption
   */
  readonly connectionPasswordEncryption?: DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption[];

  /**
   * Specifies the encryption-at-rest configuration for the Data Catalog. see Encryption At Rest.
   *
   * @schema DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettings#encryptionAtRest
   */
  readonly encryptionAtRest?: DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsEncryptionAtRest[];

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettings(obj: DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPasswordEncryption': obj.connectionPasswordEncryption?.map(y => toJson_DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption(y)),
    'encryptionAtRest': obj.encryptionAtRest?.map(y => toJson_DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsEncryptionAtRest(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataCatalogEncryptionSettingsSpecProviderConfigRefPolicy
 */
export interface DataCatalogEncryptionSettingsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataCatalogEncryptionSettingsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DataCatalogEncryptionSettingsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataCatalogEncryptionSettingsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DataCatalogEncryptionSettingsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecProviderConfigRefPolicy(obj: DataCatalogEncryptionSettingsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRef
 */
export interface DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRef(obj: DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToMetadata
 */
export interface DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToMetadata(obj: DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption
 */
export interface DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption {
  /**
   * A KMS key ARN that is used to encrypt the connection password. If connection password protection is enabled, the caller of CreateConnection and UpdateConnection needs at least kms:Encrypt permission on the specified AWS KMS key, to encrypt passwords before storing them in the Data Catalog.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption#awsKmsKeyId
   */
  readonly awsKmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate awsKmsKeyId.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption#awsKmsKeyIdRef
   */
  readonly awsKmsKeyIdRef?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate awsKmsKeyId.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption#awsKmsKeyIdSelector
   */
  readonly awsKmsKeyIdSelector?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelector;

  /**
   * When set to true, passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently of the catalog encryption.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption#returnConnectionPasswordEncrypted
   */
  readonly returnConnectionPasswordEncrypted?: boolean;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption(obj: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsKmsKeyId': obj.awsKmsKeyId,
    'awsKmsKeyIdRef': toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRef(obj.awsKmsKeyIdRef),
    'awsKmsKeyIdSelector': toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelector(obj.awsKmsKeyIdSelector),
    'returnConnectionPasswordEncrypted': obj.returnConnectionPasswordEncrypted,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRest
 */
export interface DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRest {
  /**
   * The encryption-at-rest mode for encrypting Data Catalog data. Valid values are DISABLED and SSE-KMS.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRest#catalogEncryptionMode
   */
  readonly catalogEncryptionMode?: string;

  /**
   * The ARN of the AWS KMS key to use for encryption at rest.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRest#sseAwsKmsKeyId
   */
  readonly sseAwsKmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate sseAwsKmsKeyId.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRest#sseAwsKmsKeyIdRef
   */
  readonly sseAwsKmsKeyIdRef?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate sseAwsKmsKeyId.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRest#sseAwsKmsKeyIdSelector
   */
  readonly sseAwsKmsKeyIdSelector?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelector;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRest(obj: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogEncryptionMode': obj.catalogEncryptionMode,
    'sseAwsKmsKeyId': obj.sseAwsKmsKeyId,
    'sseAwsKmsKeyIdRef': toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRef(obj.sseAwsKmsKeyIdRef),
    'sseAwsKmsKeyIdSelector': toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelector(obj.sseAwsKmsKeyIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption
 */
export interface DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption {
  /**
   * When set to true, passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently of the catalog encryption.
   *
   * @schema DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption#returnConnectionPasswordEncrypted
   */
  readonly returnConnectionPasswordEncrypted?: boolean;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption(obj: DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsConnectionPasswordEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'returnConnectionPasswordEncrypted': obj.returnConnectionPasswordEncrypted,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsEncryptionAtRest
 */
export interface DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsEncryptionAtRest {
  /**
   * The encryption-at-rest mode for encrypting Data Catalog data. Valid values are DISABLED and SSE-KMS.
   *
   * @schema DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsEncryptionAtRest#catalogEncryptionMode
   */
  readonly catalogEncryptionMode?: string;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsEncryptionAtRest' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsEncryptionAtRest(obj: DataCatalogEncryptionSettingsSpecInitProviderDataCatalogEncryptionSettingsEncryptionAtRest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogEncryptionMode': obj.catalogEncryptionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataCatalogEncryptionSettingsSpecProviderConfigRefPolicyResolution
 */
export enum DataCatalogEncryptionSettingsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataCatalogEncryptionSettingsSpecProviderConfigRefPolicyResolve
 */
export enum DataCatalogEncryptionSettingsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj: DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate awsKmsKeyId.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRef
 */
export interface DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRef#policy
   */
  readonly policy?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRef(obj: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate awsKmsKeyId.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelector
 */
export interface DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelector#policy
   */
  readonly policy?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelector(obj: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate sseAwsKmsKeyId.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRef
 */
export interface DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRef#policy
   */
  readonly policy?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRef(obj: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate sseAwsKmsKeyId.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelector
 */
export interface DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelector#policy
   */
  readonly policy?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelector(obj: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DataCatalogEncryptionSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicy
 */
export interface DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicy(obj: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicy
 */
export interface DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicy(obj: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicy
 */
export interface DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicy(obj: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicy
 */
export interface DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicy(obj: DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicyResolution
 */
export enum DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicyResolve
 */
export enum DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicyResolution
 */
export enum DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicyResolve
 */
export enum DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsConnectionPasswordEncryptionAwsKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicyResolution
 */
export enum DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicyResolve
 */
export enum DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicyResolution
 */
export enum DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicyResolve
 */
export enum DataCatalogEncryptionSettingsSpecForProviderDataCatalogEncryptionSettingsEncryptionAtRestSseAwsKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Job is the Schema for the Jobs API. Provides an Glue Job resource.
 *
 * @schema Job
 */
export class Job extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Job"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'Job',
  }

  /**
   * Renders a Kubernetes manifest for "Job".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: JobProps): any {
    return {
      ...Job.GVK,
      ...toJson_JobProps(props),
    };
  }

  /**
   * Defines a "Job" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: JobProps) {
    super(scope, id, {
      ...Job.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Job.GVK,
      ...toJson_JobProps(resolved),
    };
  }
}

/**
 * Job is the Schema for the Jobs API. Provides an Glue Job resource.
 *
 * @schema Job
 */
export interface JobProps {
  /**
   * @schema Job#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * JobSpec defines the desired state of Job
   *
   * @schema Job#spec
   */
  readonly spec: JobSpec;

}

/**
 * Converts an object of type 'JobProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobProps(obj: JobProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_JobSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JobSpec defines the desired state of Job
 *
 * @schema JobSpec
 */
export interface JobSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema JobSpec#deletionPolicy
   */
  readonly deletionPolicy?: JobSpecDeletionPolicy;

  /**
   * @schema JobSpec#forProvider
   */
  readonly forProvider: JobSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema JobSpec#initProvider
   */
  readonly initProvider?: JobSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema JobSpec#managementPolicies
   */
  readonly managementPolicies?: JobSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema JobSpec#providerConfigRef
   */
  readonly providerConfigRef?: JobSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema JobSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: JobSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema JobSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: JobSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'JobSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpec(obj: JobSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_JobSpecForProvider(obj.forProvider),
    'initProvider': toJson_JobSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_JobSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_JobSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_JobSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema JobSpecDeletionPolicy
 */
export enum JobSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema JobSpecForProvider
 */
export interface JobSpecForProvider {
  /**
   *   The command of the job. Defined below.
   *
   * @schema JobSpecForProvider#command
   */
  readonly command?: JobSpecForProviderCommand[];

  /**
   *   The list of connections used for this job.
   *
   * @schema JobSpecForProvider#connections
   */
  readonly connections?: string[];

  /**
   * execution script consumes, as well as arguments that AWS Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling AWS Glue APIs in Python topic in the developer guide. For information about the key-value pairs that AWS Glue consumes to set up your job, see the Special Parameters Used by AWS Glue topic in the developer guide.
   *
   * @schema JobSpecForProvider#defaultArguments
   */
  readonly defaultArguments?: { [key: string]: string };

  /**
   *   Description of the job.
   *
   * @schema JobSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Indicates whether the job is run with a standard or flexible execution class. The standard execution class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. Valid value: FLEX, STANDARD.
   *
   * @schema JobSpecForProvider#executionClass
   */
  readonly executionClass?: string;

  /**
   *   Execution property of the job. Defined below.
   *
   * @schema JobSpecForProvider#executionProperty
   */
  readonly executionProperty?: JobSpecForProviderExecutionProperty[];

  /**
   * The version of glue to use, for example "1.0". For information about available versions, see the AWS Glue Release Notes.
   *
   * @schema JobSpecForProvider#glueVersion
   */
  readonly glueVersion?: string;

  /**
   *   The maximum number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. Required when pythonshell is set, accept either 0.0625 or 1.0. Use number_of_workers and worker_type arguments instead with glue_version 2.0 and above.
   *
   * @schema JobSpecForProvider#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   *   The maximum number of times to retry this job if it fails.
   *
   * @schema JobSpecForProvider#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * overridable arguments for this job, specified as name-value pairs.
   *
   * @schema JobSpecForProvider#nonOverridableArguments
   */
  readonly nonOverridableArguments?: { [key: string]: string };

  /**
   * Notification property of the job. Defined below.
   *
   * @schema JobSpecForProvider#notificationProperty
   */
  readonly notificationProperty?: JobSpecForProviderNotificationProperty[];

  /**
   * The number of workers of a defined workerType that are allocated when a job runs.
   *
   * @schema JobSpecForProvider#numberOfWorkers
   */
  readonly numberOfWorkers?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema JobSpecForProvider#region
   */
  readonly region: string;

  /**
   *   The ARN of the IAM role associated with this job.
   *
   * @schema JobSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema JobSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: JobSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema JobSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: JobSpecForProviderRoleArnSelector;

  /**
   * The name of the Security Configuration to be associated with the job.
   *
   * @schema JobSpecForProvider#securityConfiguration
   */
  readonly securityConfiguration?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema JobSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   *   The job timeout in minutes. The default is 2880 minutes (48 hours) for glueetl and pythonshell jobs, and null (unlimited) for gluestreaming jobs.
   *
   * @schema JobSpecForProvider#timeout
   */
  readonly timeout?: number;

  /**
   * The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.
   *
   * @schema JobSpecForProvider#workerType
   */
  readonly workerType?: string;

}

/**
 * Converts an object of type 'JobSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProvider(obj: JobSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => toJson_JobSpecForProviderCommand(y)),
    'connections': obj.connections?.map(y => y),
    'defaultArguments': ((obj.defaultArguments) === undefined) ? undefined : (Object.entries(obj.defaultArguments).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'description': obj.description,
    'executionClass': obj.executionClass,
    'executionProperty': obj.executionProperty?.map(y => toJson_JobSpecForProviderExecutionProperty(y)),
    'glueVersion': obj.glueVersion,
    'maxCapacity': obj.maxCapacity,
    'maxRetries': obj.maxRetries,
    'nonOverridableArguments': ((obj.nonOverridableArguments) === undefined) ? undefined : (Object.entries(obj.nonOverridableArguments).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'notificationProperty': obj.notificationProperty?.map(y => toJson_JobSpecForProviderNotificationProperty(y)),
    'numberOfWorkers': obj.numberOfWorkers,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_JobSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_JobSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'securityConfiguration': obj.securityConfiguration,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timeout': obj.timeout,
    'workerType': obj.workerType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema JobSpecInitProvider
 */
export interface JobSpecInitProvider {
  /**
   *   The command of the job. Defined below.
   *
   * @schema JobSpecInitProvider#command
   */
  readonly command?: JobSpecInitProviderCommand[];

  /**
   *   The list of connections used for this job.
   *
   * @schema JobSpecInitProvider#connections
   */
  readonly connections?: string[];

  /**
   * execution script consumes, as well as arguments that AWS Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling AWS Glue APIs in Python topic in the developer guide. For information about the key-value pairs that AWS Glue consumes to set up your job, see the Special Parameters Used by AWS Glue topic in the developer guide.
   *
   * @schema JobSpecInitProvider#defaultArguments
   */
  readonly defaultArguments?: { [key: string]: string };

  /**
   *   Description of the job.
   *
   * @schema JobSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Indicates whether the job is run with a standard or flexible execution class. The standard execution class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. Valid value: FLEX, STANDARD.
   *
   * @schema JobSpecInitProvider#executionClass
   */
  readonly executionClass?: string;

  /**
   *   Execution property of the job. Defined below.
   *
   * @schema JobSpecInitProvider#executionProperty
   */
  readonly executionProperty?: JobSpecInitProviderExecutionProperty[];

  /**
   * The version of glue to use, for example "1.0". For information about available versions, see the AWS Glue Release Notes.
   *
   * @schema JobSpecInitProvider#glueVersion
   */
  readonly glueVersion?: string;

  /**
   *   The maximum number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. Required when pythonshell is set, accept either 0.0625 or 1.0. Use number_of_workers and worker_type arguments instead with glue_version 2.0 and above.
   *
   * @schema JobSpecInitProvider#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   *   The maximum number of times to retry this job if it fails.
   *
   * @schema JobSpecInitProvider#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * overridable arguments for this job, specified as name-value pairs.
   *
   * @schema JobSpecInitProvider#nonOverridableArguments
   */
  readonly nonOverridableArguments?: { [key: string]: string };

  /**
   * Notification property of the job. Defined below.
   *
   * @schema JobSpecInitProvider#notificationProperty
   */
  readonly notificationProperty?: JobSpecInitProviderNotificationProperty[];

  /**
   * The number of workers of a defined workerType that are allocated when a job runs.
   *
   * @schema JobSpecInitProvider#numberOfWorkers
   */
  readonly numberOfWorkers?: number;

  /**
   * The name of the Security Configuration to be associated with the job.
   *
   * @schema JobSpecInitProvider#securityConfiguration
   */
  readonly securityConfiguration?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema JobSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   *   The job timeout in minutes. The default is 2880 minutes (48 hours) for glueetl and pythonshell jobs, and null (unlimited) for gluestreaming jobs.
   *
   * @schema JobSpecInitProvider#timeout
   */
  readonly timeout?: number;

  /**
   * The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.
   *
   * @schema JobSpecInitProvider#workerType
   */
  readonly workerType?: string;

}

/**
 * Converts an object of type 'JobSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecInitProvider(obj: JobSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => toJson_JobSpecInitProviderCommand(y)),
    'connections': obj.connections?.map(y => y),
    'defaultArguments': ((obj.defaultArguments) === undefined) ? undefined : (Object.entries(obj.defaultArguments).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'description': obj.description,
    'executionClass': obj.executionClass,
    'executionProperty': obj.executionProperty?.map(y => toJson_JobSpecInitProviderExecutionProperty(y)),
    'glueVersion': obj.glueVersion,
    'maxCapacity': obj.maxCapacity,
    'maxRetries': obj.maxRetries,
    'nonOverridableArguments': ((obj.nonOverridableArguments) === undefined) ? undefined : (Object.entries(obj.nonOverridableArguments).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'notificationProperty': obj.notificationProperty?.map(y => toJson_JobSpecInitProviderNotificationProperty(y)),
    'numberOfWorkers': obj.numberOfWorkers,
    'securityConfiguration': obj.securityConfiguration,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timeout': obj.timeout,
    'workerType': obj.workerType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema JobSpecManagementPolicies
 */
export enum JobSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema JobSpecProviderConfigRef
 */
export interface JobSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecProviderConfigRef#policy
   */
  readonly policy?: JobSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'JobSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecProviderConfigRef(obj: JobSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema JobSpecPublishConnectionDetailsTo
 */
export interface JobSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema JobSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: JobSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema JobSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: JobSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema JobSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsTo(obj: JobSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_JobSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_JobSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema JobSpecWriteConnectionSecretToRef
 */
export interface JobSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema JobSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema JobSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'JobSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecWriteConnectionSecretToRef(obj: JobSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderCommand
 */
export interface JobSpecForProviderCommand {
  /**
   *   The name you assign to this job. It must be unique in your account.
   *
   * @schema JobSpecForProviderCommand#name
   */
  readonly name?: string;

  /**
   * The Python version being used to execute a Python shell job. Allowed values are 2, 3 or 3.9. Version 3 refers to Python 3.6.
   *
   * @schema JobSpecForProviderCommand#pythonVersion
   */
  readonly pythonVersion?: string;

  /**
   * Specifies the S3 path to a script that executes a job.
   *
   * @schema JobSpecForProviderCommand#scriptLocation
   */
  readonly scriptLocation?: string;

}

/**
 * Converts an object of type 'JobSpecForProviderCommand' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderCommand(obj: JobSpecForProviderCommand | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'pythonVersion': obj.pythonVersion,
    'scriptLocation': obj.scriptLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderExecutionProperty
 */
export interface JobSpecForProviderExecutionProperty {
  /**
   * The maximum number of concurrent runs allowed for a job. The default is 1.
   *
   * @schema JobSpecForProviderExecutionProperty#maxConcurrentRuns
   */
  readonly maxConcurrentRuns?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderExecutionProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderExecutionProperty(obj: JobSpecForProviderExecutionProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConcurrentRuns': obj.maxConcurrentRuns,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecForProviderNotificationProperty
 */
export interface JobSpecForProviderNotificationProperty {
  /**
   * After a job run starts, the number of minutes to wait before sending a job run delay notification.
   *
   * @schema JobSpecForProviderNotificationProperty#notifyDelayAfter
   */
  readonly notifyDelayAfter?: number;

}

/**
 * Converts an object of type 'JobSpecForProviderNotificationProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderNotificationProperty(obj: JobSpecForProviderNotificationProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notifyDelayAfter': obj.notifyDelayAfter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema JobSpecForProviderRoleArnRef
 */
export interface JobSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecForProviderRoleArnRef#policy
   */
  readonly policy?: JobSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderRoleArnRef(obj: JobSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema JobSpecForProviderRoleArnSelector
 */
export interface JobSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema JobSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema JobSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema JobSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: JobSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'JobSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderRoleArnSelector(obj: JobSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_JobSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecInitProviderCommand
 */
export interface JobSpecInitProviderCommand {
  /**
   *   The name you assign to this job. It must be unique in your account.
   *
   * @schema JobSpecInitProviderCommand#name
   */
  readonly name?: string;

  /**
   * The Python version being used to execute a Python shell job. Allowed values are 2, 3 or 3.9. Version 3 refers to Python 3.6.
   *
   * @schema JobSpecInitProviderCommand#pythonVersion
   */
  readonly pythonVersion?: string;

  /**
   * Specifies the S3 path to a script that executes a job.
   *
   * @schema JobSpecInitProviderCommand#scriptLocation
   */
  readonly scriptLocation?: string;

}

/**
 * Converts an object of type 'JobSpecInitProviderCommand' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecInitProviderCommand(obj: JobSpecInitProviderCommand | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'pythonVersion': obj.pythonVersion,
    'scriptLocation': obj.scriptLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecInitProviderExecutionProperty
 */
export interface JobSpecInitProviderExecutionProperty {
  /**
   * The maximum number of concurrent runs allowed for a job. The default is 1.
   *
   * @schema JobSpecInitProviderExecutionProperty#maxConcurrentRuns
   */
  readonly maxConcurrentRuns?: number;

}

/**
 * Converts an object of type 'JobSpecInitProviderExecutionProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecInitProviderExecutionProperty(obj: JobSpecInitProviderExecutionProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConcurrentRuns': obj.maxConcurrentRuns,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema JobSpecInitProviderNotificationProperty
 */
export interface JobSpecInitProviderNotificationProperty {
  /**
   * After a job run starts, the number of minutes to wait before sending a job run delay notification.
   *
   * @schema JobSpecInitProviderNotificationProperty#notifyDelayAfter
   */
  readonly notifyDelayAfter?: number;

}

/**
 * Converts an object of type 'JobSpecInitProviderNotificationProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecInitProviderNotificationProperty(obj: JobSpecInitProviderNotificationProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notifyDelayAfter': obj.notifyDelayAfter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecProviderConfigRefPolicy
 */
export interface JobSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: JobSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: JobSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecProviderConfigRefPolicy(obj: JobSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRef
 */
export interface JobSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: JobSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsToConfigRef(obj: JobSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_JobSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema JobSpecPublishConnectionDetailsToMetadata
 */
export interface JobSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema JobSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema JobSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema JobSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsToMetadata(obj: JobSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema JobSpecForProviderRoleArnRefPolicy
 */
export interface JobSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderRoleArnRefPolicy(obj: JobSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema JobSpecForProviderRoleArnSelectorPolicy
 */
export interface JobSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: JobSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: JobSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecForProviderRoleArnSelectorPolicy(obj: JobSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecProviderConfigRefPolicyResolution
 */
export enum JobSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecProviderConfigRefPolicyResolve
 */
export enum JobSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface JobSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: JobSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema JobSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: JobSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'JobSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_JobSpecPublishConnectionDetailsToConfigRefPolicy(obj: JobSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderRoleArnRefPolicyResolution
 */
export enum JobSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderRoleArnRefPolicyResolve
 */
export enum JobSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum JobSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum JobSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum JobSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema JobSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum JobSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Registry is the Schema for the Registrys API. Provides a Glue Registry resource.
 *
 * @schema Registry
 */
export class Registry extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Registry"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'Registry',
  }

  /**
   * Renders a Kubernetes manifest for "Registry".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RegistryProps): any {
    return {
      ...Registry.GVK,
      ...toJson_RegistryProps(props),
    };
  }

  /**
   * Defines a "Registry" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RegistryProps) {
    super(scope, id, {
      ...Registry.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Registry.GVK,
      ...toJson_RegistryProps(resolved),
    };
  }
}

/**
 * Registry is the Schema for the Registrys API. Provides a Glue Registry resource.
 *
 * @schema Registry
 */
export interface RegistryProps {
  /**
   * @schema Registry#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RegistrySpec defines the desired state of Registry
   *
   * @schema Registry#spec
   */
  readonly spec: RegistrySpec;

}

/**
 * Converts an object of type 'RegistryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryProps(obj: RegistryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RegistrySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RegistrySpec defines the desired state of Registry
 *
 * @schema RegistrySpec
 */
export interface RegistrySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RegistrySpec#deletionPolicy
   */
  readonly deletionPolicy?: RegistrySpecDeletionPolicy;

  /**
   * @schema RegistrySpec#forProvider
   */
  readonly forProvider: RegistrySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RegistrySpec#initProvider
   */
  readonly initProvider?: RegistrySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RegistrySpec#managementPolicies
   */
  readonly managementPolicies?: RegistrySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RegistrySpec#providerConfigRef
   */
  readonly providerConfigRef?: RegistrySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RegistrySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RegistrySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RegistrySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RegistrySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RegistrySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpec(obj: RegistrySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RegistrySpecForProvider(obj.forProvider),
    'initProvider': toJson_RegistrySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RegistrySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RegistrySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RegistrySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RegistrySpecDeletionPolicy
 */
export enum RegistrySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RegistrySpecForProvider
 */
export interface RegistrySpecForProvider {
  /**
   *   A description of the registry.
   *
   * @schema RegistrySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RegistrySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RegistrySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RegistrySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecForProvider(obj: RegistrySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RegistrySpecInitProvider
 */
export interface RegistrySpecInitProvider {
  /**
   *   A description of the registry.
   *
   * @schema RegistrySpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RegistrySpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RegistrySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecInitProvider(obj: RegistrySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RegistrySpecManagementPolicies
 */
export enum RegistrySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RegistrySpecProviderConfigRef
 */
export interface RegistrySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistrySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistrySpecProviderConfigRef#policy
   */
  readonly policy?: RegistrySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RegistrySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecProviderConfigRef(obj: RegistrySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistrySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RegistrySpecPublishConnectionDetailsTo
 */
export interface RegistrySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RegistrySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RegistrySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RegistrySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RegistrySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RegistrySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsTo(obj: RegistrySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RegistrySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RegistrySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RegistrySpecWriteConnectionSecretToRef
 */
export interface RegistrySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RegistrySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RegistrySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RegistrySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecWriteConnectionSecretToRef(obj: RegistrySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegistrySpecProviderConfigRefPolicy
 */
export interface RegistrySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistrySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RegistrySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistrySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RegistrySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistrySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecProviderConfigRefPolicy(obj: RegistrySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRef
 */
export interface RegistrySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RegistrySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsToConfigRef(obj: RegistrySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistrySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RegistrySpecPublishConnectionDetailsToMetadata
 */
export interface RegistrySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegistrySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegistrySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RegistrySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsToMetadata(obj: RegistrySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistrySpecProviderConfigRefPolicyResolution
 */
export enum RegistrySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistrySpecProviderConfigRefPolicyResolve
 */
export enum RegistrySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RegistrySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistrySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistrySpecPublishConnectionDetailsToConfigRefPolicy(obj: RegistrySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RegistrySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ResourcePolicy is the Schema for the ResourcePolicys API. Provides a resource to configure the aws glue resource policy.
 *
 * @schema ResourcePolicy
 */
export class ResourcePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResourcePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'ResourcePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ResourcePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResourcePolicyProps): any {
    return {
      ...ResourcePolicy.GVK,
      ...toJson_ResourcePolicyProps(props),
    };
  }

  /**
   * Defines a "ResourcePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResourcePolicyProps) {
    super(scope, id, {
      ...ResourcePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResourcePolicy.GVK,
      ...toJson_ResourcePolicyProps(resolved),
    };
  }
}

/**
 * ResourcePolicy is the Schema for the ResourcePolicys API. Provides a resource to configure the aws glue resource policy.
 *
 * @schema ResourcePolicy
 */
export interface ResourcePolicyProps {
  /**
   * @schema ResourcePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResourcePolicySpec defines the desired state of ResourcePolicy
   *
   * @schema ResourcePolicy#spec
   */
  readonly spec: ResourcePolicySpec;

}

/**
 * Converts an object of type 'ResourcePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicyProps(obj: ResourcePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResourcePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourcePolicySpec defines the desired state of ResourcePolicy
 *
 * @schema ResourcePolicySpec
 */
export interface ResourcePolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResourcePolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: ResourcePolicySpecDeletionPolicy;

  /**
   * @schema ResourcePolicySpec#forProvider
   */
  readonly forProvider: ResourcePolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ResourcePolicySpec#initProvider
   */
  readonly initProvider?: ResourcePolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ResourcePolicySpec#managementPolicies
   */
  readonly managementPolicies?: ResourcePolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResourcePolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: ResourcePolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResourcePolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResourcePolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResourcePolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResourcePolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResourcePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpec(obj: ResourcePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResourcePolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_ResourcePolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ResourcePolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ResourcePolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResourcePolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResourcePolicySpecDeletionPolicy
 */
export enum ResourcePolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ResourcePolicySpecForProvider
 */
export interface ResourcePolicySpecForProvider {
  /**
   * Indicates that you are using both methods to grant cross-account. Valid values are TRUE and FALSE.
   *
   * @schema ResourcePolicySpecForProvider#enableHybrid
   */
  readonly enableHybrid?: string;

  /**
   *   The policy to be applied to the aws glue data catalog.
   *
   * @schema ResourcePolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ResourcePolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ResourcePolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecForProvider(obj: ResourcePolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableHybrid': obj.enableHybrid,
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ResourcePolicySpecInitProvider
 */
export interface ResourcePolicySpecInitProvider {
  /**
   * Indicates that you are using both methods to grant cross-account. Valid values are TRUE and FALSE.
   *
   * @schema ResourcePolicySpecInitProvider#enableHybrid
   */
  readonly enableHybrid?: string;

  /**
   *   The policy to be applied to the aws glue data catalog.
   *
   * @schema ResourcePolicySpecInitProvider#policy
   */
  readonly policy?: string;

}

/**
 * Converts an object of type 'ResourcePolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecInitProvider(obj: ResourcePolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableHybrid': obj.enableHybrid,
    'policy': obj.policy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ResourcePolicySpecManagementPolicies
 */
export enum ResourcePolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResourcePolicySpecProviderConfigRef
 */
export interface ResourcePolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourcePolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourcePolicySpecProviderConfigRef#policy
   */
  readonly policy?: ResourcePolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourcePolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecProviderConfigRef(obj: ResourcePolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourcePolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsTo
 */
export interface ResourcePolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResourcePolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResourcePolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResourcePolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecPublishConnectionDetailsTo(obj: ResourcePolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResourcePolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResourcePolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResourcePolicySpecWriteConnectionSecretToRef
 */
export interface ResourcePolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResourcePolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResourcePolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResourcePolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecWriteConnectionSecretToRef(obj: ResourcePolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourcePolicySpecProviderConfigRefPolicy
 */
export interface ResourcePolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourcePolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResourcePolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourcePolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResourcePolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourcePolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecProviderConfigRefPolicy(obj: ResourcePolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRef
 */
export interface ResourcePolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourcePolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecPublishConnectionDetailsToConfigRef(obj: ResourcePolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsToMetadata
 */
export interface ResourcePolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResourcePolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecPublishConnectionDetailsToMetadata(obj: ResourcePolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourcePolicySpecProviderConfigRefPolicyResolution
 */
export enum ResourcePolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourcePolicySpecProviderConfigRefPolicyResolve
 */
export enum ResourcePolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Schema is the Schema for the Schemas API. Provides a Glue Schema resource.
 *
 * @schema Schema
 */
export class Schema extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Schema"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'Schema',
  }

  /**
   * Renders a Kubernetes manifest for "Schema".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SchemaProps): any {
    return {
      ...Schema.GVK,
      ...toJson_SchemaProps(props),
    };
  }

  /**
   * Defines a "Schema" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SchemaProps) {
    super(scope, id, {
      ...Schema.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Schema.GVK,
      ...toJson_SchemaProps(resolved),
    };
  }
}

/**
 * Schema is the Schema for the Schemas API. Provides a Glue Schema resource.
 *
 * @schema Schema
 */
export interface SchemaProps {
  /**
   * @schema Schema#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SchemaSpec defines the desired state of Schema
   *
   * @schema Schema#spec
   */
  readonly spec: SchemaSpec;

}

/**
 * Converts an object of type 'SchemaProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaProps(obj: SchemaProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SchemaSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SchemaSpec defines the desired state of Schema
 *
 * @schema SchemaSpec
 */
export interface SchemaSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SchemaSpec#deletionPolicy
   */
  readonly deletionPolicy?: SchemaSpecDeletionPolicy;

  /**
   * @schema SchemaSpec#forProvider
   */
  readonly forProvider: SchemaSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SchemaSpec#initProvider
   */
  readonly initProvider?: SchemaSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SchemaSpec#managementPolicies
   */
  readonly managementPolicies?: SchemaSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SchemaSpec#providerConfigRef
   */
  readonly providerConfigRef?: SchemaSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SchemaSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SchemaSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SchemaSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SchemaSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SchemaSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpec(obj: SchemaSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SchemaSpecForProvider(obj.forProvider),
    'initProvider': toJson_SchemaSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SchemaSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SchemaSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SchemaSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SchemaSpecDeletionPolicy
 */
export enum SchemaSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SchemaSpecForProvider
 */
export interface SchemaSpecForProvider {
  /**
   * The compatibility mode of the schema. Values values are: NONE, DISABLED, BACKWARD, BACKWARD_ALL, FORWARD, FORWARD_ALL, FULL, and FULL_ALL.
   *
   * @schema SchemaSpecForProvider#compatibility
   */
  readonly compatibility?: string;

  /**
   * The data format of the schema definition. Valid values are AVRO, JSON and PROTOBUF.
   *
   * @schema SchemaSpecForProvider#dataFormat
   */
  readonly dataFormat?: string;

  /**
   *   A description of the schema.
   *
   * @schema SchemaSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SchemaSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of the Glue Registry to create the schema in.
   *
   * @schema SchemaSpecForProvider#registryArn
   */
  readonly registryArn?: string;

  /**
   * Reference to a Registry in glue to populate registryArn.
   *
   * @schema SchemaSpecForProvider#registryArnRef
   */
  readonly registryArnRef?: SchemaSpecForProviderRegistryArnRef;

  /**
   * Selector for a Registry in glue to populate registryArn.
   *
   * @schema SchemaSpecForProvider#registryArnSelector
   */
  readonly registryArnSelector?: SchemaSpecForProviderRegistryArnSelector;

  /**
   * The schema definition using the data_format setting for schema_name.
   *
   * @schema SchemaSpecForProvider#schemaDefinition
   */
  readonly schemaDefinition?: string;

  /**
   *   The Name of the schema.
   *
   * @schema SchemaSpecForProvider#schemaName
   */
  readonly schemaName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema SchemaSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SchemaSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecForProvider(obj: SchemaSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compatibility': obj.compatibility,
    'dataFormat': obj.dataFormat,
    'description': obj.description,
    'region': obj.region,
    'registryArn': obj.registryArn,
    'registryArnRef': toJson_SchemaSpecForProviderRegistryArnRef(obj.registryArnRef),
    'registryArnSelector': toJson_SchemaSpecForProviderRegistryArnSelector(obj.registryArnSelector),
    'schemaDefinition': obj.schemaDefinition,
    'schemaName': obj.schemaName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SchemaSpecInitProvider
 */
export interface SchemaSpecInitProvider {
  /**
   * The compatibility mode of the schema. Values values are: NONE, DISABLED, BACKWARD, BACKWARD_ALL, FORWARD, FORWARD_ALL, FULL, and FULL_ALL.
   *
   * @schema SchemaSpecInitProvider#compatibility
   */
  readonly compatibility?: string;

  /**
   * The data format of the schema definition. Valid values are AVRO, JSON and PROTOBUF.
   *
   * @schema SchemaSpecInitProvider#dataFormat
   */
  readonly dataFormat?: string;

  /**
   *   A description of the schema.
   *
   * @schema SchemaSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The schema definition using the data_format setting for schema_name.
   *
   * @schema SchemaSpecInitProvider#schemaDefinition
   */
  readonly schemaDefinition?: string;

  /**
   *   The Name of the schema.
   *
   * @schema SchemaSpecInitProvider#schemaName
   */
  readonly schemaName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema SchemaSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SchemaSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecInitProvider(obj: SchemaSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'compatibility': obj.compatibility,
    'dataFormat': obj.dataFormat,
    'description': obj.description,
    'schemaDefinition': obj.schemaDefinition,
    'schemaName': obj.schemaName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SchemaSpecManagementPolicies
 */
export enum SchemaSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SchemaSpecProviderConfigRef
 */
export interface SchemaSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SchemaSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SchemaSpecProviderConfigRef#policy
   */
  readonly policy?: SchemaSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SchemaSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecProviderConfigRef(obj: SchemaSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SchemaSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SchemaSpecPublishConnectionDetailsTo
 */
export interface SchemaSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SchemaSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SchemaSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SchemaSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SchemaSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SchemaSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsTo(obj: SchemaSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SchemaSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SchemaSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SchemaSpecWriteConnectionSecretToRef
 */
export interface SchemaSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SchemaSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SchemaSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SchemaSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecWriteConnectionSecretToRef(obj: SchemaSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Registry in glue to populate registryArn.
 *
 * @schema SchemaSpecForProviderRegistryArnRef
 */
export interface SchemaSpecForProviderRegistryArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SchemaSpecForProviderRegistryArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SchemaSpecForProviderRegistryArnRef#policy
   */
  readonly policy?: SchemaSpecForProviderRegistryArnRefPolicy;

}

/**
 * Converts an object of type 'SchemaSpecForProviderRegistryArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecForProviderRegistryArnRef(obj: SchemaSpecForProviderRegistryArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SchemaSpecForProviderRegistryArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Registry in glue to populate registryArn.
 *
 * @schema SchemaSpecForProviderRegistryArnSelector
 */
export interface SchemaSpecForProviderRegistryArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SchemaSpecForProviderRegistryArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SchemaSpecForProviderRegistryArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SchemaSpecForProviderRegistryArnSelector#policy
   */
  readonly policy?: SchemaSpecForProviderRegistryArnSelectorPolicy;

}

/**
 * Converts an object of type 'SchemaSpecForProviderRegistryArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecForProviderRegistryArnSelector(obj: SchemaSpecForProviderRegistryArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SchemaSpecForProviderRegistryArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SchemaSpecProviderConfigRefPolicy
 */
export interface SchemaSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SchemaSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SchemaSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SchemaSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SchemaSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SchemaSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecProviderConfigRefPolicy(obj: SchemaSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRef
 */
export interface SchemaSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SchemaSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsToConfigRef(obj: SchemaSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SchemaSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SchemaSpecPublishConnectionDetailsToMetadata
 */
export interface SchemaSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SchemaSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SchemaSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SchemaSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsToMetadata(obj: SchemaSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SchemaSpecForProviderRegistryArnRefPolicy
 */
export interface SchemaSpecForProviderRegistryArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SchemaSpecForProviderRegistryArnRefPolicy#resolution
   */
  readonly resolution?: SchemaSpecForProviderRegistryArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SchemaSpecForProviderRegistryArnRefPolicy#resolve
   */
  readonly resolve?: SchemaSpecForProviderRegistryArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SchemaSpecForProviderRegistryArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecForProviderRegistryArnRefPolicy(obj: SchemaSpecForProviderRegistryArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SchemaSpecForProviderRegistryArnSelectorPolicy
 */
export interface SchemaSpecForProviderRegistryArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SchemaSpecForProviderRegistryArnSelectorPolicy#resolution
   */
  readonly resolution?: SchemaSpecForProviderRegistryArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SchemaSpecForProviderRegistryArnSelectorPolicy#resolve
   */
  readonly resolve?: SchemaSpecForProviderRegistryArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SchemaSpecForProviderRegistryArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecForProviderRegistryArnSelectorPolicy(obj: SchemaSpecForProviderRegistryArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SchemaSpecProviderConfigRefPolicyResolution
 */
export enum SchemaSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SchemaSpecProviderConfigRefPolicyResolve
 */
export enum SchemaSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SchemaSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SchemaSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SchemaSpecPublishConnectionDetailsToConfigRefPolicy(obj: SchemaSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SchemaSpecForProviderRegistryArnRefPolicyResolution
 */
export enum SchemaSpecForProviderRegistryArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SchemaSpecForProviderRegistryArnRefPolicyResolve
 */
export enum SchemaSpecForProviderRegistryArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SchemaSpecForProviderRegistryArnSelectorPolicyResolution
 */
export enum SchemaSpecForProviderRegistryArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SchemaSpecForProviderRegistryArnSelectorPolicyResolve
 */
export enum SchemaSpecForProviderRegistryArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SchemaSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SecurityConfiguration is the Schema for the SecurityConfigurations API. Manages a Glue Security Configuration
 *
 * @schema SecurityConfiguration
 */
export class SecurityConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecurityConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'SecurityConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "SecurityConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecurityConfigurationProps): any {
    return {
      ...SecurityConfiguration.GVK,
      ...toJson_SecurityConfigurationProps(props),
    };
  }

  /**
   * Defines a "SecurityConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecurityConfigurationProps) {
    super(scope, id, {
      ...SecurityConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecurityConfiguration.GVK,
      ...toJson_SecurityConfigurationProps(resolved),
    };
  }
}

/**
 * SecurityConfiguration is the Schema for the SecurityConfigurations API. Manages a Glue Security Configuration
 *
 * @schema SecurityConfiguration
 */
export interface SecurityConfigurationProps {
  /**
   * @schema SecurityConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecurityConfigurationSpec defines the desired state of SecurityConfiguration
   *
   * @schema SecurityConfiguration#spec
   */
  readonly spec: SecurityConfigurationSpec;

}

/**
 * Converts an object of type 'SecurityConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationProps(obj: SecurityConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecurityConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityConfigurationSpec defines the desired state of SecurityConfiguration
 *
 * @schema SecurityConfigurationSpec
 */
export interface SecurityConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecurityConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecurityConfigurationSpecDeletionPolicy;

  /**
   * @schema SecurityConfigurationSpec#forProvider
   */
  readonly forProvider: SecurityConfigurationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SecurityConfigurationSpec#initProvider
   */
  readonly initProvider?: SecurityConfigurationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SecurityConfigurationSpec#managementPolicies
   */
  readonly managementPolicies?: SecurityConfigurationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecurityConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecurityConfigurationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecurityConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecurityConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecurityConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecurityConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecurityConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpec(obj: SecurityConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecurityConfigurationSpecForProvider(obj.forProvider),
    'initProvider': toJson_SecurityConfigurationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SecurityConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SecurityConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecurityConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecurityConfigurationSpecDeletionPolicy
 */
export enum SecurityConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SecurityConfigurationSpecForProvider
 */
export interface SecurityConfigurationSpecForProvider {
  /**
   *   Configuration block containing encryption configuration. Detailed below.
   *
   * @schema SecurityConfigurationSpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: SecurityConfigurationSpecForProviderEncryptionConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SecurityConfigurationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProvider(obj: SecurityConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_SecurityConfigurationSpecForProviderEncryptionConfiguration(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SecurityConfigurationSpecInitProvider
 */
export interface SecurityConfigurationSpecInitProvider {
  /**
   *   Configuration block containing encryption configuration. Detailed below.
   *
   * @schema SecurityConfigurationSpecInitProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: SecurityConfigurationSpecInitProviderEncryptionConfiguration[];

}

/**
 * Converts an object of type 'SecurityConfigurationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecInitProvider(obj: SecurityConfigurationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_SecurityConfigurationSpecInitProviderEncryptionConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SecurityConfigurationSpecManagementPolicies
 */
export enum SecurityConfigurationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecurityConfigurationSpecProviderConfigRef
 */
export interface SecurityConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: SecurityConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecProviderConfigRef(obj: SecurityConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsTo
 */
export interface SecurityConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecurityConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecurityConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecPublishConnectionDetailsTo(obj: SecurityConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecurityConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecurityConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecurityConfigurationSpecWriteConnectionSecretToRef
 */
export interface SecurityConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecurityConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecurityConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecWriteConnectionSecretToRef(obj: SecurityConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecurityConfigurationSpecForProviderEncryptionConfiguration
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfiguration {
  /**
   * @schema SecurityConfigurationSpecForProviderEncryptionConfiguration#cloudwatchEncryption
   */
  readonly cloudwatchEncryption?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryption[];

  /**
   * @schema SecurityConfigurationSpecForProviderEncryptionConfiguration#jobBookmarksEncryption
   */
  readonly jobBookmarksEncryption?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption[];

  /**
   * A s3_encryption  block as described below, which contains encryption configuration for S3 data.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfiguration#s3Encryption
   */
  readonly s3Encryption?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption[];

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfiguration(obj: SecurityConfigurationSpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchEncryption': obj.cloudwatchEncryption?.map(y => toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryption(y)),
    'jobBookmarksEncryption': obj.jobBookmarksEncryption?.map(y => toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption(y)),
    's3Encryption': obj.s3Encryption?.map(y => toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecurityConfigurationSpecInitProviderEncryptionConfiguration
 */
export interface SecurityConfigurationSpecInitProviderEncryptionConfiguration {
  /**
   * @schema SecurityConfigurationSpecInitProviderEncryptionConfiguration#cloudwatchEncryption
   */
  readonly cloudwatchEncryption?: SecurityConfigurationSpecInitProviderEncryptionConfigurationCloudwatchEncryption[];

  /**
   * @schema SecurityConfigurationSpecInitProviderEncryptionConfiguration#jobBookmarksEncryption
   */
  readonly jobBookmarksEncryption?: SecurityConfigurationSpecInitProviderEncryptionConfigurationJobBookmarksEncryption[];

  /**
   * A s3_encryption  block as described below, which contains encryption configuration for S3 data.
   *
   * @schema SecurityConfigurationSpecInitProviderEncryptionConfiguration#s3Encryption
   */
  readonly s3Encryption?: SecurityConfigurationSpecInitProviderEncryptionConfigurationS3Encryption[];

}

/**
 * Converts an object of type 'SecurityConfigurationSpecInitProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecInitProviderEncryptionConfiguration(obj: SecurityConfigurationSpecInitProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchEncryption': obj.cloudwatchEncryption?.map(y => toJson_SecurityConfigurationSpecInitProviderEncryptionConfigurationCloudwatchEncryption(y)),
    'jobBookmarksEncryption': obj.jobBookmarksEncryption?.map(y => toJson_SecurityConfigurationSpecInitProviderEncryptionConfigurationJobBookmarksEncryption(y)),
    's3Encryption': obj.s3Encryption?.map(y => toJson_SecurityConfigurationSpecInitProviderEncryptionConfigurationS3Encryption(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityConfigurationSpecProviderConfigRefPolicy
 */
export interface SecurityConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecProviderConfigRefPolicy(obj: SecurityConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface SecurityConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecPublishConnectionDetailsToConfigRef(obj: SecurityConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface SecurityConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecPublishConnectionDetailsToMetadata(obj: SecurityConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryption
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryption {
  /**
   * Encryption mode to use for CloudWatch data. Valid values: DISABLED, SSE-KMS. Default value: DISABLED.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryption#cloudwatchEncryptionMode
   */
  readonly cloudwatchEncryptionMode?: string;

  /**
   * Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryption#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryption#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelector;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryption(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchEncryptionMode': obj.cloudwatchEncryptionMode,
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelector(obj.kmsKeyArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption {
  /**
   * Encryption mode to use for job bookmarks data. Valid values: CSE-KMS, DISABLED. Default value: DISABLED.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption#jobBookmarksEncryptionMode
   */
  readonly jobBookmarksEncryptionMode?: string;

  /**
   * Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jobBookmarksEncryptionMode': obj.jobBookmarksEncryptionMode,
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector(obj.kmsKeyArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption {
  /**
   * Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector;

  /**
   * Encryption mode to use for S3 data. Valid values: DISABLED, SSE-KMS, SSE-S3. Default value: DISABLED.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption#s3EncryptionMode
   */
  readonly s3EncryptionMode?: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationS3Encryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector(obj.kmsKeyArnSelector),
    's3EncryptionMode': obj.s3EncryptionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecurityConfigurationSpecInitProviderEncryptionConfigurationCloudwatchEncryption
 */
export interface SecurityConfigurationSpecInitProviderEncryptionConfigurationCloudwatchEncryption {
  /**
   * Encryption mode to use for CloudWatch data. Valid values: DISABLED, SSE-KMS. Default value: DISABLED.
   *
   * @schema SecurityConfigurationSpecInitProviderEncryptionConfigurationCloudwatchEncryption#cloudwatchEncryptionMode
   */
  readonly cloudwatchEncryptionMode?: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecInitProviderEncryptionConfigurationCloudwatchEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecInitProviderEncryptionConfigurationCloudwatchEncryption(obj: SecurityConfigurationSpecInitProviderEncryptionConfigurationCloudwatchEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchEncryptionMode': obj.cloudwatchEncryptionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecurityConfigurationSpecInitProviderEncryptionConfigurationJobBookmarksEncryption
 */
export interface SecurityConfigurationSpecInitProviderEncryptionConfigurationJobBookmarksEncryption {
  /**
   * Encryption mode to use for job bookmarks data. Valid values: CSE-KMS, DISABLED. Default value: DISABLED.
   *
   * @schema SecurityConfigurationSpecInitProviderEncryptionConfigurationJobBookmarksEncryption#jobBookmarksEncryptionMode
   */
  readonly jobBookmarksEncryptionMode?: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecInitProviderEncryptionConfigurationJobBookmarksEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecInitProviderEncryptionConfigurationJobBookmarksEncryption(obj: SecurityConfigurationSpecInitProviderEncryptionConfigurationJobBookmarksEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jobBookmarksEncryptionMode': obj.jobBookmarksEncryptionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecurityConfigurationSpecInitProviderEncryptionConfigurationS3Encryption
 */
export interface SecurityConfigurationSpecInitProviderEncryptionConfigurationS3Encryption {
  /**
   * Encryption mode to use for S3 data. Valid values: DISABLED, SSE-KMS, SSE-S3. Default value: DISABLED.
   *
   * @schema SecurityConfigurationSpecInitProviderEncryptionConfigurationS3Encryption#s3EncryptionMode
   */
  readonly s3EncryptionMode?: string;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecInitProviderEncryptionConfigurationS3Encryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecInitProviderEncryptionConfigurationS3Encryption(obj: SecurityConfigurationSpecInitProviderEncryptionConfigurationS3Encryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3EncryptionMode': obj.s3EncryptionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum SecurityConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum SecurityConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRef
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRef#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRef(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelector
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelector#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelector(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector#policy
   */
  readonly policy?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecurityConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy
 */
export interface SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy(obj: SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationCloudwatchEncryptionKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationJobBookmarksEncryptionKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolution
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolve
 */
export enum SecurityConfigurationSpecForProviderEncryptionConfigurationS3EncryptionKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Trigger is the Schema for the Triggers API. Manages a Glue Trigger resource.
 *
 * @schema Trigger
 */
export class Trigger extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Trigger"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'Trigger',
  }

  /**
   * Renders a Kubernetes manifest for "Trigger".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TriggerProps): any {
    return {
      ...Trigger.GVK,
      ...toJson_TriggerProps(props),
    };
  }

  /**
   * Defines a "Trigger" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TriggerProps) {
    super(scope, id, {
      ...Trigger.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Trigger.GVK,
      ...toJson_TriggerProps(resolved),
    };
  }
}

/**
 * Trigger is the Schema for the Triggers API. Manages a Glue Trigger resource.
 *
 * @schema Trigger
 */
export interface TriggerProps {
  /**
   * @schema Trigger#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TriggerSpec defines the desired state of Trigger
   *
   * @schema Trigger#spec
   */
  readonly spec: TriggerSpec;

}

/**
 * Converts an object of type 'TriggerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerProps(obj: TriggerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TriggerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TriggerSpec defines the desired state of Trigger
 *
 * @schema TriggerSpec
 */
export interface TriggerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TriggerSpec#deletionPolicy
   */
  readonly deletionPolicy?: TriggerSpecDeletionPolicy;

  /**
   * @schema TriggerSpec#forProvider
   */
  readonly forProvider: TriggerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TriggerSpec#initProvider
   */
  readonly initProvider?: TriggerSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TriggerSpec#managementPolicies
   */
  readonly managementPolicies?: TriggerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TriggerSpec#providerConfigRef
   */
  readonly providerConfigRef?: TriggerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TriggerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TriggerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TriggerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TriggerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TriggerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpec(obj: TriggerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TriggerSpecForProvider(obj.forProvider),
    'initProvider': toJson_TriggerSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TriggerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TriggerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TriggerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TriggerSpecDeletionPolicy
 */
export enum TriggerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TriggerSpecForProvider
 */
export interface TriggerSpecForProvider {
  /**
   *   List of actions initiated by this trigger when it fires. See Actions Below.
   *
   * @schema TriggerSpecForProvider#actions
   */
  readonly actions?: TriggerSpecForProviderActions[];

  /**
   *   A description of the new trigger.
   *
   * @schema TriggerSpecForProvider#description
   */
  readonly description?: string;

  /**
   *   Start the trigger. Defaults to true.
   *
   * @default true.
   * @schema TriggerSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires. See Event Batching Condition.
   *
   * @schema TriggerSpecForProvider#eventBatchingCondition
   */
  readonly eventBatchingCondition?: TriggerSpecForProviderEventBatchingCondition[];

  /**
   *   A predicate to specify when the new trigger should fire. Required when trigger type is CONDITIONAL. See Predicate Below.
   *
   * @schema TriggerSpecForProvider#predicate
   */
  readonly predicate?: TriggerSpecForProviderPredicate[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TriggerSpecForProvider#region
   */
  readonly region: string;

  /**
   * Based Schedules for Jobs and Crawlers
   *
   * @schema TriggerSpecForProvider#schedule
   */
  readonly schedule?: string;

  /**
   *   Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.
   *
   * @schema TriggerSpecForProvider#startOnCreation
   */
  readonly startOnCreation?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema TriggerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   *   The type of trigger. Valid values are CONDITIONAL, EVENT, ON_DEMAND, and SCHEDULED.
   *
   * @schema TriggerSpecForProvider#type
   */
  readonly type?: string;

  /**
   * A workflow to which the trigger should be associated to. Every workflow graph (DAG) needs a starting trigger (ON_DEMAND or SCHEDULED type) and can contain multiple additional CONDITIONAL triggers.
   *
   * @schema TriggerSpecForProvider#workflowName
   */
  readonly workflowName?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProvider(obj: TriggerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => toJson_TriggerSpecForProviderActions(y)),
    'description': obj.description,
    'enabled': obj.enabled,
    'eventBatchingCondition': obj.eventBatchingCondition?.map(y => toJson_TriggerSpecForProviderEventBatchingCondition(y)),
    'predicate': obj.predicate?.map(y => toJson_TriggerSpecForProviderPredicate(y)),
    'region': obj.region,
    'schedule': obj.schedule,
    'startOnCreation': obj.startOnCreation,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
    'workflowName': obj.workflowName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TriggerSpecInitProvider
 */
export interface TriggerSpecInitProvider {
  /**
   *   List of actions initiated by this trigger when it fires. See Actions Below.
   *
   * @schema TriggerSpecInitProvider#actions
   */
  readonly actions?: TriggerSpecInitProviderActions[];

  /**
   *   A description of the new trigger.
   *
   * @schema TriggerSpecInitProvider#description
   */
  readonly description?: string;

  /**
   *   Start the trigger. Defaults to true.
   *
   * @default true.
   * @schema TriggerSpecInitProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires. See Event Batching Condition.
   *
   * @schema TriggerSpecInitProvider#eventBatchingCondition
   */
  readonly eventBatchingCondition?: TriggerSpecInitProviderEventBatchingCondition[];

  /**
   *   A predicate to specify when the new trigger should fire. Required when trigger type is CONDITIONAL. See Predicate Below.
   *
   * @schema TriggerSpecInitProvider#predicate
   */
  readonly predicate?: TriggerSpecInitProviderPredicate[];

  /**
   * Based Schedules for Jobs and Crawlers
   *
   * @schema TriggerSpecInitProvider#schedule
   */
  readonly schedule?: string;

  /**
   *   Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.
   *
   * @schema TriggerSpecInitProvider#startOnCreation
   */
  readonly startOnCreation?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema TriggerSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   *   The type of trigger. Valid values are CONDITIONAL, EVENT, ON_DEMAND, and SCHEDULED.
   *
   * @schema TriggerSpecInitProvider#type
   */
  readonly type?: string;

  /**
   * A workflow to which the trigger should be associated to. Every workflow graph (DAG) needs a starting trigger (ON_DEMAND or SCHEDULED type) and can contain multiple additional CONDITIONAL triggers.
   *
   * @schema TriggerSpecInitProvider#workflowName
   */
  readonly workflowName?: string;

}

/**
 * Converts an object of type 'TriggerSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecInitProvider(obj: TriggerSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => toJson_TriggerSpecInitProviderActions(y)),
    'description': obj.description,
    'enabled': obj.enabled,
    'eventBatchingCondition': obj.eventBatchingCondition?.map(y => toJson_TriggerSpecInitProviderEventBatchingCondition(y)),
    'predicate': obj.predicate?.map(y => toJson_TriggerSpecInitProviderPredicate(y)),
    'schedule': obj.schedule,
    'startOnCreation': obj.startOnCreation,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
    'workflowName': obj.workflowName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TriggerSpecManagementPolicies
 */
export enum TriggerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TriggerSpecProviderConfigRef
 */
export interface TriggerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecProviderConfigRef#policy
   */
  readonly policy?: TriggerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecProviderConfigRef(obj: TriggerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TriggerSpecPublishConnectionDetailsTo
 */
export interface TriggerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TriggerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TriggerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TriggerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TriggerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TriggerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsTo(obj: TriggerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TriggerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TriggerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TriggerSpecWriteConnectionSecretToRef
 */
export interface TriggerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TriggerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TriggerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TriggerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecWriteConnectionSecretToRef(obj: TriggerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderActions
 */
export interface TriggerSpecForProviderActions {
  /**
   * Arguments to be passed to the job. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes.
   *
   * @schema TriggerSpecForProviderActions#arguments
   */
  readonly arguments?: { [key: string]: string };

  /**
   * The name of the crawler to be executed. Conflicts with job_name.
   *
   * @schema TriggerSpecForProviderActions#crawlerName
   */
  readonly crawlerName?: string;

  /**
   * Reference to a Crawler in glue to populate crawlerName.
   *
   * @schema TriggerSpecForProviderActions#crawlerNameRef
   */
  readonly crawlerNameRef?: TriggerSpecForProviderActionsCrawlerNameRef;

  /**
   * Selector for a Crawler in glue to populate crawlerName.
   *
   * @schema TriggerSpecForProviderActions#crawlerNameSelector
   */
  readonly crawlerNameSelector?: TriggerSpecForProviderActionsCrawlerNameSelector;

  /**
   * The name of a job to be executed. Conflicts with crawler_name.
   *
   * @schema TriggerSpecForProviderActions#jobName
   */
  readonly jobName?: string;

  /**
   * Reference to a Job in glue to populate jobName.
   *
   * @schema TriggerSpecForProviderActions#jobNameRef
   */
  readonly jobNameRef?: TriggerSpecForProviderActionsJobNameRef;

  /**
   * Selector for a Job in glue to populate jobName.
   *
   * @schema TriggerSpecForProviderActions#jobNameSelector
   */
  readonly jobNameSelector?: TriggerSpecForProviderActionsJobNameSelector;

  /**
   * Specifies configuration properties of a job run notification. See Notification Property details below.
   *
   * @schema TriggerSpecForProviderActions#notificationProperty
   */
  readonly notificationProperty?: TriggerSpecForProviderActionsNotificationProperty[];

  /**
   * The name of the Security Configuration structure to be used with this action.
   *
   * @schema TriggerSpecForProviderActions#securityConfiguration
   */
  readonly securityConfiguration?: string;

  /**
   * The job run timeout in minutes. It overrides the timeout value of the job.
   *
   * @schema TriggerSpecForProviderActions#timeout
   */
  readonly timeout?: number;

}

/**
 * Converts an object of type 'TriggerSpecForProviderActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderActions(obj: TriggerSpecForProviderActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arguments': ((obj.arguments) === undefined) ? undefined : (Object.entries(obj.arguments).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'crawlerName': obj.crawlerName,
    'crawlerNameRef': toJson_TriggerSpecForProviderActionsCrawlerNameRef(obj.crawlerNameRef),
    'crawlerNameSelector': toJson_TriggerSpecForProviderActionsCrawlerNameSelector(obj.crawlerNameSelector),
    'jobName': obj.jobName,
    'jobNameRef': toJson_TriggerSpecForProviderActionsJobNameRef(obj.jobNameRef),
    'jobNameSelector': toJson_TriggerSpecForProviderActionsJobNameSelector(obj.jobNameSelector),
    'notificationProperty': obj.notificationProperty?.map(y => toJson_TriggerSpecForProviderActionsNotificationProperty(y)),
    'securityConfiguration': obj.securityConfiguration,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderEventBatchingCondition
 */
export interface TriggerSpecForProviderEventBatchingCondition {
  /**
   * Number of events that must be received from Amazon EventBridge before EventBridge  event trigger fires.
   *
   * @schema TriggerSpecForProviderEventBatchingCondition#batchSize
   */
  readonly batchSize?: number;

  /**
   * Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received. Default value is 900.
   *
   * @schema TriggerSpecForProviderEventBatchingCondition#batchWindow
   */
  readonly batchWindow?: number;

}

/**
 * Converts an object of type 'TriggerSpecForProviderEventBatchingCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderEventBatchingCondition(obj: TriggerSpecForProviderEventBatchingCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchSize': obj.batchSize,
    'batchWindow': obj.batchWindow,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderPredicate
 */
export interface TriggerSpecForProviderPredicate {
  /**
   * A list of the conditions that determine when the trigger will fire. See Conditions.
   *
   * @schema TriggerSpecForProviderPredicate#conditions
   */
  readonly conditions?: TriggerSpecForProviderPredicateConditions[];

  /**
   * How to handle multiple conditions. Defaults to AND. Valid values are AND or ANY.
   *
   * @default AND. Valid values are AND or ANY.
   * @schema TriggerSpecForProviderPredicate#logical
   */
  readonly logical?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPredicate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPredicate(obj: TriggerSpecForProviderPredicate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_TriggerSpecForProviderPredicateConditions(y)),
    'logical': obj.logical,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecInitProviderActions
 */
export interface TriggerSpecInitProviderActions {
  /**
   * Arguments to be passed to the job. You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes.
   *
   * @schema TriggerSpecInitProviderActions#arguments
   */
  readonly arguments?: { [key: string]: string };

  /**
   * Specifies configuration properties of a job run notification. See Notification Property details below.
   *
   * @schema TriggerSpecInitProviderActions#notificationProperty
   */
  readonly notificationProperty?: TriggerSpecInitProviderActionsNotificationProperty[];

  /**
   * The name of the Security Configuration structure to be used with this action.
   *
   * @schema TriggerSpecInitProviderActions#securityConfiguration
   */
  readonly securityConfiguration?: string;

  /**
   * The job run timeout in minutes. It overrides the timeout value of the job.
   *
   * @schema TriggerSpecInitProviderActions#timeout
   */
  readonly timeout?: number;

}

/**
 * Converts an object of type 'TriggerSpecInitProviderActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecInitProviderActions(obj: TriggerSpecInitProviderActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arguments': ((obj.arguments) === undefined) ? undefined : (Object.entries(obj.arguments).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'notificationProperty': obj.notificationProperty?.map(y => toJson_TriggerSpecInitProviderActionsNotificationProperty(y)),
    'securityConfiguration': obj.securityConfiguration,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecInitProviderEventBatchingCondition
 */
export interface TriggerSpecInitProviderEventBatchingCondition {
  /**
   * Number of events that must be received from Amazon EventBridge before EventBridge  event trigger fires.
   *
   * @schema TriggerSpecInitProviderEventBatchingCondition#batchSize
   */
  readonly batchSize?: number;

  /**
   * Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received. Default value is 900.
   *
   * @schema TriggerSpecInitProviderEventBatchingCondition#batchWindow
   */
  readonly batchWindow?: number;

}

/**
 * Converts an object of type 'TriggerSpecInitProviderEventBatchingCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecInitProviderEventBatchingCondition(obj: TriggerSpecInitProviderEventBatchingCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'batchSize': obj.batchSize,
    'batchWindow': obj.batchWindow,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecInitProviderPredicate
 */
export interface TriggerSpecInitProviderPredicate {
  /**
   * A list of the conditions that determine when the trigger will fire. See Conditions.
   *
   * @schema TriggerSpecInitProviderPredicate#conditions
   */
  readonly conditions?: TriggerSpecInitProviderPredicateConditions[];

  /**
   * How to handle multiple conditions. Defaults to AND. Valid values are AND or ANY.
   *
   * @default AND. Valid values are AND or ANY.
   * @schema TriggerSpecInitProviderPredicate#logical
   */
  readonly logical?: string;

}

/**
 * Converts an object of type 'TriggerSpecInitProviderPredicate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecInitProviderPredicate(obj: TriggerSpecInitProviderPredicate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_TriggerSpecInitProviderPredicateConditions(y)),
    'logical': obj.logical,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecProviderConfigRefPolicy
 */
export interface TriggerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecProviderConfigRefPolicy(obj: TriggerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRef
 */
export interface TriggerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TriggerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsToConfigRef(obj: TriggerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TriggerSpecPublishConnectionDetailsToMetadata
 */
export interface TriggerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TriggerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TriggerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TriggerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsToMetadata(obj: TriggerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Crawler in glue to populate crawlerName.
 *
 * @schema TriggerSpecForProviderActionsCrawlerNameRef
 */
export interface TriggerSpecForProviderActionsCrawlerNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecForProviderActionsCrawlerNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecForProviderActionsCrawlerNameRef#policy
   */
  readonly policy?: TriggerSpecForProviderActionsCrawlerNameRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderActionsCrawlerNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderActionsCrawlerNameRef(obj: TriggerSpecForProviderActionsCrawlerNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecForProviderActionsCrawlerNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Crawler in glue to populate crawlerName.
 *
 * @schema TriggerSpecForProviderActionsCrawlerNameSelector
 */
export interface TriggerSpecForProviderActionsCrawlerNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TriggerSpecForProviderActionsCrawlerNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TriggerSpecForProviderActionsCrawlerNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TriggerSpecForProviderActionsCrawlerNameSelector#policy
   */
  readonly policy?: TriggerSpecForProviderActionsCrawlerNameSelectorPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderActionsCrawlerNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderActionsCrawlerNameSelector(obj: TriggerSpecForProviderActionsCrawlerNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TriggerSpecForProviderActionsCrawlerNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Job in glue to populate jobName.
 *
 * @schema TriggerSpecForProviderActionsJobNameRef
 */
export interface TriggerSpecForProviderActionsJobNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecForProviderActionsJobNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecForProviderActionsJobNameRef#policy
   */
  readonly policy?: TriggerSpecForProviderActionsJobNameRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderActionsJobNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderActionsJobNameRef(obj: TriggerSpecForProviderActionsJobNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecForProviderActionsJobNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Job in glue to populate jobName.
 *
 * @schema TriggerSpecForProviderActionsJobNameSelector
 */
export interface TriggerSpecForProviderActionsJobNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TriggerSpecForProviderActionsJobNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TriggerSpecForProviderActionsJobNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TriggerSpecForProviderActionsJobNameSelector#policy
   */
  readonly policy?: TriggerSpecForProviderActionsJobNameSelectorPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderActionsJobNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderActionsJobNameSelector(obj: TriggerSpecForProviderActionsJobNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TriggerSpecForProviderActionsJobNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderActionsNotificationProperty
 */
export interface TriggerSpecForProviderActionsNotificationProperty {
  /**
   * After a job run starts, the number of minutes to wait before sending a job run delay notification.
   *
   * @schema TriggerSpecForProviderActionsNotificationProperty#notifyDelayAfter
   */
  readonly notifyDelayAfter?: number;

}

/**
 * Converts an object of type 'TriggerSpecForProviderActionsNotificationProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderActionsNotificationProperty(obj: TriggerSpecForProviderActionsNotificationProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notifyDelayAfter': obj.notifyDelayAfter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecForProviderPredicateConditions
 */
export interface TriggerSpecForProviderPredicateConditions {
  /**
   * The condition crawl state. Currently, the values supported are RUNNING, SUCCEEDED, CANCELLED, and FAILED. If this is specified, crawler_name must also be specified. Conflicts with state.
   *
   * @schema TriggerSpecForProviderPredicateConditions#crawlState
   */
  readonly crawlState?: string;

  /**
   * The name of the crawler to be executed. Conflicts with job_name.
   *
   * @schema TriggerSpecForProviderPredicateConditions#crawlerName
   */
  readonly crawlerName?: string;

  /**
   * Reference to a Crawler in glue to populate crawlerName.
   *
   * @schema TriggerSpecForProviderPredicateConditions#crawlerNameRef
   */
  readonly crawlerNameRef?: TriggerSpecForProviderPredicateConditionsCrawlerNameRef;

  /**
   * Selector for a Crawler in glue to populate crawlerName.
   *
   * @schema TriggerSpecForProviderPredicateConditions#crawlerNameSelector
   */
  readonly crawlerNameSelector?: TriggerSpecForProviderPredicateConditionsCrawlerNameSelector;

  /**
   * The name of a job to be executed. Conflicts with crawler_name.
   *
   * @schema TriggerSpecForProviderPredicateConditions#jobName
   */
  readonly jobName?: string;

  /**
   * Reference to a Job in glue to populate jobName.
   *
   * @schema TriggerSpecForProviderPredicateConditions#jobNameRef
   */
  readonly jobNameRef?: TriggerSpecForProviderPredicateConditionsJobNameRef;

  /**
   * Selector for a Job in glue to populate jobName.
   *
   * @schema TriggerSpecForProviderPredicateConditions#jobNameSelector
   */
  readonly jobNameSelector?: TriggerSpecForProviderPredicateConditionsJobNameSelector;

  /**
   * A logical operator. Defaults to EQUALS.
   *
   * @default EQUALS.
   * @schema TriggerSpecForProviderPredicateConditions#logicalOperator
   */
  readonly logicalOperator?: string;

  /**
   * The condition job state. Currently, the values supported are SUCCEEDED, STOPPED, TIMEOUT and FAILED. If this is specified, job_name must also be specified. Conflicts with crawler_state.
   *
   * @schema TriggerSpecForProviderPredicateConditions#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPredicateConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPredicateConditions(obj: TriggerSpecForProviderPredicateConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crawlState': obj.crawlState,
    'crawlerName': obj.crawlerName,
    'crawlerNameRef': toJson_TriggerSpecForProviderPredicateConditionsCrawlerNameRef(obj.crawlerNameRef),
    'crawlerNameSelector': toJson_TriggerSpecForProviderPredicateConditionsCrawlerNameSelector(obj.crawlerNameSelector),
    'jobName': obj.jobName,
    'jobNameRef': toJson_TriggerSpecForProviderPredicateConditionsJobNameRef(obj.jobNameRef),
    'jobNameSelector': toJson_TriggerSpecForProviderPredicateConditionsJobNameSelector(obj.jobNameSelector),
    'logicalOperator': obj.logicalOperator,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecInitProviderActionsNotificationProperty
 */
export interface TriggerSpecInitProviderActionsNotificationProperty {
  /**
   * After a job run starts, the number of minutes to wait before sending a job run delay notification.
   *
   * @schema TriggerSpecInitProviderActionsNotificationProperty#notifyDelayAfter
   */
  readonly notifyDelayAfter?: number;

}

/**
 * Converts an object of type 'TriggerSpecInitProviderActionsNotificationProperty' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecInitProviderActionsNotificationProperty(obj: TriggerSpecInitProviderActionsNotificationProperty | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notifyDelayAfter': obj.notifyDelayAfter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TriggerSpecInitProviderPredicateConditions
 */
export interface TriggerSpecInitProviderPredicateConditions {
  /**
   * The condition crawl state. Currently, the values supported are RUNNING, SUCCEEDED, CANCELLED, and FAILED. If this is specified, crawler_name must also be specified. Conflicts with state.
   *
   * @schema TriggerSpecInitProviderPredicateConditions#crawlState
   */
  readonly crawlState?: string;

  /**
   * A logical operator. Defaults to EQUALS.
   *
   * @default EQUALS.
   * @schema TriggerSpecInitProviderPredicateConditions#logicalOperator
   */
  readonly logicalOperator?: string;

  /**
   * The condition job state. Currently, the values supported are SUCCEEDED, STOPPED, TIMEOUT and FAILED. If this is specified, job_name must also be specified. Conflicts with crawler_state.
   *
   * @schema TriggerSpecInitProviderPredicateConditions#state
   */
  readonly state?: string;

}

/**
 * Converts an object of type 'TriggerSpecInitProviderPredicateConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecInitProviderPredicateConditions(obj: TriggerSpecInitProviderPredicateConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crawlState': obj.crawlState,
    'logicalOperator': obj.logicalOperator,
    'state': obj.state,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecProviderConfigRefPolicyResolution
 */
export enum TriggerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecProviderConfigRefPolicyResolve
 */
export enum TriggerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TriggerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecPublishConnectionDetailsToConfigRefPolicy(obj: TriggerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecForProviderActionsCrawlerNameRefPolicy
 */
export interface TriggerSpecForProviderActionsCrawlerNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderActionsCrawlerNameRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderActionsCrawlerNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderActionsCrawlerNameRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderActionsCrawlerNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderActionsCrawlerNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderActionsCrawlerNameRefPolicy(obj: TriggerSpecForProviderActionsCrawlerNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TriggerSpecForProviderActionsCrawlerNameSelectorPolicy
 */
export interface TriggerSpecForProviderActionsCrawlerNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderActionsCrawlerNameSelectorPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderActionsCrawlerNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderActionsCrawlerNameSelectorPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderActionsCrawlerNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderActionsCrawlerNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderActionsCrawlerNameSelectorPolicy(obj: TriggerSpecForProviderActionsCrawlerNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecForProviderActionsJobNameRefPolicy
 */
export interface TriggerSpecForProviderActionsJobNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderActionsJobNameRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderActionsJobNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderActionsJobNameRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderActionsJobNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderActionsJobNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderActionsJobNameRefPolicy(obj: TriggerSpecForProviderActionsJobNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TriggerSpecForProviderActionsJobNameSelectorPolicy
 */
export interface TriggerSpecForProviderActionsJobNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderActionsJobNameSelectorPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderActionsJobNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderActionsJobNameSelectorPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderActionsJobNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderActionsJobNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderActionsJobNameSelectorPolicy(obj: TriggerSpecForProviderActionsJobNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Crawler in glue to populate crawlerName.
 *
 * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameRef
 */
export interface TriggerSpecForProviderPredicateConditionsCrawlerNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameRef#policy
   */
  readonly policy?: TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPredicateConditionsCrawlerNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPredicateConditionsCrawlerNameRef(obj: TriggerSpecForProviderPredicateConditionsCrawlerNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Crawler in glue to populate crawlerName.
 *
 * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameSelector
 */
export interface TriggerSpecForProviderPredicateConditionsCrawlerNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameSelector#policy
   */
  readonly policy?: TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPredicateConditionsCrawlerNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPredicateConditionsCrawlerNameSelector(obj: TriggerSpecForProviderPredicateConditionsCrawlerNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Job in glue to populate jobName.
 *
 * @schema TriggerSpecForProviderPredicateConditionsJobNameRef
 */
export interface TriggerSpecForProviderPredicateConditionsJobNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TriggerSpecForProviderPredicateConditionsJobNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TriggerSpecForProviderPredicateConditionsJobNameRef#policy
   */
  readonly policy?: TriggerSpecForProviderPredicateConditionsJobNameRefPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPredicateConditionsJobNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPredicateConditionsJobNameRef(obj: TriggerSpecForProviderPredicateConditionsJobNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TriggerSpecForProviderPredicateConditionsJobNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Job in glue to populate jobName.
 *
 * @schema TriggerSpecForProviderPredicateConditionsJobNameSelector
 */
export interface TriggerSpecForProviderPredicateConditionsJobNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TriggerSpecForProviderPredicateConditionsJobNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TriggerSpecForProviderPredicateConditionsJobNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TriggerSpecForProviderPredicateConditionsJobNameSelector#policy
   */
  readonly policy?: TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicy;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPredicateConditionsJobNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPredicateConditionsJobNameSelector(obj: TriggerSpecForProviderPredicateConditionsJobNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TriggerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderActionsCrawlerNameRefPolicyResolution
 */
export enum TriggerSpecForProviderActionsCrawlerNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderActionsCrawlerNameRefPolicyResolve
 */
export enum TriggerSpecForProviderActionsCrawlerNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderActionsCrawlerNameSelectorPolicyResolution
 */
export enum TriggerSpecForProviderActionsCrawlerNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderActionsCrawlerNameSelectorPolicyResolve
 */
export enum TriggerSpecForProviderActionsCrawlerNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderActionsJobNameRefPolicyResolution
 */
export enum TriggerSpecForProviderActionsJobNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderActionsJobNameRefPolicyResolve
 */
export enum TriggerSpecForProviderActionsJobNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderActionsJobNameSelectorPolicyResolution
 */
export enum TriggerSpecForProviderActionsJobNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderActionsJobNameSelectorPolicyResolve
 */
export enum TriggerSpecForProviderActionsJobNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicy
 */
export interface TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicy(obj: TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicy
 */
export interface TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicy(obj: TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TriggerSpecForProviderPredicateConditionsJobNameRefPolicy
 */
export interface TriggerSpecForProviderPredicateConditionsJobNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderPredicateConditionsJobNameRefPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderPredicateConditionsJobNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderPredicateConditionsJobNameRefPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderPredicateConditionsJobNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPredicateConditionsJobNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPredicateConditionsJobNameRefPolicy(obj: TriggerSpecForProviderPredicateConditionsJobNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicy
 */
export interface TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicy#resolution
   */
  readonly resolution?: TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicy#resolve
   */
  readonly resolve?: TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicy(obj: TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicyResolution
 */
export enum TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicyResolve
 */
export enum TriggerSpecForProviderPredicateConditionsCrawlerNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicyResolution
 */
export enum TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicyResolve
 */
export enum TriggerSpecForProviderPredicateConditionsCrawlerNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderPredicateConditionsJobNameRefPolicyResolution
 */
export enum TriggerSpecForProviderPredicateConditionsJobNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderPredicateConditionsJobNameRefPolicyResolve
 */
export enum TriggerSpecForProviderPredicateConditionsJobNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicyResolution
 */
export enum TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicyResolve
 */
export enum TriggerSpecForProviderPredicateConditionsJobNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserDefinedFunction is the Schema for the UserDefinedFunctions API. Provides a Glue User Defined Function.
 *
 * @schema UserDefinedFunction
 */
export class UserDefinedFunction extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserDefinedFunction"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'UserDefinedFunction',
  }

  /**
   * Renders a Kubernetes manifest for "UserDefinedFunction".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserDefinedFunctionProps): any {
    return {
      ...UserDefinedFunction.GVK,
      ...toJson_UserDefinedFunctionProps(props),
    };
  }

  /**
   * Defines a "UserDefinedFunction" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserDefinedFunctionProps) {
    super(scope, id, {
      ...UserDefinedFunction.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserDefinedFunction.GVK,
      ...toJson_UserDefinedFunctionProps(resolved),
    };
  }
}

/**
 * UserDefinedFunction is the Schema for the UserDefinedFunctions API. Provides a Glue User Defined Function.
 *
 * @schema UserDefinedFunction
 */
export interface UserDefinedFunctionProps {
  /**
   * @schema UserDefinedFunction#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserDefinedFunctionSpec defines the desired state of UserDefinedFunction
   *
   * @schema UserDefinedFunction#spec
   */
  readonly spec: UserDefinedFunctionSpec;

}

/**
 * Converts an object of type 'UserDefinedFunctionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionProps(obj: UserDefinedFunctionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserDefinedFunctionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserDefinedFunctionSpec defines the desired state of UserDefinedFunction
 *
 * @schema UserDefinedFunctionSpec
 */
export interface UserDefinedFunctionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserDefinedFunctionSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserDefinedFunctionSpecDeletionPolicy;

  /**
   * @schema UserDefinedFunctionSpec#forProvider
   */
  readonly forProvider: UserDefinedFunctionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema UserDefinedFunctionSpec#initProvider
   */
  readonly initProvider?: UserDefinedFunctionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UserDefinedFunctionSpec#managementPolicies
   */
  readonly managementPolicies?: UserDefinedFunctionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserDefinedFunctionSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserDefinedFunctionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserDefinedFunctionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserDefinedFunctionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserDefinedFunctionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserDefinedFunctionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpec(obj: UserDefinedFunctionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserDefinedFunctionSpecForProvider(obj.forProvider),
    'initProvider': toJson_UserDefinedFunctionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UserDefinedFunctionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UserDefinedFunctionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserDefinedFunctionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserDefinedFunctionSpecDeletionPolicy
 */
export enum UserDefinedFunctionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserDefinedFunctionSpecForProvider
 */
export interface UserDefinedFunctionSpecForProvider {
  /**
   * ID of the Glue Catalog to create the function in. If omitted, this defaults to the AWS Account ID.
   *
   * @schema UserDefinedFunctionSpecForProvider#catalogId
   */
  readonly catalogId: string;

  /**
   * The Java class that contains the function code.
   *
   * @schema UserDefinedFunctionSpecForProvider#className
   */
  readonly className?: string;

  /**
   * The name of the Database to create the Function.
   *
   * @schema UserDefinedFunctionSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * Reference to a CatalogDatabase in glue to populate databaseName.
   *
   * @schema UserDefinedFunctionSpecForProvider#databaseNameRef
   */
  readonly databaseNameRef?: UserDefinedFunctionSpecForProviderDatabaseNameRef;

  /**
   * Selector for a CatalogDatabase in glue to populate databaseName.
   *
   * @schema UserDefinedFunctionSpecForProvider#databaseNameSelector
   */
  readonly databaseNameSelector?: UserDefinedFunctionSpecForProviderDatabaseNameSelector;

  /**
   * The owner of the function.
   *
   * @schema UserDefinedFunctionSpecForProvider#ownerName
   */
  readonly ownerName?: string;

  /**
   * The owner type. can be one of USER, ROLE, and GROUP.
   *
   * @schema UserDefinedFunctionSpecForProvider#ownerType
   */
  readonly ownerType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserDefinedFunctionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The configuration block for Resource URIs. See resource uris below for more details.
   *
   * @schema UserDefinedFunctionSpecForProvider#resourceUris
   */
  readonly resourceUris?: UserDefinedFunctionSpecForProviderResourceUris[];

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecForProvider(obj: UserDefinedFunctionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'catalogId': obj.catalogId,
    'className': obj.className,
    'databaseName': obj.databaseName,
    'databaseNameRef': toJson_UserDefinedFunctionSpecForProviderDatabaseNameRef(obj.databaseNameRef),
    'databaseNameSelector': toJson_UserDefinedFunctionSpecForProviderDatabaseNameSelector(obj.databaseNameSelector),
    'ownerName': obj.ownerName,
    'ownerType': obj.ownerType,
    'region': obj.region,
    'resourceUris': obj.resourceUris?.map(y => toJson_UserDefinedFunctionSpecForProviderResourceUris(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema UserDefinedFunctionSpecInitProvider
 */
export interface UserDefinedFunctionSpecInitProvider {
  /**
   * The Java class that contains the function code.
   *
   * @schema UserDefinedFunctionSpecInitProvider#className
   */
  readonly className?: string;

  /**
   * The owner of the function.
   *
   * @schema UserDefinedFunctionSpecInitProvider#ownerName
   */
  readonly ownerName?: string;

  /**
   * The owner type. can be one of USER, ROLE, and GROUP.
   *
   * @schema UserDefinedFunctionSpecInitProvider#ownerType
   */
  readonly ownerType?: string;

  /**
   * The configuration block for Resource URIs. See resource uris below for more details.
   *
   * @schema UserDefinedFunctionSpecInitProvider#resourceUris
   */
  readonly resourceUris?: UserDefinedFunctionSpecInitProviderResourceUris[];

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecInitProvider(obj: UserDefinedFunctionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'className': obj.className,
    'ownerName': obj.ownerName,
    'ownerType': obj.ownerType,
    'resourceUris': obj.resourceUris?.map(y => toJson_UserDefinedFunctionSpecInitProviderResourceUris(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UserDefinedFunctionSpecManagementPolicies
 */
export enum UserDefinedFunctionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserDefinedFunctionSpecProviderConfigRef
 */
export interface UserDefinedFunctionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserDefinedFunctionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserDefinedFunctionSpecProviderConfigRef#policy
   */
  readonly policy?: UserDefinedFunctionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecProviderConfigRef(obj: UserDefinedFunctionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserDefinedFunctionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserDefinedFunctionSpecPublishConnectionDetailsTo
 */
export interface UserDefinedFunctionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserDefinedFunctionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserDefinedFunctionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserDefinedFunctionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserDefinedFunctionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserDefinedFunctionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecPublishConnectionDetailsTo(obj: UserDefinedFunctionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserDefinedFunctionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserDefinedFunctionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserDefinedFunctionSpecWriteConnectionSecretToRef
 */
export interface UserDefinedFunctionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserDefinedFunctionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserDefinedFunctionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecWriteConnectionSecretToRef(obj: UserDefinedFunctionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CatalogDatabase in glue to populate databaseName.
 *
 * @schema UserDefinedFunctionSpecForProviderDatabaseNameRef
 */
export interface UserDefinedFunctionSpecForProviderDatabaseNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserDefinedFunctionSpecForProviderDatabaseNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserDefinedFunctionSpecForProviderDatabaseNameRef#policy
   */
  readonly policy?: UserDefinedFunctionSpecForProviderDatabaseNameRefPolicy;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecForProviderDatabaseNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecForProviderDatabaseNameRef(obj: UserDefinedFunctionSpecForProviderDatabaseNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserDefinedFunctionSpecForProviderDatabaseNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CatalogDatabase in glue to populate databaseName.
 *
 * @schema UserDefinedFunctionSpecForProviderDatabaseNameSelector
 */
export interface UserDefinedFunctionSpecForProviderDatabaseNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserDefinedFunctionSpecForProviderDatabaseNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserDefinedFunctionSpecForProviderDatabaseNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserDefinedFunctionSpecForProviderDatabaseNameSelector#policy
   */
  readonly policy?: UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicy;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecForProviderDatabaseNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecForProviderDatabaseNameSelector(obj: UserDefinedFunctionSpecForProviderDatabaseNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserDefinedFunctionSpecForProviderResourceUris
 */
export interface UserDefinedFunctionSpecForProviderResourceUris {
  /**
   * The type of the resource. can be one of JAR, FILE, and ARCHIVE.
   *
   * @schema UserDefinedFunctionSpecForProviderResourceUris#resourceType
   */
  readonly resourceType?: string;

  /**
   * The URI for accessing the resource.
   *
   * @schema UserDefinedFunctionSpecForProviderResourceUris#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecForProviderResourceUris' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecForProviderResourceUris(obj: UserDefinedFunctionSpecForProviderResourceUris | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserDefinedFunctionSpecInitProviderResourceUris
 */
export interface UserDefinedFunctionSpecInitProviderResourceUris {
  /**
   * The type of the resource. can be one of JAR, FILE, and ARCHIVE.
   *
   * @schema UserDefinedFunctionSpecInitProviderResourceUris#resourceType
   */
  readonly resourceType?: string;

  /**
   * The URI for accessing the resource.
   *
   * @schema UserDefinedFunctionSpecInitProviderResourceUris#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecInitProviderResourceUris' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecInitProviderResourceUris(obj: UserDefinedFunctionSpecInitProviderResourceUris | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceType': obj.resourceType,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserDefinedFunctionSpecProviderConfigRefPolicy
 */
export interface UserDefinedFunctionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserDefinedFunctionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserDefinedFunctionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserDefinedFunctionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserDefinedFunctionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecProviderConfigRefPolicy(obj: UserDefinedFunctionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserDefinedFunctionSpecPublishConnectionDetailsToConfigRef
 */
export interface UserDefinedFunctionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserDefinedFunctionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserDefinedFunctionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecPublishConnectionDetailsToConfigRef(obj: UserDefinedFunctionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserDefinedFunctionSpecPublishConnectionDetailsToMetadata
 */
export interface UserDefinedFunctionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserDefinedFunctionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserDefinedFunctionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserDefinedFunctionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecPublishConnectionDetailsToMetadata(obj: UserDefinedFunctionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserDefinedFunctionSpecForProviderDatabaseNameRefPolicy
 */
export interface UserDefinedFunctionSpecForProviderDatabaseNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserDefinedFunctionSpecForProviderDatabaseNameRefPolicy#resolution
   */
  readonly resolution?: UserDefinedFunctionSpecForProviderDatabaseNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserDefinedFunctionSpecForProviderDatabaseNameRefPolicy#resolve
   */
  readonly resolve?: UserDefinedFunctionSpecForProviderDatabaseNameRefPolicyResolve;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecForProviderDatabaseNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecForProviderDatabaseNameRefPolicy(obj: UserDefinedFunctionSpecForProviderDatabaseNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicy
 */
export interface UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicy#resolution
   */
  readonly resolution?: UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicy#resolve
   */
  readonly resolve?: UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicy(obj: UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserDefinedFunctionSpecProviderConfigRefPolicyResolution
 */
export enum UserDefinedFunctionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserDefinedFunctionSpecProviderConfigRefPolicyResolve
 */
export enum UserDefinedFunctionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserDefinedFunctionSpecForProviderDatabaseNameRefPolicyResolution
 */
export enum UserDefinedFunctionSpecForProviderDatabaseNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserDefinedFunctionSpecForProviderDatabaseNameRefPolicyResolve
 */
export enum UserDefinedFunctionSpecForProviderDatabaseNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicyResolution
 */
export enum UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicyResolve
 */
export enum UserDefinedFunctionSpecForProviderDatabaseNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserDefinedFunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Workflow is the Schema for the Workflows API. Provides a Glue Workflow resource.
 *
 * @schema Workflow
 */
export class Workflow extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Workflow"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'glue.aws.upbound.io/v1beta1',
    kind: 'Workflow',
  }

  /**
   * Renders a Kubernetes manifest for "Workflow".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkflowProps): any {
    return {
      ...Workflow.GVK,
      ...toJson_WorkflowProps(props),
    };
  }

  /**
   * Defines a "Workflow" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkflowProps) {
    super(scope, id, {
      ...Workflow.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Workflow.GVK,
      ...toJson_WorkflowProps(resolved),
    };
  }
}

/**
 * Workflow is the Schema for the Workflows API. Provides a Glue Workflow resource.
 *
 * @schema Workflow
 */
export interface WorkflowProps {
  /**
   * @schema Workflow#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkflowSpec defines the desired state of Workflow
   *
   * @schema Workflow#spec
   */
  readonly spec: WorkflowSpec;

}

/**
 * Converts an object of type 'WorkflowProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowProps(obj: WorkflowProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkflowSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkflowSpec defines the desired state of Workflow
 *
 * @schema WorkflowSpec
 */
export interface WorkflowSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkflowSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkflowSpecDeletionPolicy;

  /**
   * @schema WorkflowSpec#forProvider
   */
  readonly forProvider: WorkflowSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema WorkflowSpec#initProvider
   */
  readonly initProvider?: WorkflowSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WorkflowSpec#managementPolicies
   */
  readonly managementPolicies?: WorkflowSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkflowSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkflowSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkflowSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkflowSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkflowSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkflowSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkflowSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpec(obj: WorkflowSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkflowSpecForProvider(obj.forProvider),
    'initProvider': toJson_WorkflowSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WorkflowSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WorkflowSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkflowSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkflowSpecDeletionPolicy
 */
export enum WorkflowSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkflowSpecForProvider
 */
export interface WorkflowSpecForProvider {
  /**
   *   A map of default run properties for this workflow. These properties are passed to all jobs associated to the workflow.
   *
   * @schema WorkflowSpecForProvider#defaultRunProperties
   */
  readonly defaultRunProperties?: { [key: string]: string };

  /**
   *   Description of the workflow.
   *
   * @schema WorkflowSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Prevents exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
   *
   * @schema WorkflowSpecForProvider#maxConcurrentRuns
   */
  readonly maxConcurrentRuns?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WorkflowSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkflowSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkflowSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProvider(obj: WorkflowSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultRunProperties': ((obj.defaultRunProperties) === undefined) ? undefined : (Object.entries(obj.defaultRunProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'description': obj.description,
    'maxConcurrentRuns': obj.maxConcurrentRuns,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema WorkflowSpecInitProvider
 */
export interface WorkflowSpecInitProvider {
  /**
   *   A map of default run properties for this workflow. These properties are passed to all jobs associated to the workflow.
   *
   * @schema WorkflowSpecInitProvider#defaultRunProperties
   */
  readonly defaultRunProperties?: { [key: string]: string };

  /**
   *   Description of the workflow.
   *
   * @schema WorkflowSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Prevents exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
   *
   * @schema WorkflowSpecInitProvider#maxConcurrentRuns
   */
  readonly maxConcurrentRuns?: number;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkflowSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkflowSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProvider(obj: WorkflowSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultRunProperties': ((obj.defaultRunProperties) === undefined) ? undefined : (Object.entries(obj.defaultRunProperties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'description': obj.description,
    'maxConcurrentRuns': obj.maxConcurrentRuns,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WorkflowSpecManagementPolicies
 */
export enum WorkflowSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkflowSpecProviderConfigRef
 */
export interface WorkflowSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkflowSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkflowSpecProviderConfigRef#policy
   */
  readonly policy?: WorkflowSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkflowSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecProviderConfigRef(obj: WorkflowSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkflowSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkflowSpecPublishConnectionDetailsTo
 */
export interface WorkflowSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkflowSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkflowSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkflowSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkflowSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkflowSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkflowSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecPublishConnectionDetailsTo(obj: WorkflowSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkflowSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkflowSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkflowSpecWriteConnectionSecretToRef
 */
export interface WorkflowSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkflowSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkflowSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkflowSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecWriteConnectionSecretToRef(obj: WorkflowSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkflowSpecProviderConfigRefPolicy
 */
export interface WorkflowSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkflowSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkflowSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkflowSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkflowSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkflowSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecProviderConfigRefPolicy(obj: WorkflowSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkflowSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkflowSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkflowSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkflowSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecPublishConnectionDetailsToConfigRef(obj: WorkflowSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkflowSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkflowSpecPublishConnectionDetailsToMetadata
 */
export interface WorkflowSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkflowSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecPublishConnectionDetailsToMetadata(obj: WorkflowSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkflowSpecProviderConfigRefPolicyResolution
 */
export enum WorkflowSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkflowSpecProviderConfigRefPolicyResolve
 */
export enum WorkflowSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkflowSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkflowSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkflowSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkflowSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

