// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Stream is the Schema for the Streams API. Provides a AWS Kinesis Video Stream
 *
 * @schema Stream
 */
export class Stream extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stream"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kinesisvideo.aws.upbound.io/v1beta1',
    kind: 'Stream',
  }

  /**
   * Renders a Kubernetes manifest for "Stream".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StreamProps): any {
    return {
      ...Stream.GVK,
      ...toJson_StreamProps(props),
    };
  }

  /**
   * Defines a "Stream" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StreamProps) {
    super(scope, id, {
      ...Stream.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stream.GVK,
      ...toJson_StreamProps(resolved),
    };
  }
}

/**
 * Stream is the Schema for the Streams API. Provides a AWS Kinesis Video Stream
 *
 * @schema Stream
 */
export interface StreamProps {
  /**
   * @schema Stream#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StreamSpec defines the desired state of Stream
   *
   * @schema Stream#spec
   */
  readonly spec: StreamSpec;

}

/**
 * Converts an object of type 'StreamProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamProps(obj: StreamProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StreamSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StreamSpec defines the desired state of Stream
 *
 * @schema StreamSpec
 */
export interface StreamSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema StreamSpec#deletionPolicy
   */
  readonly deletionPolicy?: StreamSpecDeletionPolicy;

  /**
   * @schema StreamSpec#forProvider
   */
  readonly forProvider: StreamSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StreamSpec#providerConfigRef
   */
  readonly providerConfigRef?: StreamSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StreamSpec#providerRef
   */
  readonly providerRef?: StreamSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StreamSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StreamSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StreamSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StreamSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StreamSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpec(obj: StreamSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StreamSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_StreamSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StreamSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StreamSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StreamSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema StreamSpecDeletionPolicy
 */
export enum StreamSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StreamSpecForProvider
 */
export interface StreamSpecForProvider {
  /**
   * â€“  The number of hours that you want to retain the data in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. The default value is 0, indicating that the stream does not persist data.
   *
   * @schema StreamSpecForProvider#dataRetentionInHours
   */
  readonly dataRetentionInHours?: number;

  /**
   * The name of the device that is writing to the stream. In the current implementation, Kinesis Video Streams does not use this name.
   *
   * @schema StreamSpecForProvider#deviceName
   */
  readonly deviceName?: string;

  /**
   * The ID of the AWS Key Management Service (AWS KMS) key that you want Kinesis Video Streams to use to encrypt stream data. If no key ID is specified, the default, Kinesis Video-managed key (aws/kinesisvideo) is used.
   *
   * @schema StreamSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema StreamSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: StreamSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema StreamSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: StreamSpecForProviderKmsKeyIdSelector;

  /**
   * The media type of the stream. Consumers of the stream can use this information when processing the stream. For more information about media types, see Media Types. If you choose to specify the MediaType, see Naming Requirements for guidelines.
   *
   * @schema StreamSpecForProvider#mediaType
   */
  readonly mediaType?: string;

  /**
   * A name to identify the stream. This is unique to the AWS account and region the Stream is created in.
   *
   * @schema StreamSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StreamSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StreamSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'StreamSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProvider(obj: StreamSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataRetentionInHours': obj.dataRetentionInHours,
    'deviceName': obj.deviceName,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_StreamSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_StreamSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'mediaType': obj.mediaType,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StreamSpecProviderConfigRef
 */
export interface StreamSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecProviderConfigRef#policy
   */
  readonly policy?: StreamSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderConfigRef(obj: StreamSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StreamSpecProviderRef
 */
export interface StreamSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecProviderRef#policy
   */
  readonly policy?: StreamSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderRef(obj: StreamSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StreamSpecPublishConnectionDetailsTo
 */
export interface StreamSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StreamSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StreamSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StreamSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsTo(obj: StreamSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StreamSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StreamSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StreamSpecWriteConnectionSecretToRef
 */
export interface StreamSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StreamSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StreamSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StreamSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecWriteConnectionSecretToRef(obj: StreamSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema StreamSpecForProviderKmsKeyIdRef
 */
export interface StreamSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: StreamSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyIdRef(obj: StreamSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema StreamSpecForProviderKmsKeyIdSelector
 */
export interface StreamSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StreamSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StreamSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StreamSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: StreamSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyIdSelector(obj: StreamSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StreamSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecProviderConfigRefPolicy
 */
export interface StreamSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StreamSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StreamSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderConfigRefPolicy(obj: StreamSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecProviderRefPolicy
 */
export interface StreamSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StreamSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StreamSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecProviderRefPolicy(obj: StreamSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRef
 */
export interface StreamSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StreamSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToConfigRef(obj: StreamSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StreamSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StreamSpecPublishConnectionDetailsToMetadata
 */
export interface StreamSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StreamSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToMetadata(obj: StreamSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StreamSpecForProviderKmsKeyIdRefPolicy
 */
export interface StreamSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyIdRefPolicy(obj: StreamSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StreamSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface StreamSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: StreamSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: StreamSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecForProviderKmsKeyIdSelectorPolicy(obj: StreamSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecProviderConfigRefPolicyResolution
 */
export enum StreamSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecProviderConfigRefPolicyResolve
 */
export enum StreamSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecProviderRefPolicyResolution
 */
export enum StreamSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecProviderRefPolicyResolve
 */
export enum StreamSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StreamSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StreamSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamSpecPublishConnectionDetailsToConfigRefPolicy(obj: StreamSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum StreamSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum StreamSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum StreamSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum StreamSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StreamSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StreamSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

