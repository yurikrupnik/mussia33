// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Bucket is the Schema for the Buckets API. Provides a S3 bucket resource.
 *
 * @schema Bucket
 */
export class Bucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "Bucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketProps): any {
    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(props),
    };
  }

  /**
   * Defines a "Bucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketProps) {
    super(scope, id, {
      ...Bucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the Buckets API. Provides a S3 bucket resource.
 *
 * @schema Bucket
 */
export interface BucketProps {
  /**
   * @schema Bucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec defines the desired state of Bucket
   *
   * @schema Bucket#spec
   */
  readonly spec: BucketSpec;

}

/**
 * Converts an object of type 'BucketProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketProps(obj: BucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketSpec defines the desired state of Bucket
 *
 * @schema BucketSpec
 */
export interface BucketSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketSpecDeletionPolicy;

  /**
   * @schema BucketSpec#forProvider
   */
  readonly forProvider: BucketSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketSpec#providerRef
   */
  readonly providerRef?: BucketSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpec(obj: BucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketSpecDeletionPolicy
 */
export enum BucketSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketSpecForProvider
 */
export interface BucketSpecForProvider {
  /**
   * Boolean that indicates all objects (including any locked objects) should be deleted from the bucket when the bucket is destroyed so that the bucket can be destroyed without error. These objects are not recoverable. This only deletes objects when the bucket is destroyed, not when setting this parameter to true.
   *
   * @schema BucketSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * Indicates whether this bucket has an Object Lock configuration enabled. Valid values are true or false. This argument is not supported in all regions or partitions.
   *
   * @schema BucketSpecForProvider#objectLockEnabled
   */
  readonly objectLockEnabled?: boolean;

  /**
   * AWS region this bucket resides in. Region is the region you'd like your resource to be created in.
   *
   * @schema BucketSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema BucketSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'BucketSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecForProvider(obj: BucketSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceDestroy': obj.forceDestroy,
    'objectLockEnabled': obj.objectLockEnabled,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketSpecProviderConfigRef
 */
export interface BucketSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecProviderConfigRef#policy
   */
  readonly policy?: BucketSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderConfigRef(obj: BucketSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketSpecProviderRef
 */
export interface BucketSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecProviderRef#policy
   */
  readonly policy?: BucketSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderRef(obj: BucketSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketSpecPublishConnectionDetailsTo
 */
export interface BucketSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsTo(obj: BucketSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketSpecWriteConnectionSecretToRef
 */
export interface BucketSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecWriteConnectionSecretToRef(obj: BucketSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecProviderConfigRefPolicy
 */
export interface BucketSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderConfigRefPolicy(obj: BucketSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketSpecProviderRefPolicy
 */
export interface BucketSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecProviderRefPolicy(obj: BucketSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToConfigRef(obj: BucketSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketSpecPublishConnectionDetailsToMetadata
 */
export interface BucketSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToMetadata(obj: BucketSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecProviderConfigRefPolicyResolution
 */
export enum BucketSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecProviderConfigRefPolicyResolve
 */
export enum BucketSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecProviderRefPolicyResolution
 */
export enum BucketSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecProviderRefPolicyResolve
 */
export enum BucketSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketAccelerateConfiguration is the Schema for the BucketAccelerateConfigurations API. Provides an S3 bucket accelerate configuration resource.
 *
 * @schema BucketAccelerateConfiguration
 */
export class BucketAccelerateConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketAccelerateConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketAccelerateConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "BucketAccelerateConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketAccelerateConfigurationProps): any {
    return {
      ...BucketAccelerateConfiguration.GVK,
      ...toJson_BucketAccelerateConfigurationProps(props),
    };
  }

  /**
   * Defines a "BucketAccelerateConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketAccelerateConfigurationProps) {
    super(scope, id, {
      ...BucketAccelerateConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketAccelerateConfiguration.GVK,
      ...toJson_BucketAccelerateConfigurationProps(resolved),
    };
  }
}

/**
 * BucketAccelerateConfiguration is the Schema for the BucketAccelerateConfigurations API. Provides an S3 bucket accelerate configuration resource.
 *
 * @schema BucketAccelerateConfiguration
 */
export interface BucketAccelerateConfigurationProps {
  /**
   * @schema BucketAccelerateConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketAccelerateConfigurationSpec defines the desired state of BucketAccelerateConfiguration
   *
   * @schema BucketAccelerateConfiguration#spec
   */
  readonly spec: BucketAccelerateConfigurationSpec;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationProps(obj: BucketAccelerateConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketAccelerateConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketAccelerateConfigurationSpec defines the desired state of BucketAccelerateConfiguration
 *
 * @schema BucketAccelerateConfigurationSpec
 */
export interface BucketAccelerateConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketAccelerateConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketAccelerateConfigurationSpecDeletionPolicy;

  /**
   * @schema BucketAccelerateConfigurationSpec#forProvider
   */
  readonly forProvider: BucketAccelerateConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketAccelerateConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketAccelerateConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketAccelerateConfigurationSpec#providerRef
   */
  readonly providerRef?: BucketAccelerateConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketAccelerateConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketAccelerateConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketAccelerateConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketAccelerateConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpec(obj: BucketAccelerateConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketAccelerateConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketAccelerateConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketAccelerateConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketAccelerateConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketAccelerateConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketAccelerateConfigurationSpecDeletionPolicy
 */
export enum BucketAccelerateConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketAccelerateConfigurationSpecForProvider
 */
export interface BucketAccelerateConfigurationSpecForProvider {
  /**
   * Name of the bucket.
   *
   * @schema BucketAccelerateConfigurationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketAccelerateConfigurationSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketAccelerateConfigurationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketAccelerateConfigurationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketAccelerateConfigurationSpecForProviderBucketSelector;

  /**
   * Account ID of the expected bucket owner.
   *
   * @schema BucketAccelerateConfigurationSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketAccelerateConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Transfer acceleration state of the bucket. Valid values: Enabled, Suspended.
   *
   * @schema BucketAccelerateConfigurationSpecForProvider#status
   */
  readonly status: string;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecForProvider(obj: BucketAccelerateConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketAccelerateConfigurationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketAccelerateConfigurationSpecForProviderBucketSelector(obj.bucketSelector),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'region': obj.region,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketAccelerateConfigurationSpecProviderConfigRef
 */
export interface BucketAccelerateConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAccelerateConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAccelerateConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: BucketAccelerateConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecProviderConfigRef(obj: BucketAccelerateConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAccelerateConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketAccelerateConfigurationSpecProviderRef
 */
export interface BucketAccelerateConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAccelerateConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAccelerateConfigurationSpecProviderRef#policy
   */
  readonly policy?: BucketAccelerateConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecProviderRef(obj: BucketAccelerateConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAccelerateConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsTo
 */
export interface BucketAccelerateConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketAccelerateConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecPublishConnectionDetailsTo(obj: BucketAccelerateConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketAccelerateConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketAccelerateConfigurationSpecWriteConnectionSecretToRef
 */
export interface BucketAccelerateConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketAccelerateConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketAccelerateConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecWriteConnectionSecretToRef(obj: BucketAccelerateConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketAccelerateConfigurationSpecForProviderBucketRef
 */
export interface BucketAccelerateConfigurationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAccelerateConfigurationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAccelerateConfigurationSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketAccelerateConfigurationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecForProviderBucketRef(obj: BucketAccelerateConfigurationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAccelerateConfigurationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketAccelerateConfigurationSpecForProviderBucketSelector
 */
export interface BucketAccelerateConfigurationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketAccelerateConfigurationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketAccelerateConfigurationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketAccelerateConfigurationSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecForProviderBucketSelector(obj: BucketAccelerateConfigurationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAccelerateConfigurationSpecProviderConfigRefPolicy
 */
export interface BucketAccelerateConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccelerateConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAccelerateConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccelerateConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAccelerateConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecProviderConfigRefPolicy(obj: BucketAccelerateConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAccelerateConfigurationSpecProviderRefPolicy
 */
export interface BucketAccelerateConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccelerateConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketAccelerateConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccelerateConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketAccelerateConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecProviderRefPolicy(obj: BucketAccelerateConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRef(obj: BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface BucketAccelerateConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecPublishConnectionDetailsToMetadata(obj: BucketAccelerateConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAccelerateConfigurationSpecForProviderBucketRefPolicy
 */
export interface BucketAccelerateConfigurationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccelerateConfigurationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketAccelerateConfigurationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccelerateConfigurationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketAccelerateConfigurationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecForProviderBucketRefPolicy(obj: BucketAccelerateConfigurationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicy
 */
export interface BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicy(obj: BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccelerateConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum BucketAccelerateConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccelerateConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum BucketAccelerateConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccelerateConfigurationSpecProviderRefPolicyResolution
 */
export enum BucketAccelerateConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccelerateConfigurationSpecProviderRefPolicyResolve
 */
export enum BucketAccelerateConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccelerateConfigurationSpecForProviderBucketRefPolicyResolution
 */
export enum BucketAccelerateConfigurationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccelerateConfigurationSpecForProviderBucketRefPolicyResolve
 */
export enum BucketAccelerateConfigurationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketAccelerateConfigurationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketAccelerateConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketACL is the Schema for the BucketACLs API. Provides an S3 bucket ACL resource.
 *
 * @schema BucketACL
 */
export class BucketAcl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketACL"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketACL',
  }

  /**
   * Renders a Kubernetes manifest for "BucketACL".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketAclProps): any {
    return {
      ...BucketAcl.GVK,
      ...toJson_BucketAclProps(props),
    };
  }

  /**
   * Defines a "BucketACL" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketAclProps) {
    super(scope, id, {
      ...BucketAcl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketAcl.GVK,
      ...toJson_BucketAclProps(resolved),
    };
  }
}

/**
 * BucketACL is the Schema for the BucketACLs API. Provides an S3 bucket ACL resource.
 *
 * @schema BucketACL
 */
export interface BucketAclProps {
  /**
   * @schema BucketACL#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketACLSpec defines the desired state of BucketACL
   *
   * @schema BucketACL#spec
   */
  readonly spec: BucketAclSpec;

}

/**
 * Converts an object of type 'BucketAclProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclProps(obj: BucketAclProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketAclSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketACLSpec defines the desired state of BucketACL
 *
 * @schema BucketAclSpec
 */
export interface BucketAclSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketAclSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketAclSpecDeletionPolicy;

  /**
   * @schema BucketAclSpec#forProvider
   */
  readonly forProvider: BucketAclSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketAclSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketAclSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketAclSpec#providerRef
   */
  readonly providerRef?: BucketAclSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketAclSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketAclSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketAclSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketAclSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketAclSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpec(obj: BucketAclSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketAclSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketAclSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketAclSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketAclSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketAclSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketAclSpecDeletionPolicy
 */
export enum BucketAclSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketAclSpecForProvider
 */
export interface BucketAclSpecForProvider {
  /**
   * Configuration block that sets the ACL permissions for an object per grantee. See below.
   *
   * @schema BucketAclSpecForProvider#accessControlPolicy
   */
  readonly accessControlPolicy?: BucketAclSpecForProviderAccessControlPolicy[];

  /**
   * Canned ACL to apply to the bucket.
   *
   * @schema BucketAclSpecForProvider#acl
   */
  readonly acl?: string;

  /**
   * Name of the bucket.
   *
   * @schema BucketAclSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketAclSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketAclSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketAclSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketAclSpecForProviderBucketSelector;

  /**
   * Account ID of the expected bucket owner.
   *
   * @schema BucketAclSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketAclSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BucketAclSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProvider(obj: BucketAclSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControlPolicy': obj.accessControlPolicy?.map(y => toJson_BucketAclSpecForProviderAccessControlPolicy(y)),
    'acl': obj.acl,
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketAclSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketAclSpecForProviderBucketSelector(obj.bucketSelector),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketAclSpecProviderConfigRef
 */
export interface BucketAclSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAclSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAclSpecProviderConfigRef#policy
   */
  readonly policy?: BucketAclSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecProviderConfigRef(obj: BucketAclSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAclSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketAclSpecProviderRef
 */
export interface BucketAclSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAclSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAclSpecProviderRef#policy
   */
  readonly policy?: BucketAclSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecProviderRef(obj: BucketAclSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAclSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketAclSpecPublishConnectionDetailsTo
 */
export interface BucketAclSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketAclSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketAclSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketAclSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketAclSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketAclSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsTo(obj: BucketAclSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketAclSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketAclSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketAclSpecWriteConnectionSecretToRef
 */
export interface BucketAclSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketAclSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketAclSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketAclSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecWriteConnectionSecretToRef(obj: BucketAclSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketAclSpecForProviderAccessControlPolicy
 */
export interface BucketAclSpecForProviderAccessControlPolicy {
  /**
   * Set of grant configuration blocks. See below.
   *
   * @schema BucketAclSpecForProviderAccessControlPolicy#grant
   */
  readonly grant?: BucketAclSpecForProviderAccessControlPolicyGrant[];

  /**
   * Configuration block of the bucket owner's display name and ID. See below.
   *
   * @schema BucketAclSpecForProviderAccessControlPolicy#owner
   */
  readonly owner: BucketAclSpecForProviderAccessControlPolicyOwner[];

}

/**
 * Converts an object of type 'BucketAclSpecForProviderAccessControlPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderAccessControlPolicy(obj: BucketAclSpecForProviderAccessControlPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grant': obj.grant?.map(y => toJson_BucketAclSpecForProviderAccessControlPolicyGrant(y)),
    'owner': obj.owner?.map(y => toJson_BucketAclSpecForProviderAccessControlPolicyOwner(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketAclSpecForProviderBucketRef
 */
export interface BucketAclSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAclSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAclSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketAclSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketRef(obj: BucketAclSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAclSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketAclSpecForProviderBucketSelector
 */
export interface BucketAclSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketAclSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketAclSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketAclSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketAclSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketSelector(obj: BucketAclSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketAclSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAclSpecProviderConfigRefPolicy
 */
export interface BucketAclSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAclSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAclSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecProviderConfigRefPolicy(obj: BucketAclSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAclSpecProviderRefPolicy
 */
export interface BucketAclSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketAclSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketAclSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecProviderRefPolicy(obj: BucketAclSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketAclSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketAclSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsToConfigRef(obj: BucketAclSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAclSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToMetadata
 */
export interface BucketAclSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsToMetadata(obj: BucketAclSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketAclSpecForProviderAccessControlPolicyGrant
 */
export interface BucketAclSpecForProviderAccessControlPolicyGrant {
  /**
   * Configuration block for the person being granted permissions. See below.
   *
   * @schema BucketAclSpecForProviderAccessControlPolicyGrant#grantee
   */
  readonly grantee?: BucketAclSpecForProviderAccessControlPolicyGrantGrantee[];

  /**
   * Logging permissions assigned to the grantee for the bucket.
   *
   * @schema BucketAclSpecForProviderAccessControlPolicyGrant#permission
   */
  readonly permission: string;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderAccessControlPolicyGrant' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderAccessControlPolicyGrant(obj: BucketAclSpecForProviderAccessControlPolicyGrant | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grantee': obj.grantee?.map(y => toJson_BucketAclSpecForProviderAccessControlPolicyGrantGrantee(y)),
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketAclSpecForProviderAccessControlPolicyOwner
 */
export interface BucketAclSpecForProviderAccessControlPolicyOwner {
  /**
   * Display name of the owner.
   *
   * @schema BucketAclSpecForProviderAccessControlPolicyOwner#displayName
   */
  readonly displayName?: string;

  /**
   * ID of the owner.
   *
   * @schema BucketAclSpecForProviderAccessControlPolicyOwner#id
   */
  readonly id: string;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderAccessControlPolicyOwner' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderAccessControlPolicyOwner(obj: BucketAclSpecForProviderAccessControlPolicyOwner | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'id': obj.id,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAclSpecForProviderBucketRefPolicy
 */
export interface BucketAclSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketAclSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketAclSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketRefPolicy(obj: BucketAclSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketAclSpecForProviderBucketSelectorPolicy
 */
export interface BucketAclSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketAclSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketAclSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderBucketSelectorPolicy(obj: BucketAclSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecProviderConfigRefPolicyResolution
 */
export enum BucketAclSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecProviderConfigRefPolicyResolve
 */
export enum BucketAclSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecProviderRefPolicyResolution
 */
export enum BucketAclSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecProviderRefPolicyResolve
 */
export enum BucketAclSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketAclSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAclSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketAclSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketAclSpecForProviderAccessControlPolicyGrantGrantee
 */
export interface BucketAclSpecForProviderAccessControlPolicyGrantGrantee {
  /**
   * Email address of the grantee. See Regions and Endpoints for supported AWS regions where this argument can be specified.
   *
   * @schema BucketAclSpecForProviderAccessControlPolicyGrantGrantee#emailAddress
   */
  readonly emailAddress?: string;

  /**
   * ID of the owner.
   *
   * @schema BucketAclSpecForProviderAccessControlPolicyGrantGrantee#id
   */
  readonly id?: string;

  /**
   * Type of grantee. Valid values: CanonicalUser, AmazonCustomerByEmail, Group.
   *
   * @schema BucketAclSpecForProviderAccessControlPolicyGrantGrantee#type
   */
  readonly type: string;

  /**
   * URI of the grantee group.
   *
   * @schema BucketAclSpecForProviderAccessControlPolicyGrantGrantee#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'BucketAclSpecForProviderAccessControlPolicyGrantGrantee' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAclSpecForProviderAccessControlPolicyGrantGrantee(obj: BucketAclSpecForProviderAccessControlPolicyGrantGrantee | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'emailAddress': obj.emailAddress,
    'id': obj.id,
    'type': obj.type,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecForProviderBucketRefPolicyResolution
 */
export enum BucketAclSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecForProviderBucketRefPolicyResolve
 */
export enum BucketAclSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketAclSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketAclSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketAclSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketAnalyticsConfiguration is the Schema for the BucketAnalyticsConfigurations API. Provides a S3 bucket analytics configuration resource.
 *
 * @schema BucketAnalyticsConfiguration
 */
export class BucketAnalyticsConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketAnalyticsConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketAnalyticsConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "BucketAnalyticsConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketAnalyticsConfigurationProps): any {
    return {
      ...BucketAnalyticsConfiguration.GVK,
      ...toJson_BucketAnalyticsConfigurationProps(props),
    };
  }

  /**
   * Defines a "BucketAnalyticsConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketAnalyticsConfigurationProps) {
    super(scope, id, {
      ...BucketAnalyticsConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketAnalyticsConfiguration.GVK,
      ...toJson_BucketAnalyticsConfigurationProps(resolved),
    };
  }
}

/**
 * BucketAnalyticsConfiguration is the Schema for the BucketAnalyticsConfigurations API. Provides a S3 bucket analytics configuration resource.
 *
 * @schema BucketAnalyticsConfiguration
 */
export interface BucketAnalyticsConfigurationProps {
  /**
   * @schema BucketAnalyticsConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketAnalyticsConfigurationSpec defines the desired state of BucketAnalyticsConfiguration
   *
   * @schema BucketAnalyticsConfiguration#spec
   */
  readonly spec: BucketAnalyticsConfigurationSpec;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationProps(obj: BucketAnalyticsConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketAnalyticsConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketAnalyticsConfigurationSpec defines the desired state of BucketAnalyticsConfiguration
 *
 * @schema BucketAnalyticsConfigurationSpec
 */
export interface BucketAnalyticsConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketAnalyticsConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketAnalyticsConfigurationSpecDeletionPolicy;

  /**
   * @schema BucketAnalyticsConfigurationSpec#forProvider
   */
  readonly forProvider: BucketAnalyticsConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketAnalyticsConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketAnalyticsConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketAnalyticsConfigurationSpec#providerRef
   */
  readonly providerRef?: BucketAnalyticsConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketAnalyticsConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketAnalyticsConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketAnalyticsConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketAnalyticsConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpec(obj: BucketAnalyticsConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketAnalyticsConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketAnalyticsConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketAnalyticsConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketAnalyticsConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketAnalyticsConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketAnalyticsConfigurationSpecDeletionPolicy
 */
export enum BucketAnalyticsConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketAnalyticsConfigurationSpecForProvider
 */
export interface BucketAnalyticsConfigurationSpecForProvider {
  /**
   * Name of the bucket this analytics configuration is associated with.
   *
   * @schema BucketAnalyticsConfigurationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketAnalyticsConfigurationSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketAnalyticsConfigurationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketAnalyticsConfigurationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketAnalyticsConfigurationSpecForProviderBucketSelector;

  /**
   * Object filtering that accepts a prefix, tags, or a logical AND of prefix and tags (documented below).
   *
   * @schema BucketAnalyticsConfigurationSpecForProvider#filter
   */
  readonly filter?: BucketAnalyticsConfigurationSpecForProviderFilter[];

  /**
   * Unique identifier of the analytics configuration for the bucket.
   *
   * @schema BucketAnalyticsConfigurationSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketAnalyticsConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration for the analytics data export (documented below).
   *
   * @schema BucketAnalyticsConfigurationSpecForProvider#storageClassAnalysis
   */
  readonly storageClassAnalysis?: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysis[];

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProvider(obj: BucketAnalyticsConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketAnalyticsConfigurationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketAnalyticsConfigurationSpecForProviderBucketSelector(obj.bucketSelector),
    'filter': obj.filter?.map(y => toJson_BucketAnalyticsConfigurationSpecForProviderFilter(y)),
    'name': obj.name,
    'region': obj.region,
    'storageClassAnalysis': obj.storageClassAnalysis?.map(y => toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysis(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketAnalyticsConfigurationSpecProviderConfigRef
 */
export interface BucketAnalyticsConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAnalyticsConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAnalyticsConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: BucketAnalyticsConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecProviderConfigRef(obj: BucketAnalyticsConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAnalyticsConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketAnalyticsConfigurationSpecProviderRef
 */
export interface BucketAnalyticsConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAnalyticsConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAnalyticsConfigurationSpecProviderRef#policy
   */
  readonly policy?: BucketAnalyticsConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecProviderRef(obj: BucketAnalyticsConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAnalyticsConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsTo
 */
export interface BucketAnalyticsConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketAnalyticsConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecPublishConnectionDetailsTo(obj: BucketAnalyticsConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketAnalyticsConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketAnalyticsConfigurationSpecWriteConnectionSecretToRef
 */
export interface BucketAnalyticsConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketAnalyticsConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketAnalyticsConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecWriteConnectionSecretToRef(obj: BucketAnalyticsConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderBucketRef
 */
export interface BucketAnalyticsConfigurationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketAnalyticsConfigurationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderBucketRef(obj: BucketAnalyticsConfigurationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAnalyticsConfigurationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderBucketSelector
 */
export interface BucketAnalyticsConfigurationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderBucketSelector(obj: BucketAnalyticsConfigurationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketAnalyticsConfigurationSpecForProviderFilter
 */
export interface BucketAnalyticsConfigurationSpecForProviderFilter {
  /**
   * Object prefix for filtering.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderFilter#prefix
   */
  readonly prefix?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderFilter#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderFilter(obj: BucketAnalyticsConfigurationSpecForProviderFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysis
 */
export interface BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysis {
  /**
   * Data export configuration (documented below).
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysis#dataExport
   */
  readonly dataExport: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExport[];

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysis' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysis(obj: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysis | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataExport': obj.dataExport?.map(y => toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExport(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAnalyticsConfigurationSpecProviderConfigRefPolicy
 */
export interface BucketAnalyticsConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAnalyticsConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAnalyticsConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAnalyticsConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAnalyticsConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecProviderConfigRefPolicy(obj: BucketAnalyticsConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAnalyticsConfigurationSpecProviderRefPolicy
 */
export interface BucketAnalyticsConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAnalyticsConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketAnalyticsConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAnalyticsConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketAnalyticsConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecProviderRefPolicy(obj: BucketAnalyticsConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRef(obj: BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface BucketAnalyticsConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecPublishConnectionDetailsToMetadata(obj: BucketAnalyticsConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderBucketRefPolicy
 */
export interface BucketAnalyticsConfigurationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketAnalyticsConfigurationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketAnalyticsConfigurationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderBucketRefPolicy(obj: BucketAnalyticsConfigurationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicy
 */
export interface BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicy(obj: BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExport
 */
export interface BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExport {
  /**
   * Specifies the destination for the exported analytics data (documented below).
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExport#destination
   */
  readonly destination: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestination[];

  /**
   * Schema version of exported analytics data. Allowed values: V_1. Default value: V_1.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExport#outputSchemaVersion
   */
  readonly outputSchemaVersion?: string;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExport' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExport(obj: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExport | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination?.map(y => toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestination(y)),
    'outputSchemaVersion': obj.outputSchemaVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAnalyticsConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum BucketAnalyticsConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAnalyticsConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum BucketAnalyticsConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAnalyticsConfigurationSpecProviderRefPolicyResolution
 */
export enum BucketAnalyticsConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAnalyticsConfigurationSpecProviderRefPolicyResolve
 */
export enum BucketAnalyticsConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderBucketRefPolicyResolution
 */
export enum BucketAnalyticsConfigurationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderBucketRefPolicyResolve
 */
export enum BucketAnalyticsConfigurationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketAnalyticsConfigurationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestination
 */
export interface BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestination {
  /**
   * Analytics data export currently only supports an S3 bucket destination (documented below).
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestination#s3BucketDestination
   */
  readonly s3BucketDestination: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination[];

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestination(obj: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3BucketDestination': obj.s3BucketDestination?.map(y => toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketAnalyticsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination
 */
export interface BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination {
  /**
   * Account ID that owns the destination bucket.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination#bucketAccountId
   */
  readonly bucketAccountId?: string;

  /**
   * ARN of the destination bucket.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination#bucketArn
   */
  readonly bucketArn?: string;

  /**
   * Reference to a Bucket in s3 to populate bucketArn.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination#bucketArnRef
   */
  readonly bucketArnRef?: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRef;

  /**
   * Selector for a Bucket in s3 to populate bucketArn.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination#bucketArnSelector
   */
  readonly bucketArnSelector?: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelector;

  /**
   * Output format of exported analytics data. Allowed values: CSV. Default value: CSV.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination#format
   */
  readonly format?: string;

  /**
   * Object prefix for filtering.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination(obj: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketAccountId': obj.bucketAccountId,
    'bucketArn': obj.bucketArn,
    'bucketArnRef': toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRef(obj.bucketArnRef),
    'bucketArnSelector': toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelector(obj.bucketArnSelector),
    'format': obj.format,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucketArn.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRef
 */
export interface BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRef#policy
   */
  readonly policy?: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicy;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRef(obj: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucketArn.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelector
 */
export interface BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelector#policy
   */
  readonly policy?: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelector(obj: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicy
 */
export interface BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicy#resolution
   */
  readonly resolution?: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicy#resolve
   */
  readonly resolve?: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicy(obj: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicy
 */
export interface BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicy(obj: BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicyResolution
 */
export enum BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicyResolve
 */
export enum BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicyResolution
 */
export enum BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicyResolve
 */
export enum BucketAnalyticsConfigurationSpecForProviderStorageClassAnalysisDataExportDestinationS3BucketDestinationBucketArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketCorsConfiguration is the Schema for the BucketCorsConfigurations API. Provides an S3 bucket CORS configuration resource.
 *
 * @schema BucketCorsConfiguration
 */
export class BucketCorsConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketCorsConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketCorsConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "BucketCorsConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketCorsConfigurationProps): any {
    return {
      ...BucketCorsConfiguration.GVK,
      ...toJson_BucketCorsConfigurationProps(props),
    };
  }

  /**
   * Defines a "BucketCorsConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketCorsConfigurationProps) {
    super(scope, id, {
      ...BucketCorsConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketCorsConfiguration.GVK,
      ...toJson_BucketCorsConfigurationProps(resolved),
    };
  }
}

/**
 * BucketCorsConfiguration is the Schema for the BucketCorsConfigurations API. Provides an S3 bucket CORS configuration resource.
 *
 * @schema BucketCorsConfiguration
 */
export interface BucketCorsConfigurationProps {
  /**
   * @schema BucketCorsConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketCorsConfigurationSpec defines the desired state of BucketCorsConfiguration
   *
   * @schema BucketCorsConfiguration#spec
   */
  readonly spec: BucketCorsConfigurationSpec;

}

/**
 * Converts an object of type 'BucketCorsConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationProps(obj: BucketCorsConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketCorsConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketCorsConfigurationSpec defines the desired state of BucketCorsConfiguration
 *
 * @schema BucketCorsConfigurationSpec
 */
export interface BucketCorsConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketCorsConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketCorsConfigurationSpecDeletionPolicy;

  /**
   * @schema BucketCorsConfigurationSpec#forProvider
   */
  readonly forProvider: BucketCorsConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketCorsConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketCorsConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketCorsConfigurationSpec#providerRef
   */
  readonly providerRef?: BucketCorsConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketCorsConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketCorsConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketCorsConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketCorsConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpec(obj: BucketCorsConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketCorsConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketCorsConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketCorsConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketCorsConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketCorsConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketCorsConfigurationSpecDeletionPolicy
 */
export enum BucketCorsConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketCorsConfigurationSpecForProvider
 */
export interface BucketCorsConfigurationSpecForProvider {
  /**
   * Name of the bucket.
   *
   * @schema BucketCorsConfigurationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketCorsConfigurationSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketCorsConfigurationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketCorsConfigurationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketCorsConfigurationSpecForProviderBucketSelector;

  /**
   * Set of origins and methods (cross-origin access that you want to allow). See below. You can configure up to 100 rules.
   *
   * @schema BucketCorsConfigurationSpecForProvider#corsRule
   */
  readonly corsRule: BucketCorsConfigurationSpecForProviderCorsRule[];

  /**
   * Account ID of the expected bucket owner.
   *
   * @schema BucketCorsConfigurationSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketCorsConfigurationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecForProvider(obj: BucketCorsConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketCorsConfigurationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketCorsConfigurationSpecForProviderBucketSelector(obj.bucketSelector),
    'corsRule': obj.corsRule?.map(y => toJson_BucketCorsConfigurationSpecForProviderCorsRule(y)),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketCorsConfigurationSpecProviderConfigRef
 */
export interface BucketCorsConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketCorsConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketCorsConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: BucketCorsConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecProviderConfigRef(obj: BucketCorsConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketCorsConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketCorsConfigurationSpecProviderRef
 */
export interface BucketCorsConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketCorsConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketCorsConfigurationSpecProviderRef#policy
   */
  readonly policy?: BucketCorsConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecProviderRef(obj: BucketCorsConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketCorsConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketCorsConfigurationSpecPublishConnectionDetailsTo
 */
export interface BucketCorsConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketCorsConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketCorsConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketCorsConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketCorsConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecPublishConnectionDetailsTo(obj: BucketCorsConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketCorsConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketCorsConfigurationSpecWriteConnectionSecretToRef
 */
export interface BucketCorsConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketCorsConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketCorsConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecWriteConnectionSecretToRef(obj: BucketCorsConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketCorsConfigurationSpecForProviderBucketRef
 */
export interface BucketCorsConfigurationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketCorsConfigurationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketCorsConfigurationSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketCorsConfigurationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecForProviderBucketRef(obj: BucketCorsConfigurationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketCorsConfigurationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketCorsConfigurationSpecForProviderBucketSelector
 */
export interface BucketCorsConfigurationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketCorsConfigurationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketCorsConfigurationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketCorsConfigurationSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketCorsConfigurationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecForProviderBucketSelector(obj: BucketCorsConfigurationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketCorsConfigurationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketCorsConfigurationSpecForProviderCorsRule
 */
export interface BucketCorsConfigurationSpecForProviderCorsRule {
  /**
   * Set of Headers that are specified in the Access-Control-Request-Headers header.
   *
   * @schema BucketCorsConfigurationSpecForProviderCorsRule#allowedHeaders
   */
  readonly allowedHeaders?: string[];

  /**
   * Set of HTTP methods that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
   *
   * @schema BucketCorsConfigurationSpecForProviderCorsRule#allowedMethods
   */
  readonly allowedMethods: string[];

  /**
   * Set of origins you want customers to be able to access the bucket from.
   *
   * @schema BucketCorsConfigurationSpecForProviderCorsRule#allowedOrigins
   */
  readonly allowedOrigins: string[];

  /**
   * Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
   *
   * @schema BucketCorsConfigurationSpecForProviderCorsRule#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Unique identifier for the rule. The value cannot be longer than 255 characters.
   *
   * @schema BucketCorsConfigurationSpecForProviderCorsRule#id
   */
  readonly id?: string;

  /**
   * Time in seconds that your browser is to cache the preflight response for the specified resource.
   *
   * @schema BucketCorsConfigurationSpecForProviderCorsRule#maxAgeSeconds
   */
  readonly maxAgeSeconds?: number;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecForProviderCorsRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecForProviderCorsRule(obj: BucketCorsConfigurationSpecForProviderCorsRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedHeaders': obj.allowedHeaders?.map(y => y),
    'allowedMethods': obj.allowedMethods?.map(y => y),
    'allowedOrigins': obj.allowedOrigins?.map(y => y),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'id': obj.id,
    'maxAgeSeconds': obj.maxAgeSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketCorsConfigurationSpecProviderConfigRefPolicy
 */
export interface BucketCorsConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketCorsConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketCorsConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketCorsConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketCorsConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecProviderConfigRefPolicy(obj: BucketCorsConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketCorsConfigurationSpecProviderRefPolicy
 */
export interface BucketCorsConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketCorsConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketCorsConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketCorsConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketCorsConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecProviderRefPolicy(obj: BucketCorsConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRef(obj: BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface BucketCorsConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecPublishConnectionDetailsToMetadata(obj: BucketCorsConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketCorsConfigurationSpecForProviderBucketRefPolicy
 */
export interface BucketCorsConfigurationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketCorsConfigurationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketCorsConfigurationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketCorsConfigurationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketCorsConfigurationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecForProviderBucketRefPolicy(obj: BucketCorsConfigurationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketCorsConfigurationSpecForProviderBucketSelectorPolicy
 */
export interface BucketCorsConfigurationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketCorsConfigurationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketCorsConfigurationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketCorsConfigurationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketCorsConfigurationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecForProviderBucketSelectorPolicy(obj: BucketCorsConfigurationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketCorsConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum BucketCorsConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketCorsConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum BucketCorsConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketCorsConfigurationSpecProviderRefPolicyResolution
 */
export enum BucketCorsConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketCorsConfigurationSpecProviderRefPolicyResolve
 */
export enum BucketCorsConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketCorsConfigurationSpecForProviderBucketRefPolicyResolution
 */
export enum BucketCorsConfigurationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketCorsConfigurationSpecForProviderBucketRefPolicyResolve
 */
export enum BucketCorsConfigurationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketCorsConfigurationSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketCorsConfigurationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketCorsConfigurationSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketCorsConfigurationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketCorsConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketIntelligentTieringConfiguration is the Schema for the BucketIntelligentTieringConfigurations API. Provides an S3 Intelligent-Tiering configuration resource.
 *
 * @schema BucketIntelligentTieringConfiguration
 */
export class BucketIntelligentTieringConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketIntelligentTieringConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketIntelligentTieringConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "BucketIntelligentTieringConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketIntelligentTieringConfigurationProps): any {
    return {
      ...BucketIntelligentTieringConfiguration.GVK,
      ...toJson_BucketIntelligentTieringConfigurationProps(props),
    };
  }

  /**
   * Defines a "BucketIntelligentTieringConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketIntelligentTieringConfigurationProps) {
    super(scope, id, {
      ...BucketIntelligentTieringConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketIntelligentTieringConfiguration.GVK,
      ...toJson_BucketIntelligentTieringConfigurationProps(resolved),
    };
  }
}

/**
 * BucketIntelligentTieringConfiguration is the Schema for the BucketIntelligentTieringConfigurations API. Provides an S3 Intelligent-Tiering configuration resource.
 *
 * @schema BucketIntelligentTieringConfiguration
 */
export interface BucketIntelligentTieringConfigurationProps {
  /**
   * @schema BucketIntelligentTieringConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketIntelligentTieringConfigurationSpec defines the desired state of BucketIntelligentTieringConfiguration
   *
   * @schema BucketIntelligentTieringConfiguration#spec
   */
  readonly spec: BucketIntelligentTieringConfigurationSpec;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationProps(obj: BucketIntelligentTieringConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketIntelligentTieringConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketIntelligentTieringConfigurationSpec defines the desired state of BucketIntelligentTieringConfiguration
 *
 * @schema BucketIntelligentTieringConfigurationSpec
 */
export interface BucketIntelligentTieringConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketIntelligentTieringConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketIntelligentTieringConfigurationSpecDeletionPolicy;

  /**
   * @schema BucketIntelligentTieringConfigurationSpec#forProvider
   */
  readonly forProvider: BucketIntelligentTieringConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketIntelligentTieringConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketIntelligentTieringConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketIntelligentTieringConfigurationSpec#providerRef
   */
  readonly providerRef?: BucketIntelligentTieringConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketIntelligentTieringConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketIntelligentTieringConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketIntelligentTieringConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpec(obj: BucketIntelligentTieringConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketIntelligentTieringConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketIntelligentTieringConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketIntelligentTieringConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketIntelligentTieringConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketIntelligentTieringConfigurationSpecDeletionPolicy
 */
export enum BucketIntelligentTieringConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketIntelligentTieringConfigurationSpecForProvider
 */
export interface BucketIntelligentTieringConfigurationSpecForProvider {
  /**
   * Name of the bucket this intelligent tiering configuration is associated with.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketIntelligentTieringConfigurationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketIntelligentTieringConfigurationSpecForProviderBucketSelector;

  /**
   * Bucket filter. The configuration only includes objects that meet the filter's criteria (documented below).
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProvider#filter
   */
  readonly filter?: BucketIntelligentTieringConfigurationSpecForProviderFilter[];

  /**
   * Unique name used to identify the S3 Intelligent-Tiering configuration for the bucket.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the status of the configuration. Valid values: Enabled, Disabled.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProvider#status
   */
  readonly status?: string;

  /**
   * S3 Intelligent-Tiering storage class tiers of the configuration (documented below).
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProvider#tiering
   */
  readonly tiering: BucketIntelligentTieringConfigurationSpecForProviderTiering[];

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecForProvider(obj: BucketIntelligentTieringConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketIntelligentTieringConfigurationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketIntelligentTieringConfigurationSpecForProviderBucketSelector(obj.bucketSelector),
    'filter': obj.filter?.map(y => toJson_BucketIntelligentTieringConfigurationSpecForProviderFilter(y)),
    'name': obj.name,
    'region': obj.region,
    'status': obj.status,
    'tiering': obj.tiering?.map(y => toJson_BucketIntelligentTieringConfigurationSpecForProviderTiering(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketIntelligentTieringConfigurationSpecProviderConfigRef
 */
export interface BucketIntelligentTieringConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIntelligentTieringConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIntelligentTieringConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecProviderConfigRef(obj: BucketIntelligentTieringConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketIntelligentTieringConfigurationSpecProviderRef
 */
export interface BucketIntelligentTieringConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIntelligentTieringConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIntelligentTieringConfigurationSpecProviderRef#policy
   */
  readonly policy?: BucketIntelligentTieringConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecProviderRef(obj: BucketIntelligentTieringConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIntelligentTieringConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsTo
 */
export interface BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsTo(obj: BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketIntelligentTieringConfigurationSpecWriteConnectionSecretToRef
 */
export interface BucketIntelligentTieringConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketIntelligentTieringConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketIntelligentTieringConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecWriteConnectionSecretToRef(obj: BucketIntelligentTieringConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketRef
 */
export interface BucketIntelligentTieringConfigurationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecForProviderBucketRef(obj: BucketIntelligentTieringConfigurationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketSelector
 */
export interface BucketIntelligentTieringConfigurationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecForProviderBucketSelector(obj: BucketIntelligentTieringConfigurationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketIntelligentTieringConfigurationSpecForProviderFilter
 */
export interface BucketIntelligentTieringConfigurationSpecForProviderFilter {
  /**
   * Object key name prefix that identifies the subset of objects to which the configuration applies.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderFilter#prefix
   */
  readonly prefix?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderFilter#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecForProviderFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecForProviderFilter(obj: BucketIntelligentTieringConfigurationSpecForProviderFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketIntelligentTieringConfigurationSpecForProviderTiering
 */
export interface BucketIntelligentTieringConfigurationSpecForProviderTiering {
  /**
   * S3 Intelligent-Tiering access tier. Valid values: ARCHIVE_ACCESS, DEEP_ARCHIVE_ACCESS.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderTiering#accessTier
   */
  readonly accessTier: string;

  /**
   * Number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderTiering#days
   */
  readonly days: number;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecForProviderTiering' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecForProviderTiering(obj: BucketIntelligentTieringConfigurationSpecForProviderTiering | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTier': obj.accessTier,
    'days': obj.days,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicy
 */
export interface BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicy(obj: BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIntelligentTieringConfigurationSpecProviderRefPolicy
 */
export interface BucketIntelligentTieringConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIntelligentTieringConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketIntelligentTieringConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIntelligentTieringConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketIntelligentTieringConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecProviderRefPolicy(obj: BucketIntelligentTieringConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRef(obj: BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToMetadata(obj: BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicy
 */
export interface BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicy(obj: BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicy
 */
export interface BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicy(obj: BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum BucketIntelligentTieringConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIntelligentTieringConfigurationSpecProviderRefPolicyResolution
 */
export enum BucketIntelligentTieringConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIntelligentTieringConfigurationSpecProviderRefPolicyResolve
 */
export enum BucketIntelligentTieringConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicyResolution
 */
export enum BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicyResolve
 */
export enum BucketIntelligentTieringConfigurationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketIntelligentTieringConfigurationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketIntelligentTieringConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketInventory is the Schema for the BucketInventorys API. Provides a S3 bucket inventory configuration resource.
 *
 * @schema BucketInventory
 */
export class BucketInventory extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketInventory"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketInventory',
  }

  /**
   * Renders a Kubernetes manifest for "BucketInventory".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketInventoryProps): any {
    return {
      ...BucketInventory.GVK,
      ...toJson_BucketInventoryProps(props),
    };
  }

  /**
   * Defines a "BucketInventory" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketInventoryProps) {
    super(scope, id, {
      ...BucketInventory.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketInventory.GVK,
      ...toJson_BucketInventoryProps(resolved),
    };
  }
}

/**
 * BucketInventory is the Schema for the BucketInventorys API. Provides a S3 bucket inventory configuration resource.
 *
 * @schema BucketInventory
 */
export interface BucketInventoryProps {
  /**
   * @schema BucketInventory#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketInventorySpec defines the desired state of BucketInventory
   *
   * @schema BucketInventory#spec
   */
  readonly spec: BucketInventorySpec;

}

/**
 * Converts an object of type 'BucketInventoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventoryProps(obj: BucketInventoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketInventorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketInventorySpec defines the desired state of BucketInventory
 *
 * @schema BucketInventorySpec
 */
export interface BucketInventorySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketInventorySpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketInventorySpecDeletionPolicy;

  /**
   * @schema BucketInventorySpec#forProvider
   */
  readonly forProvider: BucketInventorySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketInventorySpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketInventorySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketInventorySpec#providerRef
   */
  readonly providerRef?: BucketInventorySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketInventorySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketInventorySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketInventorySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketInventorySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketInventorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpec(obj: BucketInventorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketInventorySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketInventorySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketInventorySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketInventorySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketInventorySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketInventorySpecDeletionPolicy
 */
export enum BucketInventorySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketInventorySpecForProvider
 */
export interface BucketInventorySpecForProvider {
  /**
   * Name of the source bucket that inventory lists the objects for.
   *
   * @schema BucketInventorySpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketInventorySpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketInventorySpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketInventorySpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketInventorySpecForProviderBucketSelector;

  /**
   * Contains information about where to publish the inventory results (documented below).
   *
   * @schema BucketInventorySpecForProvider#destination
   */
  readonly destination: BucketInventorySpecForProviderDestination[];

  /**
   * Specifies whether the inventory is enabled or disabled.
   *
   * @schema BucketInventorySpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Specifies an inventory filter. The inventory only includes objects that meet the filter's criteria (documented below).
   *
   * @schema BucketInventorySpecForProvider#filter
   */
  readonly filter?: BucketInventorySpecForProviderFilter[];

  /**
   * Object versions to include in the inventory list. Valid values: All, Current.
   *
   * @schema BucketInventorySpecForProvider#includedObjectVersions
   */
  readonly includedObjectVersions: string;

  /**
   * Unique identifier of the inventory configuration for the bucket.
   *
   * @schema BucketInventorySpecForProvider#name
   */
  readonly name: string;

  /**
   * List of optional fields that are included in the inventory results. Please refer to the S3 documentation for more details.
   *
   * @schema BucketInventorySpecForProvider#optionalFields
   */
  readonly optionalFields?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketInventorySpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the schedule for generating inventory results (documented below).
   *
   * @schema BucketInventorySpecForProvider#schedule
   */
  readonly schedule: BucketInventorySpecForProviderSchedule[];

}

/**
 * Converts an object of type 'BucketInventorySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProvider(obj: BucketInventorySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketInventorySpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketInventorySpecForProviderBucketSelector(obj.bucketSelector),
    'destination': obj.destination?.map(y => toJson_BucketInventorySpecForProviderDestination(y)),
    'enabled': obj.enabled,
    'filter': obj.filter?.map(y => toJson_BucketInventorySpecForProviderFilter(y)),
    'includedObjectVersions': obj.includedObjectVersions,
    'name': obj.name,
    'optionalFields': obj.optionalFields?.map(y => y),
    'region': obj.region,
    'schedule': obj.schedule?.map(y => toJson_BucketInventorySpecForProviderSchedule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketInventorySpecProviderConfigRef
 */
export interface BucketInventorySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketInventorySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketInventorySpecProviderConfigRef#policy
   */
  readonly policy?: BucketInventorySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketInventorySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecProviderConfigRef(obj: BucketInventorySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketInventorySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketInventorySpecProviderRef
 */
export interface BucketInventorySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketInventorySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketInventorySpecProviderRef#policy
   */
  readonly policy?: BucketInventorySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketInventorySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecProviderRef(obj: BucketInventorySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketInventorySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketInventorySpecPublishConnectionDetailsTo
 */
export interface BucketInventorySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketInventorySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketInventorySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketInventorySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketInventorySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketInventorySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketInventorySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecPublishConnectionDetailsTo(obj: BucketInventorySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketInventorySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketInventorySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketInventorySpecWriteConnectionSecretToRef
 */
export interface BucketInventorySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketInventorySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketInventorySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketInventorySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecWriteConnectionSecretToRef(obj: BucketInventorySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketInventorySpecForProviderBucketRef
 */
export interface BucketInventorySpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketInventorySpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketInventorySpecForProviderBucketRef#policy
   */
  readonly policy?: BucketInventorySpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderBucketRef(obj: BucketInventorySpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketInventorySpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketInventorySpecForProviderBucketSelector
 */
export interface BucketInventorySpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketInventorySpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketInventorySpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketInventorySpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketInventorySpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderBucketSelector(obj: BucketInventorySpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketInventorySpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketInventorySpecForProviderDestination
 */
export interface BucketInventorySpecForProviderDestination {
  /**
   * Name of the source bucket that inventory lists the objects for.
   *
   * @schema BucketInventorySpecForProviderDestination#bucket
   */
  readonly bucket: BucketInventorySpecForProviderDestinationBucket[];

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderDestination(obj: BucketInventorySpecForProviderDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket?.map(y => toJson_BucketInventorySpecForProviderDestinationBucket(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketInventorySpecForProviderFilter
 */
export interface BucketInventorySpecForProviderFilter {
  /**
   * Prefix that an object must have to be included in the inventory results.
   *
   * @schema BucketInventorySpecForProviderFilter#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderFilter(obj: BucketInventorySpecForProviderFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketInventorySpecForProviderSchedule
 */
export interface BucketInventorySpecForProviderSchedule {
  /**
   * Specifies how frequently inventory results are produced. Valid values: Daily, Weekly.
   *
   * @schema BucketInventorySpecForProviderSchedule#frequency
   */
  readonly frequency: string;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderSchedule(obj: BucketInventorySpecForProviderSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'frequency': obj.frequency,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketInventorySpecProviderConfigRefPolicy
 */
export interface BucketInventorySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketInventorySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketInventorySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketInventorySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketInventorySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketInventorySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecProviderConfigRefPolicy(obj: BucketInventorySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketInventorySpecProviderRefPolicy
 */
export interface BucketInventorySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketInventorySpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketInventorySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketInventorySpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketInventorySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketInventorySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecProviderRefPolicy(obj: BucketInventorySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketInventorySpecPublishConnectionDetailsToConfigRef
 */
export interface BucketInventorySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketInventorySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketInventorySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketInventorySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketInventorySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecPublishConnectionDetailsToConfigRef(obj: BucketInventorySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketInventorySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketInventorySpecPublishConnectionDetailsToMetadata
 */
export interface BucketInventorySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketInventorySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketInventorySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketInventorySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketInventorySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecPublishConnectionDetailsToMetadata(obj: BucketInventorySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketInventorySpecForProviderBucketRefPolicy
 */
export interface BucketInventorySpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketInventorySpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketInventorySpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketInventorySpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketInventorySpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderBucketRefPolicy(obj: BucketInventorySpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketInventorySpecForProviderBucketSelectorPolicy
 */
export interface BucketInventorySpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketInventorySpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketInventorySpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketInventorySpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketInventorySpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderBucketSelectorPolicy(obj: BucketInventorySpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketInventorySpecForProviderDestinationBucket
 */
export interface BucketInventorySpecForProviderDestinationBucket {
  /**
   * ID of the account that owns the destination bucket. Recommended to be set to prevent problems if the destination bucket ownership changes.
   *
   * @schema BucketInventorySpecForProviderDestinationBucket#accountId
   */
  readonly accountId?: string;

  /**
   * Amazon S3 bucket ARN of the destination.
   *
   * @schema BucketInventorySpecForProviderDestinationBucket#bucketArn
   */
  readonly bucketArn?: string;

  /**
   * Reference to a Bucket in s3 to populate bucketArn.
   *
   * @schema BucketInventorySpecForProviderDestinationBucket#bucketArnRef
   */
  readonly bucketArnRef?: BucketInventorySpecForProviderDestinationBucketBucketArnRef;

  /**
   * Selector for a Bucket in s3 to populate bucketArn.
   *
   * @schema BucketInventorySpecForProviderDestinationBucket#bucketArnSelector
   */
  readonly bucketArnSelector?: BucketInventorySpecForProviderDestinationBucketBucketArnSelector;

  /**
   * Contains the type of server-side encryption to use to encrypt the inventory (documented below).
   *
   * @schema BucketInventorySpecForProviderDestinationBucket#encryption
   */
  readonly encryption?: BucketInventorySpecForProviderDestinationBucketEncryption[];

  /**
   * Specifies the output format of the inventory results. Can be CSV, ORC or Parquet.
   *
   * @schema BucketInventorySpecForProviderDestinationBucket#format
   */
  readonly format: string;

  /**
   * Prefix that an object must have to be included in the inventory results.
   *
   * @schema BucketInventorySpecForProviderDestinationBucket#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderDestinationBucket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderDestinationBucket(obj: BucketInventorySpecForProviderDestinationBucket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'bucketArn': obj.bucketArn,
    'bucketArnRef': toJson_BucketInventorySpecForProviderDestinationBucketBucketArnRef(obj.bucketArnRef),
    'bucketArnSelector': toJson_BucketInventorySpecForProviderDestinationBucketBucketArnSelector(obj.bucketArnSelector),
    'encryption': obj.encryption?.map(y => toJson_BucketInventorySpecForProviderDestinationBucketEncryption(y)),
    'format': obj.format,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketInventorySpecProviderConfigRefPolicyResolution
 */
export enum BucketInventorySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketInventorySpecProviderConfigRefPolicyResolve
 */
export enum BucketInventorySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketInventorySpecProviderRefPolicyResolution
 */
export enum BucketInventorySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketInventorySpecProviderRefPolicyResolve
 */
export enum BucketInventorySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketInventorySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketInventorySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketInventorySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketInventorySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketInventorySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketInventorySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketInventorySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketInventorySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketInventorySpecForProviderBucketRefPolicyResolution
 */
export enum BucketInventorySpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketInventorySpecForProviderBucketRefPolicyResolve
 */
export enum BucketInventorySpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketInventorySpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketInventorySpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketInventorySpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketInventorySpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Bucket in s3 to populate bucketArn.
 *
 * @schema BucketInventorySpecForProviderDestinationBucketBucketArnRef
 */
export interface BucketInventorySpecForProviderDestinationBucketBucketArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketInventorySpecForProviderDestinationBucketBucketArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketInventorySpecForProviderDestinationBucketBucketArnRef#policy
   */
  readonly policy?: BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicy;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderDestinationBucketBucketArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderDestinationBucketBucketArnRef(obj: BucketInventorySpecForProviderDestinationBucketBucketArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucketArn.
 *
 * @schema BucketInventorySpecForProviderDestinationBucketBucketArnSelector
 */
export interface BucketInventorySpecForProviderDestinationBucketBucketArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketInventorySpecForProviderDestinationBucketBucketArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketInventorySpecForProviderDestinationBucketBucketArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketInventorySpecForProviderDestinationBucketBucketArnSelector#policy
   */
  readonly policy?: BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderDestinationBucketBucketArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderDestinationBucketBucketArnSelector(obj: BucketInventorySpecForProviderDestinationBucketBucketArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketInventorySpecForProviderDestinationBucketEncryption
 */
export interface BucketInventorySpecForProviderDestinationBucketEncryption {
  /**
   * Specifies to use server-side encryption with AWS KMS-managed keys to encrypt the inventory file (documented below).
   *
   * @schema BucketInventorySpecForProviderDestinationBucketEncryption#sseKms
   */
  readonly sseKms?: BucketInventorySpecForProviderDestinationBucketEncryptionSseKms[];

  /**
   * Specifies to use server-side encryption with Amazon S3-managed keys (SSE-S3) to encrypt the inventory file.
   *
   * @schema BucketInventorySpecForProviderDestinationBucketEncryption#sseS3
   */
  readonly sseS3?: any[];

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderDestinationBucketEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderDestinationBucketEncryption(obj: BucketInventorySpecForProviderDestinationBucketEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sseKms': obj.sseKms?.map(y => toJson_BucketInventorySpecForProviderDestinationBucketEncryptionSseKms(y)),
    'sseS3': obj.sseS3?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketInventorySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketInventorySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketInventorySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketInventorySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicy
 */
export interface BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicy#resolution
   */
  readonly resolution?: BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicy#resolve
   */
  readonly resolve?: BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicy(obj: BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicy
 */
export interface BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicy(obj: BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketInventorySpecForProviderDestinationBucketEncryptionSseKms
 */
export interface BucketInventorySpecForProviderDestinationBucketEncryptionSseKms {
  /**
   * ARN of the KMS customer master key (CMK) used to encrypt the inventory file.
   *
   * @schema BucketInventorySpecForProviderDestinationBucketEncryptionSseKms#keyId
   */
  readonly keyId: string;

}

/**
 * Converts an object of type 'BucketInventorySpecForProviderDestinationBucketEncryptionSseKms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketInventorySpecForProviderDestinationBucketEncryptionSseKms(obj: BucketInventorySpecForProviderDestinationBucketEncryptionSseKms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicyResolution
 */
export enum BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicyResolve
 */
export enum BucketInventorySpecForProviderDestinationBucketBucketArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicyResolution
 */
export enum BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicyResolve
 */
export enum BucketInventorySpecForProviderDestinationBucketBucketArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketLifecycleConfiguration is the Schema for the BucketLifecycleConfigurations API. Provides a S3 bucket lifecycle configuration resource.
 *
 * @schema BucketLifecycleConfiguration
 */
export class BucketLifecycleConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketLifecycleConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketLifecycleConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "BucketLifecycleConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketLifecycleConfigurationProps): any {
    return {
      ...BucketLifecycleConfiguration.GVK,
      ...toJson_BucketLifecycleConfigurationProps(props),
    };
  }

  /**
   * Defines a "BucketLifecycleConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketLifecycleConfigurationProps) {
    super(scope, id, {
      ...BucketLifecycleConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketLifecycleConfiguration.GVK,
      ...toJson_BucketLifecycleConfigurationProps(resolved),
    };
  }
}

/**
 * BucketLifecycleConfiguration is the Schema for the BucketLifecycleConfigurations API. Provides a S3 bucket lifecycle configuration resource.
 *
 * @schema BucketLifecycleConfiguration
 */
export interface BucketLifecycleConfigurationProps {
  /**
   * @schema BucketLifecycleConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketLifecycleConfigurationSpec defines the desired state of BucketLifecycleConfiguration
   *
   * @schema BucketLifecycleConfiguration#spec
   */
  readonly spec: BucketLifecycleConfigurationSpec;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationProps(obj: BucketLifecycleConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketLifecycleConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketLifecycleConfigurationSpec defines the desired state of BucketLifecycleConfiguration
 *
 * @schema BucketLifecycleConfigurationSpec
 */
export interface BucketLifecycleConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketLifecycleConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketLifecycleConfigurationSpecDeletionPolicy;

  /**
   * @schema BucketLifecycleConfigurationSpec#forProvider
   */
  readonly forProvider: BucketLifecycleConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketLifecycleConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketLifecycleConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketLifecycleConfigurationSpec#providerRef
   */
  readonly providerRef?: BucketLifecycleConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketLifecycleConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketLifecycleConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketLifecycleConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketLifecycleConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpec(obj: BucketLifecycleConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketLifecycleConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketLifecycleConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketLifecycleConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketLifecycleConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketLifecycleConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketLifecycleConfigurationSpecDeletionPolicy
 */
export enum BucketLifecycleConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketLifecycleConfigurationSpecForProvider
 */
export interface BucketLifecycleConfigurationSpecForProvider {
  /**
   * Name of the source S3 bucket you want Amazon S3 to monitor.
   *
   * @schema BucketLifecycleConfigurationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketLifecycleConfigurationSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketLifecycleConfigurationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketLifecycleConfigurationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketLifecycleConfigurationSpecForProviderBucketSelector;

  /**
   * Account ID of the expected bucket owner. If the bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
   *
   * @schema BucketLifecycleConfigurationSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketLifecycleConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * List of configuration blocks describing the rules managing the replication. See below.
   *
   * @schema BucketLifecycleConfigurationSpecForProvider#rule
   */
  readonly rule: BucketLifecycleConfigurationSpecForProviderRule[];

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProvider(obj: BucketLifecycleConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketLifecycleConfigurationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketLifecycleConfigurationSpecForProviderBucketSelector(obj.bucketSelector),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'region': obj.region,
    'rule': obj.rule?.map(y => toJson_BucketLifecycleConfigurationSpecForProviderRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketLifecycleConfigurationSpecProviderConfigRef
 */
export interface BucketLifecycleConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketLifecycleConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketLifecycleConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: BucketLifecycleConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecProviderConfigRef(obj: BucketLifecycleConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketLifecycleConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketLifecycleConfigurationSpecProviderRef
 */
export interface BucketLifecycleConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketLifecycleConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketLifecycleConfigurationSpecProviderRef#policy
   */
  readonly policy?: BucketLifecycleConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecProviderRef(obj: BucketLifecycleConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketLifecycleConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsTo
 */
export interface BucketLifecycleConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketLifecycleConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecPublishConnectionDetailsTo(obj: BucketLifecycleConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketLifecycleConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketLifecycleConfigurationSpecWriteConnectionSecretToRef
 */
export interface BucketLifecycleConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketLifecycleConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketLifecycleConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecWriteConnectionSecretToRef(obj: BucketLifecycleConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketLifecycleConfigurationSpecForProviderBucketRef
 */
export interface BucketLifecycleConfigurationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketLifecycleConfigurationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderBucketRef(obj: BucketLifecycleConfigurationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketLifecycleConfigurationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketLifecycleConfigurationSpecForProviderBucketSelector
 */
export interface BucketLifecycleConfigurationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderBucketSelector(obj: BucketLifecycleConfigurationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketLifecycleConfigurationSpecForProviderRule
 */
export interface BucketLifecycleConfigurationSpecForProviderRule {
  /**
   * Configuration block that specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. See below.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRule#abortIncompleteMultipartUpload
   */
  readonly abortIncompleteMultipartUpload?: BucketLifecycleConfigurationSpecForProviderRuleAbortIncompleteMultipartUpload[];

  /**
   * Configuration block that specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker. See below.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRule#expiration
   */
  readonly expiration?: BucketLifecycleConfigurationSpecForProviderRuleExpiration[];

  /**
   * Configuration block used to identify objects that a Lifecycle Rule applies to. See below. If not specified, the rule will default to using prefix.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRule#filter
   */
  readonly filter?: BucketLifecycleConfigurationSpecForProviderRuleFilter[];

  /**
   * Unique identifier for the rule. The value cannot be longer than 255 characters.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRule#id
   */
  readonly id: string;

  /**
   * Configuration block that specifies when noncurrent object versions expire. See below.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRule#noncurrentVersionExpiration
   */
  readonly noncurrentVersionExpiration?: BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionExpiration[];

  /**
   * Set of configuration blocks that specify the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. See below.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRule#noncurrentVersionTransition
   */
  readonly noncurrentVersionTransition?: BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionTransition[];

  /**
   * DEPRECATED Use filter instead. This has been deprecated by Amazon S3. Prefix identifying one or more objects to which the rule applies. Defaults to an empty string ("") if filter is not specified.
   *
   * @default an empty string ("") if filter is not specified.
   * @schema BucketLifecycleConfigurationSpecForProviderRule#prefix
   */
  readonly prefix?: string;

  /**
   * Whether the rule is currently being applied. Valid values: Enabled or Disabled.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRule#status
   */
  readonly status: string;

  /**
   * Set of configuration blocks that specify when an Amazon S3 object transitions to a specified storage class. See below.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRule#transition
   */
  readonly transition?: BucketLifecycleConfigurationSpecForProviderRuleTransition[];

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderRule(obj: BucketLifecycleConfigurationSpecForProviderRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abortIncompleteMultipartUpload': obj.abortIncompleteMultipartUpload?.map(y => toJson_BucketLifecycleConfigurationSpecForProviderRuleAbortIncompleteMultipartUpload(y)),
    'expiration': obj.expiration?.map(y => toJson_BucketLifecycleConfigurationSpecForProviderRuleExpiration(y)),
    'filter': obj.filter?.map(y => toJson_BucketLifecycleConfigurationSpecForProviderRuleFilter(y)),
    'id': obj.id,
    'noncurrentVersionExpiration': obj.noncurrentVersionExpiration?.map(y => toJson_BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionExpiration(y)),
    'noncurrentVersionTransition': obj.noncurrentVersionTransition?.map(y => toJson_BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionTransition(y)),
    'prefix': obj.prefix,
    'status': obj.status,
    'transition': obj.transition?.map(y => toJson_BucketLifecycleConfigurationSpecForProviderRuleTransition(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketLifecycleConfigurationSpecProviderConfigRefPolicy
 */
export interface BucketLifecycleConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLifecycleConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketLifecycleConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLifecycleConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketLifecycleConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecProviderConfigRefPolicy(obj: BucketLifecycleConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketLifecycleConfigurationSpecProviderRefPolicy
 */
export interface BucketLifecycleConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLifecycleConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketLifecycleConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLifecycleConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketLifecycleConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecProviderRefPolicy(obj: BucketLifecycleConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef(obj: BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface BucketLifecycleConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecPublishConnectionDetailsToMetadata(obj: BucketLifecycleConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketLifecycleConfigurationSpecForProviderBucketRefPolicy
 */
export interface BucketLifecycleConfigurationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketLifecycleConfigurationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketLifecycleConfigurationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderBucketRefPolicy(obj: BucketLifecycleConfigurationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicy
 */
export interface BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicy(obj: BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketLifecycleConfigurationSpecForProviderRuleAbortIncompleteMultipartUpload
 */
export interface BucketLifecycleConfigurationSpecForProviderRuleAbortIncompleteMultipartUpload {
  /**
   * Number of days after which Amazon S3 aborts an incomplete multipart upload.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleAbortIncompleteMultipartUpload#daysAfterInitiation
   */
  readonly daysAfterInitiation?: number;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderRuleAbortIncompleteMultipartUpload' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderRuleAbortIncompleteMultipartUpload(obj: BucketLifecycleConfigurationSpecForProviderRuleAbortIncompleteMultipartUpload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'daysAfterInitiation': obj.daysAfterInitiation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketLifecycleConfigurationSpecForProviderRuleExpiration
 */
export interface BucketLifecycleConfigurationSpecForProviderRuleExpiration {
  /**
   * Date objects are transitioned to the specified storage class. The date value must be in RFC3339 format and set to midnight UTC e.g. 2023-01-13T00:00:00Z.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleExpiration#date
   */
  readonly date?: string;

  /**
   * Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both days and date are not specified, defaults to 0. Valid values depend on storage_class, see Transition objects using Amazon S3 Lifecycle for more details.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleExpiration#days
   */
  readonly days?: number;

  /**
   * Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired; if set to false the policy takes no action.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleExpiration#expiredObjectDeleteMarker
   */
  readonly expiredObjectDeleteMarker?: boolean;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderRuleExpiration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderRuleExpiration(obj: BucketLifecycleConfigurationSpecForProviderRuleExpiration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'date': obj.date,
    'days': obj.days,
    'expiredObjectDeleteMarker': obj.expiredObjectDeleteMarker,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketLifecycleConfigurationSpecForProviderRuleFilter
 */
export interface BucketLifecycleConfigurationSpecForProviderRuleFilter {
  /**
   * Configuration block used to apply a logical AND to two or more predicates. See below. The Lifecycle Rule will apply to any object matching all the predicates configured inside the and block.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleFilter#and
   */
  readonly and?: BucketLifecycleConfigurationSpecForProviderRuleFilterAnd[];

  /**
   * Minimum object size (in bytes) to which the rule applies.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleFilter#objectSizeGreaterThan
   */
  readonly objectSizeGreaterThan?: string;

  /**
   * Maximum object size (in bytes) to which the rule applies.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleFilter#objectSizeLessThan
   */
  readonly objectSizeLessThan?: string;

  /**
   * DEPRECATED Use filter instead. This has been deprecated by Amazon S3. Prefix identifying one or more objects to which the rule applies. Defaults to an empty string ("") if filter is not specified.
   *
   * @default an empty string ("") if filter is not specified.
   * @schema BucketLifecycleConfigurationSpecForProviderRuleFilter#prefix
   */
  readonly prefix?: string;

  /**
   * Configuration block for specifying a tag key and value. See below.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleFilter#tag
   */
  readonly tag?: BucketLifecycleConfigurationSpecForProviderRuleFilterTag[];

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderRuleFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderRuleFilter(obj: BucketLifecycleConfigurationSpecForProviderRuleFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': obj.and?.map(y => toJson_BucketLifecycleConfigurationSpecForProviderRuleFilterAnd(y)),
    'objectSizeGreaterThan': obj.objectSizeGreaterThan,
    'objectSizeLessThan': obj.objectSizeLessThan,
    'prefix': obj.prefix,
    'tag': obj.tag?.map(y => toJson_BucketLifecycleConfigurationSpecForProviderRuleFilterTag(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionExpiration
 */
export interface BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionExpiration {
  /**
   * Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionExpiration#newerNoncurrentVersions
   */
  readonly newerNoncurrentVersions?: string;

  /**
   * Number of days an object is noncurrent before Amazon S3 can perform the associated action.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionExpiration#noncurrentDays
   */
  readonly noncurrentDays?: number;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionExpiration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionExpiration(obj: BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionExpiration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newerNoncurrentVersions': obj.newerNoncurrentVersions,
    'noncurrentDays': obj.noncurrentDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionTransition
 */
export interface BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionTransition {
  /**
   * Number of noncurrent versions Amazon S3 will retain. Must be a non-zero positive integer.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionTransition#newerNoncurrentVersions
   */
  readonly newerNoncurrentVersions?: string;

  /**
   * Number of days an object is noncurrent before Amazon S3 can perform the associated action.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionTransition#noncurrentDays
   */
  readonly noncurrentDays?: number;

  /**
   * Class of storage used to store the object. Valid Values: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE, GLACIER_IR.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionTransition#storageClass
   */
  readonly storageClass: string;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionTransition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionTransition(obj: BucketLifecycleConfigurationSpecForProviderRuleNoncurrentVersionTransition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'newerNoncurrentVersions': obj.newerNoncurrentVersions,
    'noncurrentDays': obj.noncurrentDays,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketLifecycleConfigurationSpecForProviderRuleTransition
 */
export interface BucketLifecycleConfigurationSpecForProviderRuleTransition {
  /**
   * Date objects are transitioned to the specified storage class. The date value must be in RFC3339 format and set to midnight UTC e.g. 2023-01-13T00:00:00Z.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleTransition#date
   */
  readonly date?: string;

  /**
   * Number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer. If both days and date are not specified, defaults to 0. Valid values depend on storage_class, see Transition objects using Amazon S3 Lifecycle for more details.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleTransition#days
   */
  readonly days?: number;

  /**
   * Class of storage used to store the object. Valid Values: GLACIER, STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, DEEP_ARCHIVE, GLACIER_IR.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleTransition#storageClass
   */
  readonly storageClass: string;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderRuleTransition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderRuleTransition(obj: BucketLifecycleConfigurationSpecForProviderRuleTransition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'date': obj.date,
    'days': obj.days,
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLifecycleConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum BucketLifecycleConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLifecycleConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum BucketLifecycleConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLifecycleConfigurationSpecProviderRefPolicyResolution
 */
export enum BucketLifecycleConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLifecycleConfigurationSpecProviderRefPolicyResolve
 */
export enum BucketLifecycleConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLifecycleConfigurationSpecForProviderBucketRefPolicyResolution
 */
export enum BucketLifecycleConfigurationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLifecycleConfigurationSpecForProviderBucketRefPolicyResolve
 */
export enum BucketLifecycleConfigurationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketLifecycleConfigurationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema BucketLifecycleConfigurationSpecForProviderRuleFilterAnd
 */
export interface BucketLifecycleConfigurationSpecForProviderRuleFilterAnd {
  /**
   * Minimum object size (in bytes) to which the rule applies.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleFilterAnd#objectSizeGreaterThan
   */
  readonly objectSizeGreaterThan?: number;

  /**
   * Maximum object size (in bytes) to which the rule applies.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleFilterAnd#objectSizeLessThan
   */
  readonly objectSizeLessThan?: number;

  /**
   * DEPRECATED Use filter instead. This has been deprecated by Amazon S3. Prefix identifying one or more objects to which the rule applies. Defaults to an empty string ("") if filter is not specified.
   *
   * @default an empty string ("") if filter is not specified.
   * @schema BucketLifecycleConfigurationSpecForProviderRuleFilterAnd#prefix
   */
  readonly prefix?: string;

  /**
   * Key-value map of resource tags. All of these tags must exist in the object's tag set in order for the rule to apply.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleFilterAnd#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderRuleFilterAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderRuleFilterAnd(obj: BucketLifecycleConfigurationSpecForProviderRuleFilterAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectSizeGreaterThan': obj.objectSizeGreaterThan,
    'objectSizeLessThan': obj.objectSizeLessThan,
    'prefix': obj.prefix,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketLifecycleConfigurationSpecForProviderRuleFilterTag
 */
export interface BucketLifecycleConfigurationSpecForProviderRuleFilterTag {
  /**
   * Name of the object key.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleFilterTag#key
   */
  readonly key: string;

  /**
   * Value of the tag.
   *
   * @schema BucketLifecycleConfigurationSpecForProviderRuleFilterTag#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'BucketLifecycleConfigurationSpecForProviderRuleFilterTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLifecycleConfigurationSpecForProviderRuleFilterTag(obj: BucketLifecycleConfigurationSpecForProviderRuleFilterTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketLifecycleConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketLogging is the Schema for the BucketLoggings API. Provides an S3 bucket (server access) logging resource.
 *
 * @schema BucketLogging
 */
export class BucketLogging extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketLogging"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketLogging',
  }

  /**
   * Renders a Kubernetes manifest for "BucketLogging".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketLoggingProps): any {
    return {
      ...BucketLogging.GVK,
      ...toJson_BucketLoggingProps(props),
    };
  }

  /**
   * Defines a "BucketLogging" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketLoggingProps) {
    super(scope, id, {
      ...BucketLogging.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketLogging.GVK,
      ...toJson_BucketLoggingProps(resolved),
    };
  }
}

/**
 * BucketLogging is the Schema for the BucketLoggings API. Provides an S3 bucket (server access) logging resource.
 *
 * @schema BucketLogging
 */
export interface BucketLoggingProps {
  /**
   * @schema BucketLogging#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketLoggingSpec defines the desired state of BucketLogging
   *
   * @schema BucketLogging#spec
   */
  readonly spec: BucketLoggingSpec;

}

/**
 * Converts an object of type 'BucketLoggingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingProps(obj: BucketLoggingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketLoggingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketLoggingSpec defines the desired state of BucketLogging
 *
 * @schema BucketLoggingSpec
 */
export interface BucketLoggingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketLoggingSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketLoggingSpecDeletionPolicy;

  /**
   * @schema BucketLoggingSpec#forProvider
   */
  readonly forProvider: BucketLoggingSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketLoggingSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketLoggingSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketLoggingSpec#providerRef
   */
  readonly providerRef?: BucketLoggingSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketLoggingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketLoggingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketLoggingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketLoggingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketLoggingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpec(obj: BucketLoggingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketLoggingSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketLoggingSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketLoggingSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketLoggingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketLoggingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketLoggingSpecDeletionPolicy
 */
export enum BucketLoggingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketLoggingSpecForProvider
 */
export interface BucketLoggingSpecForProvider {
  /**
   * Name of the bucket.
   *
   * @schema BucketLoggingSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketLoggingSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketLoggingSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketLoggingSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketLoggingSpecForProviderBucketSelector;

  /**
   * Account ID of the expected bucket owner.
   *
   * @schema BucketLoggingSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketLoggingSpecForProvider#region
   */
  readonly region: string;

  /**
   * Name of the bucket where you want Amazon S3 to store server access logs.
   *
   * @schema BucketLoggingSpecForProvider#targetBucket
   */
  readonly targetBucket?: string;

  /**
   * Reference to a Bucket in s3 to populate targetBucket.
   *
   * @schema BucketLoggingSpecForProvider#targetBucketRef
   */
  readonly targetBucketRef?: BucketLoggingSpecForProviderTargetBucketRef;

  /**
   * Selector for a Bucket in s3 to populate targetBucket.
   *
   * @schema BucketLoggingSpecForProvider#targetBucketSelector
   */
  readonly targetBucketSelector?: BucketLoggingSpecForProviderTargetBucketSelector;

  /**
   * Set of configuration blocks with information for granting permissions. See below.
   *
   * @schema BucketLoggingSpecForProvider#targetGrant
   */
  readonly targetGrant?: BucketLoggingSpecForProviderTargetGrant[];

  /**
   * Prefix for all log object keys.
   *
   * @schema BucketLoggingSpecForProvider#targetPrefix
   */
  readonly targetPrefix: string;

}

/**
 * Converts an object of type 'BucketLoggingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecForProvider(obj: BucketLoggingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketLoggingSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketLoggingSpecForProviderBucketSelector(obj.bucketSelector),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'region': obj.region,
    'targetBucket': obj.targetBucket,
    'targetBucketRef': toJson_BucketLoggingSpecForProviderTargetBucketRef(obj.targetBucketRef),
    'targetBucketSelector': toJson_BucketLoggingSpecForProviderTargetBucketSelector(obj.targetBucketSelector),
    'targetGrant': obj.targetGrant?.map(y => toJson_BucketLoggingSpecForProviderTargetGrant(y)),
    'targetPrefix': obj.targetPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketLoggingSpecProviderConfigRef
 */
export interface BucketLoggingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketLoggingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketLoggingSpecProviderConfigRef#policy
   */
  readonly policy?: BucketLoggingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketLoggingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecProviderConfigRef(obj: BucketLoggingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketLoggingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketLoggingSpecProviderRef
 */
export interface BucketLoggingSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketLoggingSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketLoggingSpecProviderRef#policy
   */
  readonly policy?: BucketLoggingSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketLoggingSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecProviderRef(obj: BucketLoggingSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketLoggingSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketLoggingSpecPublishConnectionDetailsTo
 */
export interface BucketLoggingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketLoggingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketLoggingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketLoggingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketLoggingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketLoggingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketLoggingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecPublishConnectionDetailsTo(obj: BucketLoggingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketLoggingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketLoggingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketLoggingSpecWriteConnectionSecretToRef
 */
export interface BucketLoggingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketLoggingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketLoggingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketLoggingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecWriteConnectionSecretToRef(obj: BucketLoggingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketLoggingSpecForProviderBucketRef
 */
export interface BucketLoggingSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketLoggingSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketLoggingSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketLoggingSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketLoggingSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecForProviderBucketRef(obj: BucketLoggingSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketLoggingSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketLoggingSpecForProviderBucketSelector
 */
export interface BucketLoggingSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketLoggingSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketLoggingSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketLoggingSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketLoggingSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketLoggingSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecForProviderBucketSelector(obj: BucketLoggingSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketLoggingSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate targetBucket.
 *
 * @schema BucketLoggingSpecForProviderTargetBucketRef
 */
export interface BucketLoggingSpecForProviderTargetBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketLoggingSpecForProviderTargetBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketLoggingSpecForProviderTargetBucketRef#policy
   */
  readonly policy?: BucketLoggingSpecForProviderTargetBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketLoggingSpecForProviderTargetBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecForProviderTargetBucketRef(obj: BucketLoggingSpecForProviderTargetBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketLoggingSpecForProviderTargetBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate targetBucket.
 *
 * @schema BucketLoggingSpecForProviderTargetBucketSelector
 */
export interface BucketLoggingSpecForProviderTargetBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketLoggingSpecForProviderTargetBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketLoggingSpecForProviderTargetBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketLoggingSpecForProviderTargetBucketSelector#policy
   */
  readonly policy?: BucketLoggingSpecForProviderTargetBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketLoggingSpecForProviderTargetBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecForProviderTargetBucketSelector(obj: BucketLoggingSpecForProviderTargetBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketLoggingSpecForProviderTargetBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketLoggingSpecForProviderTargetGrant
 */
export interface BucketLoggingSpecForProviderTargetGrant {
  /**
   * Configuration block for the person being granted permissions. See below.
   *
   * @schema BucketLoggingSpecForProviderTargetGrant#grantee
   */
  readonly grantee: BucketLoggingSpecForProviderTargetGrantGrantee[];

  /**
   * Logging permissions assigned to the grantee for the bucket. Valid values: FULL_CONTROL, READ, WRITE.
   *
   * @schema BucketLoggingSpecForProviderTargetGrant#permission
   */
  readonly permission: string;

}

/**
 * Converts an object of type 'BucketLoggingSpecForProviderTargetGrant' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecForProviderTargetGrant(obj: BucketLoggingSpecForProviderTargetGrant | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grantee': obj.grantee?.map(y => toJson_BucketLoggingSpecForProviderTargetGrantGrantee(y)),
    'permission': obj.permission,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketLoggingSpecProviderConfigRefPolicy
 */
export interface BucketLoggingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLoggingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketLoggingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLoggingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketLoggingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketLoggingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecProviderConfigRefPolicy(obj: BucketLoggingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketLoggingSpecProviderRefPolicy
 */
export interface BucketLoggingSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLoggingSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketLoggingSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLoggingSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketLoggingSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketLoggingSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecProviderRefPolicy(obj: BucketLoggingSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketLoggingSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketLoggingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketLoggingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketLoggingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketLoggingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecPublishConnectionDetailsToConfigRef(obj: BucketLoggingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketLoggingSpecPublishConnectionDetailsToMetadata
 */
export interface BucketLoggingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketLoggingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketLoggingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketLoggingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketLoggingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecPublishConnectionDetailsToMetadata(obj: BucketLoggingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketLoggingSpecForProviderBucketRefPolicy
 */
export interface BucketLoggingSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLoggingSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketLoggingSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLoggingSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketLoggingSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketLoggingSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecForProviderBucketRefPolicy(obj: BucketLoggingSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketLoggingSpecForProviderBucketSelectorPolicy
 */
export interface BucketLoggingSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLoggingSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketLoggingSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLoggingSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketLoggingSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketLoggingSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecForProviderBucketSelectorPolicy(obj: BucketLoggingSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketLoggingSpecForProviderTargetBucketRefPolicy
 */
export interface BucketLoggingSpecForProviderTargetBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLoggingSpecForProviderTargetBucketRefPolicy#resolution
   */
  readonly resolution?: BucketLoggingSpecForProviderTargetBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLoggingSpecForProviderTargetBucketRefPolicy#resolve
   */
  readonly resolve?: BucketLoggingSpecForProviderTargetBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketLoggingSpecForProviderTargetBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecForProviderTargetBucketRefPolicy(obj: BucketLoggingSpecForProviderTargetBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketLoggingSpecForProviderTargetBucketSelectorPolicy
 */
export interface BucketLoggingSpecForProviderTargetBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLoggingSpecForProviderTargetBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketLoggingSpecForProviderTargetBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLoggingSpecForProviderTargetBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketLoggingSpecForProviderTargetBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketLoggingSpecForProviderTargetBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecForProviderTargetBucketSelectorPolicy(obj: BucketLoggingSpecForProviderTargetBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketLoggingSpecForProviderTargetGrantGrantee
 */
export interface BucketLoggingSpecForProviderTargetGrantGrantee {
  /**
   * Email address of the grantee. See Regions and Endpoints for supported AWS regions where this argument can be specified.
   *
   * @schema BucketLoggingSpecForProviderTargetGrantGrantee#emailAddress
   */
  readonly emailAddress?: string;

  /**
   * Canonical user ID of the grantee.
   *
   * @schema BucketLoggingSpecForProviderTargetGrantGrantee#id
   */
  readonly id?: string;

  /**
   * Type of grantee. Valid values: CanonicalUser, AmazonCustomerByEmail, Group.
   *
   * @schema BucketLoggingSpecForProviderTargetGrantGrantee#type
   */
  readonly type: string;

  /**
   * URI of the grantee group.
   *
   * @schema BucketLoggingSpecForProviderTargetGrantGrantee#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'BucketLoggingSpecForProviderTargetGrantGrantee' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecForProviderTargetGrantGrantee(obj: BucketLoggingSpecForProviderTargetGrantGrantee | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'emailAddress': obj.emailAddress,
    'id': obj.id,
    'type': obj.type,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLoggingSpecProviderConfigRefPolicyResolution
 */
export enum BucketLoggingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLoggingSpecProviderConfigRefPolicyResolve
 */
export enum BucketLoggingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLoggingSpecProviderRefPolicyResolution
 */
export enum BucketLoggingSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLoggingSpecProviderRefPolicyResolve
 */
export enum BucketLoggingSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLoggingSpecForProviderBucketRefPolicyResolution
 */
export enum BucketLoggingSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLoggingSpecForProviderBucketRefPolicyResolve
 */
export enum BucketLoggingSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLoggingSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketLoggingSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLoggingSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketLoggingSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLoggingSpecForProviderTargetBucketRefPolicyResolution
 */
export enum BucketLoggingSpecForProviderTargetBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLoggingSpecForProviderTargetBucketRefPolicyResolve
 */
export enum BucketLoggingSpecForProviderTargetBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLoggingSpecForProviderTargetBucketSelectorPolicyResolution
 */
export enum BucketLoggingSpecForProviderTargetBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLoggingSpecForProviderTargetBucketSelectorPolicyResolve
 */
export enum BucketLoggingSpecForProviderTargetBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketLoggingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketMetric is the Schema for the BucketMetrics API. Provides a S3 bucket metrics configuration resource.
 *
 * @schema BucketMetric
 */
export class BucketMetric extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketMetric"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketMetric',
  }

  /**
   * Renders a Kubernetes manifest for "BucketMetric".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketMetricProps): any {
    return {
      ...BucketMetric.GVK,
      ...toJson_BucketMetricProps(props),
    };
  }

  /**
   * Defines a "BucketMetric" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketMetricProps) {
    super(scope, id, {
      ...BucketMetric.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketMetric.GVK,
      ...toJson_BucketMetricProps(resolved),
    };
  }
}

/**
 * BucketMetric is the Schema for the BucketMetrics API. Provides a S3 bucket metrics configuration resource.
 *
 * @schema BucketMetric
 */
export interface BucketMetricProps {
  /**
   * @schema BucketMetric#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketMetricSpec defines the desired state of BucketMetric
   *
   * @schema BucketMetric#spec
   */
  readonly spec: BucketMetricSpec;

}

/**
 * Converts an object of type 'BucketMetricProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricProps(obj: BucketMetricProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketMetricSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketMetricSpec defines the desired state of BucketMetric
 *
 * @schema BucketMetricSpec
 */
export interface BucketMetricSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketMetricSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketMetricSpecDeletionPolicy;

  /**
   * @schema BucketMetricSpec#forProvider
   */
  readonly forProvider: BucketMetricSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketMetricSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketMetricSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketMetricSpec#providerRef
   */
  readonly providerRef?: BucketMetricSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketMetricSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketMetricSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketMetricSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketMetricSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketMetricSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpec(obj: BucketMetricSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketMetricSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketMetricSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketMetricSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketMetricSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketMetricSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketMetricSpecDeletionPolicy
 */
export enum BucketMetricSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketMetricSpecForProvider
 */
export interface BucketMetricSpecForProvider {
  /**
   * Name of the bucket to put metric configuration.
   *
   * @schema BucketMetricSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketMetricSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketMetricSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketMetricSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketMetricSpecForProviderBucketSelector;

  /**
   * Object filtering that accepts a prefix, tags, or a logical AND of prefix and tags (documented below).
   *
   * @schema BucketMetricSpecForProvider#filter
   */
  readonly filter?: BucketMetricSpecForProviderFilter[];

  /**
   * Unique identifier of the metrics configuration for the bucket. Must be less than or equal to 64 characters in length.
   *
   * @schema BucketMetricSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketMetricSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BucketMetricSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecForProvider(obj: BucketMetricSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketMetricSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketMetricSpecForProviderBucketSelector(obj.bucketSelector),
    'filter': obj.filter?.map(y => toJson_BucketMetricSpecForProviderFilter(y)),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketMetricSpecProviderConfigRef
 */
export interface BucketMetricSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketMetricSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketMetricSpecProviderConfigRef#policy
   */
  readonly policy?: BucketMetricSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketMetricSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecProviderConfigRef(obj: BucketMetricSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketMetricSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketMetricSpecProviderRef
 */
export interface BucketMetricSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketMetricSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketMetricSpecProviderRef#policy
   */
  readonly policy?: BucketMetricSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketMetricSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecProviderRef(obj: BucketMetricSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketMetricSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketMetricSpecPublishConnectionDetailsTo
 */
export interface BucketMetricSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketMetricSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketMetricSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketMetricSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketMetricSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketMetricSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketMetricSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecPublishConnectionDetailsTo(obj: BucketMetricSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketMetricSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketMetricSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketMetricSpecWriteConnectionSecretToRef
 */
export interface BucketMetricSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketMetricSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketMetricSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketMetricSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecWriteConnectionSecretToRef(obj: BucketMetricSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketMetricSpecForProviderBucketRef
 */
export interface BucketMetricSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketMetricSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketMetricSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketMetricSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketMetricSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecForProviderBucketRef(obj: BucketMetricSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketMetricSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketMetricSpecForProviderBucketSelector
 */
export interface BucketMetricSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketMetricSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketMetricSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketMetricSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketMetricSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketMetricSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecForProviderBucketSelector(obj: BucketMetricSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketMetricSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketMetricSpecForProviderFilter
 */
export interface BucketMetricSpecForProviderFilter {
  /**
   * Object prefix for filtering (singular).
   *
   * @schema BucketMetricSpecForProviderFilter#prefix
   */
  readonly prefix?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema BucketMetricSpecForProviderFilter#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'BucketMetricSpecForProviderFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecForProviderFilter(obj: BucketMetricSpecForProviderFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketMetricSpecProviderConfigRefPolicy
 */
export interface BucketMetricSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketMetricSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketMetricSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketMetricSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketMetricSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketMetricSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecProviderConfigRefPolicy(obj: BucketMetricSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketMetricSpecProviderRefPolicy
 */
export interface BucketMetricSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketMetricSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketMetricSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketMetricSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketMetricSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketMetricSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecProviderRefPolicy(obj: BucketMetricSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketMetricSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketMetricSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketMetricSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketMetricSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketMetricSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketMetricSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecPublishConnectionDetailsToConfigRef(obj: BucketMetricSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketMetricSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketMetricSpecPublishConnectionDetailsToMetadata
 */
export interface BucketMetricSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketMetricSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketMetricSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketMetricSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketMetricSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecPublishConnectionDetailsToMetadata(obj: BucketMetricSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketMetricSpecForProviderBucketRefPolicy
 */
export interface BucketMetricSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketMetricSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketMetricSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketMetricSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketMetricSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketMetricSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecForProviderBucketRefPolicy(obj: BucketMetricSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketMetricSpecForProviderBucketSelectorPolicy
 */
export interface BucketMetricSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketMetricSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketMetricSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketMetricSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketMetricSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketMetricSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecForProviderBucketSelectorPolicy(obj: BucketMetricSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketMetricSpecProviderConfigRefPolicyResolution
 */
export enum BucketMetricSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketMetricSpecProviderConfigRefPolicyResolve
 */
export enum BucketMetricSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketMetricSpecProviderRefPolicyResolution
 */
export enum BucketMetricSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketMetricSpecProviderRefPolicyResolve
 */
export enum BucketMetricSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketMetricSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketMetricSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketMetricSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketMetricSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketMetricSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketMetricSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketMetricSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketMetricSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketMetricSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketMetricSpecForProviderBucketRefPolicyResolution
 */
export enum BucketMetricSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketMetricSpecForProviderBucketRefPolicyResolve
 */
export enum BucketMetricSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketMetricSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketMetricSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketMetricSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketMetricSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketMetricSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketMetricSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketMetricSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketMetricSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketNotification is the Schema for the BucketNotifications API. Manages a S3 Bucket Notification Configuration
 *
 * @schema BucketNotification
 */
export class BucketNotification extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketNotification"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketNotification',
  }

  /**
   * Renders a Kubernetes manifest for "BucketNotification".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketNotificationProps): any {
    return {
      ...BucketNotification.GVK,
      ...toJson_BucketNotificationProps(props),
    };
  }

  /**
   * Defines a "BucketNotification" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketNotificationProps) {
    super(scope, id, {
      ...BucketNotification.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketNotification.GVK,
      ...toJson_BucketNotificationProps(resolved),
    };
  }
}

/**
 * BucketNotification is the Schema for the BucketNotifications API. Manages a S3 Bucket Notification Configuration
 *
 * @schema BucketNotification
 */
export interface BucketNotificationProps {
  /**
   * @schema BucketNotification#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketNotificationSpec defines the desired state of BucketNotification
   *
   * @schema BucketNotification#spec
   */
  readonly spec: BucketNotificationSpec;

}

/**
 * Converts an object of type 'BucketNotificationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationProps(obj: BucketNotificationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketNotificationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketNotificationSpec defines the desired state of BucketNotification
 *
 * @schema BucketNotificationSpec
 */
export interface BucketNotificationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketNotificationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketNotificationSpecDeletionPolicy;

  /**
   * @schema BucketNotificationSpec#forProvider
   */
  readonly forProvider: BucketNotificationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketNotificationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketNotificationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketNotificationSpec#providerRef
   */
  readonly providerRef?: BucketNotificationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketNotificationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketNotificationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketNotificationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketNotificationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketNotificationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpec(obj: BucketNotificationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketNotificationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketNotificationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketNotificationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketNotificationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketNotificationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketNotificationSpecDeletionPolicy
 */
export enum BucketNotificationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketNotificationSpecForProvider
 */
export interface BucketNotificationSpecForProvider {
  /**
   * Name of the bucket for notification configuration.
   *
   * @schema BucketNotificationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketNotificationSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketNotificationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketNotificationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketNotificationSpecForProviderBucketSelector;

  /**
   * Whether to enable Amazon EventBridge notifications.
   *
   * @schema BucketNotificationSpecForProvider#eventbridge
   */
  readonly eventbridge?: boolean;

  /**
   * Used to configure notifications to a Lambda Function. See below.
   *
   * @schema BucketNotificationSpecForProvider#lambdaFunction
   */
  readonly lambdaFunction?: BucketNotificationSpecForProviderLambdaFunction[];

  /**
   * Notification configuration to SQS Queue. See below.
   *
   * @schema BucketNotificationSpecForProvider#queue
   */
  readonly queue?: BucketNotificationSpecForProviderQueue[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketNotificationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Notification configuration to SNS Topic. See below.
   *
   * @schema BucketNotificationSpecForProvider#topic
   */
  readonly topic?: BucketNotificationSpecForProviderTopic[];

}

/**
 * Converts an object of type 'BucketNotificationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProvider(obj: BucketNotificationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketNotificationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketNotificationSpecForProviderBucketSelector(obj.bucketSelector),
    'eventbridge': obj.eventbridge,
    'lambdaFunction': obj.lambdaFunction?.map(y => toJson_BucketNotificationSpecForProviderLambdaFunction(y)),
    'queue': obj.queue?.map(y => toJson_BucketNotificationSpecForProviderQueue(y)),
    'region': obj.region,
    'topic': obj.topic?.map(y => toJson_BucketNotificationSpecForProviderTopic(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketNotificationSpecProviderConfigRef
 */
export interface BucketNotificationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketNotificationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketNotificationSpecProviderConfigRef#policy
   */
  readonly policy?: BucketNotificationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketNotificationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecProviderConfigRef(obj: BucketNotificationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketNotificationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketNotificationSpecProviderRef
 */
export interface BucketNotificationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketNotificationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketNotificationSpecProviderRef#policy
   */
  readonly policy?: BucketNotificationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketNotificationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecProviderRef(obj: BucketNotificationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketNotificationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketNotificationSpecPublishConnectionDetailsTo
 */
export interface BucketNotificationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketNotificationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketNotificationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketNotificationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketNotificationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketNotificationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketNotificationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecPublishConnectionDetailsTo(obj: BucketNotificationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketNotificationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketNotificationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketNotificationSpecWriteConnectionSecretToRef
 */
export interface BucketNotificationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketNotificationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketNotificationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketNotificationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecWriteConnectionSecretToRef(obj: BucketNotificationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketNotificationSpecForProviderBucketRef
 */
export interface BucketNotificationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketNotificationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketNotificationSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketNotificationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderBucketRef(obj: BucketNotificationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketNotificationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketNotificationSpecForProviderBucketSelector
 */
export interface BucketNotificationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketNotificationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketNotificationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketNotificationSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketNotificationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderBucketSelector(obj: BucketNotificationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketNotificationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketNotificationSpecForProviderLambdaFunction
 */
export interface BucketNotificationSpecForProviderLambdaFunction {
  /**
   * Event for which to send notifications.
   *
   * @schema BucketNotificationSpecForProviderLambdaFunction#events
   */
  readonly events: string[];

  /**
   * Object key name prefix.
   *
   * @schema BucketNotificationSpecForProviderLambdaFunction#filterPrefix
   */
  readonly filterPrefix?: string;

  /**
   * Object key name suffix.
   *
   * @schema BucketNotificationSpecForProviderLambdaFunction#filterSuffix
   */
  readonly filterSuffix?: string;

  /**
   * Unique identifier for each of the notification configurations.
   *
   * @schema BucketNotificationSpecForProviderLambdaFunction#id
   */
  readonly id?: string;

  /**
   * Lambda function ARN.
   *
   * @schema BucketNotificationSpecForProviderLambdaFunction#lambdaFunctionArn
   */
  readonly lambdaFunctionArn?: string;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderLambdaFunction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderLambdaFunction(obj: BucketNotificationSpecForProviderLambdaFunction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'filterPrefix': obj.filterPrefix,
    'filterSuffix': obj.filterSuffix,
    'id': obj.id,
    'lambdaFunctionArn': obj.lambdaFunctionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketNotificationSpecForProviderQueue
 */
export interface BucketNotificationSpecForProviderQueue {
  /**
   * Specifies event for which to send notifications.
   *
   * @schema BucketNotificationSpecForProviderQueue#events
   */
  readonly events: string[];

  /**
   * Object key name prefix.
   *
   * @schema BucketNotificationSpecForProviderQueue#filterPrefix
   */
  readonly filterPrefix?: string;

  /**
   * Object key name suffix.
   *
   * @schema BucketNotificationSpecForProviderQueue#filterSuffix
   */
  readonly filterSuffix?: string;

  /**
   * Unique identifier for each of the notification configurations.
   *
   * @schema BucketNotificationSpecForProviderQueue#id
   */
  readonly id?: string;

  /**
   * SQS queue ARN.
   *
   * @schema BucketNotificationSpecForProviderQueue#queueArn
   */
  readonly queueArn?: string;

  /**
   * Reference to a Queue in sqs to populate queueArn.
   *
   * @schema BucketNotificationSpecForProviderQueue#queueArnRef
   */
  readonly queueArnRef?: BucketNotificationSpecForProviderQueueQueueArnRef;

  /**
   * Selector for a Queue in sqs to populate queueArn.
   *
   * @schema BucketNotificationSpecForProviderQueue#queueArnSelector
   */
  readonly queueArnSelector?: BucketNotificationSpecForProviderQueueQueueArnSelector;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderQueue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderQueue(obj: BucketNotificationSpecForProviderQueue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'filterPrefix': obj.filterPrefix,
    'filterSuffix': obj.filterSuffix,
    'id': obj.id,
    'queueArn': obj.queueArn,
    'queueArnRef': toJson_BucketNotificationSpecForProviderQueueQueueArnRef(obj.queueArnRef),
    'queueArnSelector': toJson_BucketNotificationSpecForProviderQueueQueueArnSelector(obj.queueArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketNotificationSpecForProviderTopic
 */
export interface BucketNotificationSpecForProviderTopic {
  /**
   * Event for which to send notifications.
   *
   * @schema BucketNotificationSpecForProviderTopic#events
   */
  readonly events: string[];

  /**
   * Object key name prefix.
   *
   * @schema BucketNotificationSpecForProviderTopic#filterPrefix
   */
  readonly filterPrefix?: string;

  /**
   * Object key name suffix.
   *
   * @schema BucketNotificationSpecForProviderTopic#filterSuffix
   */
  readonly filterSuffix?: string;

  /**
   * Unique identifier for each of the notification configurations.
   *
   * @schema BucketNotificationSpecForProviderTopic#id
   */
  readonly id?: string;

  /**
   * SNS topic ARN.
   *
   * @schema BucketNotificationSpecForProviderTopic#topicArn
   */
  readonly topicArn?: string;

  /**
   * Reference to a Topic in sns to populate topicArn.
   *
   * @schema BucketNotificationSpecForProviderTopic#topicArnRef
   */
  readonly topicArnRef?: BucketNotificationSpecForProviderTopicTopicArnRef;

  /**
   * Selector for a Topic in sns to populate topicArn.
   *
   * @schema BucketNotificationSpecForProviderTopic#topicArnSelector
   */
  readonly topicArnSelector?: BucketNotificationSpecForProviderTopicTopicArnSelector;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderTopic' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderTopic(obj: BucketNotificationSpecForProviderTopic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'filterPrefix': obj.filterPrefix,
    'filterSuffix': obj.filterSuffix,
    'id': obj.id,
    'topicArn': obj.topicArn,
    'topicArnRef': toJson_BucketNotificationSpecForProviderTopicTopicArnRef(obj.topicArnRef),
    'topicArnSelector': toJson_BucketNotificationSpecForProviderTopicTopicArnSelector(obj.topicArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketNotificationSpecProviderConfigRefPolicy
 */
export interface BucketNotificationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketNotificationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketNotificationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketNotificationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketNotificationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketNotificationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecProviderConfigRefPolicy(obj: BucketNotificationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketNotificationSpecProviderRefPolicy
 */
export interface BucketNotificationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketNotificationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketNotificationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketNotificationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketNotificationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketNotificationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecProviderRefPolicy(obj: BucketNotificationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketNotificationSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketNotificationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketNotificationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketNotificationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketNotificationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecPublishConnectionDetailsToConfigRef(obj: BucketNotificationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketNotificationSpecPublishConnectionDetailsToMetadata
 */
export interface BucketNotificationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketNotificationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketNotificationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketNotificationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketNotificationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecPublishConnectionDetailsToMetadata(obj: BucketNotificationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketNotificationSpecForProviderBucketRefPolicy
 */
export interface BucketNotificationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketNotificationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketNotificationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketNotificationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketNotificationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderBucketRefPolicy(obj: BucketNotificationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketNotificationSpecForProviderBucketSelectorPolicy
 */
export interface BucketNotificationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketNotificationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketNotificationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketNotificationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketNotificationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderBucketSelectorPolicy(obj: BucketNotificationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Queue in sqs to populate queueArn.
 *
 * @schema BucketNotificationSpecForProviderQueueQueueArnRef
 */
export interface BucketNotificationSpecForProviderQueueQueueArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketNotificationSpecForProviderQueueQueueArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketNotificationSpecForProviderQueueQueueArnRef#policy
   */
  readonly policy?: BucketNotificationSpecForProviderQueueQueueArnRefPolicy;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderQueueQueueArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderQueueQueueArnRef(obj: BucketNotificationSpecForProviderQueueQueueArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketNotificationSpecForProviderQueueQueueArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Queue in sqs to populate queueArn.
 *
 * @schema BucketNotificationSpecForProviderQueueQueueArnSelector
 */
export interface BucketNotificationSpecForProviderQueueQueueArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketNotificationSpecForProviderQueueQueueArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketNotificationSpecForProviderQueueQueueArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketNotificationSpecForProviderQueueQueueArnSelector#policy
   */
  readonly policy?: BucketNotificationSpecForProviderQueueQueueArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderQueueQueueArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderQueueQueueArnSelector(obj: BucketNotificationSpecForProviderQueueQueueArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketNotificationSpecForProviderQueueQueueArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate topicArn.
 *
 * @schema BucketNotificationSpecForProviderTopicTopicArnRef
 */
export interface BucketNotificationSpecForProviderTopicTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketNotificationSpecForProviderTopicTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketNotificationSpecForProviderTopicTopicArnRef#policy
   */
  readonly policy?: BucketNotificationSpecForProviderTopicTopicArnRefPolicy;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderTopicTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderTopicTopicArnRef(obj: BucketNotificationSpecForProviderTopicTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketNotificationSpecForProviderTopicTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate topicArn.
 *
 * @schema BucketNotificationSpecForProviderTopicTopicArnSelector
 */
export interface BucketNotificationSpecForProviderTopicTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketNotificationSpecForProviderTopicTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketNotificationSpecForProviderTopicTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketNotificationSpecForProviderTopicTopicArnSelector#policy
   */
  readonly policy?: BucketNotificationSpecForProviderTopicTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderTopicTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderTopicTopicArnSelector(obj: BucketNotificationSpecForProviderTopicTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketNotificationSpecForProviderTopicTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketNotificationSpecProviderConfigRefPolicyResolution
 */
export enum BucketNotificationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketNotificationSpecProviderConfigRefPolicyResolve
 */
export enum BucketNotificationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketNotificationSpecProviderRefPolicyResolution
 */
export enum BucketNotificationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketNotificationSpecProviderRefPolicyResolve
 */
export enum BucketNotificationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketNotificationSpecForProviderBucketRefPolicyResolution
 */
export enum BucketNotificationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketNotificationSpecForProviderBucketRefPolicyResolve
 */
export enum BucketNotificationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketNotificationSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketNotificationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketNotificationSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketNotificationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketNotificationSpecForProviderQueueQueueArnRefPolicy
 */
export interface BucketNotificationSpecForProviderQueueQueueArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketNotificationSpecForProviderQueueQueueArnRefPolicy#resolution
   */
  readonly resolution?: BucketNotificationSpecForProviderQueueQueueArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketNotificationSpecForProviderQueueQueueArnRefPolicy#resolve
   */
  readonly resolve?: BucketNotificationSpecForProviderQueueQueueArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderQueueQueueArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderQueueQueueArnRefPolicy(obj: BucketNotificationSpecForProviderQueueQueueArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketNotificationSpecForProviderQueueQueueArnSelectorPolicy
 */
export interface BucketNotificationSpecForProviderQueueQueueArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketNotificationSpecForProviderQueueQueueArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketNotificationSpecForProviderQueueQueueArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketNotificationSpecForProviderQueueQueueArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketNotificationSpecForProviderQueueQueueArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderQueueQueueArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderQueueQueueArnSelectorPolicy(obj: BucketNotificationSpecForProviderQueueQueueArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketNotificationSpecForProviderTopicTopicArnRefPolicy
 */
export interface BucketNotificationSpecForProviderTopicTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketNotificationSpecForProviderTopicTopicArnRefPolicy#resolution
   */
  readonly resolution?: BucketNotificationSpecForProviderTopicTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketNotificationSpecForProviderTopicTopicArnRefPolicy#resolve
   */
  readonly resolve?: BucketNotificationSpecForProviderTopicTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderTopicTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderTopicTopicArnRefPolicy(obj: BucketNotificationSpecForProviderTopicTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketNotificationSpecForProviderTopicTopicArnSelectorPolicy
 */
export interface BucketNotificationSpecForProviderTopicTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketNotificationSpecForProviderTopicTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: BucketNotificationSpecForProviderTopicTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketNotificationSpecForProviderTopicTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: BucketNotificationSpecForProviderTopicTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketNotificationSpecForProviderTopicTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketNotificationSpecForProviderTopicTopicArnSelectorPolicy(obj: BucketNotificationSpecForProviderTopicTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketNotificationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketNotificationSpecForProviderQueueQueueArnRefPolicyResolution
 */
export enum BucketNotificationSpecForProviderQueueQueueArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketNotificationSpecForProviderQueueQueueArnRefPolicyResolve
 */
export enum BucketNotificationSpecForProviderQueueQueueArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketNotificationSpecForProviderQueueQueueArnSelectorPolicyResolution
 */
export enum BucketNotificationSpecForProviderQueueQueueArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketNotificationSpecForProviderQueueQueueArnSelectorPolicyResolve
 */
export enum BucketNotificationSpecForProviderQueueQueueArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketNotificationSpecForProviderTopicTopicArnRefPolicyResolution
 */
export enum BucketNotificationSpecForProviderTopicTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketNotificationSpecForProviderTopicTopicArnRefPolicyResolve
 */
export enum BucketNotificationSpecForProviderTopicTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketNotificationSpecForProviderTopicTopicArnSelectorPolicyResolution
 */
export enum BucketNotificationSpecForProviderTopicTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketNotificationSpecForProviderTopicTopicArnSelectorPolicyResolve
 */
export enum BucketNotificationSpecForProviderTopicTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketObject is the Schema for the BucketObjects API. Provides an S3 object resource.
 *
 * @schema BucketObject
 */
export class BucketObject extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketObject"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketObject',
  }

  /**
   * Renders a Kubernetes manifest for "BucketObject".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketObjectProps): any {
    return {
      ...BucketObject.GVK,
      ...toJson_BucketObjectProps(props),
    };
  }

  /**
   * Defines a "BucketObject" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketObjectProps) {
    super(scope, id, {
      ...BucketObject.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketObject.GVK,
      ...toJson_BucketObjectProps(resolved),
    };
  }
}

/**
 * BucketObject is the Schema for the BucketObjects API. Provides an S3 object resource.
 *
 * @schema BucketObject
 */
export interface BucketObjectProps {
  /**
   * @schema BucketObject#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketObjectSpec defines the desired state of BucketObject
   *
   * @schema BucketObject#spec
   */
  readonly spec: BucketObjectSpec;

}

/**
 * Converts an object of type 'BucketObjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectProps(obj: BucketObjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketObjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketObjectSpec defines the desired state of BucketObject
 *
 * @schema BucketObjectSpec
 */
export interface BucketObjectSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketObjectSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketObjectSpecDeletionPolicy;

  /**
   * @schema BucketObjectSpec#forProvider
   */
  readonly forProvider: BucketObjectSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketObjectSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketObjectSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketObjectSpec#providerRef
   */
  readonly providerRef?: BucketObjectSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketObjectSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketObjectSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketObjectSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketObjectSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketObjectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpec(obj: BucketObjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketObjectSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketObjectSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketObjectSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketObjectSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketObjectSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketObjectSpecDeletionPolicy
 */
export enum BucketObjectSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketObjectSpecForProvider
 */
export interface BucketObjectSpecForProvider {
  /**
   * Canned ACL to apply. Valid values are private, public-read, public-read-write, aws-exec-read, authenticated-read, bucket-owner-read, and bucket-owner-full-control. Defaults to private.
   *
   * @default private.
   * @schema BucketObjectSpecForProvider#acl
   */
  readonly acl?: string;

  /**
   * Name of the bucket to put the file in. Alternatively, an S3 access point ARN can be specified.
   *
   * @schema BucketObjectSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Whether or not to use Amazon S3 Bucket Keys for SSE-KMS.
   *
   * @schema BucketObjectSpecForProvider#bucketKeyEnabled
   */
  readonly bucketKeyEnabled?: boolean;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketObjectSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketObjectSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketObjectSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketObjectSpecForProviderBucketSelector;

  /**
   * Caching behavior along the request/reply chain Read w3c cache_control for further details.
   *
   * @schema BucketObjectSpecForProvider#cacheControl
   */
  readonly cacheControl?: string;

  /**
   * Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text.
   *
   * @schema BucketObjectSpecForProvider#content
   */
  readonly content?: string;

  /**
   * Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for small content such as the result of the gzipbase64 function with small text strings. For larger objects, use source to stream the content from a disk file.
   *
   * @schema BucketObjectSpecForProvider#contentBase64
   */
  readonly contentBase64?: string;

  /**
   * Presentational information for the object. Read w3c content_disposition for further information.
   *
   * @schema BucketObjectSpecForProvider#contentDisposition
   */
  readonly contentDisposition?: string;

  /**
   * Content encodings that have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read w3c content encoding for further information.
   *
   * @schema BucketObjectSpecForProvider#contentEncoding
   */
  readonly contentEncoding?: string;

  /**
   * Language the content is in e.g., en-US or en-GB.
   *
   * @schema BucketObjectSpecForProvider#contentLanguage
   */
  readonly contentLanguage?: string;

  /**
   * Standard MIME type describing the format of the object data, e.g., application/octet-stream. All Valid MIME Types are valid for this input.
   *
   * @schema BucketObjectSpecForProvider#contentType
   */
  readonly contentType?: string;

  /**
   * Triggers updates when the value changes.11.11.11 or earlier). This attribute is not compatible with KMS encryption, kms_key_id or server_side_encryption = "aws:kms" (see source_hash instead).
   *
   * @schema BucketObjectSpecForProvider#etag
   */
  readonly etag?: string;

  /**
   * Whether to allow the object to be deleted by removing any legal hold on any object version. Default is false. This value should be set to true only if the bucket has S3 object lock enabled.
   *
   * @default false. This value should be set to true only if the bucket has S3 object lock enabled.
   * @schema BucketObjectSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * Name of the object once it is in the bucket.
   *
   * @schema BucketObjectSpecForProvider#key
   */
  readonly key: string;

  /**
   * ARN of the KMS Key to use for object encryption. If the S3 Bucket has server-side encryption enabled, that value will automatically be used. If referencing the aws_kms_key resource, use the arn attribute. If referencing the aws_kms_alias data source or resource, use the target_key_arn attribute.
   *
   * @schema BucketObjectSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema BucketObjectSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: BucketObjectSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema BucketObjectSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: BucketObjectSpecForProviderKmsKeyIdSelector;

  /**
   * Map of keys/values to provision metadata (will be automatically prefixed by x-amz-meta-, note that only lowercase label are currently supported by the AWS Go API).
   *
   * @schema BucketObjectSpecForProvider#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * Legal hold status that you want to apply to the specified object. Valid values are ON and OFF.
   *
   * @schema BucketObjectSpecForProvider#objectLockLegalHoldStatus
   */
  readonly objectLockLegalHoldStatus?: string;

  /**
   * Object lock retention mode that you want to apply to this object. Valid values are GOVERNANCE and COMPLIANCE.
   *
   * @schema BucketObjectSpecForProvider#objectLockMode
   */
  readonly objectLockMode?: string;

  /**
   * Date and time, in RFC3339 format, when this object's object lock will expire.
   *
   * @schema BucketObjectSpecForProvider#objectLockRetainUntilDate
   */
  readonly objectLockRetainUntilDate?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketObjectSpecForProvider#region
   */
  readonly region: string;

  /**
   * Server-side encryption of the object in S3. Valid values are "AES256" and "aws:kms".
   *
   * @schema BucketObjectSpecForProvider#serverSideEncryption
   */
  readonly serverSideEncryption?: string;

  /**
   * Path to a file that will be read and uploaded as raw bytes for the object content.
   *
   * @schema BucketObjectSpecForProvider#source
   */
  readonly source?: string;

  /**
   * Triggers updates like etag but useful to address etag encryption limitations.11.12 or later). (The value is only stored in state and not saved by AWS.)
   *
   * @schema BucketObjectSpecForProvider#sourceHash
   */
  readonly sourceHash?: string;

  /**
   * Storage Class for the object. Defaults to "STANDARD".
   *
   * @default STANDARD".
   * @schema BucketObjectSpecForProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema BucketObjectSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Target URL for website redirect.
   *
   * @schema BucketObjectSpecForProvider#websiteRedirect
   */
  readonly websiteRedirect?: string;

}

/**
 * Converts an object of type 'BucketObjectSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProvider(obj: BucketObjectSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acl': obj.acl,
    'bucket': obj.bucket,
    'bucketKeyEnabled': obj.bucketKeyEnabled,
    'bucketRef': toJson_BucketObjectSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketObjectSpecForProviderBucketSelector(obj.bucketSelector),
    'cacheControl': obj.cacheControl,
    'content': obj.content,
    'contentBase64': obj.contentBase64,
    'contentDisposition': obj.contentDisposition,
    'contentEncoding': obj.contentEncoding,
    'contentLanguage': obj.contentLanguage,
    'contentType': obj.contentType,
    'etag': obj.etag,
    'forceDestroy': obj.forceDestroy,
    'key': obj.key,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_BucketObjectSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_BucketObjectSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'objectLockLegalHoldStatus': obj.objectLockLegalHoldStatus,
    'objectLockMode': obj.objectLockMode,
    'objectLockRetainUntilDate': obj.objectLockRetainUntilDate,
    'region': obj.region,
    'serverSideEncryption': obj.serverSideEncryption,
    'source': obj.source,
    'sourceHash': obj.sourceHash,
    'storageClass': obj.storageClass,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'websiteRedirect': obj.websiteRedirect,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketObjectSpecProviderConfigRef
 */
export interface BucketObjectSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecProviderConfigRef#policy
   */
  readonly policy?: BucketObjectSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecProviderConfigRef(obj: BucketObjectSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketObjectSpecProviderRef
 */
export interface BucketObjectSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecProviderRef#policy
   */
  readonly policy?: BucketObjectSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecProviderRef(obj: BucketObjectSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsTo
 */
export interface BucketObjectSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketObjectSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketObjectSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsTo(obj: BucketObjectSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketObjectSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketObjectSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketObjectSpecWriteConnectionSecretToRef
 */
export interface BucketObjectSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketObjectSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketObjectSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketObjectSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecWriteConnectionSecretToRef(obj: BucketObjectSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketObjectSpecForProviderBucketRef
 */
export interface BucketObjectSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketObjectSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketRef(obj: BucketObjectSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketObjectSpecForProviderBucketSelector
 */
export interface BucketObjectSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketObjectSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketObjectSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketObjectSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketObjectSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketSelector(obj: BucketObjectSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketObjectSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema BucketObjectSpecForProviderKmsKeyIdRef
 */
export interface BucketObjectSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: BucketObjectSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderKmsKeyIdRef(obj: BucketObjectSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema BucketObjectSpecForProviderKmsKeyIdSelector
 */
export interface BucketObjectSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketObjectSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketObjectSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketObjectSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: BucketObjectSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderKmsKeyIdSelector(obj: BucketObjectSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketObjectSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecProviderConfigRefPolicy
 */
export interface BucketObjectSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecProviderConfigRefPolicy(obj: BucketObjectSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecProviderRefPolicy
 */
export interface BucketObjectSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecProviderRefPolicy(obj: BucketObjectSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketObjectSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsToConfigRef(obj: BucketObjectSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToMetadata
 */
export interface BucketObjectSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsToMetadata(obj: BucketObjectSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecForProviderBucketRefPolicy
 */
export interface BucketObjectSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketRefPolicy(obj: BucketObjectSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketObjectSpecForProviderBucketSelectorPolicy
 */
export interface BucketObjectSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderBucketSelectorPolicy(obj: BucketObjectSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecForProviderKmsKeyIdRefPolicy
 */
export interface BucketObjectSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderKmsKeyIdRefPolicy(obj: BucketObjectSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketObjectSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface BucketObjectSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecForProviderKmsKeyIdSelectorPolicy(obj: BucketObjectSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecProviderConfigRefPolicyResolution
 */
export enum BucketObjectSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecProviderConfigRefPolicyResolve
 */
export enum BucketObjectSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecProviderRefPolicyResolution
 */
export enum BucketObjectSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecProviderRefPolicyResolve
 */
export enum BucketObjectSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketObjectSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecForProviderBucketRefPolicyResolution
 */
export enum BucketObjectSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecForProviderBucketRefPolicyResolve
 */
export enum BucketObjectSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketObjectSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketObjectSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum BucketObjectSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum BucketObjectSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum BucketObjectSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum BucketObjectSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketObjectLockConfiguration is the Schema for the BucketObjectLockConfigurations API. Provides an S3 bucket Object Lock configuration resource.
 *
 * @schema BucketObjectLockConfiguration
 */
export class BucketObjectLockConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketObjectLockConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketObjectLockConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "BucketObjectLockConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketObjectLockConfigurationProps): any {
    return {
      ...BucketObjectLockConfiguration.GVK,
      ...toJson_BucketObjectLockConfigurationProps(props),
    };
  }

  /**
   * Defines a "BucketObjectLockConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketObjectLockConfigurationProps) {
    super(scope, id, {
      ...BucketObjectLockConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketObjectLockConfiguration.GVK,
      ...toJson_BucketObjectLockConfigurationProps(resolved),
    };
  }
}

/**
 * BucketObjectLockConfiguration is the Schema for the BucketObjectLockConfigurations API. Provides an S3 bucket Object Lock configuration resource.
 *
 * @schema BucketObjectLockConfiguration
 */
export interface BucketObjectLockConfigurationProps {
  /**
   * @schema BucketObjectLockConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketObjectLockConfigurationSpec defines the desired state of BucketObjectLockConfiguration
   *
   * @schema BucketObjectLockConfiguration#spec
   */
  readonly spec: BucketObjectLockConfigurationSpec;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationProps(obj: BucketObjectLockConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketObjectLockConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketObjectLockConfigurationSpec defines the desired state of BucketObjectLockConfiguration
 *
 * @schema BucketObjectLockConfigurationSpec
 */
export interface BucketObjectLockConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketObjectLockConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketObjectLockConfigurationSpecDeletionPolicy;

  /**
   * @schema BucketObjectLockConfigurationSpec#forProvider
   */
  readonly forProvider: BucketObjectLockConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketObjectLockConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketObjectLockConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketObjectLockConfigurationSpec#providerRef
   */
  readonly providerRef?: BucketObjectLockConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketObjectLockConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketObjectLockConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketObjectLockConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketObjectLockConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpec(obj: BucketObjectLockConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketObjectLockConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketObjectLockConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketObjectLockConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketObjectLockConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketObjectLockConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketObjectLockConfigurationSpecDeletionPolicy
 */
export enum BucketObjectLockConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketObjectLockConfigurationSpecForProvider
 */
export interface BucketObjectLockConfigurationSpecForProvider {
  /**
   * Name of the bucket.
   *
   * @schema BucketObjectLockConfigurationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketObjectLockConfigurationSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketObjectLockConfigurationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketObjectLockConfigurationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketObjectLockConfigurationSpecForProviderBucketSelector;

  /**
   * Account ID of the expected bucket owner.
   *
   * @schema BucketObjectLockConfigurationSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Indicates whether this bucket has an Object Lock configuration enabled. Defaults to Enabled. Valid values: Enabled.
   *
   * @default Enabled. Valid values: Enabled.
   * @schema BucketObjectLockConfigurationSpecForProvider#objectLockEnabled
   */
  readonly objectLockEnabled?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketObjectLockConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block for specifying the Object Lock rule for the specified object. See below.
   *
   * @schema BucketObjectLockConfigurationSpecForProvider#rule
   */
  readonly rule?: BucketObjectLockConfigurationSpecForProviderRule[];

  /**
   * Token to allow Object Lock to be enabled for an existing bucket. You must contact AWS support for the bucket's "Object Lock token". The token is generated in the back-end when versioning is enabled on a bucket. For more details on versioning, see the aws_s3_bucket_versioning resource.
   *
   * @schema BucketObjectLockConfigurationSpecForProvider#tokenSecretRef
   */
  readonly tokenSecretRef?: BucketObjectLockConfigurationSpecForProviderTokenSecretRef;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecForProvider(obj: BucketObjectLockConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketObjectLockConfigurationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketObjectLockConfigurationSpecForProviderBucketSelector(obj.bucketSelector),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'objectLockEnabled': obj.objectLockEnabled,
    'region': obj.region,
    'rule': obj.rule?.map(y => toJson_BucketObjectLockConfigurationSpecForProviderRule(y)),
    'tokenSecretRef': toJson_BucketObjectLockConfigurationSpecForProviderTokenSecretRef(obj.tokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketObjectLockConfigurationSpecProviderConfigRef
 */
export interface BucketObjectLockConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectLockConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectLockConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: BucketObjectLockConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecProviderConfigRef(obj: BucketObjectLockConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectLockConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketObjectLockConfigurationSpecProviderRef
 */
export interface BucketObjectLockConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectLockConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectLockConfigurationSpecProviderRef#policy
   */
  readonly policy?: BucketObjectLockConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecProviderRef(obj: BucketObjectLockConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectLockConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsTo
 */
export interface BucketObjectLockConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketObjectLockConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecPublishConnectionDetailsTo(obj: BucketObjectLockConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketObjectLockConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketObjectLockConfigurationSpecWriteConnectionSecretToRef
 */
export interface BucketObjectLockConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketObjectLockConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketObjectLockConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecWriteConnectionSecretToRef(obj: BucketObjectLockConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketObjectLockConfigurationSpecForProviderBucketRef
 */
export interface BucketObjectLockConfigurationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketObjectLockConfigurationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecForProviderBucketRef(obj: BucketObjectLockConfigurationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectLockConfigurationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketObjectLockConfigurationSpecForProviderBucketSelector
 */
export interface BucketObjectLockConfigurationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecForProviderBucketSelector(obj: BucketObjectLockConfigurationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketObjectLockConfigurationSpecForProviderRule
 */
export interface BucketObjectLockConfigurationSpecForProviderRule {
  /**
   * Configuration block for specifying the default Object Lock retention settings for new objects placed in the specified bucket. See below.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderRule#defaultRetention
   */
  readonly defaultRetention: BucketObjectLockConfigurationSpecForProviderRuleDefaultRetention[];

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecForProviderRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecForProviderRule(obj: BucketObjectLockConfigurationSpecForProviderRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultRetention': obj.defaultRetention?.map(y => toJson_BucketObjectLockConfigurationSpecForProviderRuleDefaultRetention(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Token to allow Object Lock to be enabled for an existing bucket. You must contact AWS support for the bucket's "Object Lock token". The token is generated in the back-end when versioning is enabled on a bucket. For more details on versioning, see the aws_s3_bucket_versioning resource.
 *
 * @schema BucketObjectLockConfigurationSpecForProviderTokenSecretRef
 */
export interface BucketObjectLockConfigurationSpecForProviderTokenSecretRef {
  /**
   * The key to select.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderTokenSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderTokenSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecForProviderTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecForProviderTokenSecretRef(obj: BucketObjectLockConfigurationSpecForProviderTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectLockConfigurationSpecProviderConfigRefPolicy
 */
export interface BucketObjectLockConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectLockConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketObjectLockConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectLockConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketObjectLockConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecProviderConfigRefPolicy(obj: BucketObjectLockConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectLockConfigurationSpecProviderRefPolicy
 */
export interface BucketObjectLockConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectLockConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketObjectLockConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectLockConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketObjectLockConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecProviderRefPolicy(obj: BucketObjectLockConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRef(obj: BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface BucketObjectLockConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecPublishConnectionDetailsToMetadata(obj: BucketObjectLockConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketObjectLockConfigurationSpecForProviderBucketRefPolicy
 */
export interface BucketObjectLockConfigurationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketObjectLockConfigurationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketObjectLockConfigurationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecForProviderBucketRefPolicy(obj: BucketObjectLockConfigurationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicy
 */
export interface BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicy(obj: BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketObjectLockConfigurationSpecForProviderRuleDefaultRetention
 */
export interface BucketObjectLockConfigurationSpecForProviderRuleDefaultRetention {
  /**
   * Number of days that you want to specify for the default retention period.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderRuleDefaultRetention#days
   */
  readonly days?: number;

  /**
   * Default Object Lock retention mode you want to apply to new objects placed in the specified bucket. Valid values: COMPLIANCE, GOVERNANCE.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderRuleDefaultRetention#mode
   */
  readonly mode?: string;

  /**
   * Number of years that you want to specify for the default retention period.
   *
   * @schema BucketObjectLockConfigurationSpecForProviderRuleDefaultRetention#years
   */
  readonly years?: number;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecForProviderRuleDefaultRetention' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecForProviderRuleDefaultRetention(obj: BucketObjectLockConfigurationSpecForProviderRuleDefaultRetention | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'days': obj.days,
    'mode': obj.mode,
    'years': obj.years,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectLockConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum BucketObjectLockConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectLockConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum BucketObjectLockConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectLockConfigurationSpecProviderRefPolicyResolution
 */
export enum BucketObjectLockConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectLockConfigurationSpecProviderRefPolicyResolve
 */
export enum BucketObjectLockConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectLockConfigurationSpecForProviderBucketRefPolicyResolution
 */
export enum BucketObjectLockConfigurationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectLockConfigurationSpecForProviderBucketRefPolicyResolve
 */
export enum BucketObjectLockConfigurationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketObjectLockConfigurationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketObjectLockConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketOwnershipControls is the Schema for the BucketOwnershipControlss API. Manages S3 Bucket Ownership Controls.
 *
 * @schema BucketOwnershipControls
 */
export class BucketOwnershipControls extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketOwnershipControls"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketOwnershipControls',
  }

  /**
   * Renders a Kubernetes manifest for "BucketOwnershipControls".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketOwnershipControlsProps): any {
    return {
      ...BucketOwnershipControls.GVK,
      ...toJson_BucketOwnershipControlsProps(props),
    };
  }

  /**
   * Defines a "BucketOwnershipControls" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketOwnershipControlsProps) {
    super(scope, id, {
      ...BucketOwnershipControls.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketOwnershipControls.GVK,
      ...toJson_BucketOwnershipControlsProps(resolved),
    };
  }
}

/**
 * BucketOwnershipControls is the Schema for the BucketOwnershipControlss API. Manages S3 Bucket Ownership Controls.
 *
 * @schema BucketOwnershipControls
 */
export interface BucketOwnershipControlsProps {
  /**
   * @schema BucketOwnershipControls#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketOwnershipControlsSpec defines the desired state of BucketOwnershipControls
   *
   * @schema BucketOwnershipControls#spec
   */
  readonly spec: BucketOwnershipControlsSpec;

}

/**
 * Converts an object of type 'BucketOwnershipControlsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsProps(obj: BucketOwnershipControlsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketOwnershipControlsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketOwnershipControlsSpec defines the desired state of BucketOwnershipControls
 *
 * @schema BucketOwnershipControlsSpec
 */
export interface BucketOwnershipControlsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketOwnershipControlsSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketOwnershipControlsSpecDeletionPolicy;

  /**
   * @schema BucketOwnershipControlsSpec#forProvider
   */
  readonly forProvider: BucketOwnershipControlsSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketOwnershipControlsSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketOwnershipControlsSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketOwnershipControlsSpec#providerRef
   */
  readonly providerRef?: BucketOwnershipControlsSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketOwnershipControlsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketOwnershipControlsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketOwnershipControlsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketOwnershipControlsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpec(obj: BucketOwnershipControlsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketOwnershipControlsSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketOwnershipControlsSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketOwnershipControlsSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketOwnershipControlsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketOwnershipControlsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketOwnershipControlsSpecDeletionPolicy
 */
export enum BucketOwnershipControlsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketOwnershipControlsSpecForProvider
 */
export interface BucketOwnershipControlsSpecForProvider {
  /**
   * Name of the bucket that you want to associate this access point with.
   *
   * @schema BucketOwnershipControlsSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketOwnershipControlsSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketOwnershipControlsSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketOwnershipControlsSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketOwnershipControlsSpecForProviderBucketSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketOwnershipControlsSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block(s) with Ownership Controls rules. Detailed below.
   *
   * @schema BucketOwnershipControlsSpecForProvider#rule
   */
  readonly rule: BucketOwnershipControlsSpecForProviderRule[];

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecForProvider(obj: BucketOwnershipControlsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketOwnershipControlsSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketOwnershipControlsSpecForProviderBucketSelector(obj.bucketSelector),
    'region': obj.region,
    'rule': obj.rule?.map(y => toJson_BucketOwnershipControlsSpecForProviderRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketOwnershipControlsSpecProviderConfigRef
 */
export interface BucketOwnershipControlsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketOwnershipControlsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketOwnershipControlsSpecProviderConfigRef#policy
   */
  readonly policy?: BucketOwnershipControlsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecProviderConfigRef(obj: BucketOwnershipControlsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketOwnershipControlsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketOwnershipControlsSpecProviderRef
 */
export interface BucketOwnershipControlsSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketOwnershipControlsSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketOwnershipControlsSpecProviderRef#policy
   */
  readonly policy?: BucketOwnershipControlsSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecProviderRef(obj: BucketOwnershipControlsSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketOwnershipControlsSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketOwnershipControlsSpecPublishConnectionDetailsTo
 */
export interface BucketOwnershipControlsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketOwnershipControlsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketOwnershipControlsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketOwnershipControlsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketOwnershipControlsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecPublishConnectionDetailsTo(obj: BucketOwnershipControlsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketOwnershipControlsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketOwnershipControlsSpecWriteConnectionSecretToRef
 */
export interface BucketOwnershipControlsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketOwnershipControlsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketOwnershipControlsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecWriteConnectionSecretToRef(obj: BucketOwnershipControlsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketOwnershipControlsSpecForProviderBucketRef
 */
export interface BucketOwnershipControlsSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketOwnershipControlsSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketOwnershipControlsSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketOwnershipControlsSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecForProviderBucketRef(obj: BucketOwnershipControlsSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketOwnershipControlsSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketOwnershipControlsSpecForProviderBucketSelector
 */
export interface BucketOwnershipControlsSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketOwnershipControlsSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketOwnershipControlsSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketOwnershipControlsSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketOwnershipControlsSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecForProviderBucketSelector(obj: BucketOwnershipControlsSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketOwnershipControlsSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketOwnershipControlsSpecForProviderRule
 */
export interface BucketOwnershipControlsSpecForProviderRule {
  /**
   * Object ownership. Valid values: BucketOwnerPreferred, ObjectWriter or BucketOwnerEnforced
   *
   * @schema BucketOwnershipControlsSpecForProviderRule#objectOwnership
   */
  readonly objectOwnership: string;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecForProviderRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecForProviderRule(obj: BucketOwnershipControlsSpecForProviderRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'objectOwnership': obj.objectOwnership,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketOwnershipControlsSpecProviderConfigRefPolicy
 */
export interface BucketOwnershipControlsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketOwnershipControlsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketOwnershipControlsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketOwnershipControlsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketOwnershipControlsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecProviderConfigRefPolicy(obj: BucketOwnershipControlsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketOwnershipControlsSpecProviderRefPolicy
 */
export interface BucketOwnershipControlsSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketOwnershipControlsSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketOwnershipControlsSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketOwnershipControlsSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketOwnershipControlsSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecProviderRefPolicy(obj: BucketOwnershipControlsSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRef(obj: BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToMetadata
 */
export interface BucketOwnershipControlsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecPublishConnectionDetailsToMetadata(obj: BucketOwnershipControlsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketOwnershipControlsSpecForProviderBucketRefPolicy
 */
export interface BucketOwnershipControlsSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketOwnershipControlsSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketOwnershipControlsSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketOwnershipControlsSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketOwnershipControlsSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecForProviderBucketRefPolicy(obj: BucketOwnershipControlsSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketOwnershipControlsSpecForProviderBucketSelectorPolicy
 */
export interface BucketOwnershipControlsSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketOwnershipControlsSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketOwnershipControlsSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketOwnershipControlsSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketOwnershipControlsSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecForProviderBucketSelectorPolicy(obj: BucketOwnershipControlsSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketOwnershipControlsSpecProviderConfigRefPolicyResolution
 */
export enum BucketOwnershipControlsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketOwnershipControlsSpecProviderConfigRefPolicyResolve
 */
export enum BucketOwnershipControlsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketOwnershipControlsSpecProviderRefPolicyResolution
 */
export enum BucketOwnershipControlsSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketOwnershipControlsSpecProviderRefPolicyResolve
 */
export enum BucketOwnershipControlsSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketOwnershipControlsSpecForProviderBucketRefPolicyResolution
 */
export enum BucketOwnershipControlsSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketOwnershipControlsSpecForProviderBucketRefPolicyResolve
 */
export enum BucketOwnershipControlsSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketOwnershipControlsSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketOwnershipControlsSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketOwnershipControlsSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketOwnershipControlsSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketOwnershipControlsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketPolicy is the Schema for the BucketPolicys API. Attaches a policy to an S3 bucket resource.
 *
 * @schema BucketPolicy
 */
export class BucketPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "BucketPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketPolicyProps): any {
    return {
      ...BucketPolicy.GVK,
      ...toJson_BucketPolicyProps(props),
    };
  }

  /**
   * Defines a "BucketPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketPolicyProps) {
    super(scope, id, {
      ...BucketPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketPolicy.GVK,
      ...toJson_BucketPolicyProps(resolved),
    };
  }
}

/**
 * BucketPolicy is the Schema for the BucketPolicys API. Attaches a policy to an S3 bucket resource.
 *
 * @schema BucketPolicy
 */
export interface BucketPolicyProps {
  /**
   * @schema BucketPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketPolicySpec defines the desired state of BucketPolicy
   *
   * @schema BucketPolicy#spec
   */
  readonly spec: BucketPolicySpec;

}

/**
 * Converts an object of type 'BucketPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicyProps(obj: BucketPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketPolicySpec defines the desired state of BucketPolicy
 *
 * @schema BucketPolicySpec
 */
export interface BucketPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketPolicySpecDeletionPolicy;

  /**
   * @schema BucketPolicySpec#forProvider
   */
  readonly forProvider: BucketPolicySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketPolicySpec#providerRef
   */
  readonly providerRef?: BucketPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpec(obj: BucketPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketPolicySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketPolicySpecDeletionPolicy
 */
export enum BucketPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketPolicySpecForProvider
 */
export interface BucketPolicySpecForProvider {
  /**
   * Name of the bucket to which to apply the policy.
   *
   * @schema BucketPolicySpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketPolicySpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketPolicySpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketPolicySpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketPolicySpecForProviderBucketSelector;

  /**
   * Text of the policy. Although this is a bucket policy rather than an IAM policy, the aws_iam_policy_document data source may be used, so long as it specifies a principal. Note: Bucket policies are limited to 20 KB in size.
   *
   * @schema BucketPolicySpecForProvider#policy
   */
  readonly policy: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BucketPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProvider(obj: BucketPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketPolicySpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketPolicySpecForProviderBucketSelector(obj.bucketSelector),
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketPolicySpecProviderConfigRef
 */
export interface BucketPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPolicySpecProviderConfigRef#policy
   */
  readonly policy?: BucketPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecProviderConfigRef(obj: BucketPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketPolicySpecProviderRef
 */
export interface BucketPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPolicySpecProviderRef#policy
   */
  readonly policy?: BucketPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecProviderRef(obj: BucketPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsTo
 */
export interface BucketPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecPublishConnectionDetailsTo(obj: BucketPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketPolicySpecWriteConnectionSecretToRef
 */
export interface BucketPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecWriteConnectionSecretToRef(obj: BucketPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketPolicySpecForProviderBucketRef
 */
export interface BucketPolicySpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPolicySpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPolicySpecForProviderBucketRef#policy
   */
  readonly policy?: BucketPolicySpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderBucketRef(obj: BucketPolicySpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPolicySpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketPolicySpecForProviderBucketSelector
 */
export interface BucketPolicySpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketPolicySpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketPolicySpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketPolicySpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketPolicySpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderBucketSelector(obj: BucketPolicySpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketPolicySpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPolicySpecProviderConfigRefPolicy
 */
export interface BucketPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecProviderConfigRefPolicy(obj: BucketPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPolicySpecProviderRefPolicy
 */
export interface BucketPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecProviderRefPolicy(obj: BucketPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface BucketPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecPublishConnectionDetailsToConfigRef(obj: BucketPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsToMetadata
 */
export interface BucketPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecPublishConnectionDetailsToMetadata(obj: BucketPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPolicySpecForProviderBucketRefPolicy
 */
export interface BucketPolicySpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderBucketRefPolicy(obj: BucketPolicySpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketPolicySpecForProviderBucketSelectorPolicy
 */
export interface BucketPolicySpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecForProviderBucketSelectorPolicy(obj: BucketPolicySpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecProviderConfigRefPolicyResolution
 */
export enum BucketPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecProviderConfigRefPolicyResolve
 */
export enum BucketPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecProviderRefPolicyResolution
 */
export enum BucketPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecProviderRefPolicyResolve
 */
export enum BucketPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderBucketRefPolicyResolution
 */
export enum BucketPolicySpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderBucketRefPolicyResolve
 */
export enum BucketPolicySpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketPolicySpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketPolicySpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketPublicAccessBlock is the Schema for the BucketPublicAccessBlocks API. Manages S3 bucket-level Public Access Block Configuration
 *
 * @schema BucketPublicAccessBlock
 */
export class BucketPublicAccessBlock extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketPublicAccessBlock"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketPublicAccessBlock',
  }

  /**
   * Renders a Kubernetes manifest for "BucketPublicAccessBlock".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketPublicAccessBlockProps): any {
    return {
      ...BucketPublicAccessBlock.GVK,
      ...toJson_BucketPublicAccessBlockProps(props),
    };
  }

  /**
   * Defines a "BucketPublicAccessBlock" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketPublicAccessBlockProps) {
    super(scope, id, {
      ...BucketPublicAccessBlock.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketPublicAccessBlock.GVK,
      ...toJson_BucketPublicAccessBlockProps(resolved),
    };
  }
}

/**
 * BucketPublicAccessBlock is the Schema for the BucketPublicAccessBlocks API. Manages S3 bucket-level Public Access Block Configuration
 *
 * @schema BucketPublicAccessBlock
 */
export interface BucketPublicAccessBlockProps {
  /**
   * @schema BucketPublicAccessBlock#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketPublicAccessBlockSpec defines the desired state of BucketPublicAccessBlock
   *
   * @schema BucketPublicAccessBlock#spec
   */
  readonly spec: BucketPublicAccessBlockSpec;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockProps(obj: BucketPublicAccessBlockProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketPublicAccessBlockSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketPublicAccessBlockSpec defines the desired state of BucketPublicAccessBlock
 *
 * @schema BucketPublicAccessBlockSpec
 */
export interface BucketPublicAccessBlockSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketPublicAccessBlockSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketPublicAccessBlockSpecDeletionPolicy;

  /**
   * @schema BucketPublicAccessBlockSpec#forProvider
   */
  readonly forProvider: BucketPublicAccessBlockSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketPublicAccessBlockSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketPublicAccessBlockSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketPublicAccessBlockSpec#providerRef
   */
  readonly providerRef?: BucketPublicAccessBlockSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketPublicAccessBlockSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketPublicAccessBlockSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketPublicAccessBlockSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketPublicAccessBlockSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpec(obj: BucketPublicAccessBlockSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketPublicAccessBlockSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketPublicAccessBlockSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketPublicAccessBlockSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketPublicAccessBlockSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketPublicAccessBlockSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketPublicAccessBlockSpecDeletionPolicy
 */
export enum BucketPublicAccessBlockSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketPublicAccessBlockSpecForProvider
 */
export interface BucketPublicAccessBlockSpecForProvider {
  /**
   * Whether Amazon S3 should block public ACLs for this bucket. Defaults to false. Enabling this setting does not affect existing policies or ACLs. When set to true causes the following behavior:
   *
   * @default false. Enabling this setting does not affect existing policies or ACLs. When set to true causes the following behavior:
   * @schema BucketPublicAccessBlockSpecForProvider#blockPublicAcls
   */
  readonly blockPublicAcls?: boolean;

  /**
   * Whether Amazon S3 should block public bucket policies for this bucket. Defaults to false. Enabling this setting does not affect the existing bucket policy. When set to true causes Amazon S3 to:
   *
   * @default false. Enabling this setting does not affect the existing bucket policy. When set to true causes Amazon S3 to:
   * @schema BucketPublicAccessBlockSpecForProvider#blockPublicPolicy
   */
  readonly blockPublicPolicy?: boolean;

  /**
   * S3 Bucket to which this Public Access Block configuration should be applied.
   *
   * @schema BucketPublicAccessBlockSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketPublicAccessBlockSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketPublicAccessBlockSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketPublicAccessBlockSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketPublicAccessBlockSpecForProviderBucketSelector;

  /**
   * Whether Amazon S3 should ignore public ACLs for this bucket. Defaults to false. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to true causes Amazon S3 to:
   *
   * @default false. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to true causes Amazon S3 to:
   * @schema BucketPublicAccessBlockSpecForProvider#ignorePublicAcls
   */
  readonly ignorePublicAcls?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketPublicAccessBlockSpecForProvider#region
   */
  readonly region: string;

  /**
   * Whether Amazon S3 should restrict public bucket policies for this bucket. Defaults to false. Enabling this setting does not affect the previously stored bucket policy, except that public and cross-account access within the public bucket policy, including non-public delegation to specific accounts, is blocked. When set to true:
   *
   * @default false. Enabling this setting does not affect the previously stored bucket policy, except that public and cross-account access within the public bucket policy, including non-public delegation to specific accounts, is blocked. When set to true:
   * @schema BucketPublicAccessBlockSpecForProvider#restrictPublicBuckets
   */
  readonly restrictPublicBuckets?: boolean;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecForProvider(obj: BucketPublicAccessBlockSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockPublicAcls': obj.blockPublicAcls,
    'blockPublicPolicy': obj.blockPublicPolicy,
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketPublicAccessBlockSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketPublicAccessBlockSpecForProviderBucketSelector(obj.bucketSelector),
    'ignorePublicAcls': obj.ignorePublicAcls,
    'region': obj.region,
    'restrictPublicBuckets': obj.restrictPublicBuckets,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketPublicAccessBlockSpecProviderConfigRef
 */
export interface BucketPublicAccessBlockSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPublicAccessBlockSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPublicAccessBlockSpecProviderConfigRef#policy
   */
  readonly policy?: BucketPublicAccessBlockSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecProviderConfigRef(obj: BucketPublicAccessBlockSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPublicAccessBlockSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketPublicAccessBlockSpecProviderRef
 */
export interface BucketPublicAccessBlockSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPublicAccessBlockSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPublicAccessBlockSpecProviderRef#policy
   */
  readonly policy?: BucketPublicAccessBlockSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecProviderRef(obj: BucketPublicAccessBlockSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPublicAccessBlockSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsTo
 */
export interface BucketPublicAccessBlockSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketPublicAccessBlockSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecPublishConnectionDetailsTo(obj: BucketPublicAccessBlockSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketPublicAccessBlockSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketPublicAccessBlockSpecWriteConnectionSecretToRef
 */
export interface BucketPublicAccessBlockSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketPublicAccessBlockSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketPublicAccessBlockSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecWriteConnectionSecretToRef(obj: BucketPublicAccessBlockSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketPublicAccessBlockSpecForProviderBucketRef
 */
export interface BucketPublicAccessBlockSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPublicAccessBlockSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPublicAccessBlockSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketPublicAccessBlockSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecForProviderBucketRef(obj: BucketPublicAccessBlockSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPublicAccessBlockSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketPublicAccessBlockSpecForProviderBucketSelector
 */
export interface BucketPublicAccessBlockSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketPublicAccessBlockSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketPublicAccessBlockSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketPublicAccessBlockSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketPublicAccessBlockSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecForProviderBucketSelector(obj: BucketPublicAccessBlockSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketPublicAccessBlockSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPublicAccessBlockSpecProviderConfigRefPolicy
 */
export interface BucketPublicAccessBlockSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPublicAccessBlockSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketPublicAccessBlockSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPublicAccessBlockSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketPublicAccessBlockSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecProviderConfigRefPolicy(obj: BucketPublicAccessBlockSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPublicAccessBlockSpecProviderRefPolicy
 */
export interface BucketPublicAccessBlockSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPublicAccessBlockSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketPublicAccessBlockSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPublicAccessBlockSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketPublicAccessBlockSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecProviderRefPolicy(obj: BucketPublicAccessBlockSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRef(obj: BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToMetadata
 */
export interface BucketPublicAccessBlockSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecPublishConnectionDetailsToMetadata(obj: BucketPublicAccessBlockSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketPublicAccessBlockSpecForProviderBucketRefPolicy
 */
export interface BucketPublicAccessBlockSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPublicAccessBlockSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketPublicAccessBlockSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPublicAccessBlockSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketPublicAccessBlockSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecForProviderBucketRefPolicy(obj: BucketPublicAccessBlockSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketPublicAccessBlockSpecForProviderBucketSelectorPolicy
 */
export interface BucketPublicAccessBlockSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPublicAccessBlockSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketPublicAccessBlockSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPublicAccessBlockSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketPublicAccessBlockSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecForProviderBucketSelectorPolicy(obj: BucketPublicAccessBlockSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPublicAccessBlockSpecProviderConfigRefPolicyResolution
 */
export enum BucketPublicAccessBlockSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPublicAccessBlockSpecProviderConfigRefPolicyResolve
 */
export enum BucketPublicAccessBlockSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPublicAccessBlockSpecProviderRefPolicyResolution
 */
export enum BucketPublicAccessBlockSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPublicAccessBlockSpecProviderRefPolicyResolve
 */
export enum BucketPublicAccessBlockSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPublicAccessBlockSpecForProviderBucketRefPolicyResolution
 */
export enum BucketPublicAccessBlockSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPublicAccessBlockSpecForProviderBucketRefPolicyResolve
 */
export enum BucketPublicAccessBlockSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPublicAccessBlockSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketPublicAccessBlockSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPublicAccessBlockSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketPublicAccessBlockSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketReplicationConfiguration is the Schema for the BucketReplicationConfigurations API. Provides a S3 bucket replication configuration resource.
 *
 * @schema BucketReplicationConfiguration
 */
export class BucketReplicationConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketReplicationConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketReplicationConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "BucketReplicationConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketReplicationConfigurationProps): any {
    return {
      ...BucketReplicationConfiguration.GVK,
      ...toJson_BucketReplicationConfigurationProps(props),
    };
  }

  /**
   * Defines a "BucketReplicationConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketReplicationConfigurationProps) {
    super(scope, id, {
      ...BucketReplicationConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketReplicationConfiguration.GVK,
      ...toJson_BucketReplicationConfigurationProps(resolved),
    };
  }
}

/**
 * BucketReplicationConfiguration is the Schema for the BucketReplicationConfigurations API. Provides a S3 bucket replication configuration resource.
 *
 * @schema BucketReplicationConfiguration
 */
export interface BucketReplicationConfigurationProps {
  /**
   * @schema BucketReplicationConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketReplicationConfigurationSpec defines the desired state of BucketReplicationConfiguration
   *
   * @schema BucketReplicationConfiguration#spec
   */
  readonly spec: BucketReplicationConfigurationSpec;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationProps(obj: BucketReplicationConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketReplicationConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketReplicationConfigurationSpec defines the desired state of BucketReplicationConfiguration
 *
 * @schema BucketReplicationConfigurationSpec
 */
export interface BucketReplicationConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketReplicationConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketReplicationConfigurationSpecDeletionPolicy;

  /**
   * @schema BucketReplicationConfigurationSpec#forProvider
   */
  readonly forProvider: BucketReplicationConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketReplicationConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketReplicationConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketReplicationConfigurationSpec#providerRef
   */
  readonly providerRef?: BucketReplicationConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketReplicationConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketReplicationConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketReplicationConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketReplicationConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpec(obj: BucketReplicationConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketReplicationConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketReplicationConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketReplicationConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketReplicationConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketReplicationConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketReplicationConfigurationSpecDeletionPolicy
 */
export enum BucketReplicationConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketReplicationConfigurationSpecForProvider
 */
export interface BucketReplicationConfigurationSpecForProvider {
  /**
   * Name of the source S3 bucket you want Amazon S3 to monitor.
   *
   * @schema BucketReplicationConfigurationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketReplicationConfigurationSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketReplicationConfigurationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketReplicationConfigurationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketReplicationConfigurationSpecForProviderBucketSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketReplicationConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN of the IAM role for Amazon S3 to assume when replicating the objects.
   *
   * @schema BucketReplicationConfigurationSpecForProvider#role
   */
  readonly role?: string;

  /**
   * Reference to a Role in iam to populate role.
   *
   * @schema BucketReplicationConfigurationSpecForProvider#roleRef
   */
  readonly roleRef?: BucketReplicationConfigurationSpecForProviderRoleRef;

  /**
   * Selector for a Role in iam to populate role.
   *
   * @schema BucketReplicationConfigurationSpecForProvider#roleSelector
   */
  readonly roleSelector?: BucketReplicationConfigurationSpecForProviderRoleSelector;

  /**
   * List of configuration blocks describing the rules managing the replication. See below.
   *
   * @schema BucketReplicationConfigurationSpecForProvider#rule
   */
  readonly rule: BucketReplicationConfigurationSpecForProviderRule[];

  /**
   * Token to allow replication to be enabled on an Object Lock-enabled bucket. You must contact AWS support for the bucket's "Object Lock token". For more details, see Using S3 Object Lock with replication.
   *
   * @schema BucketReplicationConfigurationSpecForProvider#tokenSecretRef
   */
  readonly tokenSecretRef?: BucketReplicationConfigurationSpecForProviderTokenSecretRef;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProvider(obj: BucketReplicationConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketReplicationConfigurationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketReplicationConfigurationSpecForProviderBucketSelector(obj.bucketSelector),
    'region': obj.region,
    'role': obj.role,
    'roleRef': toJson_BucketReplicationConfigurationSpecForProviderRoleRef(obj.roleRef),
    'roleSelector': toJson_BucketReplicationConfigurationSpecForProviderRoleSelector(obj.roleSelector),
    'rule': obj.rule?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRule(y)),
    'tokenSecretRef': toJson_BucketReplicationConfigurationSpecForProviderTokenSecretRef(obj.tokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketReplicationConfigurationSpecProviderConfigRef
 */
export interface BucketReplicationConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketReplicationConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketReplicationConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: BucketReplicationConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecProviderConfigRef(obj: BucketReplicationConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketReplicationConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketReplicationConfigurationSpecProviderRef
 */
export interface BucketReplicationConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketReplicationConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketReplicationConfigurationSpecProviderRef#policy
   */
  readonly policy?: BucketReplicationConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecProviderRef(obj: BucketReplicationConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketReplicationConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsTo
 */
export interface BucketReplicationConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketReplicationConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecPublishConnectionDetailsTo(obj: BucketReplicationConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketReplicationConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketReplicationConfigurationSpecWriteConnectionSecretToRef
 */
export interface BucketReplicationConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketReplicationConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketReplicationConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecWriteConnectionSecretToRef(obj: BucketReplicationConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketReplicationConfigurationSpecForProviderBucketRef
 */
export interface BucketReplicationConfigurationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketReplicationConfigurationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketReplicationConfigurationSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketReplicationConfigurationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderBucketRef(obj: BucketReplicationConfigurationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketReplicationConfigurationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketReplicationConfigurationSpecForProviderBucketSelector
 */
export interface BucketReplicationConfigurationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketReplicationConfigurationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketReplicationConfigurationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketReplicationConfigurationSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketReplicationConfigurationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderBucketSelector(obj: BucketReplicationConfigurationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketReplicationConfigurationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate role.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRoleRef
 */
export interface BucketReplicationConfigurationSpecForProviderRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRoleRef#policy
   */
  readonly policy?: BucketReplicationConfigurationSpecForProviderRoleRefPolicy;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRoleRef(obj: BucketReplicationConfigurationSpecForProviderRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketReplicationConfigurationSpecForProviderRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate role.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRoleSelector
 */
export interface BucketReplicationConfigurationSpecForProviderRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRoleSelector#policy
   */
  readonly policy?: BucketReplicationConfigurationSpecForProviderRoleSelectorPolicy;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRoleSelector(obj: BucketReplicationConfigurationSpecForProviderRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketReplicationConfigurationSpecForProviderRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRule
 */
export interface BucketReplicationConfigurationSpecForProviderRule {
  /**
   * Whether delete markers are replicated. This argument is only valid with V2 replication configurations (i.e., when filter is used)documented below.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRule#deleteMarkerReplication
   */
  readonly deleteMarkerReplication?: BucketReplicationConfigurationSpecForProviderRuleDeleteMarkerReplication[];

  /**
   * Specifies the destination for the rule. See below.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRule#destination
   */
  readonly destination: BucketReplicationConfigurationSpecForProviderRuleDestination[];

  /**
   * Replicate existing objects in the source bucket according to the rule configurations. See below.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRule#existingObjectReplication
   */
  readonly existingObjectReplication?: BucketReplicationConfigurationSpecForProviderRuleExistingObjectReplication[];

  /**
   * Filter that identifies subset of objects to which the replication rule applies. See below. If not specified, the rule will default to using prefix.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRule#filter
   */
  readonly filter?: BucketReplicationConfigurationSpecForProviderRuleFilter[];

  /**
   * Unique identifier for the rule. Must be less than or equal to 255 characters in length.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRule#id
   */
  readonly id?: string;

  /**
   * Object key name prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length. Defaults to an empty string ("") if filter is not specified.
   *
   * @default an empty string ("") if filter is not specified.
   * @schema BucketReplicationConfigurationSpecForProviderRule#prefix
   */
  readonly prefix?: string;

  /**
   * Priority associated with the rule. Priority should only be set if filter is configured. If not provided, defaults to 0. Priority must be unique between multiple rules.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRule#priority
   */
  readonly priority?: number;

  /**
   * Specifies special object selection criteria. See below.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRule#sourceSelectionCriteria
   */
  readonly sourceSelectionCriteria?: BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteria[];

  /**
   * Status of the rule. Either "Enabled" or "Disabled". The rule is ignored if status is not "Enabled".
   *
   * @schema BucketReplicationConfigurationSpecForProviderRule#status
   */
  readonly status: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRule(obj: BucketReplicationConfigurationSpecForProviderRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deleteMarkerReplication': obj.deleteMarkerReplication?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleDeleteMarkerReplication(y)),
    'destination': obj.destination?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleDestination(y)),
    'existingObjectReplication': obj.existingObjectReplication?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleExistingObjectReplication(y)),
    'filter': obj.filter?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleFilter(y)),
    'id': obj.id,
    'prefix': obj.prefix,
    'priority': obj.priority,
    'sourceSelectionCriteria': obj.sourceSelectionCriteria?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteria(y)),
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Token to allow replication to be enabled on an Object Lock-enabled bucket. You must contact AWS support for the bucket's "Object Lock token". For more details, see Using S3 Object Lock with replication.
 *
 * @schema BucketReplicationConfigurationSpecForProviderTokenSecretRef
 */
export interface BucketReplicationConfigurationSpecForProviderTokenSecretRef {
  /**
   * The key to select.
   *
   * @schema BucketReplicationConfigurationSpecForProviderTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema BucketReplicationConfigurationSpecForProviderTokenSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketReplicationConfigurationSpecForProviderTokenSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderTokenSecretRef(obj: BucketReplicationConfigurationSpecForProviderTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketReplicationConfigurationSpecProviderConfigRefPolicy
 */
export interface BucketReplicationConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketReplicationConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketReplicationConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketReplicationConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketReplicationConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecProviderConfigRefPolicy(obj: BucketReplicationConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketReplicationConfigurationSpecProviderRefPolicy
 */
export interface BucketReplicationConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketReplicationConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketReplicationConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketReplicationConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketReplicationConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecProviderRefPolicy(obj: BucketReplicationConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRef(obj: BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface BucketReplicationConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecPublishConnectionDetailsToMetadata(obj: BucketReplicationConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketReplicationConfigurationSpecForProviderBucketRefPolicy
 */
export interface BucketReplicationConfigurationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketReplicationConfigurationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketReplicationConfigurationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketReplicationConfigurationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketReplicationConfigurationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderBucketRefPolicy(obj: BucketReplicationConfigurationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketReplicationConfigurationSpecForProviderBucketSelectorPolicy
 */
export interface BucketReplicationConfigurationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketReplicationConfigurationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketReplicationConfigurationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketReplicationConfigurationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketReplicationConfigurationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderBucketSelectorPolicy(obj: BucketReplicationConfigurationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRoleRefPolicy
 */
export interface BucketReplicationConfigurationSpecForProviderRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRoleRefPolicy#resolution
   */
  readonly resolution?: BucketReplicationConfigurationSpecForProviderRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRoleRefPolicy#resolve
   */
  readonly resolve?: BucketReplicationConfigurationSpecForProviderRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRoleRefPolicy(obj: BucketReplicationConfigurationSpecForProviderRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRoleSelectorPolicy
 */
export interface BucketReplicationConfigurationSpecForProviderRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRoleSelectorPolicy#resolution
   */
  readonly resolution?: BucketReplicationConfigurationSpecForProviderRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRoleSelectorPolicy#resolve
   */
  readonly resolve?: BucketReplicationConfigurationSpecForProviderRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRoleSelectorPolicy(obj: BucketReplicationConfigurationSpecForProviderRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleDeleteMarkerReplication
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDeleteMarkerReplication {
  /**
   * Whether delete markers should be replicated. Either "Enabled" or "Disabled".
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDeleteMarkerReplication#status
   */
  readonly status: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDeleteMarkerReplication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDeleteMarkerReplication(obj: BucketReplicationConfigurationSpecForProviderRuleDeleteMarkerReplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestination
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDestination {
  /**
   * Configuration block that specifies the overrides to use for object owners on replication. See below. Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object. Must be used in conjunction with account owner override configuration.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestination#accessControlTranslation
   */
  readonly accessControlTranslation?: BucketReplicationConfigurationSpecForProviderRuleDestinationAccessControlTranslation[];

  /**
   * Account ID to specify the replica ownership. Must be used in conjunction with access_control_translation override configuration.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestination#account
   */
  readonly account?: string;

  /**
   * ARN of the bucket where you want Amazon S3 to store the results.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestination#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestination#bucketRef
   */
  readonly bucketRef?: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestination#bucketSelector
   */
  readonly bucketSelector?: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelector;

  /**
   * Configuration block that provides information about encryption. See below. If source_selection_criteria is specified, you must specify this element.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestination#encryptionConfiguration
   */
  readonly encryptionConfiguration?: BucketReplicationConfigurationSpecForProviderRuleDestinationEncryptionConfiguration[];

  /**
   * Configuration block that specifies replication metrics-related settings enabling replication metrics and events. See below.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestination#metrics
   */
  readonly metrics?: BucketReplicationConfigurationSpecForProviderRuleDestinationMetrics[];

  /**
   * Configuration block that specifies S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. See below. Replication Time Control must be used in conjunction with metrics.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestination#replicationTime
   */
  readonly replicationTime?: BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTime[];

  /**
   * The storage class used to store the object. By default, Amazon S3 uses the storage class of the source object to create the object replica.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestination#storageClass
   */
  readonly storageClass?: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDestination(obj: BucketReplicationConfigurationSpecForProviderRuleDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControlTranslation': obj.accessControlTranslation?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationAccessControlTranslation(y)),
    'account': obj.account,
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelector(obj.bucketSelector),
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationEncryptionConfiguration(y)),
    'metrics': obj.metrics?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationMetrics(y)),
    'replicationTime': obj.replicationTime?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTime(y)),
    'storageClass': obj.storageClass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleExistingObjectReplication
 */
export interface BucketReplicationConfigurationSpecForProviderRuleExistingObjectReplication {
  /**
   * Whether the existing objects should be replicated. Either "Enabled" or "Disabled".
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleExistingObjectReplication#status
   */
  readonly status: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleExistingObjectReplication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleExistingObjectReplication(obj: BucketReplicationConfigurationSpecForProviderRuleExistingObjectReplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleFilter
 */
export interface BucketReplicationConfigurationSpecForProviderRuleFilter {
  /**
   * Configuration block for specifying rule filters. This element is required only if you specify more than one filter. See and below for more details.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleFilter#and
   */
  readonly and?: BucketReplicationConfigurationSpecForProviderRuleFilterAnd[];

  /**
   * Object key name prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length. Defaults to an empty string ("") if filter is not specified.
   *
   * @default an empty string ("") if filter is not specified.
   * @schema BucketReplicationConfigurationSpecForProviderRuleFilter#prefix
   */
  readonly prefix?: string;

  /**
   * Configuration block for specifying a tag key and value. See below.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleFilter#tag
   */
  readonly tag?: BucketReplicationConfigurationSpecForProviderRuleFilterTag[];

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleFilter(obj: BucketReplicationConfigurationSpecForProviderRuleFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'and': obj.and?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleFilterAnd(y)),
    'prefix': obj.prefix,
    'tag': obj.tag?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleFilterTag(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteria
 */
export interface BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteria {
  /**
   * Configuration block that you can specify for selections for modifications on replicas. Amazon S3 doesn't replicate replica modifications by default. In the latest version of replication configuration (when filter is specified), you can specify this element and set the status to Enabled to replicate modifications on replicas.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteria#replicaModifications
   */
  readonly replicaModifications?: BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaReplicaModifications[];

  /**
   * Configuration block for filter information for the selection of Amazon S3 objects encrypted with AWS KMS. If specified, replica_kms_key_id in destination encryption_configuration must be specified as well.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteria#sseKmsEncryptedObjects
   */
  readonly sseKmsEncryptedObjects?: BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaSseKmsEncryptedObjects[];

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteria' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteria(obj: BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteria | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicaModifications': obj.replicaModifications?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaReplicaModifications(y)),
    'sseKmsEncryptedObjects': obj.sseKmsEncryptedObjects?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaSseKmsEncryptedObjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketReplicationConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum BucketReplicationConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketReplicationConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum BucketReplicationConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketReplicationConfigurationSpecProviderRefPolicyResolution
 */
export enum BucketReplicationConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketReplicationConfigurationSpecProviderRefPolicyResolve
 */
export enum BucketReplicationConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketReplicationConfigurationSpecForProviderBucketRefPolicyResolution
 */
export enum BucketReplicationConfigurationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketReplicationConfigurationSpecForProviderBucketRefPolicyResolve
 */
export enum BucketReplicationConfigurationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketReplicationConfigurationSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketReplicationConfigurationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketReplicationConfigurationSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketReplicationConfigurationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRoleRefPolicyResolution
 */
export enum BucketReplicationConfigurationSpecForProviderRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRoleRefPolicyResolve
 */
export enum BucketReplicationConfigurationSpecForProviderRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRoleSelectorPolicyResolution
 */
export enum BucketReplicationConfigurationSpecForProviderRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRoleSelectorPolicyResolve
 */
export enum BucketReplicationConfigurationSpecForProviderRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationAccessControlTranslation
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDestinationAccessControlTranslation {
  /**
   * Specifies the replica ownership. For default and valid values, see PUT bucket replication in the Amazon S3 API Reference. Valid values: Destination.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationAccessControlTranslation#owner
   */
  readonly owner: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDestinationAccessControlTranslation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationAccessControlTranslation(obj: BucketReplicationConfigurationSpecForProviderRuleDestinationAccessControlTranslation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'owner': obj.owner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRef
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRef#policy
   */
  readonly policy?: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRef(obj: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelector
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelector#policy
   */
  readonly policy?: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelector(obj: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationEncryptionConfiguration
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDestinationEncryptionConfiguration {
  /**
   * ID (Key ARN or Alias ARN) of the customer managed AWS KMS key stored in AWS Key Management Service (KMS) for the destination bucket.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationEncryptionConfiguration#replicaKmsKeyId
   */
  readonly replicaKmsKeyId: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDestinationEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationEncryptionConfiguration(obj: BucketReplicationConfigurationSpecForProviderRuleDestinationEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicaKmsKeyId': obj.replicaKmsKeyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationMetrics
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDestinationMetrics {
  /**
   * Configuration block that specifies the time threshold for emitting the s3:Replication:OperationMissedThreshold event. See below.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationMetrics#eventThreshold
   */
  readonly eventThreshold?: BucketReplicationConfigurationSpecForProviderRuleDestinationMetricsEventThreshold[];

  /**
   * Whether the existing objects should be replicated. Either "Enabled" or "Disabled".
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationMetrics#status
   */
  readonly status: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDestinationMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationMetrics(obj: BucketReplicationConfigurationSpecForProviderRuleDestinationMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventThreshold': obj.eventThreshold?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationMetricsEventThreshold(y)),
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTime
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTime {
  /**
   * Whether the existing objects should be replicated. Either "Enabled" or "Disabled".
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTime#status
   */
  readonly status: string;

  /**
   * Configuration block specifying the time by which replication should be complete for all objects and operations on objects. See below.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTime#time
   */
  readonly time: BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTimeTime[];

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTime(obj: BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
    'time': obj.time?.map(y => toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTimeTime(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleFilterAnd
 */
export interface BucketReplicationConfigurationSpecForProviderRuleFilterAnd {
  /**
   * Object key name prefix identifying one or more objects to which the rule applies. Must be less than or equal to 1024 characters in length. Defaults to an empty string ("") if filter is not specified.
   *
   * @default an empty string ("") if filter is not specified.
   * @schema BucketReplicationConfigurationSpecForProviderRuleFilterAnd#prefix
   */
  readonly prefix?: string;

  /**
   * Map of tags (key and value pairs) that identifies a subset of objects to which the rule applies. The rule applies only to objects having all the tags in its tagset.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleFilterAnd#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleFilterAnd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleFilterAnd(obj: BucketReplicationConfigurationSpecForProviderRuleFilterAnd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleFilterTag
 */
export interface BucketReplicationConfigurationSpecForProviderRuleFilterTag {
  /**
   * Name of the object key.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleFilterTag#key
   */
  readonly key: string;

  /**
   * Value of the tag.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleFilterTag#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleFilterTag' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleFilterTag(obj: BucketReplicationConfigurationSpecForProviderRuleFilterTag | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaReplicaModifications
 */
export interface BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaReplicaModifications {
  /**
   * Whether the existing objects should be replicated. Either "Enabled" or "Disabled".
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaReplicaModifications#status
   */
  readonly status: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaReplicaModifications' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaReplicaModifications(obj: BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaReplicaModifications | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaSseKmsEncryptedObjects
 */
export interface BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaSseKmsEncryptedObjects {
  /**
   * Whether the existing objects should be replicated. Either "Enabled" or "Disabled".
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaSseKmsEncryptedObjects#status
   */
  readonly status: string;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaSseKmsEncryptedObjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaSseKmsEncryptedObjects(obj: BucketReplicationConfigurationSpecForProviderRuleSourceSelectionCriteriaSseKmsEncryptedObjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicy
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicy#resolution
   */
  readonly resolution?: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicy#resolve
   */
  readonly resolve?: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicy(obj: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicy
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicy(obj: BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationMetricsEventThreshold
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDestinationMetricsEventThreshold {
  /**
   * Time in minutes. Valid values: 15.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationMetricsEventThreshold#minutes
   */
  readonly minutes: number;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDestinationMetricsEventThreshold' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationMetricsEventThreshold(obj: BucketReplicationConfigurationSpecForProviderRuleDestinationMetricsEventThreshold | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minutes': obj.minutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTimeTime
 */
export interface BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTimeTime {
  /**
   * Time in minutes. Valid values: 15.
   *
   * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTimeTime#minutes
   */
  readonly minutes: number;

}

/**
 * Converts an object of type 'BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTimeTime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTimeTime(obj: BucketReplicationConfigurationSpecForProviderRuleDestinationReplicationTimeTime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minutes': obj.minutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicyResolution
 */
export enum BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicyResolve
 */
export enum BucketReplicationConfigurationSpecForProviderRuleDestinationBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicyResolution
 */
export enum BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicyResolve
 */
export enum BucketReplicationConfigurationSpecForProviderRuleDestinationBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketRequestPaymentConfiguration is the Schema for the BucketRequestPaymentConfigurations API. Provides an S3 bucket request payment configuration resource.
 *
 * @schema BucketRequestPaymentConfiguration
 */
export class BucketRequestPaymentConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketRequestPaymentConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketRequestPaymentConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "BucketRequestPaymentConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketRequestPaymentConfigurationProps): any {
    return {
      ...BucketRequestPaymentConfiguration.GVK,
      ...toJson_BucketRequestPaymentConfigurationProps(props),
    };
  }

  /**
   * Defines a "BucketRequestPaymentConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketRequestPaymentConfigurationProps) {
    super(scope, id, {
      ...BucketRequestPaymentConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketRequestPaymentConfiguration.GVK,
      ...toJson_BucketRequestPaymentConfigurationProps(resolved),
    };
  }
}

/**
 * BucketRequestPaymentConfiguration is the Schema for the BucketRequestPaymentConfigurations API. Provides an S3 bucket request payment configuration resource.
 *
 * @schema BucketRequestPaymentConfiguration
 */
export interface BucketRequestPaymentConfigurationProps {
  /**
   * @schema BucketRequestPaymentConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketRequestPaymentConfigurationSpec defines the desired state of BucketRequestPaymentConfiguration
   *
   * @schema BucketRequestPaymentConfiguration#spec
   */
  readonly spec: BucketRequestPaymentConfigurationSpec;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationProps(obj: BucketRequestPaymentConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketRequestPaymentConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketRequestPaymentConfigurationSpec defines the desired state of BucketRequestPaymentConfiguration
 *
 * @schema BucketRequestPaymentConfigurationSpec
 */
export interface BucketRequestPaymentConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketRequestPaymentConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketRequestPaymentConfigurationSpecDeletionPolicy;

  /**
   * @schema BucketRequestPaymentConfigurationSpec#forProvider
   */
  readonly forProvider: BucketRequestPaymentConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketRequestPaymentConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketRequestPaymentConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketRequestPaymentConfigurationSpec#providerRef
   */
  readonly providerRef?: BucketRequestPaymentConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketRequestPaymentConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketRequestPaymentConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketRequestPaymentConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketRequestPaymentConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpec(obj: BucketRequestPaymentConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketRequestPaymentConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketRequestPaymentConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketRequestPaymentConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketRequestPaymentConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketRequestPaymentConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketRequestPaymentConfigurationSpecDeletionPolicy
 */
export enum BucketRequestPaymentConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketRequestPaymentConfigurationSpecForProvider
 */
export interface BucketRequestPaymentConfigurationSpecForProvider {
  /**
   * Name of the bucket.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketRequestPaymentConfigurationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketRequestPaymentConfigurationSpecForProviderBucketSelector;

  /**
   * Account ID of the expected bucket owner.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Specifies who pays for the download and request fees. Valid values: BucketOwner, Requester.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProvider#payer
   */
  readonly payer: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecForProvider(obj: BucketRequestPaymentConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketRequestPaymentConfigurationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketRequestPaymentConfigurationSpecForProviderBucketSelector(obj.bucketSelector),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'payer': obj.payer,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketRequestPaymentConfigurationSpecProviderConfigRef
 */
export interface BucketRequestPaymentConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketRequestPaymentConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketRequestPaymentConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: BucketRequestPaymentConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecProviderConfigRef(obj: BucketRequestPaymentConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketRequestPaymentConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketRequestPaymentConfigurationSpecProviderRef
 */
export interface BucketRequestPaymentConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketRequestPaymentConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketRequestPaymentConfigurationSpecProviderRef#policy
   */
  readonly policy?: BucketRequestPaymentConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecProviderRef(obj: BucketRequestPaymentConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketRequestPaymentConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsTo
 */
export interface BucketRequestPaymentConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecPublishConnectionDetailsTo(obj: BucketRequestPaymentConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketRequestPaymentConfigurationSpecWriteConnectionSecretToRef
 */
export interface BucketRequestPaymentConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketRequestPaymentConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketRequestPaymentConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecWriteConnectionSecretToRef(obj: BucketRequestPaymentConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketRequestPaymentConfigurationSpecForProviderBucketRef
 */
export interface BucketRequestPaymentConfigurationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecForProviderBucketRef(obj: BucketRequestPaymentConfigurationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketRequestPaymentConfigurationSpecForProviderBucketSelector
 */
export interface BucketRequestPaymentConfigurationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecForProviderBucketSelector(obj: BucketRequestPaymentConfigurationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketRequestPaymentConfigurationSpecProviderConfigRefPolicy
 */
export interface BucketRequestPaymentConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketRequestPaymentConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketRequestPaymentConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketRequestPaymentConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketRequestPaymentConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecProviderConfigRefPolicy(obj: BucketRequestPaymentConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketRequestPaymentConfigurationSpecProviderRefPolicy
 */
export interface BucketRequestPaymentConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketRequestPaymentConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketRequestPaymentConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketRequestPaymentConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketRequestPaymentConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecProviderRefPolicy(obj: BucketRequestPaymentConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRef(obj: BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToMetadata(obj: BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicy
 */
export interface BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicy(obj: BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicy
 */
export interface BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicy(obj: BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketRequestPaymentConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum BucketRequestPaymentConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketRequestPaymentConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum BucketRequestPaymentConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketRequestPaymentConfigurationSpecProviderRefPolicyResolution
 */
export enum BucketRequestPaymentConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketRequestPaymentConfigurationSpecProviderRefPolicyResolve
 */
export enum BucketRequestPaymentConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicyResolution
 */
export enum BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicyResolve
 */
export enum BucketRequestPaymentConfigurationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketRequestPaymentConfigurationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketRequestPaymentConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketServerSideEncryptionConfiguration is the Schema for the BucketServerSideEncryptionConfigurations API. Provides a S3 bucket server-side encryption configuration resource.
 *
 * @schema BucketServerSideEncryptionConfiguration
 */
export class BucketServerSideEncryptionConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketServerSideEncryptionConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketServerSideEncryptionConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "BucketServerSideEncryptionConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketServerSideEncryptionConfigurationProps): any {
    return {
      ...BucketServerSideEncryptionConfiguration.GVK,
      ...toJson_BucketServerSideEncryptionConfigurationProps(props),
    };
  }

  /**
   * Defines a "BucketServerSideEncryptionConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketServerSideEncryptionConfigurationProps) {
    super(scope, id, {
      ...BucketServerSideEncryptionConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketServerSideEncryptionConfiguration.GVK,
      ...toJson_BucketServerSideEncryptionConfigurationProps(resolved),
    };
  }
}

/**
 * BucketServerSideEncryptionConfiguration is the Schema for the BucketServerSideEncryptionConfigurations API. Provides a S3 bucket server-side encryption configuration resource.
 *
 * @schema BucketServerSideEncryptionConfiguration
 */
export interface BucketServerSideEncryptionConfigurationProps {
  /**
   * @schema BucketServerSideEncryptionConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketServerSideEncryptionConfigurationSpec defines the desired state of BucketServerSideEncryptionConfiguration
   *
   * @schema BucketServerSideEncryptionConfiguration#spec
   */
  readonly spec: BucketServerSideEncryptionConfigurationSpec;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationProps(obj: BucketServerSideEncryptionConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketServerSideEncryptionConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketServerSideEncryptionConfigurationSpec defines the desired state of BucketServerSideEncryptionConfiguration
 *
 * @schema BucketServerSideEncryptionConfigurationSpec
 */
export interface BucketServerSideEncryptionConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketServerSideEncryptionConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketServerSideEncryptionConfigurationSpecDeletionPolicy;

  /**
   * @schema BucketServerSideEncryptionConfigurationSpec#forProvider
   */
  readonly forProvider: BucketServerSideEncryptionConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketServerSideEncryptionConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketServerSideEncryptionConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketServerSideEncryptionConfigurationSpec#providerRef
   */
  readonly providerRef?: BucketServerSideEncryptionConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketServerSideEncryptionConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketServerSideEncryptionConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketServerSideEncryptionConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpec(obj: BucketServerSideEncryptionConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketServerSideEncryptionConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketServerSideEncryptionConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketServerSideEncryptionConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketServerSideEncryptionConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecDeletionPolicy
 */
export enum BucketServerSideEncryptionConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketServerSideEncryptionConfigurationSpecForProvider
 */
export interface BucketServerSideEncryptionConfigurationSpecForProvider {
  /**
   * ID (name) of the bucket.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketServerSideEncryptionConfigurationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketServerSideEncryptionConfigurationSpecForProviderBucketSelector;

  /**
   * Account ID of the expected bucket owner.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Set of server-side encryption configuration rules. See below. Currently, only a single rule is supported.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProvider#rule
   */
  readonly rule: BucketServerSideEncryptionConfigurationSpecForProviderRule[];

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecForProvider(obj: BucketServerSideEncryptionConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketServerSideEncryptionConfigurationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketServerSideEncryptionConfigurationSpecForProviderBucketSelector(obj.bucketSelector),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'region': obj.region,
    'rule': obj.rule?.map(y => toJson_BucketServerSideEncryptionConfigurationSpecForProviderRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecProviderConfigRef
 */
export interface BucketServerSideEncryptionConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecProviderConfigRef(obj: BucketServerSideEncryptionConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketServerSideEncryptionConfigurationSpecProviderRef
 */
export interface BucketServerSideEncryptionConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecProviderRef#policy
   */
  readonly policy?: BucketServerSideEncryptionConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecProviderRef(obj: BucketServerSideEncryptionConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketServerSideEncryptionConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsTo
 */
export interface BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsTo(obj: BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecWriteConnectionSecretToRef
 */
export interface BucketServerSideEncryptionConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecWriteConnectionSecretToRef(obj: BucketServerSideEncryptionConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketRef
 */
export interface BucketServerSideEncryptionConfigurationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecForProviderBucketRef(obj: BucketServerSideEncryptionConfigurationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketSelector
 */
export interface BucketServerSideEncryptionConfigurationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecForProviderBucketSelector(obj: BucketServerSideEncryptionConfigurationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderRule
 */
export interface BucketServerSideEncryptionConfigurationSpecForProviderRule {
  /**
   * Single object for setting server-side encryption by default. See below.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRule#applyServerSideEncryptionByDefault
   */
  readonly applyServerSideEncryptionByDefault?: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefault[];

  /**
   * Whether or not to use Amazon S3 Bucket Keys for SSE-KMS.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRule#bucketKeyEnabled
   */
  readonly bucketKeyEnabled?: boolean;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecForProviderRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecForProviderRule(obj: BucketServerSideEncryptionConfigurationSpecForProviderRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyServerSideEncryptionByDefault': obj.applyServerSideEncryptionByDefault?.map(y => toJson_BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefault(y)),
    'bucketKeyEnabled': obj.bucketKeyEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicy
 */
export interface BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicy(obj: BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecProviderRefPolicy
 */
export interface BucketServerSideEncryptionConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketServerSideEncryptionConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketServerSideEncryptionConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecProviderRefPolicy(obj: BucketServerSideEncryptionConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRef(obj: BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToMetadata(obj: BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicy
 */
export interface BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicy(obj: BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicy
 */
export interface BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicy(obj: BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefault
 */
export interface BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefault {
  /**
   * AWS KMS master key ID used for the SSE-KMS encryption. This can only be used when you set the value of sse_algorithm as aws:kms. The default aws/s3 AWS KMS master key is used if this element is absent while the sse_algorithm is aws:kms.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefault#kmsMasterKeyId
   */
  readonly kmsMasterKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsMasterKeyId.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefault#kmsMasterKeyIdRef
   */
  readonly kmsMasterKeyIdRef?: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsMasterKeyId.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefault#kmsMasterKeyIdSelector
   */
  readonly kmsMasterKeyIdSelector?: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector;

  /**
   * Server-side encryption algorithm to use. Valid values are AES256 and aws:kms
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefault#sseAlgorithm
   */
  readonly sseAlgorithm: string;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefault(obj: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsMasterKeyId': obj.kmsMasterKeyId,
    'kmsMasterKeyIdRef': toJson_BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef(obj.kmsMasterKeyIdRef),
    'kmsMasterKeyIdSelector': toJson_BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector(obj.kmsMasterKeyIdSelector),
    'sseAlgorithm': obj.sseAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum BucketServerSideEncryptionConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecProviderRefPolicyResolution
 */
export enum BucketServerSideEncryptionConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecProviderRefPolicyResolve
 */
export enum BucketServerSideEncryptionConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicyResolution
 */
export enum BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicyResolve
 */
export enum BucketServerSideEncryptionConfigurationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketServerSideEncryptionConfigurationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Key in kms to populate kmsMasterKeyId.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef
 */
export interface BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef#policy
   */
  readonly policy?: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef(obj: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsMasterKeyId.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector
 */
export interface BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector#policy
   */
  readonly policy?: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector(obj: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketServerSideEncryptionConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy
 */
export interface BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy#resolution
   */
  readonly resolution?: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy#resolve
   */
  readonly resolve?: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy(obj: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy
 */
export interface BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy(obj: BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolution
 */
export enum BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolve
 */
export enum BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolution
 */
export enum BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolve
 */
export enum BucketServerSideEncryptionConfigurationSpecForProviderRuleApplyServerSideEncryptionByDefaultKmsMasterKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketVersioning is the Schema for the BucketVersionings API. Provides an S3 bucket versioning resource.
 *
 * @schema BucketVersioning
 */
export class BucketVersioning extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketVersioning"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketVersioning',
  }

  /**
   * Renders a Kubernetes manifest for "BucketVersioning".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketVersioningProps): any {
    return {
      ...BucketVersioning.GVK,
      ...toJson_BucketVersioningProps(props),
    };
  }

  /**
   * Defines a "BucketVersioning" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketVersioningProps) {
    super(scope, id, {
      ...BucketVersioning.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketVersioning.GVK,
      ...toJson_BucketVersioningProps(resolved),
    };
  }
}

/**
 * BucketVersioning is the Schema for the BucketVersionings API. Provides an S3 bucket versioning resource.
 *
 * @schema BucketVersioning
 */
export interface BucketVersioningProps {
  /**
   * @schema BucketVersioning#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketVersioningSpec defines the desired state of BucketVersioning
   *
   * @schema BucketVersioning#spec
   */
  readonly spec: BucketVersioningSpec;

}

/**
 * Converts an object of type 'BucketVersioningProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningProps(obj: BucketVersioningProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketVersioningSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketVersioningSpec defines the desired state of BucketVersioning
 *
 * @schema BucketVersioningSpec
 */
export interface BucketVersioningSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketVersioningSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketVersioningSpecDeletionPolicy;

  /**
   * @schema BucketVersioningSpec#forProvider
   */
  readonly forProvider: BucketVersioningSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketVersioningSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketVersioningSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketVersioningSpec#providerRef
   */
  readonly providerRef?: BucketVersioningSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketVersioningSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketVersioningSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketVersioningSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketVersioningSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketVersioningSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpec(obj: BucketVersioningSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketVersioningSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketVersioningSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketVersioningSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketVersioningSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketVersioningSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketVersioningSpecDeletionPolicy
 */
export enum BucketVersioningSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketVersioningSpecForProvider
 */
export interface BucketVersioningSpecForProvider {
  /**
   * Name of the S3 bucket.
   *
   * @schema BucketVersioningSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketVersioningSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketVersioningSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketVersioningSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketVersioningSpecForProviderBucketSelector;

  /**
   * Account ID of the expected bucket owner.
   *
   * @schema BucketVersioningSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Concatenation of the authentication device's serial number, a space, and the value that is displayed on your authentication device.
   *
   * @schema BucketVersioningSpecForProvider#mfa
   */
  readonly mfa?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketVersioningSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block for the versioning parameters. See below.
   *
   * @schema BucketVersioningSpecForProvider#versioningConfiguration
   */
  readonly versioningConfiguration: BucketVersioningSpecForProviderVersioningConfiguration[];

}

/**
 * Converts an object of type 'BucketVersioningSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecForProvider(obj: BucketVersioningSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketVersioningSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketVersioningSpecForProviderBucketSelector(obj.bucketSelector),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'mfa': obj.mfa,
    'region': obj.region,
    'versioningConfiguration': obj.versioningConfiguration?.map(y => toJson_BucketVersioningSpecForProviderVersioningConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketVersioningSpecProviderConfigRef
 */
export interface BucketVersioningSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketVersioningSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketVersioningSpecProviderConfigRef#policy
   */
  readonly policy?: BucketVersioningSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketVersioningSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecProviderConfigRef(obj: BucketVersioningSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketVersioningSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketVersioningSpecProviderRef
 */
export interface BucketVersioningSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketVersioningSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketVersioningSpecProviderRef#policy
   */
  readonly policy?: BucketVersioningSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketVersioningSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecProviderRef(obj: BucketVersioningSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketVersioningSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketVersioningSpecPublishConnectionDetailsTo
 */
export interface BucketVersioningSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketVersioningSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketVersioningSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketVersioningSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketVersioningSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketVersioningSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketVersioningSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecPublishConnectionDetailsTo(obj: BucketVersioningSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketVersioningSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketVersioningSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketVersioningSpecWriteConnectionSecretToRef
 */
export interface BucketVersioningSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketVersioningSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketVersioningSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketVersioningSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecWriteConnectionSecretToRef(obj: BucketVersioningSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketVersioningSpecForProviderBucketRef
 */
export interface BucketVersioningSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketVersioningSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketVersioningSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketVersioningSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketVersioningSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecForProviderBucketRef(obj: BucketVersioningSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketVersioningSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketVersioningSpecForProviderBucketSelector
 */
export interface BucketVersioningSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketVersioningSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketVersioningSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketVersioningSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketVersioningSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketVersioningSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecForProviderBucketSelector(obj: BucketVersioningSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketVersioningSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketVersioningSpecForProviderVersioningConfiguration
 */
export interface BucketVersioningSpecForProviderVersioningConfiguration {
  /**
   * Specifies whether MFA delete is enabled in the bucket versioning configuration. Valid values: Enabled or Disabled.
   *
   * @schema BucketVersioningSpecForProviderVersioningConfiguration#mfaDelete
   */
  readonly mfaDelete?: string;

  /**
   * Versioning state of the bucket. Valid values: Enabled, Suspended, or Disabled. Disabled should only be used when creating or importing resources that correspond to unversioned S3 buckets.
   *
   * @schema BucketVersioningSpecForProviderVersioningConfiguration#status
   */
  readonly status: string;

}

/**
 * Converts an object of type 'BucketVersioningSpecForProviderVersioningConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecForProviderVersioningConfiguration(obj: BucketVersioningSpecForProviderVersioningConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mfaDelete': obj.mfaDelete,
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketVersioningSpecProviderConfigRefPolicy
 */
export interface BucketVersioningSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketVersioningSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketVersioningSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketVersioningSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketVersioningSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketVersioningSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecProviderConfigRefPolicy(obj: BucketVersioningSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketVersioningSpecProviderRefPolicy
 */
export interface BucketVersioningSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketVersioningSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketVersioningSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketVersioningSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketVersioningSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketVersioningSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecProviderRefPolicy(obj: BucketVersioningSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketVersioningSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketVersioningSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketVersioningSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketVersioningSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketVersioningSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecPublishConnectionDetailsToConfigRef(obj: BucketVersioningSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketVersioningSpecPublishConnectionDetailsToMetadata
 */
export interface BucketVersioningSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketVersioningSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketVersioningSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketVersioningSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketVersioningSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecPublishConnectionDetailsToMetadata(obj: BucketVersioningSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketVersioningSpecForProviderBucketRefPolicy
 */
export interface BucketVersioningSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketVersioningSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketVersioningSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketVersioningSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketVersioningSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketVersioningSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecForProviderBucketRefPolicy(obj: BucketVersioningSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketVersioningSpecForProviderBucketSelectorPolicy
 */
export interface BucketVersioningSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketVersioningSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketVersioningSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketVersioningSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketVersioningSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketVersioningSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecForProviderBucketSelectorPolicy(obj: BucketVersioningSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketVersioningSpecProviderConfigRefPolicyResolution
 */
export enum BucketVersioningSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketVersioningSpecProviderConfigRefPolicyResolve
 */
export enum BucketVersioningSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketVersioningSpecProviderRefPolicyResolution
 */
export enum BucketVersioningSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketVersioningSpecProviderRefPolicyResolve
 */
export enum BucketVersioningSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketVersioningSpecForProviderBucketRefPolicyResolution
 */
export enum BucketVersioningSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketVersioningSpecForProviderBucketRefPolicyResolve
 */
export enum BucketVersioningSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketVersioningSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketVersioningSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketVersioningSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketVersioningSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketVersioningSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * BucketWebsiteConfiguration is the Schema for the BucketWebsiteConfigurations API. Provides an S3 bucket website configuration resource.
 *
 * @schema BucketWebsiteConfiguration
 */
export class BucketWebsiteConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketWebsiteConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'BucketWebsiteConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "BucketWebsiteConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketWebsiteConfigurationProps): any {
    return {
      ...BucketWebsiteConfiguration.GVK,
      ...toJson_BucketWebsiteConfigurationProps(props),
    };
  }

  /**
   * Defines a "BucketWebsiteConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketWebsiteConfigurationProps) {
    super(scope, id, {
      ...BucketWebsiteConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketWebsiteConfiguration.GVK,
      ...toJson_BucketWebsiteConfigurationProps(resolved),
    };
  }
}

/**
 * BucketWebsiteConfiguration is the Schema for the BucketWebsiteConfigurations API. Provides an S3 bucket website configuration resource.
 *
 * @schema BucketWebsiteConfiguration
 */
export interface BucketWebsiteConfigurationProps {
  /**
   * @schema BucketWebsiteConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketWebsiteConfigurationSpec defines the desired state of BucketWebsiteConfiguration
   *
   * @schema BucketWebsiteConfiguration#spec
   */
  readonly spec: BucketWebsiteConfigurationSpec;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationProps(obj: BucketWebsiteConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketWebsiteConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketWebsiteConfigurationSpec defines the desired state of BucketWebsiteConfiguration
 *
 * @schema BucketWebsiteConfigurationSpec
 */
export interface BucketWebsiteConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema BucketWebsiteConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BucketWebsiteConfigurationSpecDeletionPolicy;

  /**
   * @schema BucketWebsiteConfigurationSpec#forProvider
   */
  readonly forProvider: BucketWebsiteConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BucketWebsiteConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BucketWebsiteConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BucketWebsiteConfigurationSpec#providerRef
   */
  readonly providerRef?: BucketWebsiteConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BucketWebsiteConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BucketWebsiteConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BucketWebsiteConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BucketWebsiteConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpec(obj: BucketWebsiteConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BucketWebsiteConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_BucketWebsiteConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BucketWebsiteConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BucketWebsiteConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BucketWebsiteConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema BucketWebsiteConfigurationSpecDeletionPolicy
 */
export enum BucketWebsiteConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BucketWebsiteConfigurationSpecForProvider
 */
export interface BucketWebsiteConfigurationSpecForProvider {
  /**
   * Name of the bucket.
   *
   * @schema BucketWebsiteConfigurationSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema BucketWebsiteConfigurationSpecForProvider#bucketRef
   */
  readonly bucketRef?: BucketWebsiteConfigurationSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema BucketWebsiteConfigurationSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: BucketWebsiteConfigurationSpecForProviderBucketSelector;

  /**
   * Name of the error document for the website. See below.
   *
   * @schema BucketWebsiteConfigurationSpecForProvider#errorDocument
   */
  readonly errorDocument?: BucketWebsiteConfigurationSpecForProviderErrorDocument[];

  /**
   * Account ID of the expected bucket owner.
   *
   * @schema BucketWebsiteConfigurationSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Name of the index document for the website. See below.
   *
   * @schema BucketWebsiteConfigurationSpecForProvider#indexDocument
   */
  readonly indexDocument?: BucketWebsiteConfigurationSpecForProviderIndexDocument[];

  /**
   * Redirect behavior for every request to this bucket's website endpoint. See below. Conflicts with error_document, index_document, and routing_rule.
   *
   * @schema BucketWebsiteConfigurationSpecForProvider#redirectAllRequestsTo
   */
  readonly redirectAllRequestsTo?: BucketWebsiteConfigurationSpecForProviderRedirectAllRequestsTo[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BucketWebsiteConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * List of rules that define when a redirect is applied and the redirect behavior. See below.
   *
   * @schema BucketWebsiteConfigurationSpecForProvider#routingRule
   */
  readonly routingRule?: BucketWebsiteConfigurationSpecForProviderRoutingRule[];

  /**
   * JSON array containing routing rules describing redirect behavior and when redirects are applied. Use this parameter when your routing rules contain empty String values ("") as seen in the example above.
   *
   * @schema BucketWebsiteConfigurationSpecForProvider#routingRules
   */
  readonly routingRules?: string;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecForProvider(obj: BucketWebsiteConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_BucketWebsiteConfigurationSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_BucketWebsiteConfigurationSpecForProviderBucketSelector(obj.bucketSelector),
    'errorDocument': obj.errorDocument?.map(y => toJson_BucketWebsiteConfigurationSpecForProviderErrorDocument(y)),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'indexDocument': obj.indexDocument?.map(y => toJson_BucketWebsiteConfigurationSpecForProviderIndexDocument(y)),
    'redirectAllRequestsTo': obj.redirectAllRequestsTo?.map(y => toJson_BucketWebsiteConfigurationSpecForProviderRedirectAllRequestsTo(y)),
    'region': obj.region,
    'routingRule': obj.routingRule?.map(y => toJson_BucketWebsiteConfigurationSpecForProviderRoutingRule(y)),
    'routingRules': obj.routingRules,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BucketWebsiteConfigurationSpecProviderConfigRef
 */
export interface BucketWebsiteConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketWebsiteConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketWebsiteConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: BucketWebsiteConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecProviderConfigRef(obj: BucketWebsiteConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketWebsiteConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BucketWebsiteConfigurationSpecProviderRef
 */
export interface BucketWebsiteConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketWebsiteConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketWebsiteConfigurationSpecProviderRef#policy
   */
  readonly policy?: BucketWebsiteConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecProviderRef(obj: BucketWebsiteConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketWebsiteConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsTo
 */
export interface BucketWebsiteConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BucketWebsiteConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecPublishConnectionDetailsTo(obj: BucketWebsiteConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BucketWebsiteConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BucketWebsiteConfigurationSpecWriteConnectionSecretToRef
 */
export interface BucketWebsiteConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BucketWebsiteConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BucketWebsiteConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecWriteConnectionSecretToRef(obj: BucketWebsiteConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema BucketWebsiteConfigurationSpecForProviderBucketRef
 */
export interface BucketWebsiteConfigurationSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderBucketRef#policy
   */
  readonly policy?: BucketWebsiteConfigurationSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecForProviderBucketRef(obj: BucketWebsiteConfigurationSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketWebsiteConfigurationSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema BucketWebsiteConfigurationSpecForProviderBucketSelector
 */
export interface BucketWebsiteConfigurationSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderBucketSelector#policy
   */
  readonly policy?: BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecForProviderBucketSelector(obj: BucketWebsiteConfigurationSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketWebsiteConfigurationSpecForProviderErrorDocument
 */
export interface BucketWebsiteConfigurationSpecForProviderErrorDocument {
  /**
   * Object key name to use when a 4XX class error occurs.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderErrorDocument#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecForProviderErrorDocument' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecForProviderErrorDocument(obj: BucketWebsiteConfigurationSpecForProviderErrorDocument | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketWebsiteConfigurationSpecForProviderIndexDocument
 */
export interface BucketWebsiteConfigurationSpecForProviderIndexDocument {
  /**
   * Suffix that is appended to a request that is for a directory on the website endpoint. For example, if the suffix is index.html and you make a request to samplebucket/images/, the data that is returned will be for the object with the key name images/index.html. The suffix must not be empty and must not include a slash character.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderIndexDocument#suffix
   */
  readonly suffix: string;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecForProviderIndexDocument' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecForProviderIndexDocument(obj: BucketWebsiteConfigurationSpecForProviderIndexDocument | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketWebsiteConfigurationSpecForProviderRedirectAllRequestsTo
 */
export interface BucketWebsiteConfigurationSpecForProviderRedirectAllRequestsTo {
  /**
   * Name of the host where requests are redirected.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderRedirectAllRequestsTo#hostName
   */
  readonly hostName: string;

  /**
   * Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: http, https.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderRedirectAllRequestsTo#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecForProviderRedirectAllRequestsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecForProviderRedirectAllRequestsTo(obj: BucketWebsiteConfigurationSpecForProviderRedirectAllRequestsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostName': obj.hostName,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketWebsiteConfigurationSpecForProviderRoutingRule
 */
export interface BucketWebsiteConfigurationSpecForProviderRoutingRule {
  /**
   * Configuration block for describing a condition that must be met for the specified redirect to apply. See below.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderRoutingRule#condition
   */
  readonly condition?: BucketWebsiteConfigurationSpecForProviderRoutingRuleCondition[];

  /**
   * Configuration block for redirect information. See below.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderRoutingRule#redirect
   */
  readonly redirect: BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect[];

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecForProviderRoutingRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecForProviderRoutingRule(obj: BucketWebsiteConfigurationSpecForProviderRoutingRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_BucketWebsiteConfigurationSpecForProviderRoutingRuleCondition(y)),
    'redirect': obj.redirect?.map(y => toJson_BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketWebsiteConfigurationSpecProviderConfigRefPolicy
 */
export interface BucketWebsiteConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketWebsiteConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BucketWebsiteConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketWebsiteConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BucketWebsiteConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecProviderConfigRefPolicy(obj: BucketWebsiteConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketWebsiteConfigurationSpecProviderRefPolicy
 */
export interface BucketWebsiteConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketWebsiteConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BucketWebsiteConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketWebsiteConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BucketWebsiteConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecProviderRefPolicy(obj: BucketWebsiteConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRef(obj: BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface BucketWebsiteConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecPublishConnectionDetailsToMetadata(obj: BucketWebsiteConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BucketWebsiteConfigurationSpecForProviderBucketRefPolicy
 */
export interface BucketWebsiteConfigurationSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: BucketWebsiteConfigurationSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: BucketWebsiteConfigurationSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecForProviderBucketRefPolicy(obj: BucketWebsiteConfigurationSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicy
 */
export interface BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicy(obj: BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketWebsiteConfigurationSpecForProviderRoutingRuleCondition
 */
export interface BucketWebsiteConfigurationSpecForProviderRoutingRuleCondition {
  /**
   * HTTP error code when the redirect is applied. If specified with key_prefix_equals, then both must be true for the redirect to be applied.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderRoutingRuleCondition#httpErrorCodeReturnedEquals
   */
  readonly httpErrorCodeReturnedEquals?: string;

  /**
   * Object key name prefix when the redirect is applied. If specified with http_error_code_returned_equals, then both must be true for the redirect to be applied.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderRoutingRuleCondition#keyPrefixEquals
   */
  readonly keyPrefixEquals?: string;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecForProviderRoutingRuleCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecForProviderRoutingRuleCondition(obj: BucketWebsiteConfigurationSpecForProviderRoutingRuleCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpErrorCodeReturnedEquals': obj.httpErrorCodeReturnedEquals,
    'keyPrefixEquals': obj.keyPrefixEquals,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect
 */
export interface BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect {
  /**
   * Name of the host where requests are redirected.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect#hostName
   */
  readonly hostName?: string;

  /**
   * HTTP redirect code to use on the response.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect#httpRedirectCode
   */
  readonly httpRedirectCode?: string;

  /**
   * Protocol to use when redirecting requests. The default is the protocol that is used in the original request. Valid values: http, https.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect#protocol
   */
  readonly protocol?: string;

  /**
   * Object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix docs/ (objects in the docs/ folder) to documents/, you can set a condition block with key_prefix_equals set to docs/ and in the redirect set replace_key_prefix_with to /documents.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect#replaceKeyPrefixWith
   */
  readonly replaceKeyPrefixWith?: string;

  /**
   * Specific object key to use in the redirect request. For example, redirect request to error.html.
   *
   * @schema BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect#replaceKeyWith
   */
  readonly replaceKeyWith?: string;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect(obj: BucketWebsiteConfigurationSpecForProviderRoutingRuleRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostName': obj.hostName,
    'httpRedirectCode': obj.httpRedirectCode,
    'protocol': obj.protocol,
    'replaceKeyPrefixWith': obj.replaceKeyPrefixWith,
    'replaceKeyWith': obj.replaceKeyWith,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketWebsiteConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum BucketWebsiteConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketWebsiteConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum BucketWebsiteConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketWebsiteConfigurationSpecProviderRefPolicyResolution
 */
export enum BucketWebsiteConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketWebsiteConfigurationSpecProviderRefPolicyResolve
 */
export enum BucketWebsiteConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketWebsiteConfigurationSpecForProviderBucketRefPolicyResolution
 */
export enum BucketWebsiteConfigurationSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketWebsiteConfigurationSpecForProviderBucketRefPolicyResolve
 */
export enum BucketWebsiteConfigurationSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicyResolution
 */
export enum BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicyResolve
 */
export enum BucketWebsiteConfigurationSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BucketWebsiteConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Object is the Schema for the Objects API. Provides an S3 object resource.
 *
 * @schema Object
 */
export class Object extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Object"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'Object',
  }

  /**
   * Renders a Kubernetes manifest for "Object".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ObjectProps): any {
    return {
      ...Object.GVK,
      ...toJson_ObjectProps(props),
    };
  }

  /**
   * Defines a "Object" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ObjectProps) {
    super(scope, id, {
      ...Object.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Object.GVK,
      ...toJson_ObjectProps(resolved),
    };
  }
}

/**
 * Object is the Schema for the Objects API. Provides an S3 object resource.
 *
 * @schema Object
 */
export interface ObjectProps {
  /**
   * @schema Object#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ObjectSpec defines the desired state of Object
   *
   * @schema Object#spec
   */
  readonly spec: ObjectSpec;

}

/**
 * Converts an object of type 'ObjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectProps(obj: ObjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ObjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectSpec defines the desired state of Object
 *
 * @schema ObjectSpec
 */
export interface ObjectSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ObjectSpec#deletionPolicy
   */
  readonly deletionPolicy?: ObjectSpecDeletionPolicy;

  /**
   * @schema ObjectSpec#forProvider
   */
  readonly forProvider: ObjectSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ObjectSpec#providerConfigRef
   */
  readonly providerConfigRef?: ObjectSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ObjectSpec#providerRef
   */
  readonly providerRef?: ObjectSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ObjectSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ObjectSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ObjectSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ObjectSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ObjectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpec(obj: ObjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ObjectSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ObjectSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ObjectSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ObjectSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ObjectSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ObjectSpecDeletionPolicy
 */
export enum ObjectSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ObjectSpecForProvider
 */
export interface ObjectSpecForProvider {
  /**
   * Canned ACL to apply. Valid values are private, public-read, public-read-write, aws-exec-read, authenticated-read, bucket-owner-read, and bucket-owner-full-control. Defaults to private.
   *
   * @default private.
   * @schema ObjectSpecForProvider#acl
   */
  readonly acl?: string;

  /**
   * Name of the bucket to put the file in. Alternatively, an S3 access point ARN can be specified.
   *
   * @schema ObjectSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * Whether or not to use Amazon S3 Bucket Keys for SSE-KMS.
   *
   * @schema ObjectSpecForProvider#bucketKeyEnabled
   */
  readonly bucketKeyEnabled?: boolean;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema ObjectSpecForProvider#bucketRef
   */
  readonly bucketRef?: ObjectSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema ObjectSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: ObjectSpecForProviderBucketSelector;

  /**
   * Caching behavior along the request/reply chain Read w3c cache_control for further details.
   *
   * @schema ObjectSpecForProvider#cacheControl
   */
  readonly cacheControl?: string;

  /**
   * Literal string value to use as the object content, which will be uploaded as UTF-8-encoded text.
   *
   * @schema ObjectSpecForProvider#content
   */
  readonly content?: string;

  /**
   * Base64-encoded data that will be decoded and uploaded as raw bytes for the object content. This allows safely uploading non-UTF8 binary data, but is recommended only for small content such as the result of the gzipbase64 function with small text strings. For larger objects, use source to stream the content from a disk file.
   *
   * @schema ObjectSpecForProvider#contentBase64
   */
  readonly contentBase64?: string;

  /**
   * Presentational information for the object. Read w3c content_disposition for further information.
   *
   * @schema ObjectSpecForProvider#contentDisposition
   */
  readonly contentDisposition?: string;

  /**
   * Content encodings that have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read w3c content encoding for further information.
   *
   * @schema ObjectSpecForProvider#contentEncoding
   */
  readonly contentEncoding?: string;

  /**
   * Language the content is in e.g., en-US or en-GB.
   *
   * @schema ObjectSpecForProvider#contentLanguage
   */
  readonly contentLanguage?: string;

  /**
   * Standard MIME type describing the format of the object data, e.g., application/octet-stream. All Valid MIME Types are valid for this input.
   *
   * @schema ObjectSpecForProvider#contentType
   */
  readonly contentType?: string;

  /**
   * Triggers updates when the value changes.11.11.11 or earlier). This attribute is not compatible with KMS encryption, kms_key_id or server_side_encryption = "aws:kms", also if an object is larger than 16 MB, the AWS Management Console will upload or copy that object as a Multipart Upload, and therefore the ETag will not be an MD5 digest (see source_hash instead).
   *
   * @schema ObjectSpecForProvider#etag
   */
  readonly etag?: string;

  /**
   * Whether to allow the object to be deleted by removing any legal hold on any object version. Default is false. This value should be set to true only if the bucket has S3 object lock enabled.
   *
   * @default false. This value should be set to true only if the bucket has S3 object lock enabled.
   * @schema ObjectSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * Name of the object once it is in the bucket.
   *
   * @schema ObjectSpecForProvider#key
   */
  readonly key: string;

  /**
   * ARN of the KMS Key to use for object encryption. If the S3 Bucket has server-side encryption enabled, that value will automatically be used. If referencing the aws_kms_key resource, use the arn attribute. If referencing the aws_kms_alias data source or resource, use the target_key_arn attribute.
   *
   * @schema ObjectSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema ObjectSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: ObjectSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema ObjectSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: ObjectSpecForProviderKmsKeyIdSelector;

  /**
   * Map of keys/values to provision metadata (will be automatically prefixed by x-amz-meta-, note that only lowercase label are currently supported by the AWS Go API).
   *
   * @schema ObjectSpecForProvider#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * Legal hold status that you want to apply to the specified object. Valid values are ON and OFF.
   *
   * @schema ObjectSpecForProvider#objectLockLegalHoldStatus
   */
  readonly objectLockLegalHoldStatus?: string;

  /**
   * Object lock retention mode that you want to apply to this object. Valid values are GOVERNANCE and COMPLIANCE.
   *
   * @schema ObjectSpecForProvider#objectLockMode
   */
  readonly objectLockMode?: string;

  /**
   * Date and time, in RFC3339 format, when this object's object lock will expire.
   *
   * @schema ObjectSpecForProvider#objectLockRetainUntilDate
   */
  readonly objectLockRetainUntilDate?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ObjectSpecForProvider#region
   */
  readonly region: string;

  /**
   * Server-side encryption of the object in S3. Valid values are "AES256" and "aws:kms".
   *
   * @schema ObjectSpecForProvider#serverSideEncryption
   */
  readonly serverSideEncryption?: string;

  /**
   * Path to a file that will be read and uploaded as raw bytes for the object content.
   *
   * @schema ObjectSpecForProvider#source
   */
  readonly source?: string;

  /**
   * Triggers updates like etag but useful to address etag encryption limitations.11.12 or later). (The value is only stored in state and not saved by AWS.)
   *
   * @schema ObjectSpecForProvider#sourceHash
   */
  readonly sourceHash?: string;

  /**
   * Storage Class for the object. Defaults to "STANDARD".
   *
   * @default STANDARD".
   * @schema ObjectSpecForProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ObjectSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Target URL for website redirect.
   *
   * @schema ObjectSpecForProvider#websiteRedirect
   */
  readonly websiteRedirect?: string;

}

/**
 * Converts an object of type 'ObjectSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecForProvider(obj: ObjectSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acl': obj.acl,
    'bucket': obj.bucket,
    'bucketKeyEnabled': obj.bucketKeyEnabled,
    'bucketRef': toJson_ObjectSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_ObjectSpecForProviderBucketSelector(obj.bucketSelector),
    'cacheControl': obj.cacheControl,
    'content': obj.content,
    'contentBase64': obj.contentBase64,
    'contentDisposition': obj.contentDisposition,
    'contentEncoding': obj.contentEncoding,
    'contentLanguage': obj.contentLanguage,
    'contentType': obj.contentType,
    'etag': obj.etag,
    'forceDestroy': obj.forceDestroy,
    'key': obj.key,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_ObjectSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_ObjectSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'objectLockLegalHoldStatus': obj.objectLockLegalHoldStatus,
    'objectLockMode': obj.objectLockMode,
    'objectLockRetainUntilDate': obj.objectLockRetainUntilDate,
    'region': obj.region,
    'serverSideEncryption': obj.serverSideEncryption,
    'source': obj.source,
    'sourceHash': obj.sourceHash,
    'storageClass': obj.storageClass,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'websiteRedirect': obj.websiteRedirect,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ObjectSpecProviderConfigRef
 */
export interface ObjectSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectSpecProviderConfigRef#policy
   */
  readonly policy?: ObjectSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecProviderConfigRef(obj: ObjectSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ObjectSpecProviderRef
 */
export interface ObjectSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectSpecProviderRef#policy
   */
  readonly policy?: ObjectSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ObjectSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecProviderRef(obj: ObjectSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ObjectSpecPublishConnectionDetailsTo
 */
export interface ObjectSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ObjectSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ObjectSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ObjectSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ObjectSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ObjectSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ObjectSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecPublishConnectionDetailsTo(obj: ObjectSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ObjectSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ObjectSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ObjectSpecWriteConnectionSecretToRef
 */
export interface ObjectSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ObjectSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecWriteConnectionSecretToRef(obj: ObjectSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema ObjectSpecForProviderBucketRef
 */
export interface ObjectSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectSpecForProviderBucketRef#policy
   */
  readonly policy?: ObjectSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'ObjectSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecForProviderBucketRef(obj: ObjectSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema ObjectSpecForProviderBucketSelector
 */
export interface ObjectSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectSpecForProviderBucketSelector#policy
   */
  readonly policy?: ObjectSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecForProviderBucketSelector(obj: ObjectSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema ObjectSpecForProviderKmsKeyIdRef
 */
export interface ObjectSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: ObjectSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'ObjectSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecForProviderKmsKeyIdRef(obj: ObjectSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema ObjectSpecForProviderKmsKeyIdSelector
 */
export interface ObjectSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: ObjectSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecForProviderKmsKeyIdSelector(obj: ObjectSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectSpecProviderConfigRefPolicy
 */
export interface ObjectSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecProviderConfigRefPolicy(obj: ObjectSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectSpecProviderRefPolicy
 */
export interface ObjectSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ObjectSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ObjectSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecProviderRefPolicy(obj: ObjectSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ObjectSpecPublishConnectionDetailsToConfigRef
 */
export interface ObjectSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ObjectSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecPublishConnectionDetailsToConfigRef(obj: ObjectSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ObjectSpecPublishConnectionDetailsToMetadata
 */
export interface ObjectSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ObjectSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ObjectSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecPublishConnectionDetailsToMetadata(obj: ObjectSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectSpecForProviderBucketRefPolicy
 */
export interface ObjectSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: ObjectSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: ObjectSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecForProviderBucketRefPolicy(obj: ObjectSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectSpecForProviderBucketSelectorPolicy
 */
export interface ObjectSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: ObjectSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: ObjectSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecForProviderBucketSelectorPolicy(obj: ObjectSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectSpecForProviderKmsKeyIdRefPolicy
 */
export interface ObjectSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: ObjectSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: ObjectSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecForProviderKmsKeyIdRefPolicy(obj: ObjectSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface ObjectSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: ObjectSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: ObjectSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecForProviderKmsKeyIdSelectorPolicy(obj: ObjectSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectSpecProviderConfigRefPolicyResolution
 */
export enum ObjectSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectSpecProviderConfigRefPolicyResolve
 */
export enum ObjectSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectSpecProviderRefPolicyResolution
 */
export enum ObjectSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectSpecProviderRefPolicyResolve
 */
export enum ObjectSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ObjectSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ObjectSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectSpecPublishConnectionDetailsToConfigRefPolicy(obj: ObjectSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectSpecForProviderBucketRefPolicyResolution
 */
export enum ObjectSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectSpecForProviderBucketRefPolicyResolve
 */
export enum ObjectSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectSpecForProviderBucketSelectorPolicyResolution
 */
export enum ObjectSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectSpecForProviderBucketSelectorPolicyResolve
 */
export enum ObjectSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum ObjectSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum ObjectSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum ObjectSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum ObjectSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ObjectSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ObjectCopy is the Schema for the ObjectCopys API. Provides a resource for copying an S3 object.
 *
 * @schema ObjectCopy
 */
export class ObjectCopy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ObjectCopy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3.aws.upbound.io/v1beta1',
    kind: 'ObjectCopy',
  }

  /**
   * Renders a Kubernetes manifest for "ObjectCopy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ObjectCopyProps): any {
    return {
      ...ObjectCopy.GVK,
      ...toJson_ObjectCopyProps(props),
    };
  }

  /**
   * Defines a "ObjectCopy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ObjectCopyProps) {
    super(scope, id, {
      ...ObjectCopy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ObjectCopy.GVK,
      ...toJson_ObjectCopyProps(resolved),
    };
  }
}

/**
 * ObjectCopy is the Schema for the ObjectCopys API. Provides a resource for copying an S3 object.
 *
 * @schema ObjectCopy
 */
export interface ObjectCopyProps {
  /**
   * @schema ObjectCopy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ObjectCopySpec defines the desired state of ObjectCopy
   *
   * @schema ObjectCopy#spec
   */
  readonly spec: ObjectCopySpec;

}

/**
 * Converts an object of type 'ObjectCopyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopyProps(obj: ObjectCopyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ObjectCopySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectCopySpec defines the desired state of ObjectCopy
 *
 * @schema ObjectCopySpec
 */
export interface ObjectCopySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ObjectCopySpec#deletionPolicy
   */
  readonly deletionPolicy?: ObjectCopySpecDeletionPolicy;

  /**
   * @schema ObjectCopySpec#forProvider
   */
  readonly forProvider: ObjectCopySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ObjectCopySpec#providerConfigRef
   */
  readonly providerConfigRef?: ObjectCopySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ObjectCopySpec#providerRef
   */
  readonly providerRef?: ObjectCopySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ObjectCopySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ObjectCopySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ObjectCopySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ObjectCopySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ObjectCopySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpec(obj: ObjectCopySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ObjectCopySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ObjectCopySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ObjectCopySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ObjectCopySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ObjectCopySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ObjectCopySpecDeletionPolicy
 */
export enum ObjectCopySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ObjectCopySpecForProvider
 */
export interface ObjectCopySpecForProvider {
  /**
   * Canned ACL to apply. Defaults to private. Valid values are private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, and bucket-owner-full-control. Conflicts with grant.
   *
   * @default private. Valid values are private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, and bucket-owner-full-control. Conflicts with grant.
   * @schema ObjectCopySpecForProvider#acl
   */
  readonly acl?: string;

  /**
   * Name of the bucket to put the file in.
   *
   * @schema ObjectCopySpecForProvider#bucket
   */
  readonly bucket: string;

  /**
   * @schema ObjectCopySpecForProvider#bucketKeyEnabled
   */
  readonly bucketKeyEnabled?: boolean;

  /**
   * Specifies caching behavior along the request/reply chain Read w3c cache_control for further details.
   *
   * @schema ObjectCopySpecForProvider#cacheControl
   */
  readonly cacheControl?: string;

  /**
   * Specifies presentational information for the object. Read w3c content_disposition for further information.
   *
   * @schema ObjectCopySpecForProvider#contentDisposition
   */
  readonly contentDisposition?: string;

  /**
   * Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read w3c content encoding for further information.
   *
   * @schema ObjectCopySpecForProvider#contentEncoding
   */
  readonly contentEncoding?: string;

  /**
   * Language the content is in e.g., en-US or en-GB.
   *
   * @schema ObjectCopySpecForProvider#contentLanguage
   */
  readonly contentLanguage?: string;

  /**
   * Standard MIME type describing the format of the object data, e.g., application/octet-stream. All Valid MIME Types are valid for this input.
   *
   * @schema ObjectCopySpecForProvider#contentType
   */
  readonly contentType?: string;

  /**
   * Copies the object if its entity tag (ETag) matches the specified tag.
   *
   * @schema ObjectCopySpecForProvider#copyIfMatch
   */
  readonly copyIfMatch?: string;

  /**
   * Copies the object if it has been modified since the specified time, in RFC3339 format.
   *
   * @schema ObjectCopySpecForProvider#copyIfModifiedSince
   */
  readonly copyIfModifiedSince?: string;

  /**
   * Copies the object if its entity tag (ETag) is different than the specified ETag.
   *
   * @schema ObjectCopySpecForProvider#copyIfNoneMatch
   */
  readonly copyIfNoneMatch?: string;

  /**
   * Copies the object if it hasn't been modified since the specified time, in RFC3339 format.
   *
   * @schema ObjectCopySpecForProvider#copyIfUnmodifiedSince
   */
  readonly copyIfUnmodifiedSince?: string;

  /**
   * Specifies the algorithm to use to when encrypting the object (for example, AES256).
   *
   * @schema ObjectCopySpecForProvider#customerAlgorithm
   */
  readonly customerAlgorithm?: string;

  /**
   * Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
   *
   * @schema ObjectCopySpecForProvider#customerKeyMd5
   */
  readonly customerKeyMd5?: string;

  /**
   * Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side-encryption-customer-algorithm header.
   *
   * @schema ObjectCopySpecForProvider#customerKeySecretRef
   */
  readonly customerKeySecretRef?: ObjectCopySpecForProviderCustomerKeySecretRef;

  /**
   * Account id of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
   *
   * @schema ObjectCopySpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * Account id of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
   *
   * @schema ObjectCopySpecForProvider#expectedSourceBucketOwner
   */
  readonly expectedSourceBucketOwner?: string;

  /**
   * Date and time at which the object is no longer cacheable, in RFC3339 format.
   *
   * @schema ObjectCopySpecForProvider#expires
   */
  readonly expires?: string;

  /**
   * Allow the object to be deleted by removing any legal hold on any object version. Default is false. This value should be set to true only if the bucket has S3 object lock enabled.
   *
   * @default false. This value should be set to true only if the bucket has S3 object lock enabled.
   * @schema ObjectCopySpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * Configuration block for header grants. Documented below. Conflicts with acl.
   *
   * @schema ObjectCopySpecForProvider#grant
   */
  readonly grant?: ObjectCopySpecForProviderGrant[];

  /**
   * Name of the object once it is in the bucket.
   *
   * @schema ObjectCopySpecForProvider#key
   */
  readonly key: string;

  /**
   * Specifies the AWS KMS Encryption Context to use for object encryption. The value is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
   *
   * @schema ObjectCopySpecForProvider#kmsEncryptionContextSecretRef
   */
  readonly kmsEncryptionContextSecretRef?: ObjectCopySpecForProviderKmsEncryptionContextSecretRef;

  /**
   * Specifies the AWS KMS Key ARN to use for object encryption. This value is a fully qualified ARN of the KMS Key. If using aws_kms_key, use the exported arn attribute: kms_key_id = aws_kms_key.foo.arn
   *
   * @schema ObjectCopySpecForProvider#kmsKeyIdSecretRef
   */
  readonly kmsKeyIdSecretRef?: ObjectCopySpecForProviderKmsKeyIdSecretRef;

  /**
   * Map of keys/values to provision metadata (will be automatically prefixed by x-amz-meta-, note that only lowercase label are currently supported by the AWS Go API).
   *
   * @schema ObjectCopySpecForProvider#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * Specifies whether the metadata is copied from the source object or replaced with metadata provided in the request. Valid values are COPY and REPLACE.
   *
   * @schema ObjectCopySpecForProvider#metadataDirective
   */
  readonly metadataDirective?: string;

  /**
   * The legal hold status that you want to apply to the specified object. Valid values are ON and OFF.
   *
   * @schema ObjectCopySpecForProvider#objectLockLegalHoldStatus
   */
  readonly objectLockLegalHoldStatus?: string;

  /**
   * Object lock retention mode that you want to apply to this object. Valid values are GOVERNANCE and COMPLIANCE.
   *
   * @schema ObjectCopySpecForProvider#objectLockMode
   */
  readonly objectLockMode?: string;

  /**
   * Date and time, in RFC3339 format, when this object's object lock will expire.
   *
   * @schema ObjectCopySpecForProvider#objectLockRetainUntilDate
   */
  readonly objectLockRetainUntilDate?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ObjectCopySpecForProvider#region
   */
  readonly region: string;

  /**
   * Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see Downloading Objects in Requestor Pays Buckets (https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 Developer Guide. If included, the only valid value is requester.
   *
   * @schema ObjectCopySpecForProvider#requestPayer
   */
  readonly requestPayer?: string;

  /**
   * Specifies server-side encryption of the object in S3. Valid values are AES256 and aws:kms.
   *
   * @schema ObjectCopySpecForProvider#serverSideEncryption
   */
  readonly serverSideEncryption?: string;

  /**
   * Specifies the source object for the copy operation. You specify the value in one of two formats. For objects not accessed through an access point, specify the name of the source bucket and the key of the source object, separated by a slash (/). For example, testbucket/test1.json. For objects accessed through access points, specify the ARN of the object as accessed through the access point, in the format arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key>. For example, arn:aws:s3:us-west-2:9999912999:accesspoint/my-access-point/object/testbucket/test1.json.
   *
   * @schema ObjectCopySpecForProvider#source
   */
  readonly source: string;

  /**
   * Specifies the algorithm to use when decrypting the source object (for example, AES256).
   *
   * @schema ObjectCopySpecForProvider#sourceCustomerAlgorithm
   */
  readonly sourceCustomerAlgorithm?: string;

  /**
   * Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
   *
   * @schema ObjectCopySpecForProvider#sourceCustomerKeyMd5
   */
  readonly sourceCustomerKeyMd5?: string;

  /**
   * Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source object. The encryption key provided in this header must be one that was used when the source object was created.
   *
   * @schema ObjectCopySpecForProvider#sourceCustomerKeySecretRef
   */
  readonly sourceCustomerKeySecretRef?: ObjectCopySpecForProviderSourceCustomerKeySecretRef;

  /**
   * Specifies the desired storage class for the object. Defaults to STANDARD.
   *
   * @default STANDARD.
   * @schema ObjectCopySpecForProvider#storageClass
   */
  readonly storageClass?: string;

  /**
   * Specifies whether the object tag-set are copied from the source object or replaced with tag-set provided in the request. Valid values are COPY and REPLACE.
   *
   * @schema ObjectCopySpecForProvider#taggingDirective
   */
  readonly taggingDirective?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ObjectCopySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Specifies a target URL for website redirect.
   *
   * @schema ObjectCopySpecForProvider#websiteRedirect
   */
  readonly websiteRedirect?: string;

}

/**
 * Converts an object of type 'ObjectCopySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecForProvider(obj: ObjectCopySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acl': obj.acl,
    'bucket': obj.bucket,
    'bucketKeyEnabled': obj.bucketKeyEnabled,
    'cacheControl': obj.cacheControl,
    'contentDisposition': obj.contentDisposition,
    'contentEncoding': obj.contentEncoding,
    'contentLanguage': obj.contentLanguage,
    'contentType': obj.contentType,
    'copyIfMatch': obj.copyIfMatch,
    'copyIfModifiedSince': obj.copyIfModifiedSince,
    'copyIfNoneMatch': obj.copyIfNoneMatch,
    'copyIfUnmodifiedSince': obj.copyIfUnmodifiedSince,
    'customerAlgorithm': obj.customerAlgorithm,
    'customerKeyMd5': obj.customerKeyMd5,
    'customerKeySecretRef': toJson_ObjectCopySpecForProviderCustomerKeySecretRef(obj.customerKeySecretRef),
    'expectedBucketOwner': obj.expectedBucketOwner,
    'expectedSourceBucketOwner': obj.expectedSourceBucketOwner,
    'expires': obj.expires,
    'forceDestroy': obj.forceDestroy,
    'grant': obj.grant?.map(y => toJson_ObjectCopySpecForProviderGrant(y)),
    'key': obj.key,
    'kmsEncryptionContextSecretRef': toJson_ObjectCopySpecForProviderKmsEncryptionContextSecretRef(obj.kmsEncryptionContextSecretRef),
    'kmsKeyIdSecretRef': toJson_ObjectCopySpecForProviderKmsKeyIdSecretRef(obj.kmsKeyIdSecretRef),
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'metadataDirective': obj.metadataDirective,
    'objectLockLegalHoldStatus': obj.objectLockLegalHoldStatus,
    'objectLockMode': obj.objectLockMode,
    'objectLockRetainUntilDate': obj.objectLockRetainUntilDate,
    'region': obj.region,
    'requestPayer': obj.requestPayer,
    'serverSideEncryption': obj.serverSideEncryption,
    'source': obj.source,
    'sourceCustomerAlgorithm': obj.sourceCustomerAlgorithm,
    'sourceCustomerKeyMd5': obj.sourceCustomerKeyMd5,
    'sourceCustomerKeySecretRef': toJson_ObjectCopySpecForProviderSourceCustomerKeySecretRef(obj.sourceCustomerKeySecretRef),
    'storageClass': obj.storageClass,
    'taggingDirective': obj.taggingDirective,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'websiteRedirect': obj.websiteRedirect,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ObjectCopySpecProviderConfigRef
 */
export interface ObjectCopySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectCopySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectCopySpecProviderConfigRef#policy
   */
  readonly policy?: ObjectCopySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectCopySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecProviderConfigRef(obj: ObjectCopySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectCopySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ObjectCopySpecProviderRef
 */
export interface ObjectCopySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectCopySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectCopySpecProviderRef#policy
   */
  readonly policy?: ObjectCopySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ObjectCopySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecProviderRef(obj: ObjectCopySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectCopySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ObjectCopySpecPublishConnectionDetailsTo
 */
export interface ObjectCopySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ObjectCopySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ObjectCopySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ObjectCopySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ObjectCopySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ObjectCopySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ObjectCopySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecPublishConnectionDetailsTo(obj: ObjectCopySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ObjectCopySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ObjectCopySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ObjectCopySpecWriteConnectionSecretToRef
 */
export interface ObjectCopySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ObjectCopySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectCopySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectCopySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecWriteConnectionSecretToRef(obj: ObjectCopySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side-encryption-customer-algorithm header.
 *
 * @schema ObjectCopySpecForProviderCustomerKeySecretRef
 */
export interface ObjectCopySpecForProviderCustomerKeySecretRef {
  /**
   * The key to select.
   *
   * @schema ObjectCopySpecForProviderCustomerKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ObjectCopySpecForProviderCustomerKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectCopySpecForProviderCustomerKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectCopySpecForProviderCustomerKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecForProviderCustomerKeySecretRef(obj: ObjectCopySpecForProviderCustomerKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ObjectCopySpecForProviderGrant
 */
export interface ObjectCopySpecForProviderGrant {
  /**
   * Email address of the grantee. Used only when type is AmazonCustomerByEmail.
   *
   * @schema ObjectCopySpecForProviderGrant#email
   */
  readonly email?: string;

  /**
   * Canonical user ID of the grantee. Used only when type is CanonicalUser.
   *
   * @schema ObjectCopySpecForProviderGrant#id
   */
  readonly id?: string;

  /**
   * List of permissions to grant to grantee. Valid values are READ, READ_ACP, WRITE_ACP, FULL_CONTROL.
   *
   * @schema ObjectCopySpecForProviderGrant#permissions
   */
  readonly permissions: string[];

  /**
   * - Type of grantee. Valid values are CanonicalUser, Group, and AmazonCustomerByEmail.
   *
   * @schema ObjectCopySpecForProviderGrant#type
   */
  readonly type: string;

  /**
   * URI of the grantee group. Used only when type is Group.
   *
   * @schema ObjectCopySpecForProviderGrant#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'ObjectCopySpecForProviderGrant' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecForProviderGrant(obj: ObjectCopySpecForProviderGrant | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'email': obj.email,
    'id': obj.id,
    'permissions': obj.permissions?.map(y => y),
    'type': obj.type,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the AWS KMS Encryption Context to use for object encryption. The value is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
 *
 * @schema ObjectCopySpecForProviderKmsEncryptionContextSecretRef
 */
export interface ObjectCopySpecForProviderKmsEncryptionContextSecretRef {
  /**
   * The key to select.
   *
   * @schema ObjectCopySpecForProviderKmsEncryptionContextSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ObjectCopySpecForProviderKmsEncryptionContextSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectCopySpecForProviderKmsEncryptionContextSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectCopySpecForProviderKmsEncryptionContextSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecForProviderKmsEncryptionContextSecretRef(obj: ObjectCopySpecForProviderKmsEncryptionContextSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the AWS KMS Key ARN to use for object encryption. This value is a fully qualified ARN of the KMS Key. If using aws_kms_key, use the exported arn attribute: kms_key_id = aws_kms_key.foo.arn
 *
 * @schema ObjectCopySpecForProviderKmsKeyIdSecretRef
 */
export interface ObjectCopySpecForProviderKmsKeyIdSecretRef {
  /**
   * The key to select.
   *
   * @schema ObjectCopySpecForProviderKmsKeyIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ObjectCopySpecForProviderKmsKeyIdSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectCopySpecForProviderKmsKeyIdSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectCopySpecForProviderKmsKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecForProviderKmsKeyIdSecretRef(obj: ObjectCopySpecForProviderKmsKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source object. The encryption key provided in this header must be one that was used when the source object was created.
 *
 * @schema ObjectCopySpecForProviderSourceCustomerKeySecretRef
 */
export interface ObjectCopySpecForProviderSourceCustomerKeySecretRef {
  /**
   * The key to select.
   *
   * @schema ObjectCopySpecForProviderSourceCustomerKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ObjectCopySpecForProviderSourceCustomerKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectCopySpecForProviderSourceCustomerKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectCopySpecForProviderSourceCustomerKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecForProviderSourceCustomerKeySecretRef(obj: ObjectCopySpecForProviderSourceCustomerKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectCopySpecProviderConfigRefPolicy
 */
export interface ObjectCopySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectCopySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectCopySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectCopySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectCopySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectCopySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecProviderConfigRefPolicy(obj: ObjectCopySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectCopySpecProviderRefPolicy
 */
export interface ObjectCopySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectCopySpecProviderRefPolicy#resolution
   */
  readonly resolution?: ObjectCopySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectCopySpecProviderRefPolicy#resolve
   */
  readonly resolve?: ObjectCopySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectCopySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecProviderRefPolicy(obj: ObjectCopySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ObjectCopySpecPublishConnectionDetailsToConfigRef
 */
export interface ObjectCopySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectCopySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectCopySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ObjectCopySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectCopySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecPublishConnectionDetailsToConfigRef(obj: ObjectCopySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectCopySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ObjectCopySpecPublishConnectionDetailsToMetadata
 */
export interface ObjectCopySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectCopySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectCopySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ObjectCopySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ObjectCopySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecPublishConnectionDetailsToMetadata(obj: ObjectCopySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectCopySpecProviderConfigRefPolicyResolution
 */
export enum ObjectCopySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectCopySpecProviderConfigRefPolicyResolve
 */
export enum ObjectCopySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectCopySpecProviderRefPolicyResolution
 */
export enum ObjectCopySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectCopySpecProviderRefPolicyResolve
 */
export enum ObjectCopySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ObjectCopySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ObjectCopySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectCopySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectCopySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectCopySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectCopySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectCopySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectCopySpecPublishConnectionDetailsToConfigRefPolicy(obj: ObjectCopySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectCopySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ObjectCopySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectCopySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ObjectCopySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

