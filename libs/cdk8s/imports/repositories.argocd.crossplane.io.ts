// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A Repository is a managed resource that represents an ArgoCD Git Repository
 *
 * @schema Repository
 */
export class Repository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Repository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'repositories.argocd.crossplane.io/v1alpha1',
    kind: 'Repository',
  }

  /**
   * Renders a Kubernetes manifest for "Repository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RepositoryProps): any {
    return {
      ...Repository.GVK,
      ...toJson_RepositoryProps(props),
    };
  }

  /**
   * Defines a "Repository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RepositoryProps) {
    super(scope, id, {
      ...Repository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Repository.GVK,
      ...toJson_RepositoryProps(resolved),
    };
  }
}

/**
 * A Repository is a managed resource that represents an ArgoCD Git Repository
 *
 * @schema Repository
 */
export interface RepositoryProps {
  /**
   * @schema Repository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A RepositorySpec defines the desired state of an ArgoCD Repository.
   *
   * @schema Repository#spec
   */
  readonly spec: RepositorySpec;

}

/**
 * Converts an object of type 'RepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryProps(obj: RepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A RepositorySpec defines the desired state of an ArgoCD Repository.
 *
 * @schema RepositorySpec
 */
export interface RepositorySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RepositorySpec#deletionPolicy
   */
  readonly deletionPolicy?: RepositorySpecDeletionPolicy;

  /**
   * RepositoryParameters define the desired state of an ArgoCD Git Repository
   *
   * @schema RepositorySpec#forProvider
   */
  readonly forProvider: RepositorySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RepositorySpec#providerConfigRef
   */
  readonly providerConfigRef?: RepositorySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RepositorySpec#providerRef
   */
  readonly providerRef?: RepositorySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RepositorySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RepositorySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RepositorySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RepositorySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpec(obj: RepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RepositorySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RepositorySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RepositorySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RepositorySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RepositorySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RepositorySpecDeletionPolicy
 */
export enum RepositorySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * RepositoryParameters define the desired state of an ArgoCD Git Repository
 *
 * @schema RepositorySpecForProvider
 */
export interface RepositorySpecForProvider {
  /**
   * Whether git-lfs support should be enabled for this repo
   *
   * @schema RepositorySpecForProvider#enableLfs
   */
  readonly enableLfs?: boolean;

  /**
   * Whether helm-oci support should be enabled for this repo
   *
   * @schema RepositorySpecForProvider#enableOCI
   */
  readonly enableOci?: boolean;

  /**
   * Github App Enterprise base url if empty will default to https://api.github.com
   *
   * @schema RepositorySpecForProvider#githubAppEnterpriseBaseUrl
   */
  readonly githubAppEnterpriseBaseUrl?: string;

  /**
   * Github App ID of the app used to access the repo
   *
   * @schema RepositorySpecForProvider#githubAppID
   */
  readonly githubAppId?: number;

  /**
   * Github App Installation ID of the installed GitHub App
   *
   * @schema RepositorySpecForProvider#githubAppInstallationID
   */
  readonly githubAppInstallationId?: number;

  /**
   * Github App Private Key PEM data
   *
   * @schema RepositorySpecForProvider#githubAppPrivateKeyRef
   */
  readonly githubAppPrivateKeyRef?: RepositorySpecForProviderGithubAppPrivateKeyRef;

  /**
   * Whether credentials were inherited from a credential set
   *
   * @schema RepositorySpecForProvider#inheritedCreds
   */
  readonly inheritedCreds?: boolean;

  /**
   * Whether the repo is insecure
   *
   * @schema RepositorySpecForProvider#insecure
   */
  readonly insecure?: boolean;

  /**
   * only for Helm repos
   *
   * @schema RepositorySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Password for authenticating at the repo server
   *
   * @schema RepositorySpecForProvider#passwordRef
   */
  readonly passwordRef?: RepositorySpecForProviderPasswordRef;

  /**
   * URL of the repo
   *
   * @schema RepositorySpecForProvider#repo
   */
  readonly repo: string;

  /**
   * SSH private key data for authenticating at the repo server only for Git repos SSHPrivateKey *string `json:"sshPrivateKey,omitempty"`
   *
   * @schema RepositorySpecForProvider#sshPrivateKeyRef
   */
  readonly sshPrivateKeyRef?: RepositorySpecForProviderSshPrivateKeyRef;

  /**
   * TLS client cert data for authenticating at the repo server
   *
   * @schema RepositorySpecForProvider#tlsClientCertDataRef
   */
  readonly tlsClientCertDataRef?: RepositorySpecForProviderTlsClientCertDataRef;

  /**
   * TLS client cert key for authenticating at the repo server
   *
   * @schema RepositorySpecForProvider#tlsClientCertKeyRef
   */
  readonly tlsClientCertKeyRef?: RepositorySpecForProviderTlsClientCertKeyRef;

  /**
   * type of the repo, maybe "git or "helm, "git" is assumed if empty or absent
   *
   * @schema RepositorySpecForProvider#type
   */
  readonly type?: string;

  /**
   * Username for authenticating at the repo server
   *
   * @schema RepositorySpecForProvider#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'RepositorySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProvider(obj: RepositorySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLfs': obj.enableLfs,
    'enableOCI': obj.enableOci,
    'githubAppEnterpriseBaseUrl': obj.githubAppEnterpriseBaseUrl,
    'githubAppID': obj.githubAppId,
    'githubAppInstallationID': obj.githubAppInstallationId,
    'githubAppPrivateKeyRef': toJson_RepositorySpecForProviderGithubAppPrivateKeyRef(obj.githubAppPrivateKeyRef),
    'inheritedCreds': obj.inheritedCreds,
    'insecure': obj.insecure,
    'name': obj.name,
    'passwordRef': toJson_RepositorySpecForProviderPasswordRef(obj.passwordRef),
    'repo': obj.repo,
    'sshPrivateKeyRef': toJson_RepositorySpecForProviderSshPrivateKeyRef(obj.sshPrivateKeyRef),
    'tlsClientCertDataRef': toJson_RepositorySpecForProviderTlsClientCertDataRef(obj.tlsClientCertDataRef),
    'tlsClientCertKeyRef': toJson_RepositorySpecForProviderTlsClientCertKeyRef(obj.tlsClientCertKeyRef),
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RepositorySpecProviderConfigRef
 */
export interface RepositorySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecProviderConfigRef#policy
   */
  readonly policy?: RepositorySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderConfigRef(obj: RepositorySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RepositorySpecProviderRef
 */
export interface RepositorySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecProviderRef#policy
   */
  readonly policy?: RepositorySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderRef(obj: RepositorySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RepositorySpecPublishConnectionDetailsTo
 */
export interface RepositorySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RepositorySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RepositorySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsTo(obj: RepositorySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RepositorySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RepositorySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RepositorySpecWriteConnectionSecretToRef
 */
export interface RepositorySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RepositorySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositorySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositorySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecWriteConnectionSecretToRef(obj: RepositorySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Github App Private Key PEM data
 *
 * @schema RepositorySpecForProviderGithubAppPrivateKeyRef
 */
export interface RepositorySpecForProviderGithubAppPrivateKeyRef {
  /**
   * Key whose value will be used.
   *
   * @schema RepositorySpecForProviderGithubAppPrivateKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema RepositorySpecForProviderGithubAppPrivateKeyRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositorySpecForProviderGithubAppPrivateKeyRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositorySpecForProviderGithubAppPrivateKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderGithubAppPrivateKeyRef(obj: RepositorySpecForProviderGithubAppPrivateKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for authenticating at the repo server
 *
 * @schema RepositorySpecForProviderPasswordRef
 */
export interface RepositorySpecForProviderPasswordRef {
  /**
   * Key whose value will be used.
   *
   * @schema RepositorySpecForProviderPasswordRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema RepositorySpecForProviderPasswordRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositorySpecForProviderPasswordRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositorySpecForProviderPasswordRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderPasswordRef(obj: RepositorySpecForProviderPasswordRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SSH private key data for authenticating at the repo server only for Git repos SSHPrivateKey *string `json:"sshPrivateKey,omitempty"`
 *
 * @schema RepositorySpecForProviderSshPrivateKeyRef
 */
export interface RepositorySpecForProviderSshPrivateKeyRef {
  /**
   * Key whose value will be used.
   *
   * @schema RepositorySpecForProviderSshPrivateKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema RepositorySpecForProviderSshPrivateKeyRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositorySpecForProviderSshPrivateKeyRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositorySpecForProviderSshPrivateKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderSshPrivateKeyRef(obj: RepositorySpecForProviderSshPrivateKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS client cert data for authenticating at the repo server
 *
 * @schema RepositorySpecForProviderTlsClientCertDataRef
 */
export interface RepositorySpecForProviderTlsClientCertDataRef {
  /**
   * Key whose value will be used.
   *
   * @schema RepositorySpecForProviderTlsClientCertDataRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema RepositorySpecForProviderTlsClientCertDataRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositorySpecForProviderTlsClientCertDataRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositorySpecForProviderTlsClientCertDataRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderTlsClientCertDataRef(obj: RepositorySpecForProviderTlsClientCertDataRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS client cert key for authenticating at the repo server
 *
 * @schema RepositorySpecForProviderTlsClientCertKeyRef
 */
export interface RepositorySpecForProviderTlsClientCertKeyRef {
  /**
   * Key whose value will be used.
   *
   * @schema RepositorySpecForProviderTlsClientCertKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema RepositorySpecForProviderTlsClientCertKeyRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositorySpecForProviderTlsClientCertKeyRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositorySpecForProviderTlsClientCertKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderTlsClientCertKeyRef(obj: RepositorySpecForProviderTlsClientCertKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecProviderConfigRefPolicy
 */
export interface RepositorySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderConfigRefPolicy(obj: RepositorySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecProviderRefPolicy
 */
export interface RepositorySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecProviderRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecProviderRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderRefPolicy(obj: RepositorySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRef
 */
export interface RepositorySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RepositorySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToConfigRef(obj: RepositorySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RepositorySpecPublishConnectionDetailsToMetadata
 */
export interface RepositorySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToMetadata(obj: RepositorySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecProviderConfigRefPolicyResolution
 */
export enum RepositorySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecProviderConfigRefPolicyResolve
 */
export enum RepositorySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecProviderRefPolicyResolution
 */
export enum RepositorySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecProviderRefPolicyResolve
 */
export enum RepositorySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RepositorySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj: RepositorySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

