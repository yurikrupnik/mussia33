// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Application is the Schema for the Applications API. Allows management of an App Engine application.
 *
 * @schema Application
 */
export class Application extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Application"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appengine.gcp.upbound.io/v1beta1',
    kind: 'Application',
  }

  /**
   * Renders a Kubernetes manifest for "Application".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApplicationProps): any {
    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(props),
    };
  }

  /**
   * Defines a "Application" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApplicationProps) {
    super(scope, id, {
      ...Application.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Application.GVK,
      ...toJson_ApplicationProps(resolved),
    };
  }
}

/**
 * Application is the Schema for the Applications API. Allows management of an App Engine application.
 *
 * @schema Application
 */
export interface ApplicationProps {
  /**
   * @schema Application#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApplicationSpec defines the desired state of Application
   *
   * @schema Application#spec
   */
  readonly spec: ApplicationSpec;

}

/**
 * Converts an object of type 'ApplicationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationProps(obj: ApplicationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApplicationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationSpec defines the desired state of Application
 *
 * @schema ApplicationSpec
 */
export interface ApplicationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ApplicationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApplicationSpecDeletionPolicy;

  /**
   * @schema ApplicationSpec#forProvider
   */
  readonly forProvider: ApplicationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApplicationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApplicationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ApplicationSpec#providerRef
   */
  readonly providerRef?: ApplicationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApplicationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApplicationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApplicationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApplicationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApplicationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpec(obj: ApplicationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApplicationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ApplicationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ApplicationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ApplicationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApplicationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ApplicationSpecDeletionPolicy
 */
export enum ApplicationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApplicationSpecForProvider
 */
export interface ApplicationSpecForProvider {
  /**
   * The domain to authenticate users with when using App Engine's User API.
   *
   * @schema ApplicationSpecForProvider#authDomain
   */
  readonly authDomain?: string;

  /**
   * The type of the Cloud Firestore or Cloud Datastore database associated with this application. Can be CLOUD_FIRESTORE or CLOUD_DATASTORE_COMPATIBILITY for new instances.  To support old instances, the value CLOUD_DATASTORE is accepted by the provider, but will be rejected by the API.
   *
   * @schema ApplicationSpecForProvider#databaseType
   */
  readonly databaseType?: string;

  /**
   * A block of optional settings to configure specific App Engine features:
   *
   * @schema ApplicationSpecForProvider#featureSettings
   */
  readonly featureSettings?: ApplicationSpecForProviderFeatureSettings[];

  /**
   * Settings for enabling Cloud Identity Aware Proxy
   *
   * @schema ApplicationSpecForProvider#iap
   */
  readonly iap?: ApplicationSpecForProviderIap[];

  /**
   * The location to serve the app from.
   *
   * @schema ApplicationSpecForProvider#locationId
   */
  readonly locationId: string;

  /**
   * The project ID to create the application under. ~>NOTE: GCP only accepts project ID, not project number. If you are using number, you may get a "Permission denied" error.
   *
   * @schema ApplicationSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in cloudplatform to populate project.
   *
   * @schema ApplicationSpecForProvider#projectRef
   */
  readonly projectRef?: ApplicationSpecForProviderProjectRef;

  /**
   * Selector for a Project in cloudplatform to populate project.
   *
   * @schema ApplicationSpecForProvider#projectSelector
   */
  readonly projectSelector?: ApplicationSpecForProviderProjectSelector;

  /**
   * The serving status of the app.
   *
   * @schema ApplicationSpecForProvider#servingStatus
   */
  readonly servingStatus?: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProvider(obj: ApplicationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authDomain': obj.authDomain,
    'databaseType': obj.databaseType,
    'featureSettings': obj.featureSettings?.map(y => toJson_ApplicationSpecForProviderFeatureSettings(y)),
    'iap': obj.iap?.map(y => toJson_ApplicationSpecForProviderIap(y)),
    'locationId': obj.locationId,
    'project': obj.project,
    'projectRef': toJson_ApplicationSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_ApplicationSpecForProviderProjectSelector(obj.projectSelector),
    'servingStatus': obj.servingStatus,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApplicationSpecProviderConfigRef
 */
export interface ApplicationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderConfigRef#policy
   */
  readonly policy?: ApplicationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRef(obj: ApplicationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ApplicationSpecProviderRef
 */
export interface ApplicationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecProviderRef#policy
   */
  readonly policy?: ApplicationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderRef(obj: ApplicationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApplicationSpecPublishConnectionDetailsTo
 */
export interface ApplicationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApplicationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApplicationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApplicationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsTo(obj: ApplicationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApplicationSpecWriteConnectionSecretToRef
 */
export interface ApplicationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecWriteConnectionSecretToRef(obj: ApplicationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderFeatureSettings
 */
export interface ApplicationSpecForProviderFeatureSettings {
  /**
   * Set to false to use the legacy health check instead of the readiness and liveness checks.
   *
   * @schema ApplicationSpecForProviderFeatureSettings#splitHealthChecks
   */
  readonly splitHealthChecks: boolean;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderFeatureSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderFeatureSettings(obj: ApplicationSpecForProviderFeatureSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'splitHealthChecks': obj.splitHealthChecks,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationSpecForProviderIap
 */
export interface ApplicationSpecForProviderIap {
  /**
   * Whether the serving infrastructure will authenticate and authorize all incoming requests. (default is false)
   *
   * @schema ApplicationSpecForProviderIap#enabled
   */
  readonly enabled?: boolean;

  /**
   * OAuth2 client ID to use for the authentication flow.
   *
   * @schema ApplicationSpecForProviderIap#oauth2ClientId
   */
  readonly oauth2ClientId: string;

  /**
   * OAuth2 client secret to use for the authentication flow. The SHA-256 hash of the value is returned in the oauth2ClientSecretSha256 field.
   *
   * @schema ApplicationSpecForProviderIap#oauth2ClientSecretSecretRef
   */
  readonly oauth2ClientSecretSecretRef: ApplicationSpecForProviderIapOauth2ClientSecretSecretRef;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderIap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderIap(obj: ApplicationSpecForProviderIap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'oauth2ClientId': obj.oauth2ClientId,
    'oauth2ClientSecretSecretRef': toJson_ApplicationSpecForProviderIapOauth2ClientSecretSecretRef(obj.oauth2ClientSecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project in cloudplatform to populate project.
 *
 * @schema ApplicationSpecForProviderProjectRef
 */
export interface ApplicationSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecForProviderProjectRef#policy
   */
  readonly policy?: ApplicationSpecForProviderProjectRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderProjectRef(obj: ApplicationSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project in cloudplatform to populate project.
 *
 * @schema ApplicationSpecForProviderProjectSelector
 */
export interface ApplicationSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationSpecForProviderProjectSelector#policy
   */
  readonly policy?: ApplicationSpecForProviderProjectSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderProjectSelector(obj: ApplicationSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderConfigRefPolicy
 */
export interface ApplicationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderConfigRefPolicy(obj: ApplicationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecProviderRefPolicy
 */
export interface ApplicationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecProviderRefPolicy(obj: ApplicationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRef
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRef(obj: ApplicationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToMetadata
 */
export interface ApplicationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToMetadata(obj: ApplicationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client secret to use for the authentication flow. The SHA-256 hash of the value is returned in the oauth2ClientSecretSha256 field.
 *
 * @schema ApplicationSpecForProviderIapOauth2ClientSecretSecretRef
 */
export interface ApplicationSpecForProviderIapOauth2ClientSecretSecretRef {
  /**
   * The key to select.
   *
   * @schema ApplicationSpecForProviderIapOauth2ClientSecretSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ApplicationSpecForProviderIapOauth2ClientSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationSpecForProviderIapOauth2ClientSecretSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderIapOauth2ClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderIapOauth2ClientSecretSecretRef(obj: ApplicationSpecForProviderIapOauth2ClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecForProviderProjectRefPolicy
 */
export interface ApplicationSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderProjectRefPolicy(obj: ApplicationSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationSpecForProviderProjectSelectorPolicy
 */
export interface ApplicationSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationSpecForProviderProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecForProviderProjectSelectorPolicy(obj: ApplicationSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolution
 */
export enum ApplicationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderConfigRefPolicyResolve
 */
export enum ApplicationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecProviderRefPolicyResolution
 */
export enum ApplicationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecProviderRefPolicyResolve
 */
export enum ApplicationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApplicationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApplicationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderProjectRefPolicyResolution
 */
export enum ApplicationSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderProjectRefPolicyResolve
 */
export enum ApplicationSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecForProviderProjectSelectorPolicyResolution
 */
export enum ApplicationSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecForProviderProjectSelectorPolicyResolve
 */
export enum ApplicationSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ApplicationURLDispatchRules is the Schema for the ApplicationURLDispatchRuless API. Rules to match an HTTP request and dispatch that request to a service.
 *
 * @schema ApplicationURLDispatchRules
 */
export class ApplicationUrlDispatchRules extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ApplicationURLDispatchRules"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appengine.gcp.upbound.io/v1beta1',
    kind: 'ApplicationURLDispatchRules',
  }

  /**
   * Renders a Kubernetes manifest for "ApplicationURLDispatchRules".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApplicationUrlDispatchRulesProps): any {
    return {
      ...ApplicationUrlDispatchRules.GVK,
      ...toJson_ApplicationUrlDispatchRulesProps(props),
    };
  }

  /**
   * Defines a "ApplicationURLDispatchRules" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApplicationUrlDispatchRulesProps) {
    super(scope, id, {
      ...ApplicationUrlDispatchRules.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApplicationUrlDispatchRules.GVK,
      ...toJson_ApplicationUrlDispatchRulesProps(resolved),
    };
  }
}

/**
 * ApplicationURLDispatchRules is the Schema for the ApplicationURLDispatchRuless API. Rules to match an HTTP request and dispatch that request to a service.
 *
 * @schema ApplicationURLDispatchRules
 */
export interface ApplicationUrlDispatchRulesProps {
  /**
   * @schema ApplicationURLDispatchRules#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ApplicationURLDispatchRulesSpec defines the desired state of ApplicationURLDispatchRules
   *
   * @schema ApplicationURLDispatchRules#spec
   */
  readonly spec: ApplicationUrlDispatchRulesSpec;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesProps(obj: ApplicationUrlDispatchRulesProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApplicationUrlDispatchRulesSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplicationURLDispatchRulesSpec defines the desired state of ApplicationURLDispatchRules
 *
 * @schema ApplicationUrlDispatchRulesSpec
 */
export interface ApplicationUrlDispatchRulesSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ApplicationUrlDispatchRulesSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApplicationUrlDispatchRulesSpecDeletionPolicy;

  /**
   * @schema ApplicationUrlDispatchRulesSpec#forProvider
   */
  readonly forProvider: ApplicationUrlDispatchRulesSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApplicationUrlDispatchRulesSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApplicationUrlDispatchRulesSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ApplicationUrlDispatchRulesSpec#providerRef
   */
  readonly providerRef?: ApplicationUrlDispatchRulesSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApplicationUrlDispatchRulesSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApplicationUrlDispatchRulesSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApplicationUrlDispatchRulesSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApplicationUrlDispatchRulesSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpec(obj: ApplicationUrlDispatchRulesSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApplicationUrlDispatchRulesSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ApplicationUrlDispatchRulesSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ApplicationUrlDispatchRulesSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ApplicationUrlDispatchRulesSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApplicationUrlDispatchRulesSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ApplicationUrlDispatchRulesSpecDeletionPolicy
 */
export enum ApplicationUrlDispatchRulesSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApplicationUrlDispatchRulesSpecForProvider
 */
export interface ApplicationUrlDispatchRulesSpecForProvider {
  /**
   * Rules to match an HTTP request and dispatch that request to a service. Structure is documented below.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProvider#dispatchRules
   */
  readonly dispatchRules: ApplicationUrlDispatchRulesSpecForProviderDispatchRules[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecForProvider(obj: ApplicationUrlDispatchRulesSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dispatchRules': obj.dispatchRules?.map(y => toJson_ApplicationUrlDispatchRulesSpecForProviderDispatchRules(y)),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApplicationUrlDispatchRulesSpecProviderConfigRef
 */
export interface ApplicationUrlDispatchRulesSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationUrlDispatchRulesSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationUrlDispatchRulesSpecProviderConfigRef#policy
   */
  readonly policy?: ApplicationUrlDispatchRulesSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecProviderConfigRef(obj: ApplicationUrlDispatchRulesSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationUrlDispatchRulesSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ApplicationUrlDispatchRulesSpecProviderRef
 */
export interface ApplicationUrlDispatchRulesSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationUrlDispatchRulesSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationUrlDispatchRulesSpecProviderRef#policy
   */
  readonly policy?: ApplicationUrlDispatchRulesSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecProviderRef(obj: ApplicationUrlDispatchRulesSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationUrlDispatchRulesSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsTo
 */
export interface ApplicationUrlDispatchRulesSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecPublishConnectionDetailsTo(obj: ApplicationUrlDispatchRulesSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApplicationUrlDispatchRulesSpecWriteConnectionSecretToRef
 */
export interface ApplicationUrlDispatchRulesSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApplicationUrlDispatchRulesSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApplicationUrlDispatchRulesSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecWriteConnectionSecretToRef(obj: ApplicationUrlDispatchRulesSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRules
 */
export interface ApplicationUrlDispatchRulesSpecForProviderDispatchRules {
  /**
   * Domain name to match against. The wildcard "" is supported if specified before a period: ".". Defaults to matching all domains: "*".
   *
   * @default matching all domains: "*".
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRules#domain
   */
  readonly domain?: string;

  /**
   * Pathname within the host. Must start with a "/". A single "*" can be included at the end of the path. The sum of the lengths of the domain and path may not exceed 100 characters.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRules#path
   */
  readonly path: string;

  /**
   * Pathname within the host. Must start with a "/". A single "*" can be included at the end of the path. The sum of the lengths of the domain and path may not exceed 100 characters.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRules#service
   */
  readonly service?: string;

  /**
   * Reference to a StandardAppVersion in appengine to populate service.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRules#serviceRef
   */
  readonly serviceRef?: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRef;

  /**
   * Selector for a StandardAppVersion in appengine to populate service.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRules#serviceSelector
   */
  readonly serviceSelector?: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelector;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecForProviderDispatchRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecForProviderDispatchRules(obj: ApplicationUrlDispatchRulesSpecForProviderDispatchRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'path': obj.path,
    'service': obj.service,
    'serviceRef': toJson_ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRef(obj.serviceRef),
    'serviceSelector': toJson_ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelector(obj.serviceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationUrlDispatchRulesSpecProviderConfigRefPolicy
 */
export interface ApplicationUrlDispatchRulesSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationUrlDispatchRulesSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationUrlDispatchRulesSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationUrlDispatchRulesSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationUrlDispatchRulesSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecProviderConfigRefPolicy(obj: ApplicationUrlDispatchRulesSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationUrlDispatchRulesSpecProviderRefPolicy
 */
export interface ApplicationUrlDispatchRulesSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationUrlDispatchRulesSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ApplicationUrlDispatchRulesSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationUrlDispatchRulesSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ApplicationUrlDispatchRulesSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecProviderRefPolicy(obj: ApplicationUrlDispatchRulesSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRef
 */
export interface ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRef(obj: ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToMetadata
 */
export interface ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToMetadata(obj: ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a StandardAppVersion in appengine to populate service.
 *
 * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRef
 */
export interface ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRef#policy
   */
  readonly policy?: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicy;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRef(obj: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a StandardAppVersion in appengine to populate service.
 *
 * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelector
 */
export interface ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelector#policy
   */
  readonly policy?: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicy;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelector(obj: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationUrlDispatchRulesSpecProviderConfigRefPolicyResolution
 */
export enum ApplicationUrlDispatchRulesSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationUrlDispatchRulesSpecProviderConfigRefPolicyResolve
 */
export enum ApplicationUrlDispatchRulesSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationUrlDispatchRulesSpecProviderRefPolicyResolution
 */
export enum ApplicationUrlDispatchRulesSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationUrlDispatchRulesSpecProviderRefPolicyResolve
 */
export enum ApplicationUrlDispatchRulesSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicy
 */
export interface ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicy#resolution
   */
  readonly resolution?: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicy#resolve
   */
  readonly resolve?: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicy(obj: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicy
 */
export interface ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicy#resolution
   */
  readonly resolution?: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicy#resolve
   */
  readonly resolve?: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicy(obj: ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApplicationUrlDispatchRulesSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicyResolution
 */
export enum ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicyResolve
 */
export enum ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicyResolution
 */
export enum ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicyResolve
 */
export enum ApplicationUrlDispatchRulesSpecForProviderDispatchRulesServiceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * FirewallRule is the Schema for the FirewallRules API. A single firewall rule that is evaluated against incoming traffic and provides an action to take on matched requests.
 *
 * @schema FirewallRule
 */
export class FirewallRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FirewallRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appengine.gcp.upbound.io/v1beta1',
    kind: 'FirewallRule',
  }

  /**
   * Renders a Kubernetes manifest for "FirewallRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FirewallRuleProps): any {
    return {
      ...FirewallRule.GVK,
      ...toJson_FirewallRuleProps(props),
    };
  }

  /**
   * Defines a "FirewallRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FirewallRuleProps) {
    super(scope, id, {
      ...FirewallRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...FirewallRule.GVK,
      ...toJson_FirewallRuleProps(resolved),
    };
  }
}

/**
 * FirewallRule is the Schema for the FirewallRules API. A single firewall rule that is evaluated against incoming traffic and provides an action to take on matched requests.
 *
 * @schema FirewallRule
 */
export interface FirewallRuleProps {
  /**
   * @schema FirewallRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FirewallRuleSpec defines the desired state of FirewallRule
   *
   * @schema FirewallRule#spec
   */
  readonly spec: FirewallRuleSpec;

}

/**
 * Converts an object of type 'FirewallRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleProps(obj: FirewallRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FirewallRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FirewallRuleSpec defines the desired state of FirewallRule
 *
 * @schema FirewallRuleSpec
 */
export interface FirewallRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema FirewallRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: FirewallRuleSpecDeletionPolicy;

  /**
   * @schema FirewallRuleSpec#forProvider
   */
  readonly forProvider: FirewallRuleSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FirewallRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: FirewallRuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FirewallRuleSpec#providerRef
   */
  readonly providerRef?: FirewallRuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FirewallRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FirewallRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FirewallRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FirewallRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FirewallRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpec(obj: FirewallRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FirewallRuleSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_FirewallRuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FirewallRuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FirewallRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FirewallRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema FirewallRuleSpecDeletionPolicy
 */
export enum FirewallRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FirewallRuleSpecForProvider
 */
export interface FirewallRuleSpecForProvider {
  /**
   * The action to take if this rule matches. Possible values are UNSPECIFIED_ACTION, ALLOW, and DENY.
   *
   * @schema FirewallRuleSpecForProvider#action
   */
  readonly action: string;

  /**
   * An optional string description of this rule.
   *
   * @schema FirewallRuleSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A positive integer that defines the order of rule evaluation. Rules with the lowest priority are evaluated first. A default rule at priority Int32.MaxValue matches all IPv4 and IPv6 traffic when no previous rule matches. Only the action of this rule can be modified by the user.
   *
   * @schema FirewallRuleSpecForProvider#priority
   */
  readonly priority?: number;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema FirewallRuleSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Application in appengine to populate project.
   *
   * @schema FirewallRuleSpecForProvider#projectRef
   */
  readonly projectRef?: FirewallRuleSpecForProviderProjectRef;

  /**
   * Selector for a Application in appengine to populate project.
   *
   * @schema FirewallRuleSpecForProvider#projectSelector
   */
  readonly projectSelector?: FirewallRuleSpecForProviderProjectSelector;

  /**
   * IP address or range, defined using CIDR notation, of requests that this rule applies to.
   *
   * @schema FirewallRuleSpecForProvider#sourceRange
   */
  readonly sourceRange: string;

}

/**
 * Converts an object of type 'FirewallRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecForProvider(obj: FirewallRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'description': obj.description,
    'priority': obj.priority,
    'project': obj.project,
    'projectRef': toJson_FirewallRuleSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_FirewallRuleSpecForProviderProjectSelector(obj.projectSelector),
    'sourceRange': obj.sourceRange,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FirewallRuleSpecProviderConfigRef
 */
export interface FirewallRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallRuleSpecProviderConfigRef#policy
   */
  readonly policy?: FirewallRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FirewallRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecProviderConfigRef(obj: FirewallRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FirewallRuleSpecProviderRef
 */
export interface FirewallRuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallRuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallRuleSpecProviderRef#policy
   */
  readonly policy?: FirewallRuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FirewallRuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecProviderRef(obj: FirewallRuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallRuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FirewallRuleSpecPublishConnectionDetailsTo
 */
export interface FirewallRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FirewallRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FirewallRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FirewallRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FirewallRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FirewallRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FirewallRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecPublishConnectionDetailsTo(obj: FirewallRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FirewallRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FirewallRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FirewallRuleSpecWriteConnectionSecretToRef
 */
export interface FirewallRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FirewallRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FirewallRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FirewallRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecWriteConnectionSecretToRef(obj: FirewallRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Application in appengine to populate project.
 *
 * @schema FirewallRuleSpecForProviderProjectRef
 */
export interface FirewallRuleSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallRuleSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallRuleSpecForProviderProjectRef#policy
   */
  readonly policy?: FirewallRuleSpecForProviderProjectRefPolicy;

}

/**
 * Converts an object of type 'FirewallRuleSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecForProviderProjectRef(obj: FirewallRuleSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallRuleSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Application in appengine to populate project.
 *
 * @schema FirewallRuleSpecForProviderProjectSelector
 */
export interface FirewallRuleSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FirewallRuleSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FirewallRuleSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FirewallRuleSpecForProviderProjectSelector#policy
   */
  readonly policy?: FirewallRuleSpecForProviderProjectSelectorPolicy;

}

/**
 * Converts an object of type 'FirewallRuleSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecForProviderProjectSelector(obj: FirewallRuleSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FirewallRuleSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallRuleSpecProviderConfigRefPolicy
 */
export interface FirewallRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecProviderConfigRefPolicy(obj: FirewallRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallRuleSpecProviderRefPolicy
 */
export interface FirewallRuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallRuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FirewallRuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallRuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FirewallRuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallRuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecProviderRefPolicy(obj: FirewallRuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FirewallRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface FirewallRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FirewallRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FirewallRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FirewallRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecPublishConnectionDetailsToConfigRef(obj: FirewallRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FirewallRuleSpecPublishConnectionDetailsToMetadata
 */
export interface FirewallRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FirewallRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FirewallRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FirewallRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecPublishConnectionDetailsToMetadata(obj: FirewallRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FirewallRuleSpecForProviderProjectRefPolicy
 */
export interface FirewallRuleSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallRuleSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: FirewallRuleSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallRuleSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: FirewallRuleSpecForProviderProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallRuleSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecForProviderProjectRefPolicy(obj: FirewallRuleSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FirewallRuleSpecForProviderProjectSelectorPolicy
 */
export interface FirewallRuleSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallRuleSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: FirewallRuleSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallRuleSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: FirewallRuleSpecForProviderProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FirewallRuleSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecForProviderProjectSelectorPolicy(obj: FirewallRuleSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallRuleSpecProviderConfigRefPolicyResolution
 */
export enum FirewallRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallRuleSpecProviderConfigRefPolicyResolve
 */
export enum FirewallRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallRuleSpecProviderRefPolicyResolution
 */
export enum FirewallRuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallRuleSpecProviderRefPolicyResolve
 */
export enum FirewallRuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallRuleSpecForProviderProjectRefPolicyResolution
 */
export enum FirewallRuleSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallRuleSpecForProviderProjectRefPolicyResolve
 */
export enum FirewallRuleSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallRuleSpecForProviderProjectSelectorPolicyResolution
 */
export enum FirewallRuleSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallRuleSpecForProviderProjectSelectorPolicyResolve
 */
export enum FirewallRuleSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FirewallRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceNetworkSettings is the Schema for the ServiceNetworkSettingss API. A NetworkSettings resource is a container for ingress settings for a version or service.
 *
 * @schema ServiceNetworkSettings
 */
export class ServiceNetworkSettings extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceNetworkSettings"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appengine.gcp.upbound.io/v1beta1',
    kind: 'ServiceNetworkSettings',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceNetworkSettings".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceNetworkSettingsProps): any {
    return {
      ...ServiceNetworkSettings.GVK,
      ...toJson_ServiceNetworkSettingsProps(props),
    };
  }

  /**
   * Defines a "ServiceNetworkSettings" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceNetworkSettingsProps) {
    super(scope, id, {
      ...ServiceNetworkSettings.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceNetworkSettings.GVK,
      ...toJson_ServiceNetworkSettingsProps(resolved),
    };
  }
}

/**
 * ServiceNetworkSettings is the Schema for the ServiceNetworkSettingss API. A NetworkSettings resource is a container for ingress settings for a version or service.
 *
 * @schema ServiceNetworkSettings
 */
export interface ServiceNetworkSettingsProps {
  /**
   * @schema ServiceNetworkSettings#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceNetworkSettingsSpec defines the desired state of ServiceNetworkSettings
   *
   * @schema ServiceNetworkSettings#spec
   */
  readonly spec: ServiceNetworkSettingsSpec;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsProps(obj: ServiceNetworkSettingsProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceNetworkSettingsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceNetworkSettingsSpec defines the desired state of ServiceNetworkSettings
 *
 * @schema ServiceNetworkSettingsSpec
 */
export interface ServiceNetworkSettingsSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ServiceNetworkSettingsSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceNetworkSettingsSpecDeletionPolicy;

  /**
   * @schema ServiceNetworkSettingsSpec#forProvider
   */
  readonly forProvider: ServiceNetworkSettingsSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceNetworkSettingsSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceNetworkSettingsSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ServiceNetworkSettingsSpec#providerRef
   */
  readonly providerRef?: ServiceNetworkSettingsSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceNetworkSettingsSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceNetworkSettingsSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceNetworkSettingsSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceNetworkSettingsSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpec(obj: ServiceNetworkSettingsSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceNetworkSettingsSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ServiceNetworkSettingsSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ServiceNetworkSettingsSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ServiceNetworkSettingsSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceNetworkSettingsSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ServiceNetworkSettingsSpecDeletionPolicy
 */
export enum ServiceNetworkSettingsSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceNetworkSettingsSpecForProvider
 */
export interface ServiceNetworkSettingsSpecForProvider {
  /**
   * Ingress settings for this service. Will apply to all versions. Structure is documented below.
   *
   * @schema ServiceNetworkSettingsSpecForProvider#networkSettings
   */
  readonly networkSettings: ServiceNetworkSettingsSpecForProviderNetworkSettings[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema ServiceNetworkSettingsSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The name of the service these settings apply to.
   *
   * @schema ServiceNetworkSettingsSpecForProvider#service
   */
  readonly service?: string;

  /**
   * Reference to a StandardAppVersion in appengine to populate service.
   *
   * @schema ServiceNetworkSettingsSpecForProvider#serviceRef
   */
  readonly serviceRef?: ServiceNetworkSettingsSpecForProviderServiceRef;

  /**
   * Selector for a StandardAppVersion in appengine to populate service.
   *
   * @schema ServiceNetworkSettingsSpecForProvider#serviceSelector
   */
  readonly serviceSelector?: ServiceNetworkSettingsSpecForProviderServiceSelector;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecForProvider(obj: ServiceNetworkSettingsSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'networkSettings': obj.networkSettings?.map(y => toJson_ServiceNetworkSettingsSpecForProviderNetworkSettings(y)),
    'project': obj.project,
    'service': obj.service,
    'serviceRef': toJson_ServiceNetworkSettingsSpecForProviderServiceRef(obj.serviceRef),
    'serviceSelector': toJson_ServiceNetworkSettingsSpecForProviderServiceSelector(obj.serviceSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceNetworkSettingsSpecProviderConfigRef
 */
export interface ServiceNetworkSettingsSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceNetworkSettingsSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceNetworkSettingsSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceNetworkSettingsSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecProviderConfigRef(obj: ServiceNetworkSettingsSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceNetworkSettingsSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ServiceNetworkSettingsSpecProviderRef
 */
export interface ServiceNetworkSettingsSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceNetworkSettingsSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceNetworkSettingsSpecProviderRef#policy
   */
  readonly policy?: ServiceNetworkSettingsSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecProviderRef(obj: ServiceNetworkSettingsSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceNetworkSettingsSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsTo
 */
export interface ServiceNetworkSettingsSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceNetworkSettingsSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecPublishConnectionDetailsTo(obj: ServiceNetworkSettingsSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceNetworkSettingsSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceNetworkSettingsSpecWriteConnectionSecretToRef
 */
export interface ServiceNetworkSettingsSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceNetworkSettingsSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceNetworkSettingsSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecWriteConnectionSecretToRef(obj: ServiceNetworkSettingsSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceNetworkSettingsSpecForProviderNetworkSettings
 */
export interface ServiceNetworkSettingsSpecForProviderNetworkSettings {
  /**
   * The ingress settings for version or service. Default value is INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED. Possible values are INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED, INGRESS_TRAFFIC_ALLOWED_ALL, INGRESS_TRAFFIC_ALLOWED_INTERNAL_ONLY, and INGRESS_TRAFFIC_ALLOWED_INTERNAL_AND_LB.
   *
   * @schema ServiceNetworkSettingsSpecForProviderNetworkSettings#ingressTrafficAllowed
   */
  readonly ingressTrafficAllowed?: string;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecForProviderNetworkSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecForProviderNetworkSettings(obj: ServiceNetworkSettingsSpecForProviderNetworkSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingressTrafficAllowed': obj.ingressTrafficAllowed,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a StandardAppVersion in appengine to populate service.
 *
 * @schema ServiceNetworkSettingsSpecForProviderServiceRef
 */
export interface ServiceNetworkSettingsSpecForProviderServiceRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceNetworkSettingsSpecForProviderServiceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceNetworkSettingsSpecForProviderServiceRef#policy
   */
  readonly policy?: ServiceNetworkSettingsSpecForProviderServiceRefPolicy;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecForProviderServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecForProviderServiceRef(obj: ServiceNetworkSettingsSpecForProviderServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceNetworkSettingsSpecForProviderServiceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a StandardAppVersion in appengine to populate service.
 *
 * @schema ServiceNetworkSettingsSpecForProviderServiceSelector
 */
export interface ServiceNetworkSettingsSpecForProviderServiceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceNetworkSettingsSpecForProviderServiceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceNetworkSettingsSpecForProviderServiceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceNetworkSettingsSpecForProviderServiceSelector#policy
   */
  readonly policy?: ServiceNetworkSettingsSpecForProviderServiceSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecForProviderServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecForProviderServiceSelector(obj: ServiceNetworkSettingsSpecForProviderServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceNetworkSettingsSpecForProviderServiceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceNetworkSettingsSpecProviderConfigRefPolicy
 */
export interface ServiceNetworkSettingsSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceNetworkSettingsSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceNetworkSettingsSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceNetworkSettingsSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceNetworkSettingsSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecProviderConfigRefPolicy(obj: ServiceNetworkSettingsSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceNetworkSettingsSpecProviderRefPolicy
 */
export interface ServiceNetworkSettingsSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceNetworkSettingsSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ServiceNetworkSettingsSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceNetworkSettingsSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ServiceNetworkSettingsSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecProviderRefPolicy(obj: ServiceNetworkSettingsSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRef(obj: ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceNetworkSettingsSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecPublishConnectionDetailsToMetadata(obj: ServiceNetworkSettingsSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceNetworkSettingsSpecForProviderServiceRefPolicy
 */
export interface ServiceNetworkSettingsSpecForProviderServiceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceNetworkSettingsSpecForProviderServiceRefPolicy#resolution
   */
  readonly resolution?: ServiceNetworkSettingsSpecForProviderServiceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceNetworkSettingsSpecForProviderServiceRefPolicy#resolve
   */
  readonly resolve?: ServiceNetworkSettingsSpecForProviderServiceRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecForProviderServiceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecForProviderServiceRefPolicy(obj: ServiceNetworkSettingsSpecForProviderServiceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceNetworkSettingsSpecForProviderServiceSelectorPolicy
 */
export interface ServiceNetworkSettingsSpecForProviderServiceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceNetworkSettingsSpecForProviderServiceSelectorPolicy#resolution
   */
  readonly resolution?: ServiceNetworkSettingsSpecForProviderServiceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceNetworkSettingsSpecForProviderServiceSelectorPolicy#resolve
   */
  readonly resolve?: ServiceNetworkSettingsSpecForProviderServiceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecForProviderServiceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecForProviderServiceSelectorPolicy(obj: ServiceNetworkSettingsSpecForProviderServiceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceNetworkSettingsSpecProviderConfigRefPolicyResolution
 */
export enum ServiceNetworkSettingsSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceNetworkSettingsSpecProviderConfigRefPolicyResolve
 */
export enum ServiceNetworkSettingsSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceNetworkSettingsSpecProviderRefPolicyResolution
 */
export enum ServiceNetworkSettingsSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceNetworkSettingsSpecProviderRefPolicyResolve
 */
export enum ServiceNetworkSettingsSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceNetworkSettingsSpecForProviderServiceRefPolicyResolution
 */
export enum ServiceNetworkSettingsSpecForProviderServiceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceNetworkSettingsSpecForProviderServiceRefPolicyResolve
 */
export enum ServiceNetworkSettingsSpecForProviderServiceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceNetworkSettingsSpecForProviderServiceSelectorPolicyResolution
 */
export enum ServiceNetworkSettingsSpecForProviderServiceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceNetworkSettingsSpecForProviderServiceSelectorPolicyResolve
 */
export enum ServiceNetworkSettingsSpecForProviderServiceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceNetworkSettingsSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StandardAppVersion is the Schema for the StandardAppVersions API. Standard App Version resource to create a new version of standard GAE Application.
 *
 * @schema StandardAppVersion
 */
export class StandardAppVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StandardAppVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appengine.gcp.upbound.io/v1beta1',
    kind: 'StandardAppVersion',
  }

  /**
   * Renders a Kubernetes manifest for "StandardAppVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StandardAppVersionProps): any {
    return {
      ...StandardAppVersion.GVK,
      ...toJson_StandardAppVersionProps(props),
    };
  }

  /**
   * Defines a "StandardAppVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StandardAppVersionProps) {
    super(scope, id, {
      ...StandardAppVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StandardAppVersion.GVK,
      ...toJson_StandardAppVersionProps(resolved),
    };
  }
}

/**
 * StandardAppVersion is the Schema for the StandardAppVersions API. Standard App Version resource to create a new version of standard GAE Application.
 *
 * @schema StandardAppVersion
 */
export interface StandardAppVersionProps {
  /**
   * @schema StandardAppVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StandardAppVersionSpec defines the desired state of StandardAppVersion
   *
   * @schema StandardAppVersion#spec
   */
  readonly spec: StandardAppVersionSpec;

}

/**
 * Converts an object of type 'StandardAppVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionProps(obj: StandardAppVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StandardAppVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StandardAppVersionSpec defines the desired state of StandardAppVersion
 *
 * @schema StandardAppVersionSpec
 */
export interface StandardAppVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema StandardAppVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: StandardAppVersionSpecDeletionPolicy;

  /**
   * @schema StandardAppVersionSpec#forProvider
   */
  readonly forProvider: StandardAppVersionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StandardAppVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: StandardAppVersionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StandardAppVersionSpec#providerRef
   */
  readonly providerRef?: StandardAppVersionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StandardAppVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StandardAppVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StandardAppVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StandardAppVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StandardAppVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpec(obj: StandardAppVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StandardAppVersionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_StandardAppVersionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StandardAppVersionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StandardAppVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StandardAppVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema StandardAppVersionSpecDeletionPolicy
 */
export enum StandardAppVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StandardAppVersionSpecForProvider
 */
export interface StandardAppVersionSpecForProvider {
  /**
   * Allows App Engine second generation runtimes to access the legacy bundled services.
   *
   * @schema StandardAppVersionSpecForProvider#appEngineApis
   */
  readonly appEngineApis?: boolean;

  /**
   * Automatic scaling is based on request rate, response latencies, and other application metrics. Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProvider#automaticScaling
   */
  readonly automaticScaling?: StandardAppVersionSpecForProviderAutomaticScaling[];

  /**
   * Basic scaling creates instances when your application receives requests. Each instance will be shut down when the application becomes idle. Basic scaling is ideal for work that is intermittent or driven by user activity. Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProvider#basicScaling
   */
  readonly basicScaling?: StandardAppVersionSpecForProviderBasicScaling[];

  /**
   * If set to true, the service will be deleted if it is the last version.
   *
   * @schema StandardAppVersionSpecForProvider#deleteServiceOnDestroy
   */
  readonly deleteServiceOnDestroy?: boolean;

  /**
   * Code and application artifacts that make up this version. Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProvider#deployment
   */
  readonly deployment: StandardAppVersionSpecForProviderDeployment[];

  /**
   * The entrypoint for the application. Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProvider#entrypoint
   */
  readonly entrypoint: StandardAppVersionSpecForProviderEntrypoint[];

  /**
   * Environment variables available to the application.
   *
   * @schema StandardAppVersionSpecForProvider#envVariables
   */
  readonly envVariables?: { [key: string]: string };

  /**
   * An ordered list of URL-matching patterns that should be applied to incoming requests. The first matching URL handles the request and other request handlers are not attempted. Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProvider#handlers
   */
  readonly handlers?: StandardAppVersionSpecForProviderHandlers[];

  /**
   * A list of the types of messages that this application is able to receive. Each value may be one of INBOUND_SERVICE_MAIL, INBOUND_SERVICE_MAIL_BOUNCE, INBOUND_SERVICE_XMPP_ERROR, INBOUND_SERVICE_XMPP_MESSAGE, INBOUND_SERVICE_XMPP_SUBSCRIBE, INBOUND_SERVICE_XMPP_PRESENCE, INBOUND_SERVICE_CHANNEL_PRESENCE, and INBOUND_SERVICE_WARMUP.
   *
   * @schema StandardAppVersionSpecForProvider#inboundServices
   */
  readonly inboundServices?: string[];

  /**
   * Instance class that is used to run this version. Valid values are AutomaticScaling: F1, F2, F4, F4_1G BasicScaling or ManualScaling: B1, B2, B4, B4_1G, B8 Defaults to F1 for AutomaticScaling and B2 for ManualScaling and BasicScaling. If no scaling is specified, AutomaticScaling is chosen.
   *
   * @default F1 for AutomaticScaling and B2 for ManualScaling and BasicScaling. If no scaling is specified, AutomaticScaling is chosen.
   * @schema StandardAppVersionSpecForProvider#instanceClass
   */
  readonly instanceClass?: string;

  /**
   * Configuration for third-party Python runtime libraries that are required by the application. Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProvider#libraries
   */
  readonly libraries?: StandardAppVersionSpecForProviderLibraries[];

  /**
   * A service with manual scaling runs continuously, allowing you to perform complex initialization and rely on the state of its memory over time. Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProvider#manualScaling
   */
  readonly manualScaling?: StandardAppVersionSpecForProviderManualScaling[];

  /**
   * If set to true, the application version will not be deleted.
   *
   * @schema StandardAppVersionSpecForProvider#noopOnDestroy
   */
  readonly noopOnDestroy?: boolean;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema StandardAppVersionSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Desired runtime. Example python27.
   *
   * @schema StandardAppVersionSpecForProvider#runtime
   */
  readonly runtime: string;

  /**
   * The version of the API in the given runtime environment. Please see the app.yaml reference for valid values at https://cloud.google.com/appengine/docs/standard/<language>/config/appref Substitute <language> with python, java, php, ruby, go or nodejs.
   *
   * @schema StandardAppVersionSpecForProvider#runtimeApiVersion
   */
  readonly runtimeApiVersion?: string;

  /**
   * AppEngine service resource
   *
   * @schema StandardAppVersionSpecForProvider#service
   */
  readonly service: string;

  /**
   * The identity that the deployed version will run as. Admin API will use the App Engine Appspot service account as default if this field is neither provided in app.yaml file nor through CLI flag.
   *
   * @schema StandardAppVersionSpecForProvider#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema StandardAppVersionSpecForProvider#serviceAccountRef
   */
  readonly serviceAccountRef?: StandardAppVersionSpecForProviderServiceAccountRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
   *
   * @schema StandardAppVersionSpecForProvider#serviceAccountSelector
   */
  readonly serviceAccountSelector?: StandardAppVersionSpecForProviderServiceAccountSelector;

  /**
   * Whether multiple requests can be dispatched to this version at once.
   *
   * @schema StandardAppVersionSpecForProvider#threadsafe
   */
  readonly threadsafe?: boolean;

  /**
   * Enables VPC connectivity for standard apps. Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProvider#vpcAccessConnector
   */
  readonly vpcAccessConnector?: StandardAppVersionSpecForProviderVpcAccessConnector[];

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProvider(obj: StandardAppVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appEngineApis': obj.appEngineApis,
    'automaticScaling': obj.automaticScaling?.map(y => toJson_StandardAppVersionSpecForProviderAutomaticScaling(y)),
    'basicScaling': obj.basicScaling?.map(y => toJson_StandardAppVersionSpecForProviderBasicScaling(y)),
    'deleteServiceOnDestroy': obj.deleteServiceOnDestroy,
    'deployment': obj.deployment?.map(y => toJson_StandardAppVersionSpecForProviderDeployment(y)),
    'entrypoint': obj.entrypoint?.map(y => toJson_StandardAppVersionSpecForProviderEntrypoint(y)),
    'envVariables': ((obj.envVariables) === undefined) ? undefined : (Object.entries(obj.envVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'handlers': obj.handlers?.map(y => toJson_StandardAppVersionSpecForProviderHandlers(y)),
    'inboundServices': obj.inboundServices?.map(y => y),
    'instanceClass': obj.instanceClass,
    'libraries': obj.libraries?.map(y => toJson_StandardAppVersionSpecForProviderLibraries(y)),
    'manualScaling': obj.manualScaling?.map(y => toJson_StandardAppVersionSpecForProviderManualScaling(y)),
    'noopOnDestroy': obj.noopOnDestroy,
    'project': obj.project,
    'runtime': obj.runtime,
    'runtimeApiVersion': obj.runtimeApiVersion,
    'service': obj.service,
    'serviceAccount': obj.serviceAccount,
    'serviceAccountRef': toJson_StandardAppVersionSpecForProviderServiceAccountRef(obj.serviceAccountRef),
    'serviceAccountSelector': toJson_StandardAppVersionSpecForProviderServiceAccountSelector(obj.serviceAccountSelector),
    'threadsafe': obj.threadsafe,
    'vpcAccessConnector': obj.vpcAccessConnector?.map(y => toJson_StandardAppVersionSpecForProviderVpcAccessConnector(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StandardAppVersionSpecProviderConfigRef
 */
export interface StandardAppVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StandardAppVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StandardAppVersionSpecProviderConfigRef#policy
   */
  readonly policy?: StandardAppVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StandardAppVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecProviderConfigRef(obj: StandardAppVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StandardAppVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StandardAppVersionSpecProviderRef
 */
export interface StandardAppVersionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StandardAppVersionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StandardAppVersionSpecProviderRef#policy
   */
  readonly policy?: StandardAppVersionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StandardAppVersionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecProviderRef(obj: StandardAppVersionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StandardAppVersionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StandardAppVersionSpecPublishConnectionDetailsTo
 */
export interface StandardAppVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StandardAppVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StandardAppVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StandardAppVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StandardAppVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StandardAppVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StandardAppVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecPublishConnectionDetailsTo(obj: StandardAppVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StandardAppVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StandardAppVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StandardAppVersionSpecWriteConnectionSecretToRef
 */
export interface StandardAppVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StandardAppVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StandardAppVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StandardAppVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecWriteConnectionSecretToRef(obj: StandardAppVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderAutomaticScaling
 */
export interface StandardAppVersionSpecForProviderAutomaticScaling {
  /**
   * Number of concurrent requests an automatic scaling instance can accept before the scheduler spawns a new instance. Defaults to a runtime-specific value.
   *
   * @default a runtime-specific value.
   * @schema StandardAppVersionSpecForProviderAutomaticScaling#maxConcurrentRequests
   */
  readonly maxConcurrentRequests?: number;

  /**
   * Maximum number of idle instances that should be maintained for this version.
   *
   * @schema StandardAppVersionSpecForProviderAutomaticScaling#maxIdleInstances
   */
  readonly maxIdleInstances?: number;

  /**
   * Maximum amount of time that a request should wait in the pending queue before starting a new instance to handle it. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema StandardAppVersionSpecForProviderAutomaticScaling#maxPendingLatency
   */
  readonly maxPendingLatency?: string;

  /**
   * Minimum number of idle instances that should be maintained for this version. Only applicable for the default version of a service.
   *
   * @schema StandardAppVersionSpecForProviderAutomaticScaling#minIdleInstances
   */
  readonly minIdleInstances?: number;

  /**
   * Minimum amount of time a request should wait in the pending queue before starting a new instance to handle it. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema StandardAppVersionSpecForProviderAutomaticScaling#minPendingLatency
   */
  readonly minPendingLatency?: string;

  /**
   * Scheduler settings for standard environment. Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProviderAutomaticScaling#standardSchedulerSettings
   */
  readonly standardSchedulerSettings?: StandardAppVersionSpecForProviderAutomaticScalingStandardSchedulerSettings[];

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderAutomaticScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderAutomaticScaling(obj: StandardAppVersionSpecForProviderAutomaticScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxConcurrentRequests': obj.maxConcurrentRequests,
    'maxIdleInstances': obj.maxIdleInstances,
    'maxPendingLatency': obj.maxPendingLatency,
    'minIdleInstances': obj.minIdleInstances,
    'minPendingLatency': obj.minPendingLatency,
    'standardSchedulerSettings': obj.standardSchedulerSettings?.map(y => toJson_StandardAppVersionSpecForProviderAutomaticScalingStandardSchedulerSettings(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderBasicScaling
 */
export interface StandardAppVersionSpecForProviderBasicScaling {
  /**
   * Duration of time after the last request that an instance must wait before the instance is shut down. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
   *
   * @default 900s.
   * @schema StandardAppVersionSpecForProviderBasicScaling#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of instances to create for this version. Must be in the range [1.0, 200.0].
   *
   * @schema StandardAppVersionSpecForProviderBasicScaling#maxInstances
   */
  readonly maxInstances: number;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderBasicScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderBasicScaling(obj: StandardAppVersionSpecForProviderBasicScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idleTimeout': obj.idleTimeout,
    'maxInstances': obj.maxInstances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderDeployment
 */
export interface StandardAppVersionSpecForProviderDeployment {
  /**
   * Manifest of the files stored in Google Cloud Storage that are included as part of this version. All files must be readable using the credentials supplied with this call. Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProviderDeployment#files
   */
  readonly files?: StandardAppVersionSpecForProviderDeploymentFiles[];

  /**
   * Zip File Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProviderDeployment#zip
   */
  readonly zip?: StandardAppVersionSpecForProviderDeploymentZip[];

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderDeployment(obj: StandardAppVersionSpecForProviderDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'files': obj.files?.map(y => toJson_StandardAppVersionSpecForProviderDeploymentFiles(y)),
    'zip': obj.zip?.map(y => toJson_StandardAppVersionSpecForProviderDeploymentZip(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderEntrypoint
 */
export interface StandardAppVersionSpecForProviderEntrypoint {
  /**
   * The format should be a shell command that can be fed to bash -c.
   *
   * @schema StandardAppVersionSpecForProviderEntrypoint#shell
   */
  readonly shell: string;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderEntrypoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderEntrypoint(obj: StandardAppVersionSpecForProviderEntrypoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'shell': obj.shell,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderHandlers
 */
export interface StandardAppVersionSpecForProviderHandlers {
  /**
   * Actions to take when the user is not logged in. Possible values are AUTH_FAIL_ACTION_REDIRECT and AUTH_FAIL_ACTION_UNAUTHORIZED.
   *
   * @schema StandardAppVersionSpecForProviderHandlers#authFailAction
   */
  readonly authFailAction?: string;

  /**
   * Methods to restrict access to a URL based on login status. Possible values are LOGIN_OPTIONAL, LOGIN_ADMIN, and LOGIN_REQUIRED.
   *
   * @schema StandardAppVersionSpecForProviderHandlers#login
   */
  readonly login?: string;

  /**
   * 30x code to use when performing redirects for the secure field. Possible values are REDIRECT_HTTP_RESPONSE_CODE_301, REDIRECT_HTTP_RESPONSE_CODE_302, REDIRECT_HTTP_RESPONSE_CODE_303, and REDIRECT_HTTP_RESPONSE_CODE_307.
   *
   * @schema StandardAppVersionSpecForProviderHandlers#redirectHttpResponseCode
   */
  readonly redirectHttpResponseCode?: string;

  /**
   * Executes a script to handle the requests that match this URL pattern. Only the auto value is supported for Node.js in the App Engine standard environment, for example "script:" "auto". Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProviderHandlers#script
   */
  readonly script?: StandardAppVersionSpecForProviderHandlersScript[];

  /**
   * Security (HTTPS) enforcement for this URL. Possible values are SECURE_DEFAULT, SECURE_NEVER, SECURE_OPTIONAL, and SECURE_ALWAYS.
   *
   * @schema StandardAppVersionSpecForProviderHandlers#securityLevel
   */
  readonly securityLevel?: string;

  /**
   * Files served directly to the user for a given URL, such as images, CSS stylesheets, or JavaScript source files. Static file handlers describe which files in the application directory are static files, and which URLs serve them. Structure is documented below.
   *
   * @schema StandardAppVersionSpecForProviderHandlers#staticFiles
   */
  readonly staticFiles?: StandardAppVersionSpecForProviderHandlersStaticFiles[];

  /**
   * URL prefix. Uses regular expression syntax, which means regexp special characters must be escaped, but should not contain groupings. All URLs that begin with this prefix are handled by this handler, using the portion of the URL after the prefix as part of the file path.
   *
   * @schema StandardAppVersionSpecForProviderHandlers#urlRegex
   */
  readonly urlRegex?: string;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderHandlers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderHandlers(obj: StandardAppVersionSpecForProviderHandlers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authFailAction': obj.authFailAction,
    'login': obj.login,
    'redirectHttpResponseCode': obj.redirectHttpResponseCode,
    'script': obj.script?.map(y => toJson_StandardAppVersionSpecForProviderHandlersScript(y)),
    'securityLevel': obj.securityLevel,
    'staticFiles': obj.staticFiles?.map(y => toJson_StandardAppVersionSpecForProviderHandlersStaticFiles(y)),
    'urlRegex': obj.urlRegex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderLibraries
 */
export interface StandardAppVersionSpecForProviderLibraries {
  /**
   * Name of the library. Example "django".
   *
   * @schema StandardAppVersionSpecForProviderLibraries#name
   */
  readonly name?: string;

  /**
   * Version of the library to select, or "latest".
   *
   * @schema StandardAppVersionSpecForProviderLibraries#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderLibraries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderLibraries(obj: StandardAppVersionSpecForProviderLibraries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderManualScaling
 */
export interface StandardAppVersionSpecForProviderManualScaling {
  /**
   * Number of instances to assign to the service at the start. Note: When managing the number of instances at runtime through the App Engine Admin API or the (now deprecated) Python 2 Modules API set_num_instances() you must use lifecycle.ignore_changes = ["manual_scaling"[0].instances] to prevent drift detection.
   *
   * @schema StandardAppVersionSpecForProviderManualScaling#instances
   */
  readonly instances: number;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderManualScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderManualScaling(obj: StandardAppVersionSpecForProviderManualScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instances': obj.instances,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema StandardAppVersionSpecForProviderServiceAccountRef
 */
export interface StandardAppVersionSpecForProviderServiceAccountRef {
  /**
   * Name of the referenced object.
   *
   * @schema StandardAppVersionSpecForProviderServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StandardAppVersionSpecForProviderServiceAccountRef#policy
   */
  readonly policy?: StandardAppVersionSpecForProviderServiceAccountRefPolicy;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderServiceAccountRef(obj: StandardAppVersionSpecForProviderServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StandardAppVersionSpecForProviderServiceAccountRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate serviceAccount.
 *
 * @schema StandardAppVersionSpecForProviderServiceAccountSelector
 */
export interface StandardAppVersionSpecForProviderServiceAccountSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StandardAppVersionSpecForProviderServiceAccountSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StandardAppVersionSpecForProviderServiceAccountSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StandardAppVersionSpecForProviderServiceAccountSelector#policy
   */
  readonly policy?: StandardAppVersionSpecForProviderServiceAccountSelectorPolicy;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderServiceAccountSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderServiceAccountSelector(obj: StandardAppVersionSpecForProviderServiceAccountSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StandardAppVersionSpecForProviderServiceAccountSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderVpcAccessConnector
 */
export interface StandardAppVersionSpecForProviderVpcAccessConnector {
  /**
   * The egress setting for the connector, controlling what traffic is diverted through it.
   *
   * @schema StandardAppVersionSpecForProviderVpcAccessConnector#egressSetting
   */
  readonly egressSetting?: string;

  /**
   * Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
   *
   * @schema StandardAppVersionSpecForProviderVpcAccessConnector#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderVpcAccessConnector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderVpcAccessConnector(obj: StandardAppVersionSpecForProviderVpcAccessConnector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressSetting': obj.egressSetting,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StandardAppVersionSpecProviderConfigRefPolicy
 */
export interface StandardAppVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StandardAppVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StandardAppVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StandardAppVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StandardAppVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StandardAppVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecProviderConfigRefPolicy(obj: StandardAppVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StandardAppVersionSpecProviderRefPolicy
 */
export interface StandardAppVersionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StandardAppVersionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StandardAppVersionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StandardAppVersionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StandardAppVersionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StandardAppVersionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecProviderRefPolicy(obj: StandardAppVersionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StandardAppVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface StandardAppVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StandardAppVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StandardAppVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StandardAppVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecPublishConnectionDetailsToConfigRef(obj: StandardAppVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StandardAppVersionSpecPublishConnectionDetailsToMetadata
 */
export interface StandardAppVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StandardAppVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StandardAppVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StandardAppVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StandardAppVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecPublishConnectionDetailsToMetadata(obj: StandardAppVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderAutomaticScalingStandardSchedulerSettings
 */
export interface StandardAppVersionSpecForProviderAutomaticScalingStandardSchedulerSettings {
  /**
   * Maximum number of instances to run for this version. Set to zero to disable maxInstances configuration.
   *
   * @schema StandardAppVersionSpecForProviderAutomaticScalingStandardSchedulerSettings#maxInstances
   */
  readonly maxInstances?: number;

  /**
   * Minimum number of instances to run for this version. Set to zero to disable minInstances configuration.
   *
   * @schema StandardAppVersionSpecForProviderAutomaticScalingStandardSchedulerSettings#minInstances
   */
  readonly minInstances?: number;

  /**
   * Target CPU utilization ratio to maintain when scaling. Should be a value in the range [0.50, 0.95], zero, or a negative value.
   *
   * @schema StandardAppVersionSpecForProviderAutomaticScalingStandardSchedulerSettings#targetCpuUtilization
   */
  readonly targetCpuUtilization?: number;

  /**
   * Target throughput utilization ratio to maintain when scaling. Should be a value in the range [0.50, 0.95], zero, or a negative value.
   *
   * @schema StandardAppVersionSpecForProviderAutomaticScalingStandardSchedulerSettings#targetThroughputUtilization
   */
  readonly targetThroughputUtilization?: number;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderAutomaticScalingStandardSchedulerSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderAutomaticScalingStandardSchedulerSettings(obj: StandardAppVersionSpecForProviderAutomaticScalingStandardSchedulerSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxInstances': obj.maxInstances,
    'minInstances': obj.minInstances,
    'targetCpuUtilization': obj.targetCpuUtilization,
    'targetThroughputUtilization': obj.targetThroughputUtilization,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderDeploymentFiles
 */
export interface StandardAppVersionSpecForProviderDeploymentFiles {
  /**
   * Full Serverless VPC Access Connector name e.g. /projects/my-project/locations/us-central1/connectors/c1.
   *
   * @schema StandardAppVersionSpecForProviderDeploymentFiles#name
   */
  readonly name: string;

  /**
   * SHA1 checksum of the file
   *
   * @schema StandardAppVersionSpecForProviderDeploymentFiles#sha1Sum
   */
  readonly sha1Sum?: string;

  /**
   * Source URL
   *
   * @schema StandardAppVersionSpecForProviderDeploymentFiles#sourceUrl
   */
  readonly sourceUrl: string;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderDeploymentFiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderDeploymentFiles(obj: StandardAppVersionSpecForProviderDeploymentFiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sha1Sum': obj.sha1Sum,
    'sourceUrl': obj.sourceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderDeploymentZip
 */
export interface StandardAppVersionSpecForProviderDeploymentZip {
  /**
   * files count
   *
   * @schema StandardAppVersionSpecForProviderDeploymentZip#filesCount
   */
  readonly filesCount?: number;

  /**
   * Source URL
   *
   * @schema StandardAppVersionSpecForProviderDeploymentZip#sourceUrl
   */
  readonly sourceUrl: string;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderDeploymentZip' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderDeploymentZip(obj: StandardAppVersionSpecForProviderDeploymentZip | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filesCount': obj.filesCount,
    'sourceUrl': obj.sourceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderHandlersScript
 */
export interface StandardAppVersionSpecForProviderHandlersScript {
  /**
   * Path to the script from the application root directory.
   *
   * @schema StandardAppVersionSpecForProviderHandlersScript#scriptPath
   */
  readonly scriptPath: string;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderHandlersScript' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderHandlersScript(obj: StandardAppVersionSpecForProviderHandlersScript | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scriptPath': obj.scriptPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StandardAppVersionSpecForProviderHandlersStaticFiles
 */
export interface StandardAppVersionSpecForProviderHandlersStaticFiles {
  /**
   * Whether files should also be uploaded as code data. By default, files declared in static file handlers are uploaded as static data and are only served to end users; they cannot be read by the application. If enabled, uploads are charged against both your code and static data storage resource quotas.
   *
   * @schema StandardAppVersionSpecForProviderHandlersStaticFiles#applicationReadable
   */
  readonly applicationReadable?: boolean;

  /**
   * Time a static file served by this handler should be cached by web proxies and browsers. A duration in seconds with up to nine fractional digits, terminated by 's'. Example "3.5s".
   *
   * @schema StandardAppVersionSpecForProviderHandlersStaticFiles#expiration
   */
  readonly expiration?: string;

  /**
   * HTTP headers to use for all responses from these URLs. An object containing a list of "key:value" value pairs.".
   *
   * @schema StandardAppVersionSpecForProviderHandlersStaticFiles#httpHeaders
   */
  readonly httpHeaders?: { [key: string]: string };

  /**
   * MIME type used to serve all files served by this handler. Defaults to file-specific MIME types, which are derived from each file's filename extension.
   *
   * @default file-specific MIME types, which are derived from each file's filename extension.
   * @schema StandardAppVersionSpecForProviderHandlersStaticFiles#mimeType
   */
  readonly mimeType?: string;

  /**
   * Path to the static files matched by the URL pattern, from the application root directory. The path can refer to text matched in groupings in the URL pattern.
   *
   * @schema StandardAppVersionSpecForProviderHandlersStaticFiles#path
   */
  readonly path?: string;

  /**
   * Whether this handler should match the request if the file referenced by the handler does not exist.
   *
   * @schema StandardAppVersionSpecForProviderHandlersStaticFiles#requireMatchingFile
   */
  readonly requireMatchingFile?: boolean;

  /**
   * Regular expression that matches the file paths for all files that should be referenced by this handler.
   *
   * @schema StandardAppVersionSpecForProviderHandlersStaticFiles#uploadPathRegex
   */
  readonly uploadPathRegex?: string;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderHandlersStaticFiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderHandlersStaticFiles(obj: StandardAppVersionSpecForProviderHandlersStaticFiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationReadable': obj.applicationReadable,
    'expiration': obj.expiration,
    'httpHeaders': ((obj.httpHeaders) === undefined) ? undefined : (Object.entries(obj.httpHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'mimeType': obj.mimeType,
    'path': obj.path,
    'requireMatchingFile': obj.requireMatchingFile,
    'uploadPathRegex': obj.uploadPathRegex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StandardAppVersionSpecForProviderServiceAccountRefPolicy
 */
export interface StandardAppVersionSpecForProviderServiceAccountRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StandardAppVersionSpecForProviderServiceAccountRefPolicy#resolution
   */
  readonly resolution?: StandardAppVersionSpecForProviderServiceAccountRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StandardAppVersionSpecForProviderServiceAccountRefPolicy#resolve
   */
  readonly resolve?: StandardAppVersionSpecForProviderServiceAccountRefPolicyResolve;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderServiceAccountRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderServiceAccountRefPolicy(obj: StandardAppVersionSpecForProviderServiceAccountRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StandardAppVersionSpecForProviderServiceAccountSelectorPolicy
 */
export interface StandardAppVersionSpecForProviderServiceAccountSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StandardAppVersionSpecForProviderServiceAccountSelectorPolicy#resolution
   */
  readonly resolution?: StandardAppVersionSpecForProviderServiceAccountSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StandardAppVersionSpecForProviderServiceAccountSelectorPolicy#resolve
   */
  readonly resolve?: StandardAppVersionSpecForProviderServiceAccountSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StandardAppVersionSpecForProviderServiceAccountSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecForProviderServiceAccountSelectorPolicy(obj: StandardAppVersionSpecForProviderServiceAccountSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StandardAppVersionSpecProviderConfigRefPolicyResolution
 */
export enum StandardAppVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StandardAppVersionSpecProviderConfigRefPolicyResolve
 */
export enum StandardAppVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StandardAppVersionSpecProviderRefPolicyResolution
 */
export enum StandardAppVersionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StandardAppVersionSpecProviderRefPolicyResolve
 */
export enum StandardAppVersionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StandardAppVersionSpecForProviderServiceAccountRefPolicyResolution
 */
export enum StandardAppVersionSpecForProviderServiceAccountRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StandardAppVersionSpecForProviderServiceAccountRefPolicyResolve
 */
export enum StandardAppVersionSpecForProviderServiceAccountRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StandardAppVersionSpecForProviderServiceAccountSelectorPolicyResolution
 */
export enum StandardAppVersionSpecForProviderServiceAccountSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StandardAppVersionSpecForProviderServiceAccountSelectorPolicyResolve
 */
export enum StandardAppVersionSpecForProviderServiceAccountSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StandardAppVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

