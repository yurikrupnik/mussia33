// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * CognitoIdentityPoolProviderPrincipalTag is the Schema for the CognitoIdentityPoolProviderPrincipalTags API. Provides an AWS Cognito Identity Principal Mapping.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTag
 */
export class CognitoIdentityPoolProviderPrincipalTag extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CognitoIdentityPoolProviderPrincipalTag"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidentity.aws.upbound.io/v1beta1',
    kind: 'CognitoIdentityPoolProviderPrincipalTag',
  }

  /**
   * Renders a Kubernetes manifest for "CognitoIdentityPoolProviderPrincipalTag".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CognitoIdentityPoolProviderPrincipalTagProps): any {
    return {
      ...CognitoIdentityPoolProviderPrincipalTag.GVK,
      ...toJson_CognitoIdentityPoolProviderPrincipalTagProps(props),
    };
  }

  /**
   * Defines a "CognitoIdentityPoolProviderPrincipalTag" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CognitoIdentityPoolProviderPrincipalTagProps) {
    super(scope, id, {
      ...CognitoIdentityPoolProviderPrincipalTag.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CognitoIdentityPoolProviderPrincipalTag.GVK,
      ...toJson_CognitoIdentityPoolProviderPrincipalTagProps(resolved),
    };
  }
}

/**
 * CognitoIdentityPoolProviderPrincipalTag is the Schema for the CognitoIdentityPoolProviderPrincipalTags API. Provides an AWS Cognito Identity Principal Mapping.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTag
 */
export interface CognitoIdentityPoolProviderPrincipalTagProps {
  /**
   * @schema CognitoIdentityPoolProviderPrincipalTag#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CognitoIdentityPoolProviderPrincipalTagSpec defines the desired state of CognitoIdentityPoolProviderPrincipalTag
   *
   * @schema CognitoIdentityPoolProviderPrincipalTag#spec
   */
  readonly spec: CognitoIdentityPoolProviderPrincipalTagSpec;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagProps(obj: CognitoIdentityPoolProviderPrincipalTagProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CognitoIdentityPoolProviderPrincipalTagSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CognitoIdentityPoolProviderPrincipalTagSpec defines the desired state of CognitoIdentityPoolProviderPrincipalTag
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpec
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpec#deletionPolicy
   */
  readonly deletionPolicy?: CognitoIdentityPoolProviderPrincipalTagSpecDeletionPolicy;

  /**
   * @schema CognitoIdentityPoolProviderPrincipalTagSpec#forProvider
   */
  readonly forProvider: CognitoIdentityPoolProviderPrincipalTagSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpec#providerConfigRef
   */
  readonly providerConfigRef?: CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpec#providerRef
   */
  readonly providerRef?: CognitoIdentityPoolProviderPrincipalTagSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CognitoIdentityPoolProviderPrincipalTagSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpec(obj: CognitoIdentityPoolProviderPrincipalTagSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CognitoIdentityPoolProviderPrincipalTagSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CognitoIdentityPoolProviderPrincipalTagSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecDeletionPolicy
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProvider
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecForProvider {
  /**
   * An identity pool ID.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProvider#identityPoolId
   */
  readonly identityPoolId?: string;

  /**
   * Reference to a Pool in cognitoidentity to populate identityPoolId.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProvider#identityPoolIdRef
   */
  readonly identityPoolIdRef?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRef;

  /**
   * Selector for a Pool in cognitoidentity to populate identityPoolId.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProvider#identityPoolIdSelector
   */
  readonly identityPoolIdSelector?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelector;

  /**
   * The name of the identity provider.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProvider#identityProviderName
   */
  readonly identityProviderName?: string;

  /**
   * Reference to a UserPool in cognitoidp to populate identityProviderName.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProvider#identityProviderNameRef
   */
  readonly identityProviderNameRef?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRef;

  /**
   * Selector for a UserPool in cognitoidp to populate identityProviderName.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProvider#identityProviderNameSelector
   */
  readonly identityProviderNameSelector?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelector;

  /**
   * String to string map of variables.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProvider#principalTags
   */
  readonly principalTags?: { [key: string]: string };

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProvider#region
   */
  readonly region: string;

  /**
   * :  use default (username and clientID) attribute mappings.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProvider#useDefaults
   */
  readonly useDefaults?: boolean;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProvider(obj: CognitoIdentityPoolProviderPrincipalTagSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identityPoolId': obj.identityPoolId,
    'identityPoolIdRef': toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRef(obj.identityPoolIdRef),
    'identityPoolIdSelector': toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelector(obj.identityPoolIdSelector),
    'identityProviderName': obj.identityProviderName,
    'identityProviderNameRef': toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRef(obj.identityProviderNameRef),
    'identityProviderNameSelector': toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelector(obj.identityProviderNameSelector),
    'principalTags': ((obj.principalTags) === undefined) ? undefined : (Object.entries(obj.principalTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'useDefaults': obj.useDefaults,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRef
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRef#policy
   */
  readonly policy?: CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRef(obj: CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderRef
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderRef#policy
   */
  readonly policy?: CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecProviderRef(obj: CognitoIdentityPoolProviderPrincipalTagSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsTo
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsTo(obj: CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecWriteConnectionSecretToRef
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecWriteConnectionSecretToRef(obj: CognitoIdentityPoolProviderPrincipalTagSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Pool in cognitoidentity to populate identityPoolId.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRef
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRef#policy
   */
  readonly policy?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicy;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRef(obj: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Pool in cognitoidentity to populate identityPoolId.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelector
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelector#policy
   */
  readonly policy?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelector(obj: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool in cognitoidp to populate identityProviderName.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRef
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRef#policy
   */
  readonly policy?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicy;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRef(obj: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool in cognitoidp to populate identityProviderName.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelector
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelector#policy
   */
  readonly policy?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicy;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelector(obj: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicy
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicy(obj: CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicy
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicy(obj: CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRef
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRef(obj: CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToMetadata
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToMetadata(obj: CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicy
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicy#resolution
   */
  readonly resolution?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicy#resolve
   */
  readonly resolve?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicy(obj: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicy
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicy(obj: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicy
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicy#resolution
   */
  readonly resolution?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicy#resolve
   */
  readonly resolve?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicy(obj: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicy
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicy#resolution
   */
  readonly resolution?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicy#resolve
   */
  readonly resolve?: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicy(obj: CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicyResolution
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicyResolve
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicyResolution
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicyResolve
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicy(obj: CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicyResolution
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicyResolve
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicyResolution
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicyResolve
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicyResolution
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicyResolve
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicyResolution
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicyResolve
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecForProviderIdentityProviderNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CognitoIdentityPoolProviderPrincipalTagSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Pool is the Schema for the Pools API. Provides an AWS Cognito Identity Pool.
 *
 * @schema Pool
 */
export class Pool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Pool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidentity.aws.upbound.io/v1beta1',
    kind: 'Pool',
  }

  /**
   * Renders a Kubernetes manifest for "Pool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PoolProps): any {
    return {
      ...Pool.GVK,
      ...toJson_PoolProps(props),
    };
  }

  /**
   * Defines a "Pool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PoolProps) {
    super(scope, id, {
      ...Pool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Pool.GVK,
      ...toJson_PoolProps(resolved),
    };
  }
}

/**
 * Pool is the Schema for the Pools API. Provides an AWS Cognito Identity Pool.
 *
 * @schema Pool
 */
export interface PoolProps {
  /**
   * @schema Pool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PoolSpec defines the desired state of Pool
   *
   * @schema Pool#spec
   */
  readonly spec: PoolSpec;

}

/**
 * Converts an object of type 'PoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolProps(obj: PoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PoolSpec defines the desired state of Pool
 *
 * @schema PoolSpec
 */
export interface PoolSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema PoolSpec#deletionPolicy
   */
  readonly deletionPolicy?: PoolSpecDeletionPolicy;

  /**
   * @schema PoolSpec#forProvider
   */
  readonly forProvider: PoolSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PoolSpec#providerConfigRef
   */
  readonly providerConfigRef?: PoolSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PoolSpec#providerRef
   */
  readonly providerRef?: PoolSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PoolSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PoolSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PoolSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PoolSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpec(obj: PoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PoolSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_PoolSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PoolSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PoolSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PoolSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema PoolSpecDeletionPolicy
 */
export enum PoolSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PoolSpecForProvider
 */
export interface PoolSpecForProvider {
  /**
   * Enables or disables the classic / basic authentication flow. Default is false.
   *
   * @default false.
   * @schema PoolSpecForProvider#allowClassicFlow
   */
  readonly allowClassicFlow?: boolean;

  /**
   * Whether the identity pool supports unauthenticated logins or not.
   *
   * @schema PoolSpecForProvider#allowUnauthenticatedIdentities
   */
  readonly allowUnauthenticatedIdentities?: boolean;

  /**
   * An array of Amazon Cognito Identity user pools and their client IDs.
   *
   * @schema PoolSpecForProvider#cognitoIdentityProviders
   */
  readonly cognitoIdentityProviders?: PoolSpecForProviderCognitoIdentityProviders[];

  /**
   * The "domain" by which Cognito will refer to your users. This name acts as a placeholder that allows your backend and the Cognito service to communicate about the developer provider.
   *
   * @schema PoolSpecForProvider#developerProviderName
   */
  readonly developerProviderName?: string;

  /**
   * The Cognito Identity Pool name.
   *
   * @schema PoolSpecForProvider#identityPoolName
   */
  readonly identityPoolName: string;

  /**
   * Set of OpendID Connect provider ARNs.
   *
   * @schema PoolSpecForProvider#openidConnectProviderArns
   */
  readonly openidConnectProviderArns?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PoolSpecForProvider#region
   */
  readonly region: string;

  /**
   * An array of Amazon Resource Names (ARNs) of the SAML provider for your identity.
   *
   * @schema PoolSpecForProvider#samlProviderArns
   */
  readonly samlProviderArns?: string[];

  /**
   * References to SAMLProvider in iam to populate samlProviderArns.
   *
   * @schema PoolSpecForProvider#samlProviderArnsRefs
   */
  readonly samlProviderArnsRefs?: PoolSpecForProviderSamlProviderArnsRefs[];

  /**
   * Selector for a list of SAMLProvider in iam to populate samlProviderArns.
   *
   * @schema PoolSpecForProvider#samlProviderArnsSelector
   */
  readonly samlProviderArnsSelector?: PoolSpecForProviderSamlProviderArnsSelector;

  /**
   * Key-Value pairs mapping provider names to provider app IDs.
   *
   * @schema PoolSpecForProvider#supportedLoginProviders
   */
  readonly supportedLoginProviders?: { [key: string]: string };

  /**
   * Key-value map of resource tags.
   *
   * @schema PoolSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PoolSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecForProvider(obj: PoolSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowClassicFlow': obj.allowClassicFlow,
    'allowUnauthenticatedIdentities': obj.allowUnauthenticatedIdentities,
    'cognitoIdentityProviders': obj.cognitoIdentityProviders?.map(y => toJson_PoolSpecForProviderCognitoIdentityProviders(y)),
    'developerProviderName': obj.developerProviderName,
    'identityPoolName': obj.identityPoolName,
    'openidConnectProviderArns': obj.openidConnectProviderArns?.map(y => y),
    'region': obj.region,
    'samlProviderArns': obj.samlProviderArns?.map(y => y),
    'samlProviderArnsRefs': obj.samlProviderArnsRefs?.map(y => toJson_PoolSpecForProviderSamlProviderArnsRefs(y)),
    'samlProviderArnsSelector': toJson_PoolSpecForProviderSamlProviderArnsSelector(obj.samlProviderArnsSelector),
    'supportedLoginProviders': ((obj.supportedLoginProviders) === undefined) ? undefined : (Object.entries(obj.supportedLoginProviders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PoolSpecProviderConfigRef
 */
export interface PoolSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PoolSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PoolSpecProviderConfigRef#policy
   */
  readonly policy?: PoolSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PoolSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecProviderConfigRef(obj: PoolSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PoolSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PoolSpecProviderRef
 */
export interface PoolSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PoolSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PoolSpecProviderRef#policy
   */
  readonly policy?: PoolSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PoolSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecProviderRef(obj: PoolSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PoolSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PoolSpecPublishConnectionDetailsTo
 */
export interface PoolSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PoolSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PoolSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PoolSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PoolSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PoolSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PoolSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecPublishConnectionDetailsTo(obj: PoolSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PoolSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PoolSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PoolSpecWriteConnectionSecretToRef
 */
export interface PoolSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PoolSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PoolSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PoolSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecWriteConnectionSecretToRef(obj: PoolSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PoolSpecForProviderCognitoIdentityProviders
 */
export interface PoolSpecForProviderCognitoIdentityProviders {
  /**
   * The client ID for the Amazon Cognito Identity User Pool.
   *
   * @schema PoolSpecForProviderCognitoIdentityProviders#clientId
   */
  readonly clientId?: string;

  /**
   * Reference to a UserPoolClient in cognitoidp to populate clientId.
   *
   * @schema PoolSpecForProviderCognitoIdentityProviders#clientIdRef
   */
  readonly clientIdRef?: PoolSpecForProviderCognitoIdentityProvidersClientIdRef;

  /**
   * Selector for a UserPoolClient in cognitoidp to populate clientId.
   *
   * @schema PoolSpecForProviderCognitoIdentityProviders#clientIdSelector
   */
  readonly clientIdSelector?: PoolSpecForProviderCognitoIdentityProvidersClientIdSelector;

  /**
   * The provider name for an Amazon Cognito Identity User Pool.
   *
   * @schema PoolSpecForProviderCognitoIdentityProviders#providerName
   */
  readonly providerName?: string;

  /**
   * Whether server-side token validation is enabled for the identity provider’s token or not.
   *
   * @schema PoolSpecForProviderCognitoIdentityProviders#serverSideTokenCheck
   */
  readonly serverSideTokenCheck?: boolean;

}

/**
 * Converts an object of type 'PoolSpecForProviderCognitoIdentityProviders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecForProviderCognitoIdentityProviders(obj: PoolSpecForProviderCognitoIdentityProviders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'clientIdRef': toJson_PoolSpecForProviderCognitoIdentityProvidersClientIdRef(obj.clientIdRef),
    'clientIdSelector': toJson_PoolSpecForProviderCognitoIdentityProvidersClientIdSelector(obj.clientIdSelector),
    'providerName': obj.providerName,
    'serverSideTokenCheck': obj.serverSideTokenCheck,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema PoolSpecForProviderSamlProviderArnsRefs
 */
export interface PoolSpecForProviderSamlProviderArnsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema PoolSpecForProviderSamlProviderArnsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PoolSpecForProviderSamlProviderArnsRefs#policy
   */
  readonly policy?: PoolSpecForProviderSamlProviderArnsRefsPolicy;

}

/**
 * Converts an object of type 'PoolSpecForProviderSamlProviderArnsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecForProviderSamlProviderArnsRefs(obj: PoolSpecForProviderSamlProviderArnsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PoolSpecForProviderSamlProviderArnsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SAMLProvider in iam to populate samlProviderArns.
 *
 * @schema PoolSpecForProviderSamlProviderArnsSelector
 */
export interface PoolSpecForProviderSamlProviderArnsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PoolSpecForProviderSamlProviderArnsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PoolSpecForProviderSamlProviderArnsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PoolSpecForProviderSamlProviderArnsSelector#policy
   */
  readonly policy?: PoolSpecForProviderSamlProviderArnsSelectorPolicy;

}

/**
 * Converts an object of type 'PoolSpecForProviderSamlProviderArnsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecForProviderSamlProviderArnsSelector(obj: PoolSpecForProviderSamlProviderArnsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PoolSpecForProviderSamlProviderArnsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PoolSpecProviderConfigRefPolicy
 */
export interface PoolSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PoolSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PoolSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PoolSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecProviderConfigRefPolicy(obj: PoolSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PoolSpecProviderRefPolicy
 */
export interface PoolSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PoolSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PoolSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PoolSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecProviderRefPolicy(obj: PoolSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PoolSpecPublishConnectionDetailsToConfigRef
 */
export interface PoolSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PoolSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PoolSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PoolSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PoolSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecPublishConnectionDetailsToConfigRef(obj: PoolSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PoolSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PoolSpecPublishConnectionDetailsToMetadata
 */
export interface PoolSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PoolSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PoolSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PoolSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PoolSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecPublishConnectionDetailsToMetadata(obj: PoolSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPoolClient in cognitoidp to populate clientId.
 *
 * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdRef
 */
export interface PoolSpecForProviderCognitoIdentityProvidersClientIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdRef#policy
   */
  readonly policy?: PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicy;

}

/**
 * Converts an object of type 'PoolSpecForProviderCognitoIdentityProvidersClientIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecForProviderCognitoIdentityProvidersClientIdRef(obj: PoolSpecForProviderCognitoIdentityProvidersClientIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPoolClient in cognitoidp to populate clientId.
 *
 * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdSelector
 */
export interface PoolSpecForProviderCognitoIdentityProvidersClientIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdSelector#policy
   */
  readonly policy?: PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicy;

}

/**
 * Converts an object of type 'PoolSpecForProviderCognitoIdentityProvidersClientIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecForProviderCognitoIdentityProvidersClientIdSelector(obj: PoolSpecForProviderCognitoIdentityProvidersClientIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PoolSpecForProviderSamlProviderArnsRefsPolicy
 */
export interface PoolSpecForProviderSamlProviderArnsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolSpecForProviderSamlProviderArnsRefsPolicy#resolution
   */
  readonly resolution?: PoolSpecForProviderSamlProviderArnsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolSpecForProviderSamlProviderArnsRefsPolicy#resolve
   */
  readonly resolve?: PoolSpecForProviderSamlProviderArnsRefsPolicyResolve;

}

/**
 * Converts an object of type 'PoolSpecForProviderSamlProviderArnsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecForProviderSamlProviderArnsRefsPolicy(obj: PoolSpecForProviderSamlProviderArnsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PoolSpecForProviderSamlProviderArnsSelectorPolicy
 */
export interface PoolSpecForProviderSamlProviderArnsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolSpecForProviderSamlProviderArnsSelectorPolicy#resolution
   */
  readonly resolution?: PoolSpecForProviderSamlProviderArnsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolSpecForProviderSamlProviderArnsSelectorPolicy#resolve
   */
  readonly resolve?: PoolSpecForProviderSamlProviderArnsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PoolSpecForProviderSamlProviderArnsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecForProviderSamlProviderArnsSelectorPolicy(obj: PoolSpecForProviderSamlProviderArnsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolSpecProviderConfigRefPolicyResolution
 */
export enum PoolSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolSpecProviderConfigRefPolicyResolve
 */
export enum PoolSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolSpecProviderRefPolicyResolution
 */
export enum PoolSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolSpecProviderRefPolicyResolve
 */
export enum PoolSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PoolSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PoolSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PoolSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PoolSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PoolSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecPublishConnectionDetailsToConfigRefPolicy(obj: PoolSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicy
 */
export interface PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicy#resolution
   */
  readonly resolution?: PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicy#resolve
   */
  readonly resolve?: PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicy(obj: PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicy
 */
export interface PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicy#resolution
   */
  readonly resolution?: PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicy#resolve
   */
  readonly resolve?: PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicy(obj: PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolSpecForProviderSamlProviderArnsRefsPolicyResolution
 */
export enum PoolSpecForProviderSamlProviderArnsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolSpecForProviderSamlProviderArnsRefsPolicyResolve
 */
export enum PoolSpecForProviderSamlProviderArnsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolSpecForProviderSamlProviderArnsSelectorPolicyResolution
 */
export enum PoolSpecForProviderSamlProviderArnsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolSpecForProviderSamlProviderArnsSelectorPolicyResolve
 */
export enum PoolSpecForProviderSamlProviderArnsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PoolSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PoolSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicyResolution
 */
export enum PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicyResolve
 */
export enum PoolSpecForProviderCognitoIdentityProvidersClientIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicyResolution
 */
export enum PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicyResolve
 */
export enum PoolSpecForProviderCognitoIdentityProvidersClientIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PoolRolesAttachment is the Schema for the PoolRolesAttachments API. Provides an AWS Cognito Identity Pool Roles Attachment.
 *
 * @schema PoolRolesAttachment
 */
export class PoolRolesAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PoolRolesAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidentity.aws.upbound.io/v1beta1',
    kind: 'PoolRolesAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "PoolRolesAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PoolRolesAttachmentProps): any {
    return {
      ...PoolRolesAttachment.GVK,
      ...toJson_PoolRolesAttachmentProps(props),
    };
  }

  /**
   * Defines a "PoolRolesAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PoolRolesAttachmentProps) {
    super(scope, id, {
      ...PoolRolesAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PoolRolesAttachment.GVK,
      ...toJson_PoolRolesAttachmentProps(resolved),
    };
  }
}

/**
 * PoolRolesAttachment is the Schema for the PoolRolesAttachments API. Provides an AWS Cognito Identity Pool Roles Attachment.
 *
 * @schema PoolRolesAttachment
 */
export interface PoolRolesAttachmentProps {
  /**
   * @schema PoolRolesAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PoolRolesAttachmentSpec defines the desired state of PoolRolesAttachment
   *
   * @schema PoolRolesAttachment#spec
   */
  readonly spec: PoolRolesAttachmentSpec;

}

/**
 * Converts an object of type 'PoolRolesAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentProps(obj: PoolRolesAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PoolRolesAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PoolRolesAttachmentSpec defines the desired state of PoolRolesAttachment
 *
 * @schema PoolRolesAttachmentSpec
 */
export interface PoolRolesAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema PoolRolesAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: PoolRolesAttachmentSpecDeletionPolicy;

  /**
   * @schema PoolRolesAttachmentSpec#forProvider
   */
  readonly forProvider: PoolRolesAttachmentSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PoolRolesAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: PoolRolesAttachmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PoolRolesAttachmentSpec#providerRef
   */
  readonly providerRef?: PoolRolesAttachmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PoolRolesAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PoolRolesAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PoolRolesAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PoolRolesAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpec(obj: PoolRolesAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PoolRolesAttachmentSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_PoolRolesAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PoolRolesAttachmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PoolRolesAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PoolRolesAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema PoolRolesAttachmentSpecDeletionPolicy
 */
export enum PoolRolesAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PoolRolesAttachmentSpecForProvider
 */
export interface PoolRolesAttachmentSpecForProvider {
  /**
   * An identity pool ID in the format REGION_GUID.
   *
   * @schema PoolRolesAttachmentSpecForProvider#identityPoolId
   */
  readonly identityPoolId?: string;

  /**
   * Reference to a Pool in cognitoidentity to populate identityPoolId.
   *
   * @schema PoolRolesAttachmentSpecForProvider#identityPoolIdRef
   */
  readonly identityPoolIdRef?: PoolRolesAttachmentSpecForProviderIdentityPoolIdRef;

  /**
   * Selector for a Pool in cognitoidentity to populate identityPoolId.
   *
   * @schema PoolRolesAttachmentSpecForProvider#identityPoolIdSelector
   */
  readonly identityPoolIdSelector?: PoolRolesAttachmentSpecForProviderIdentityPoolIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PoolRolesAttachmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * A List of Role Mapping.
   *
   * @schema PoolRolesAttachmentSpecForProvider#roleMapping
   */
  readonly roleMapping?: PoolRolesAttachmentSpecForProviderRoleMapping[];

  /**
   * The map of roles associated with this pool. For a given role, the key will be either "authenticated" or "unauthenticated" and the value will be the Role ARN.
   *
   * @schema PoolRolesAttachmentSpecForProvider#roles
   */
  readonly roles: { [key: string]: string };

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecForProvider(obj: PoolRolesAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identityPoolId': obj.identityPoolId,
    'identityPoolIdRef': toJson_PoolRolesAttachmentSpecForProviderIdentityPoolIdRef(obj.identityPoolIdRef),
    'identityPoolIdSelector': toJson_PoolRolesAttachmentSpecForProviderIdentityPoolIdSelector(obj.identityPoolIdSelector),
    'region': obj.region,
    'roleMapping': obj.roleMapping?.map(y => toJson_PoolRolesAttachmentSpecForProviderRoleMapping(y)),
    'roles': ((obj.roles) === undefined) ? undefined : (Object.entries(obj.roles).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PoolRolesAttachmentSpecProviderConfigRef
 */
export interface PoolRolesAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PoolRolesAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PoolRolesAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: PoolRolesAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecProviderConfigRef(obj: PoolRolesAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PoolRolesAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PoolRolesAttachmentSpecProviderRef
 */
export interface PoolRolesAttachmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PoolRolesAttachmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PoolRolesAttachmentSpecProviderRef#policy
   */
  readonly policy?: PoolRolesAttachmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecProviderRef(obj: PoolRolesAttachmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PoolRolesAttachmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PoolRolesAttachmentSpecPublishConnectionDetailsTo
 */
export interface PoolRolesAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PoolRolesAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PoolRolesAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PoolRolesAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PoolRolesAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecPublishConnectionDetailsTo(obj: PoolRolesAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PoolRolesAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PoolRolesAttachmentSpecWriteConnectionSecretToRef
 */
export interface PoolRolesAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PoolRolesAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PoolRolesAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecWriteConnectionSecretToRef(obj: PoolRolesAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Pool in cognitoidentity to populate identityPoolId.
 *
 * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdRef
 */
export interface PoolRolesAttachmentSpecForProviderIdentityPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdRef#policy
   */
  readonly policy?: PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicy;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecForProviderIdentityPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecForProviderIdentityPoolIdRef(obj: PoolRolesAttachmentSpecForProviderIdentityPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Pool in cognitoidentity to populate identityPoolId.
 *
 * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdSelector
 */
export interface PoolRolesAttachmentSpecForProviderIdentityPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdSelector#policy
   */
  readonly policy?: PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecForProviderIdentityPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecForProviderIdentityPoolIdSelector(obj: PoolRolesAttachmentSpecForProviderIdentityPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PoolRolesAttachmentSpecForProviderRoleMapping
 */
export interface PoolRolesAttachmentSpecForProviderRoleMapping {
  /**
   * Specifies the action to be taken if either no rules match the claim value for the Rules type, or there is no cognito:preferred_role claim and there are multiple cognito:roles matches for the Token type. Required if you specify Token or Rules as the Type.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMapping#ambiguousRoleResolution
   */
  readonly ambiguousRoleResolution?: string;

  /**
   * A string identifying the identity provider, for example, "graph.facebook.com" or "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id". Depends on cognito_identity_providers set on aws_cognito_identity_pool resource or a aws_cognito_identity_provider resource.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMapping#identityProvider
   */
  readonly identityProvider: string;

  /**
   * The Rules Configuration to be used for mapping users to roles. You can specify up to 25 rules per identity provider. Rules are evaluated in order. The first one to match specifies the role.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMapping#mappingRule
   */
  readonly mappingRule?: PoolRolesAttachmentSpecForProviderRoleMappingMappingRule[];

  /**
   * The role mapping type.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMapping#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecForProviderRoleMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecForProviderRoleMapping(obj: PoolRolesAttachmentSpecForProviderRoleMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ambiguousRoleResolution': obj.ambiguousRoleResolution,
    'identityProvider': obj.identityProvider,
    'mappingRule': obj.mappingRule?.map(y => toJson_PoolRolesAttachmentSpecForProviderRoleMappingMappingRule(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PoolRolesAttachmentSpecProviderConfigRefPolicy
 */
export interface PoolRolesAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolRolesAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PoolRolesAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolRolesAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PoolRolesAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecProviderConfigRefPolicy(obj: PoolRolesAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PoolRolesAttachmentSpecProviderRefPolicy
 */
export interface PoolRolesAttachmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolRolesAttachmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PoolRolesAttachmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolRolesAttachmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PoolRolesAttachmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecProviderRefPolicy(obj: PoolRolesAttachmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRef(obj: PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface PoolRolesAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecPublishConnectionDetailsToMetadata(obj: PoolRolesAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicy
 */
export interface PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicy#resolution
   */
  readonly resolution?: PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicy#resolve
   */
  readonly resolve?: PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicy(obj: PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicy
 */
export interface PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicy(obj: PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRule
 */
export interface PoolRolesAttachmentSpecForProviderRoleMappingMappingRule {
  /**
   * The claim name that must be present in the token, for example, "isAdmin" or "paid".
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRule#claim
   */
  readonly claim: string;

  /**
   * The match condition that specifies how closely the claim value in the IdP token must match Value.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRule#matchType
   */
  readonly matchType: string;

  /**
   * The role ARN.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRule#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRule#roleArnRef
   */
  readonly roleArnRef?: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRule#roleArnSelector
   */
  readonly roleArnSelector?: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelector;

  /**
   * A brief string that the claim must match, for example, "paid" or "yes".
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRule#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecForProviderRoleMappingMappingRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecForProviderRoleMappingMappingRule(obj: PoolRolesAttachmentSpecForProviderRoleMappingMappingRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claim': obj.claim,
    'matchType': obj.matchType,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelector(obj.roleArnSelector),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolRolesAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum PoolRolesAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolRolesAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum PoolRolesAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolRolesAttachmentSpecProviderRefPolicyResolution
 */
export enum PoolRolesAttachmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolRolesAttachmentSpecProviderRefPolicyResolve
 */
export enum PoolRolesAttachmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicyResolution
 */
export enum PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicyResolve
 */
export enum PoolRolesAttachmentSpecForProviderIdentityPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicyResolution
 */
export enum PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicyResolve
 */
export enum PoolRolesAttachmentSpecForProviderIdentityPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRef
 */
export interface PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRef#policy
   */
  readonly policy?: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicy;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRef(obj: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelector
 */
export interface PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelector#policy
   */
  readonly policy?: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelector(obj: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PoolRolesAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicy
 */
export interface PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicy#resolution
   */
  readonly resolution?: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicy#resolve
   */
  readonly resolve?: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicy(obj: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicy
 */
export interface PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicy(obj: PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicyResolution
 */
export enum PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicyResolve
 */
export enum PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicyResolution
 */
export enum PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicyResolve
 */
export enum PoolRolesAttachmentSpecForProviderRoleMappingMappingRuleRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

