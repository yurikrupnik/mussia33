// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Cluster is the Schema for the Clusters API. Provides an Neptune Cluster Resource
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'neptune.aws.upbound.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API. Provides an Neptune Cluster Resource
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#managementPolicy
   */
  readonly managementPolicy?: ClusterSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterSpec#providerRef
   */
  readonly providerRef?: ClusterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * Specifies whether upgrades between different major versions are allowed. You must set it to true when providing an engine_version parameter that uses a different major version than the DB cluster's current version. Default is false.
   *
   * @default false.
   * @schema ClusterSpecForProvider#allowMajorVersionUpgrade
   */
  readonly allowMajorVersionUpgrade?: boolean;

  /**
   * Specifies whether any cluster modifications are applied immediately, or during the next maintenance window. Default is false.
   *
   * @default false.
   * @schema ClusterSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * A list of EC2 Availability Zones that instances in the Neptune cluster can be created in.
   *
   * @schema ClusterSpecForProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * The days to retain backups for. Default 1
   *
   * @schema ClusterSpecForProvider#backupRetentionPeriod
   */
  readonly backupRetentionPeriod?: number;

  /**
   * If set to true, tags are copied to any snapshot of the DB cluster that is created.
   *
   * @schema ClusterSpecForProvider#copyTagsToSnapshot
   */
  readonly copyTagsToSnapshot?: boolean;

  /**
   * A value that indicates whether the DB cluster has deletion protection enabled.The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled.
   *
   * @schema ClusterSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * A list of the log types this DB cluster is configured to export to Cloudwatch Logs. Currently only supports audit.
   *
   * @schema ClusterSpecForProvider#enableCloudwatchLogsExports
   */
  readonly enableCloudwatchLogsExports?: string[];

  /**
   * The name of the database engine to be used for this Neptune cluster. Defaults to neptune.
   *
   * @default neptune.
   * @schema ClusterSpecForProvider#engine
   */
  readonly engine?: string;

  /**
   * The database engine version.
   *
   * @schema ClusterSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The name of your final Neptune snapshot when this Neptune cluster is deleted. If omitted, no final snapshot will be made.
   *
   * @schema ClusterSpecForProvider#finalSnapshotIdentifier
   */
  readonly finalSnapshotIdentifier?: string;

  /**
   * The global cluster identifier specified on aws_neptune_global_cluster.
   *
   * @schema ClusterSpecForProvider#globalClusterIdentifier
   */
  readonly globalClusterIdentifier?: string;

  /**
   * Specifies whether or not mappings of AWS Identity and Access Management (IAM) accounts to database accounts is enabled.
   *
   * @schema ClusterSpecForProvider#iamDatabaseAuthenticationEnabled
   */
  readonly iamDatabaseAuthenticationEnabled?: boolean;

  /**
   * References to Role in iam to populate iamRoles.
   *
   * @schema ClusterSpecForProvider#iamRoleRefs
   */
  readonly iamRoleRefs?: ClusterSpecForProviderIamRoleRefs[];

  /**
   * Selector for a list of Role in iam to populate iamRoles.
   *
   * @schema ClusterSpecForProvider#iamRoleSelector
   */
  readonly iamRoleSelector?: ClusterSpecForProviderIamRoleSelector;

  /**
   * A List of ARNs for the IAM roles to associate to the Neptune Cluster.
   *
   * @schema ClusterSpecForProvider#iamRoles
   */
  readonly iamRoles?: string[];

  /**
   * The ARN for the KMS encryption key. When specifying kms_key_arn, storage_encrypted needs to be set to true.
   *
   * @schema ClusterSpecForProvider#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema ClusterSpecForProvider#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: ClusterSpecForProviderKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema ClusterSpecForProvider#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: ClusterSpecForProviderKmsKeyArnSelector;

  /**
   * A cluster parameter group to associate with the cluster.
   *
   * @schema ClusterSpecForProvider#neptuneClusterParameterGroupName
   */
  readonly neptuneClusterParameterGroupName?: string;

  /**
   * Reference to a ClusterParameterGroup to populate neptuneClusterParameterGroupName.
   *
   * @schema ClusterSpecForProvider#neptuneClusterParameterGroupNameRef
   */
  readonly neptuneClusterParameterGroupNameRef?: ClusterSpecForProviderNeptuneClusterParameterGroupNameRef;

  /**
   * Selector for a ClusterParameterGroup to populate neptuneClusterParameterGroupName.
   *
   * @schema ClusterSpecForProvider#neptuneClusterParameterGroupNameSelector
   */
  readonly neptuneClusterParameterGroupNameSelector?: ClusterSpecForProviderNeptuneClusterParameterGroupNameSelector;

  /**
   * The name of the DB parameter group to apply to all instances of the DB cluster.
   *
   * @schema ClusterSpecForProvider#neptuneInstanceParameterGroupName
   */
  readonly neptuneInstanceParameterGroupName?: string;

  /**
   * A Neptune subnet group to associate with this Neptune instance.
   *
   * @schema ClusterSpecForProvider#neptuneSubnetGroupName
   */
  readonly neptuneSubnetGroupName?: string;

  /**
   * Reference to a SubnetGroup to populate neptuneSubnetGroupName.
   *
   * @schema ClusterSpecForProvider#neptuneSubnetGroupNameRef
   */
  readonly neptuneSubnetGroupNameRef?: ClusterSpecForProviderNeptuneSubnetGroupNameRef;

  /**
   * Selector for a SubnetGroup to populate neptuneSubnetGroupName.
   *
   * @schema ClusterSpecForProvider#neptuneSubnetGroupNameSelector
   */
  readonly neptuneSubnetGroupNameSelector?: ClusterSpecForProviderNeptuneSubnetGroupNameSelector;

  /**
   * The port on which the Neptune accepts connections. Default is 8182.
   *
   * @default 8182.
   * @schema ClusterSpecForProvider#port
   */
  readonly port?: number;

  /**
   * The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter. Time in UTC. Default: A 30-minute window selected at random from an 8-hour block of time per regionE.g., 04:00-09:00
   *
   * @schema ClusterSpecForProvider#preferredBackupWindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The weekly time range during which system maintenance can occur, in (UTC) e.g., wed:04:00-wed:04:30
   *
   * @schema ClusterSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN of a source Neptune cluster or Neptune instance if this Neptune cluster is to be created as a Read Replica.
   *
   * @schema ClusterSpecForProvider#replicationSourceIdentifier
   */
  readonly replicationSourceIdentifier?: string;

  /**
   * Reference to a Cluster to populate replicationSourceIdentifier.
   *
   * @schema ClusterSpecForProvider#replicationSourceIdentifierRef
   */
  readonly replicationSourceIdentifierRef?: ClusterSpecForProviderReplicationSourceIdentifierRef;

  /**
   * Selector for a Cluster to populate replicationSourceIdentifier.
   *
   * @schema ClusterSpecForProvider#replicationSourceIdentifierSelector
   */
  readonly replicationSourceIdentifierSelector?: ClusterSpecForProviderReplicationSourceIdentifierSelector;

  /**
   * If set, create the Neptune cluster as a serverless one. See Serverless for example block attributes.
   *
   * @schema ClusterSpecForProvider#serverlessV2ScalingConfiguration
   */
  readonly serverlessV2ScalingConfiguration?: ClusterSpecForProviderServerlessV2ScalingConfiguration[];

  /**
   * Determines whether a final Neptune snapshot is created before the Neptune cluster is deleted. If true is specified, no Neptune snapshot is created. If false is specified, a Neptune snapshot is created before the Neptune cluster is deleted, using the value from final_snapshot_identifier. Default is false.
   *
   * @default false.
   * @schema ClusterSpecForProvider#skipFinalSnapshot
   */
  readonly skipFinalSnapshot?: boolean;

  /**
   * Specifies whether or not to create this cluster from a snapshot. You can use either the name or ARN when specifying a Neptune cluster snapshot, or the ARN when specifying a Neptune snapshot.
   *
   * @schema ClusterSpecForProvider#snapshotIdentifier
   */
  readonly snapshotIdentifier?: string;

  /**
   * Reference to a ClusterSnapshot to populate snapshotIdentifier.
   *
   * @schema ClusterSpecForProvider#snapshotIdentifierRef
   */
  readonly snapshotIdentifierRef?: ClusterSpecForProviderSnapshotIdentifierRef;

  /**
   * Selector for a ClusterSnapshot to populate snapshotIdentifier.
   *
   * @schema ClusterSpecForProvider#snapshotIdentifierSelector
   */
  readonly snapshotIdentifierSelector?: ClusterSpecForProviderSnapshotIdentifierSelector;

  /**
   * Specifies whether the Neptune cluster is encrypted. The default is false if not specified.
   *
   * @schema ClusterSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIdRefs
   */
  readonly vpcSecurityGroupIdRefs?: ClusterSpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIdSelector
   */
  readonly vpcSecurityGroupIdSelector?: ClusterSpecForProviderVpcSecurityGroupIdSelector;

  /**
   * List of VPC security groups to associate with the Cluster
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIds
   */
  readonly vpcSecurityGroupIds?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowMajorVersionUpgrade': obj.allowMajorVersionUpgrade,
    'applyImmediately': obj.applyImmediately,
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'backupRetentionPeriod': obj.backupRetentionPeriod,
    'copyTagsToSnapshot': obj.copyTagsToSnapshot,
    'deletionProtection': obj.deletionProtection,
    'enableCloudwatchLogsExports': obj.enableCloudwatchLogsExports?.map(y => y),
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'finalSnapshotIdentifier': obj.finalSnapshotIdentifier,
    'globalClusterIdentifier': obj.globalClusterIdentifier,
    'iamDatabaseAuthenticationEnabled': obj.iamDatabaseAuthenticationEnabled,
    'iamRoleRefs': obj.iamRoleRefs?.map(y => toJson_ClusterSpecForProviderIamRoleRefs(y)),
    'iamRoleSelector': toJson_ClusterSpecForProviderIamRoleSelector(obj.iamRoleSelector),
    'iamRoles': obj.iamRoles?.map(y => y),
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_ClusterSpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_ClusterSpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'neptuneClusterParameterGroupName': obj.neptuneClusterParameterGroupName,
    'neptuneClusterParameterGroupNameRef': toJson_ClusterSpecForProviderNeptuneClusterParameterGroupNameRef(obj.neptuneClusterParameterGroupNameRef),
    'neptuneClusterParameterGroupNameSelector': toJson_ClusterSpecForProviderNeptuneClusterParameterGroupNameSelector(obj.neptuneClusterParameterGroupNameSelector),
    'neptuneInstanceParameterGroupName': obj.neptuneInstanceParameterGroupName,
    'neptuneSubnetGroupName': obj.neptuneSubnetGroupName,
    'neptuneSubnetGroupNameRef': toJson_ClusterSpecForProviderNeptuneSubnetGroupNameRef(obj.neptuneSubnetGroupNameRef),
    'neptuneSubnetGroupNameSelector': toJson_ClusterSpecForProviderNeptuneSubnetGroupNameSelector(obj.neptuneSubnetGroupNameSelector),
    'port': obj.port,
    'preferredBackupWindow': obj.preferredBackupWindow,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'region': obj.region,
    'replicationSourceIdentifier': obj.replicationSourceIdentifier,
    'replicationSourceIdentifierRef': toJson_ClusterSpecForProviderReplicationSourceIdentifierRef(obj.replicationSourceIdentifierRef),
    'replicationSourceIdentifierSelector': toJson_ClusterSpecForProviderReplicationSourceIdentifierSelector(obj.replicationSourceIdentifierSelector),
    'serverlessV2ScalingConfiguration': obj.serverlessV2ScalingConfiguration?.map(y => toJson_ClusterSpecForProviderServerlessV2ScalingConfiguration(y)),
    'skipFinalSnapshot': obj.skipFinalSnapshot,
    'snapshotIdentifier': obj.snapshotIdentifier,
    'snapshotIdentifierRef': toJson_ClusterSpecForProviderSnapshotIdentifierRef(obj.snapshotIdentifierRef),
    'snapshotIdentifierSelector': toJson_ClusterSpecForProviderSnapshotIdentifierSelector(obj.snapshotIdentifierSelector),
    'storageEncrypted': obj.storageEncrypted,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcSecurityGroupIdRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_ClusterSpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIdSelector': toJson_ClusterSpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIds': obj.vpcSecurityGroupIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecManagementPolicy
 */
export enum ClusterSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterSpecProviderRef
 */
export interface ClusterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderRef#policy
   */
  readonly policy?: ClusterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRef(obj: ClusterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderIamRoleRefs
 */
export interface ClusterSpecForProviderIamRoleRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderIamRoleRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderIamRoleRefs#policy
   */
  readonly policy?: ClusterSpecForProviderIamRoleRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleRefs(obj: ClusterSpecForProviderIamRoleRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderIamRoleRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Role in iam to populate iamRoles.
 *
 * @schema ClusterSpecForProviderIamRoleSelector
 */
export interface ClusterSpecForProviderIamRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderIamRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderIamRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderIamRoleSelector#policy
   */
  readonly policy?: ClusterSpecForProviderIamRoleSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleSelector(obj: ClusterSpecForProviderIamRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderIamRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema ClusterSpecForProviderKmsKeyArnRef
 */
export interface ClusterSpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: ClusterSpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyArnRef(obj: ClusterSpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema ClusterSpecForProviderKmsKeyArnSelector
 */
export interface ClusterSpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: ClusterSpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyArnSelector(obj: ClusterSpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ClusterParameterGroup to populate neptuneClusterParameterGroupName.
 *
 * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameRef
 */
export interface ClusterSpecForProviderNeptuneClusterParameterGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameRef#policy
   */
  readonly policy?: ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderNeptuneClusterParameterGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderNeptuneClusterParameterGroupNameRef(obj: ClusterSpecForProviderNeptuneClusterParameterGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ClusterParameterGroup to populate neptuneClusterParameterGroupName.
 *
 * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameSelector
 */
export interface ClusterSpecForProviderNeptuneClusterParameterGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameSelector#policy
   */
  readonly policy?: ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderNeptuneClusterParameterGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderNeptuneClusterParameterGroupNameSelector(obj: ClusterSpecForProviderNeptuneClusterParameterGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a SubnetGroup to populate neptuneSubnetGroupName.
 *
 * @schema ClusterSpecForProviderNeptuneSubnetGroupNameRef
 */
export interface ClusterSpecForProviderNeptuneSubnetGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderNeptuneSubnetGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderNeptuneSubnetGroupNameRef#policy
   */
  readonly policy?: ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderNeptuneSubnetGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderNeptuneSubnetGroupNameRef(obj: ClusterSpecForProviderNeptuneSubnetGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a SubnetGroup to populate neptuneSubnetGroupName.
 *
 * @schema ClusterSpecForProviderNeptuneSubnetGroupNameSelector
 */
export interface ClusterSpecForProviderNeptuneSubnetGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderNeptuneSubnetGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderNeptuneSubnetGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderNeptuneSubnetGroupNameSelector#policy
   */
  readonly policy?: ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderNeptuneSubnetGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderNeptuneSubnetGroupNameSelector(obj: ClusterSpecForProviderNeptuneSubnetGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate replicationSourceIdentifier.
 *
 * @schema ClusterSpecForProviderReplicationSourceIdentifierRef
 */
export interface ClusterSpecForProviderReplicationSourceIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderReplicationSourceIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderReplicationSourceIdentifierRef#policy
   */
  readonly policy?: ClusterSpecForProviderReplicationSourceIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderReplicationSourceIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderReplicationSourceIdentifierRef(obj: ClusterSpecForProviderReplicationSourceIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderReplicationSourceIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate replicationSourceIdentifier.
 *
 * @schema ClusterSpecForProviderReplicationSourceIdentifierSelector
 */
export interface ClusterSpecForProviderReplicationSourceIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderReplicationSourceIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderReplicationSourceIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderReplicationSourceIdentifierSelector#policy
   */
  readonly policy?: ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderReplicationSourceIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderReplicationSourceIdentifierSelector(obj: ClusterSpecForProviderReplicationSourceIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderServerlessV2ScalingConfiguration
 */
export interface ClusterSpecForProviderServerlessV2ScalingConfiguration {
  /**
   * : (default: 128) The maximum Neptune Capacity Units (NCUs) for this cluster. Must be lower or equal than 128. See AWS Documentation for more details.
   *
   * @schema ClusterSpecForProviderServerlessV2ScalingConfiguration#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * : (default: 2.5) The minimum Neptune Capacity Units (NCUs) for this cluster. Must be greater or equal than 1. See AWS Documentation for more details.
   *
   * @schema ClusterSpecForProviderServerlessV2ScalingConfiguration#minCapacity
   */
  readonly minCapacity?: number;

}

/**
 * Converts an object of type 'ClusterSpecForProviderServerlessV2ScalingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderServerlessV2ScalingConfiguration(obj: ClusterSpecForProviderServerlessV2ScalingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ClusterSnapshot to populate snapshotIdentifier.
 *
 * @schema ClusterSpecForProviderSnapshotIdentifierRef
 */
export interface ClusterSpecForProviderSnapshotIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderSnapshotIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderSnapshotIdentifierRef#policy
   */
  readonly policy?: ClusterSpecForProviderSnapshotIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderSnapshotIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderSnapshotIdentifierRef(obj: ClusterSpecForProviderSnapshotIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderSnapshotIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ClusterSnapshot to populate snapshotIdentifier.
 *
 * @schema ClusterSpecForProviderSnapshotIdentifierSelector
 */
export interface ClusterSpecForProviderSnapshotIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderSnapshotIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderSnapshotIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderSnapshotIdentifierSelector#policy
   */
  readonly policy?: ClusterSpecForProviderSnapshotIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderSnapshotIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderSnapshotIdentifierSelector(obj: ClusterSpecForProviderSnapshotIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderSnapshotIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdRefs(obj: ClusterSpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdSelector(obj: ClusterSpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderRefPolicy
 */
export interface ClusterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRefPolicy(obj: ClusterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderIamRoleRefsPolicy
 */
export interface ClusterSpecForProviderIamRoleRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderIamRoleRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderIamRoleRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderIamRoleRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderIamRoleRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleRefsPolicy(obj: ClusterSpecForProviderIamRoleRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderIamRoleSelectorPolicy
 */
export interface ClusterSpecForProviderIamRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderIamRoleSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderIamRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderIamRoleSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderIamRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderIamRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderIamRoleSelectorPolicy(obj: ClusterSpecForProviderIamRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderKmsKeyArnRefPolicy
 */
export interface ClusterSpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyArnRefPolicy(obj: ClusterSpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderKmsKeyArnSelectorPolicy
 */
export interface ClusterSpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyArnSelectorPolicy(obj: ClusterSpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicy
 */
export interface ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicy(obj: ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicy
 */
export interface ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicy(obj: ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicy
 */
export interface ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicy(obj: ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicy
 */
export interface ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicy(obj: ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderReplicationSourceIdentifierRefPolicy
 */
export interface ClusterSpecForProviderReplicationSourceIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderReplicationSourceIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderReplicationSourceIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderReplicationSourceIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderReplicationSourceIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderReplicationSourceIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderReplicationSourceIdentifierRefPolicy(obj: ClusterSpecForProviderReplicationSourceIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicy
 */
export interface ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicy(obj: ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderSnapshotIdentifierRefPolicy
 */
export interface ClusterSpecForProviderSnapshotIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderSnapshotIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderSnapshotIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderSnapshotIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderSnapshotIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderSnapshotIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderSnapshotIdentifierRefPolicy(obj: ClusterSpecForProviderSnapshotIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderSnapshotIdentifierSelectorPolicy
 */
export interface ClusterSpecForProviderSnapshotIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderSnapshotIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderSnapshotIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderSnapshotIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderSnapshotIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderSnapshotIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderSnapshotIdentifierSelectorPolicy(obj: ClusterSpecForProviderSnapshotIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderRefPolicyResolution
 */
export enum ClusterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderRefPolicyResolve
 */
export enum ClusterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderIamRoleRefsPolicyResolution
 */
export enum ClusterSpecForProviderIamRoleRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderIamRoleRefsPolicyResolve
 */
export enum ClusterSpecForProviderIamRoleRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderIamRoleSelectorPolicyResolution
 */
export enum ClusterSpecForProviderIamRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderIamRoleSelectorPolicyResolve
 */
export enum ClusterSpecForProviderIamRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum ClusterSpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum ClusterSpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum ClusterSpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum ClusterSpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicyResolution
 */
export enum ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicyResolve
 */
export enum ClusterSpecForProviderNeptuneClusterParameterGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicyResolution
 */
export enum ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicyResolve
 */
export enum ClusterSpecForProviderNeptuneClusterParameterGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicyResolution
 */
export enum ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicyResolve
 */
export enum ClusterSpecForProviderNeptuneSubnetGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolution
 */
export enum ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolve
 */
export enum ClusterSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderReplicationSourceIdentifierRefPolicyResolution
 */
export enum ClusterSpecForProviderReplicationSourceIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderReplicationSourceIdentifierRefPolicyResolve
 */
export enum ClusterSpecForProviderReplicationSourceIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicyResolution
 */
export enum ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicyResolve
 */
export enum ClusterSpecForProviderReplicationSourceIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderSnapshotIdentifierRefPolicyResolution
 */
export enum ClusterSpecForProviderSnapshotIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderSnapshotIdentifierRefPolicyResolve
 */
export enum ClusterSpecForProviderSnapshotIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderSnapshotIdentifierSelectorPolicyResolution
 */
export enum ClusterSpecForProviderSnapshotIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderSnapshotIdentifierSelectorPolicyResolve
 */
export enum ClusterSpecForProviderSnapshotIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterEndpoint is the Schema for the ClusterEndpoints API. Provides an Neptune Cluster Endpoint Resource
 *
 * @schema ClusterEndpoint
 */
export class ClusterEndpoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterEndpoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'neptune.aws.upbound.io/v1beta1',
    kind: 'ClusterEndpoint',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterEndpoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterEndpointProps): any {
    return {
      ...ClusterEndpoint.GVK,
      ...toJson_ClusterEndpointProps(props),
    };
  }

  /**
   * Defines a "ClusterEndpoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterEndpointProps) {
    super(scope, id, {
      ...ClusterEndpoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterEndpoint.GVK,
      ...toJson_ClusterEndpointProps(resolved),
    };
  }
}

/**
 * ClusterEndpoint is the Schema for the ClusterEndpoints API. Provides an Neptune Cluster Endpoint Resource
 *
 * @schema ClusterEndpoint
 */
export interface ClusterEndpointProps {
  /**
   * @schema ClusterEndpoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterEndpointSpec defines the desired state of ClusterEndpoint
   *
   * @schema ClusterEndpoint#spec
   */
  readonly spec: ClusterEndpointSpec;

}

/**
 * Converts an object of type 'ClusterEndpointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointProps(obj: ClusterEndpointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterEndpointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterEndpointSpec defines the desired state of ClusterEndpoint
 *
 * @schema ClusterEndpointSpec
 */
export interface ClusterEndpointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterEndpointSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterEndpointSpecDeletionPolicy;

  /**
   * @schema ClusterEndpointSpec#forProvider
   */
  readonly forProvider: ClusterEndpointSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterEndpointSpec#managementPolicy
   */
  readonly managementPolicy?: ClusterEndpointSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterEndpointSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterEndpointSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterEndpointSpec#providerRef
   */
  readonly providerRef?: ClusterEndpointSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterEndpointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterEndpointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterEndpointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterEndpointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterEndpointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpec(obj: ClusterEndpointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterEndpointSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ClusterEndpointSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterEndpointSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterEndpointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterEndpointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterEndpointSpecDeletionPolicy
 */
export enum ClusterEndpointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterEndpointSpecForProvider
 */
export interface ClusterEndpointSpecForProvider {
  /**
   * The DB cluster identifier of the DB cluster associated with the endpoint.
   *
   * @schema ClusterEndpointSpecForProvider#clusterIdentifier
   */
  readonly clusterIdentifier?: string;

  /**
   * Reference to a Cluster to populate clusterIdentifier.
   *
   * @schema ClusterEndpointSpecForProvider#clusterIdentifierRef
   */
  readonly clusterIdentifierRef?: ClusterEndpointSpecForProviderClusterIdentifierRef;

  /**
   * Selector for a Cluster to populate clusterIdentifier.
   *
   * @schema ClusterEndpointSpecForProvider#clusterIdentifierSelector
   */
  readonly clusterIdentifierSelector?: ClusterEndpointSpecForProviderClusterIdentifierSelector;

  /**
   * The type of the endpoint. One of: READER, WRITER, ANY.
   *
   * @schema ClusterEndpointSpecForProvider#endpointType
   */
  readonly endpointType?: string;

  /**
   * List of DB instance identifiers that aren't part of the custom endpoint group. All other eligible instances are reachable through the custom endpoint. Only relevant if the list of static members is empty.
   *
   * @schema ClusterEndpointSpecForProvider#excludedMembers
   */
  readonly excludedMembers?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterEndpointSpecForProvider#region
   */
  readonly region: string;

  /**
   * List of DB instance identifiers that are part of the custom endpoint group.
   *
   * @schema ClusterEndpointSpecForProvider#staticMembers
   */
  readonly staticMembers?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterEndpointSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterEndpointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecForProvider(obj: ClusterEndpointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterIdentifier': obj.clusterIdentifier,
    'clusterIdentifierRef': toJson_ClusterEndpointSpecForProviderClusterIdentifierRef(obj.clusterIdentifierRef),
    'clusterIdentifierSelector': toJson_ClusterEndpointSpecForProviderClusterIdentifierSelector(obj.clusterIdentifierSelector),
    'endpointType': obj.endpointType,
    'excludedMembers': obj.excludedMembers?.map(y => y),
    'region': obj.region,
    'staticMembers': obj.staticMembers?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterEndpointSpecManagementPolicy
 */
export enum ClusterEndpointSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterEndpointSpecProviderConfigRef
 */
export interface ClusterEndpointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterEndpointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterEndpointSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterEndpointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterEndpointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecProviderConfigRef(obj: ClusterEndpointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterEndpointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterEndpointSpecProviderRef
 */
export interface ClusterEndpointSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterEndpointSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterEndpointSpecProviderRef#policy
   */
  readonly policy?: ClusterEndpointSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterEndpointSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecProviderRef(obj: ClusterEndpointSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterEndpointSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsTo
 */
export interface ClusterEndpointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterEndpointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterEndpointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterEndpointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecPublishConnectionDetailsTo(obj: ClusterEndpointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterEndpointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterEndpointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterEndpointSpecWriteConnectionSecretToRef
 */
export interface ClusterEndpointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterEndpointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterEndpointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterEndpointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecWriteConnectionSecretToRef(obj: ClusterEndpointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate clusterIdentifier.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierRef
 */
export interface ClusterEndpointSpecForProviderClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierRef#policy
   */
  readonly policy?: ClusterEndpointSpecForProviderClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterEndpointSpecForProviderClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecForProviderClusterIdentifierRef(obj: ClusterEndpointSpecForProviderClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterEndpointSpecForProviderClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate clusterIdentifier.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierSelector
 */
export interface ClusterEndpointSpecForProviderClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierSelector#policy
   */
  readonly policy?: ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterEndpointSpecForProviderClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecForProviderClusterIdentifierSelector(obj: ClusterEndpointSpecForProviderClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterEndpointSpecProviderConfigRefPolicy
 */
export interface ClusterEndpointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterEndpointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterEndpointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterEndpointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterEndpointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterEndpointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecProviderConfigRefPolicy(obj: ClusterEndpointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterEndpointSpecProviderRefPolicy
 */
export interface ClusterEndpointSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterEndpointSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterEndpointSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterEndpointSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterEndpointSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterEndpointSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecProviderRefPolicy(obj: ClusterEndpointSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterEndpointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterEndpointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecPublishConnectionDetailsToConfigRef(obj: ClusterEndpointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterEndpointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterEndpointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecPublishConnectionDetailsToMetadata(obj: ClusterEndpointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierRefPolicy
 */
export interface ClusterEndpointSpecForProviderClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterEndpointSpecForProviderClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecForProviderClusterIdentifierRefPolicy(obj: ClusterEndpointSpecForProviderClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy
 */
export interface ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy(obj: ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterEndpointSpecProviderConfigRefPolicyResolution
 */
export enum ClusterEndpointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterEndpointSpecProviderConfigRefPolicyResolve
 */
export enum ClusterEndpointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterEndpointSpecProviderRefPolicyResolution
 */
export enum ClusterEndpointSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterEndpointSpecProviderRefPolicyResolve
 */
export enum ClusterEndpointSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolution
 */
export enum ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolve
 */
export enum ClusterEndpointSpecForProviderClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolution
 */
export enum ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolve
 */
export enum ClusterEndpointSpecForProviderClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterEndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterInstance is the Schema for the ClusterInstances API. Provides an Neptune Cluster Resource Instance
 *
 * @schema ClusterInstance
 */
export class ClusterInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'neptune.aws.upbound.io/v1beta1',
    kind: 'ClusterInstance',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterInstanceProps): any {
    return {
      ...ClusterInstance.GVK,
      ...toJson_ClusterInstanceProps(props),
    };
  }

  /**
   * Defines a "ClusterInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterInstanceProps) {
    super(scope, id, {
      ...ClusterInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterInstance.GVK,
      ...toJson_ClusterInstanceProps(resolved),
    };
  }
}

/**
 * ClusterInstance is the Schema for the ClusterInstances API. Provides an Neptune Cluster Resource Instance
 *
 * @schema ClusterInstance
 */
export interface ClusterInstanceProps {
  /**
   * @schema ClusterInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterInstanceSpec defines the desired state of ClusterInstance
   *
   * @schema ClusterInstance#spec
   */
  readonly spec: ClusterInstanceSpec;

}

/**
 * Converts an object of type 'ClusterInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceProps(obj: ClusterInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterInstanceSpec defines the desired state of ClusterInstance
 *
 * @schema ClusterInstanceSpec
 */
export interface ClusterInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterInstanceSpecDeletionPolicy;

  /**
   * @schema ClusterInstanceSpec#forProvider
   */
  readonly forProvider: ClusterInstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterInstanceSpec#managementPolicy
   */
  readonly managementPolicy?: ClusterInstanceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterInstanceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterInstanceSpec#providerRef
   */
  readonly providerRef?: ClusterInstanceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpec(obj: ClusterInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterInstanceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ClusterInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterInstanceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterInstanceSpecDeletionPolicy
 */
export enum ClusterInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterInstanceSpecForProvider
 */
export interface ClusterInstanceSpecForProvider {
  /**
   * Specifies whether any instance modifications are applied immediately, or during the next maintenance window. Default isfalse.
   *
   * @schema ClusterInstanceSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * Indicates that minor engine upgrades will be applied automatically to the instance during the maintenance window. Default is true.
   *
   * @default true.
   * @schema ClusterInstanceSpecForProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * The EC2 Availability Zone that the neptune instance is created in.
   *
   * @schema ClusterInstanceSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The identifier of the aws_neptune_cluster in which to launch this instance.
   *
   * @schema ClusterInstanceSpecForProvider#clusterIdentifier
   */
  readonly clusterIdentifier?: string;

  /**
   * Reference to a Cluster to populate clusterIdentifier.
   *
   * @schema ClusterInstanceSpecForProvider#clusterIdentifierRef
   */
  readonly clusterIdentifierRef?: ClusterInstanceSpecForProviderClusterIdentifierRef;

  /**
   * Selector for a Cluster to populate clusterIdentifier.
   *
   * @schema ClusterInstanceSpecForProvider#clusterIdentifierSelector
   */
  readonly clusterIdentifierSelector?: ClusterInstanceSpecForProviderClusterIdentifierSelector;

  /**
   * The name of the database engine to be used for the neptune instance. Defaults to neptune. Valid Values: neptune.
   *
   * @default neptune. Valid Values: neptune.
   * @schema ClusterInstanceSpecForProvider#engine
   */
  readonly engine?: string;

  /**
   * The neptune engine version.
   *
   * @schema ClusterInstanceSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The instance class to use.
   *
   * @schema ClusterInstanceSpecForProvider#instanceClass
   */
  readonly instanceClass?: string;

  /**
   * The name of the neptune parameter group to associate with this instance.
   *
   * @schema ClusterInstanceSpecForProvider#neptuneParameterGroupName
   */
  readonly neptuneParameterGroupName?: string;

  /**
   * Reference to a ParameterGroup to populate neptuneParameterGroupName.
   *
   * @schema ClusterInstanceSpecForProvider#neptuneParameterGroupNameRef
   */
  readonly neptuneParameterGroupNameRef?: ClusterInstanceSpecForProviderNeptuneParameterGroupNameRef;

  /**
   * Selector for a ParameterGroup to populate neptuneParameterGroupName.
   *
   * @schema ClusterInstanceSpecForProvider#neptuneParameterGroupNameSelector
   */
  readonly neptuneParameterGroupNameSelector?: ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelector;

  /**
   * A subnet group to associate with this neptune instance. NOTE: This must match the neptune_subnet_group_name of the attached aws_neptune_cluster.
   *
   * @schema ClusterInstanceSpecForProvider#neptuneSubnetGroupName
   */
  readonly neptuneSubnetGroupName?: string;

  /**
   * Reference to a SubnetGroup to populate neptuneSubnetGroupName.
   *
   * @schema ClusterInstanceSpecForProvider#neptuneSubnetGroupNameRef
   */
  readonly neptuneSubnetGroupNameRef?: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRef;

  /**
   * Selector for a SubnetGroup to populate neptuneSubnetGroupName.
   *
   * @schema ClusterInstanceSpecForProvider#neptuneSubnetGroupNameSelector
   */
  readonly neptuneSubnetGroupNameSelector?: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelector;

  /**
   * The port on which the DB accepts connections. Defaults to 8182.
   *
   * @default 8182.
   * @schema ClusterInstanceSpecForProvider#port
   */
  readonly port?: number;

  /**
   * The daily time range during which automated backups are created if automated backups are enabled. Eg: "04:00-09:00"
   *
   * @schema ClusterInstanceSpecForProvider#preferredBackupWindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The window to perform maintenance in. Syntax: "ddd:hh24:mi-ddd:hh24:mi". Eg: "Mon:00:00-Mon:03:00".
   *
   * @schema ClusterInstanceSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * Default 0. Failover Priority setting on instance level. The reader who has lower tier has higher priority to get promoter to writer.
   *
   * @schema ClusterInstanceSpecForProvider#promotionTier
   */
  readonly promotionTier?: number;

  /**
   * Bool to control if instance is publicly accessible. Default is false.
   *
   * @default false.
   * @schema ClusterInstanceSpecForProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterInstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterInstanceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProvider(obj: ClusterInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyImmediately': obj.applyImmediately,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'availabilityZone': obj.availabilityZone,
    'clusterIdentifier': obj.clusterIdentifier,
    'clusterIdentifierRef': toJson_ClusterInstanceSpecForProviderClusterIdentifierRef(obj.clusterIdentifierRef),
    'clusterIdentifierSelector': toJson_ClusterInstanceSpecForProviderClusterIdentifierSelector(obj.clusterIdentifierSelector),
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'instanceClass': obj.instanceClass,
    'neptuneParameterGroupName': obj.neptuneParameterGroupName,
    'neptuneParameterGroupNameRef': toJson_ClusterInstanceSpecForProviderNeptuneParameterGroupNameRef(obj.neptuneParameterGroupNameRef),
    'neptuneParameterGroupNameSelector': toJson_ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelector(obj.neptuneParameterGroupNameSelector),
    'neptuneSubnetGroupName': obj.neptuneSubnetGroupName,
    'neptuneSubnetGroupNameRef': toJson_ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRef(obj.neptuneSubnetGroupNameRef),
    'neptuneSubnetGroupNameSelector': toJson_ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelector(obj.neptuneSubnetGroupNameSelector),
    'port': obj.port,
    'preferredBackupWindow': obj.preferredBackupWindow,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'promotionTier': obj.promotionTier,
    'publiclyAccessible': obj.publiclyAccessible,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterInstanceSpecManagementPolicy
 */
export enum ClusterInstanceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterInstanceSpecProviderConfigRef
 */
export interface ClusterInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecProviderConfigRef(obj: ClusterInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterInstanceSpecProviderRef
 */
export interface ClusterInstanceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecProviderRef#policy
   */
  readonly policy?: ClusterInstanceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecProviderRef(obj: ClusterInstanceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsTo
 */
export interface ClusterInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsTo(obj: ClusterInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterInstanceSpecWriteConnectionSecretToRef
 */
export interface ClusterInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecWriteConnectionSecretToRef(obj: ClusterInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate clusterIdentifier.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRef
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRef#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierRef(obj: ClusterInstanceSpecForProviderClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecForProviderClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate clusterIdentifier.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierSelector(obj: ClusterInstanceSpecForProviderClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ParameterGroup to populate neptuneParameterGroupName.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameRef
 */
export interface ClusterInstanceSpecForProviderNeptuneParameterGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameRef#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderNeptuneParameterGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderNeptuneParameterGroupNameRef(obj: ClusterInstanceSpecForProviderNeptuneParameterGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ParameterGroup to populate neptuneParameterGroupName.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelector
 */
export interface ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelector#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelector(obj: ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a SubnetGroup to populate neptuneSubnetGroupName.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRef
 */
export interface ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRef#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRef(obj: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a SubnetGroup to populate neptuneSubnetGroupName.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelector
 */
export interface ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelector#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelector(obj: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecProviderConfigRefPolicy
 */
export interface ClusterInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecProviderConfigRefPolicy(obj: ClusterInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecProviderRefPolicy
 */
export interface ClusterInstanceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecProviderRefPolicy(obj: ClusterInstanceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRef(obj: ClusterInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsToMetadata(obj: ClusterInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicy
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierRefPolicy(obj: ClusterInstanceSpecForProviderClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy(obj: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicy
 */
export interface ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicy(obj: ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicy
 */
export interface ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicy(obj: ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicy
 */
export interface ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicy(obj: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicy
 */
export interface ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicy(obj: ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecProviderConfigRefPolicyResolution
 */
export enum ClusterInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecProviderConfigRefPolicyResolve
 */
export enum ClusterInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecProviderRefPolicyResolution
 */
export enum ClusterInstanceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecProviderRefPolicyResolve
 */
export enum ClusterInstanceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolution
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolve
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolution
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolve
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicyResolution
 */
export enum ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicyResolve
 */
export enum ClusterInstanceSpecForProviderNeptuneParameterGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicyResolution
 */
export enum ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicyResolve
 */
export enum ClusterInstanceSpecForProviderNeptuneParameterGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicyResolution
 */
export enum ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicyResolve
 */
export enum ClusterInstanceSpecForProviderNeptuneSubnetGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolution
 */
export enum ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolve
 */
export enum ClusterInstanceSpecForProviderNeptuneSubnetGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterParameterGroup is the Schema for the ClusterParameterGroups API. Manages a Neptune Cluster Parameter Group
 *
 * @schema ClusterParameterGroup
 */
export class ClusterParameterGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterParameterGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'neptune.aws.upbound.io/v1beta1',
    kind: 'ClusterParameterGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterParameterGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterParameterGroupProps): any {
    return {
      ...ClusterParameterGroup.GVK,
      ...toJson_ClusterParameterGroupProps(props),
    };
  }

  /**
   * Defines a "ClusterParameterGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterParameterGroupProps) {
    super(scope, id, {
      ...ClusterParameterGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterParameterGroup.GVK,
      ...toJson_ClusterParameterGroupProps(resolved),
    };
  }
}

/**
 * ClusterParameterGroup is the Schema for the ClusterParameterGroups API. Manages a Neptune Cluster Parameter Group
 *
 * @schema ClusterParameterGroup
 */
export interface ClusterParameterGroupProps {
  /**
   * @schema ClusterParameterGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterParameterGroupSpec defines the desired state of ClusterParameterGroup
   *
   * @schema ClusterParameterGroup#spec
   */
  readonly spec: ClusterParameterGroupSpec;

}

/**
 * Converts an object of type 'ClusterParameterGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupProps(obj: ClusterParameterGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterParameterGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterParameterGroupSpec defines the desired state of ClusterParameterGroup
 *
 * @schema ClusterParameterGroupSpec
 */
export interface ClusterParameterGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterParameterGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterParameterGroupSpecDeletionPolicy;

  /**
   * @schema ClusterParameterGroupSpec#forProvider
   */
  readonly forProvider: ClusterParameterGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterParameterGroupSpec#managementPolicy
   */
  readonly managementPolicy?: ClusterParameterGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterParameterGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterParameterGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterParameterGroupSpec#providerRef
   */
  readonly providerRef?: ClusterParameterGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterParameterGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterParameterGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterParameterGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterParameterGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpec(obj: ClusterParameterGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterParameterGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ClusterParameterGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterParameterGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterParameterGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterParameterGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterParameterGroupSpecDeletionPolicy
 */
export enum ClusterParameterGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterParameterGroupSpecForProvider
 */
export interface ClusterParameterGroupSpecForProvider {
  /**
   * The description of the neptune cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The family of the neptune cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecForProvider#family
   */
  readonly family?: string;

  /**
   * A list of neptune parameters to apply.
   *
   * @schema ClusterParameterGroupSpecForProvider#parameter
   */
  readonly parameter?: ClusterParameterGroupSpecForProviderParameter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterParameterGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterParameterGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecForProvider(obj: ClusterParameterGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'family': obj.family,
    'parameter': obj.parameter?.map(y => toJson_ClusterParameterGroupSpecForProviderParameter(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterParameterGroupSpecManagementPolicy
 */
export enum ClusterParameterGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRef
 */
export interface ClusterParameterGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterParameterGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecProviderConfigRef(obj: ClusterParameterGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterParameterGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterParameterGroupSpecProviderRef
 */
export interface ClusterParameterGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterParameterGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterParameterGroupSpecProviderRef#policy
   */
  readonly policy?: ClusterParameterGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecProviderRef(obj: ClusterParameterGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterParameterGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterParameterGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsTo(obj: ClusterParameterGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterParameterGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterParameterGroupSpecWriteConnectionSecretToRef
 */
export interface ClusterParameterGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterParameterGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterParameterGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecWriteConnectionSecretToRef(obj: ClusterParameterGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterParameterGroupSpecForProviderParameter
 */
export interface ClusterParameterGroupSpecForProviderParameter {
  /**
   * Valid values are immediate and pending-reboot. Defaults to pending-reboot.
   *
   * @default pending-reboot.
   * @schema ClusterParameterGroupSpecForProviderParameter#applyMethod
   */
  readonly applyMethod?: string;

  /**
   * The name of the neptune cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecForProviderParameter#name
   */
  readonly name: string;

  /**
   * The value of the neptune parameter.
   *
   * @schema ClusterParameterGroupSpecForProviderParameter#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecForProviderParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecForProviderParameter(obj: ClusterParameterGroupSpecForProviderParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyMethod': obj.applyMethod,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRefPolicy
 */
export interface ClusterParameterGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterParameterGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterParameterGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecProviderConfigRefPolicy(obj: ClusterParameterGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterParameterGroupSpecProviderRefPolicy
 */
export interface ClusterParameterGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterParameterGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterParameterGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterParameterGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterParameterGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecProviderRefPolicy(obj: ClusterParameterGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef(obj: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsToMetadata(obj: ClusterParameterGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRefPolicyResolution
 */
export enum ClusterParameterGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRefPolicyResolve
 */
export enum ClusterParameterGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterParameterGroupSpecProviderRefPolicyResolution
 */
export enum ClusterParameterGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterParameterGroupSpecProviderRefPolicyResolve
 */
export enum ClusterParameterGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterSnapshot is the Schema for the ClusterSnapshots API. Manages a Neptune database cluster snapshot.
 *
 * @schema ClusterSnapshot
 */
export class ClusterSnapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterSnapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'neptune.aws.upbound.io/v1beta1',
    kind: 'ClusterSnapshot',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterSnapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterSnapshotProps): any {
    return {
      ...ClusterSnapshot.GVK,
      ...toJson_ClusterSnapshotProps(props),
    };
  }

  /**
   * Defines a "ClusterSnapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterSnapshotProps) {
    super(scope, id, {
      ...ClusterSnapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterSnapshot.GVK,
      ...toJson_ClusterSnapshotProps(resolved),
    };
  }
}

/**
 * ClusterSnapshot is the Schema for the ClusterSnapshots API. Manages a Neptune database cluster snapshot.
 *
 * @schema ClusterSnapshot
 */
export interface ClusterSnapshotProps {
  /**
   * @schema ClusterSnapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSnapshotSpec defines the desired state of ClusterSnapshot
   *
   * @schema ClusterSnapshot#spec
   */
  readonly spec: ClusterSnapshotSpec;

}

/**
 * Converts an object of type 'ClusterSnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotProps(obj: ClusterSnapshotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSnapshotSpec defines the desired state of ClusterSnapshot
 *
 * @schema ClusterSnapshotSpec
 */
export interface ClusterSnapshotSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSnapshotSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSnapshotSpecDeletionPolicy;

  /**
   * @schema ClusterSnapshotSpec#forProvider
   */
  readonly forProvider: ClusterSnapshotSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSnapshotSpec#managementPolicy
   */
  readonly managementPolicy?: ClusterSnapshotSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSnapshotSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSnapshotSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterSnapshotSpec#providerRef
   */
  readonly providerRef?: ClusterSnapshotSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSnapshotSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSnapshotSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSnapshotSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSnapshotSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpec(obj: ClusterSnapshotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSnapshotSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ClusterSnapshotSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterSnapshotSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterSnapshotSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSnapshotSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSnapshotSpecDeletionPolicy
 */
export enum ClusterSnapshotSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSnapshotSpecForProvider
 */
export interface ClusterSnapshotSpecForProvider {
  /**
   * The DB Cluster Identifier from which to take the snapshot.
   *
   * @schema ClusterSnapshotSpecForProvider#dbClusterIdentifier
   */
  readonly dbClusterIdentifier?: string;

  /**
   * Reference to a Cluster to populate dbClusterIdentifier.
   *
   * @schema ClusterSnapshotSpecForProvider#dbClusterIdentifierRef
   */
  readonly dbClusterIdentifierRef?: ClusterSnapshotSpecForProviderDbClusterIdentifierRef;

  /**
   * Selector for a Cluster to populate dbClusterIdentifier.
   *
   * @schema ClusterSnapshotSpecForProvider#dbClusterIdentifierSelector
   */
  readonly dbClusterIdentifierSelector?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterSnapshotSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProvider(obj: ClusterSnapshotSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbClusterIdentifier': obj.dbClusterIdentifier,
    'dbClusterIdentifierRef': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRef(obj.dbClusterIdentifierRef),
    'dbClusterIdentifierSelector': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelector(obj.dbClusterIdentifierSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSnapshotSpecManagementPolicy
 */
export enum ClusterSnapshotSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSnapshotSpecProviderConfigRef
 */
export interface ClusterSnapshotSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSnapshotSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSnapshotSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSnapshotSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecProviderConfigRef(obj: ClusterSnapshotSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSnapshotSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterSnapshotSpecProviderRef
 */
export interface ClusterSnapshotSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSnapshotSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSnapshotSpecProviderRef#policy
   */
  readonly policy?: ClusterSnapshotSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecProviderRef(obj: ClusterSnapshotSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSnapshotSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsTo
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSnapshotSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsTo(obj: ClusterSnapshotSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSnapshotSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSnapshotSpecWriteConnectionSecretToRef
 */
export interface ClusterSnapshotSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSnapshotSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSnapshotSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecWriteConnectionSecretToRef(obj: ClusterSnapshotSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate dbClusterIdentifier.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRef
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRef#policy
   */
  readonly policy?: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRef(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate dbClusterIdentifier.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector#policy
   */
  readonly policy?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelector(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSnapshotSpecProviderConfigRefPolicy
 */
export interface ClusterSnapshotSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecProviderConfigRefPolicy(obj: ClusterSnapshotSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSnapshotSpecProviderRefPolicy
 */
export interface ClusterSnapshotSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecProviderRefPolicy(obj: ClusterSnapshotSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRef(obj: ClusterSnapshotSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsToMetadata(obj: ClusterSnapshotSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSnapshotSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSnapshotSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecProviderRefPolicyResolution
 */
export enum ClusterSnapshotSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecProviderRefPolicyResolve
 */
export enum ClusterSnapshotSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolution
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolve
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolution
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolve
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EventSubscription is the Schema for the EventSubscriptions API. Provides a Neptune event subscription resource.
 *
 * @schema EventSubscription
 */
export class EventSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EventSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'neptune.aws.upbound.io/v1beta1',
    kind: 'EventSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "EventSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EventSubscriptionProps): any {
    return {
      ...EventSubscription.GVK,
      ...toJson_EventSubscriptionProps(props),
    };
  }

  /**
   * Defines a "EventSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EventSubscriptionProps) {
    super(scope, id, {
      ...EventSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EventSubscription.GVK,
      ...toJson_EventSubscriptionProps(resolved),
    };
  }
}

/**
 * EventSubscription is the Schema for the EventSubscriptions API. Provides a Neptune event subscription resource.
 *
 * @schema EventSubscription
 */
export interface EventSubscriptionProps {
  /**
   * @schema EventSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EventSubscriptionSpec defines the desired state of EventSubscription
   *
   * @schema EventSubscription#spec
   */
  readonly spec: EventSubscriptionSpec;

}

/**
 * Converts an object of type 'EventSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionProps(obj: EventSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EventSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventSubscriptionSpec defines the desired state of EventSubscription
 *
 * @schema EventSubscriptionSpec
 */
export interface EventSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EventSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: EventSubscriptionSpecDeletionPolicy;

  /**
   * @schema EventSubscriptionSpec#forProvider
   */
  readonly forProvider: EventSubscriptionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EventSubscriptionSpec#managementPolicy
   */
  readonly managementPolicy?: EventSubscriptionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EventSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: EventSubscriptionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EventSubscriptionSpec#providerRef
   */
  readonly providerRef?: EventSubscriptionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EventSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EventSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EventSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EventSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EventSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpec(obj: EventSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EventSubscriptionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EventSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EventSubscriptionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EventSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EventSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EventSubscriptionSpecDeletionPolicy
 */
export enum EventSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EventSubscriptionSpecForProvider
 */
export interface EventSubscriptionSpecForProvider {
  /**
   * A boolean flag to enable/disable the subscription. Defaults to true.
   *
   * @default true.
   * @schema EventSubscriptionSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * A list of event categories for a source_type that you want to subscribe to. Run aws neptune describe-event-categories to find all the event categories.
   *
   * @schema EventSubscriptionSpecForProvider#eventCategories
   */
  readonly eventCategories?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EventSubscriptionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of the SNS topic to send events to.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArn
   */
  readonly snsTopicArn?: string;

  /**
   * Reference to a Topic in sns to populate snsTopicArn.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArnRef
   */
  readonly snsTopicArnRef?: EventSubscriptionSpecForProviderSnsTopicArnRef;

  /**
   * Selector for a Topic in sns to populate snsTopicArn.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArnSelector
   */
  readonly snsTopicArnSelector?: EventSubscriptionSpecForProviderSnsTopicArnSelector;

  /**
   * A list of identifiers of the event sources for which events will be returned. If not specified, then all sources are included in the response. If specified, a source_type must also be specified.
   *
   * @schema EventSubscriptionSpecForProvider#sourceIds
   */
  readonly sourceIds?: string[];

  /**
   * The type of source that will be generating the events. Valid options are db-instance, db-security-group, db-parameter-group, db-snapshot, db-cluster or db-cluster-snapshot. If not set, all sources will be subscribed to.
   *
   * @schema EventSubscriptionSpecForProvider#sourceType
   */
  readonly sourceType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema EventSubscriptionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProvider(obj: EventSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'eventCategories': obj.eventCategories?.map(y => y),
    'region': obj.region,
    'snsTopicArn': obj.snsTopicArn,
    'snsTopicArnRef': toJson_EventSubscriptionSpecForProviderSnsTopicArnRef(obj.snsTopicArnRef),
    'snsTopicArnSelector': toJson_EventSubscriptionSpecForProviderSnsTopicArnSelector(obj.snsTopicArnSelector),
    'sourceIds': obj.sourceIds?.map(y => y),
    'sourceType': obj.sourceType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EventSubscriptionSpecManagementPolicy
 */
export enum EventSubscriptionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EventSubscriptionSpecProviderConfigRef
 */
export interface EventSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: EventSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderConfigRef(obj: EventSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EventSubscriptionSpecProviderRef
 */
export interface EventSubscriptionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecProviderRef#policy
   */
  readonly policy?: EventSubscriptionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderRef(obj: EventSubscriptionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsTo
 */
export interface EventSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EventSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EventSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsTo(obj: EventSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EventSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EventSubscriptionSpecWriteConnectionSecretToRef
 */
export interface EventSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EventSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EventSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecWriteConnectionSecretToRef(obj: EventSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate snsTopicArn.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRef
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRef#policy
   */
  readonly policy?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnRef(obj: EventSubscriptionSpecForProviderSnsTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecForProviderSnsTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate snsTopicArn.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#policy
   */
  readonly policy?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnSelector(obj: EventSubscriptionSpecForProviderSnsTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicy
 */
export interface EventSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderConfigRefPolicy(obj: EventSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecProviderRefPolicy
 */
export interface EventSubscriptionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderRefPolicy(obj: EventSubscriptionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: EventSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToMetadata(obj: EventSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnRefPolicy(obj: EventSubscriptionSpecForProviderSnsTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy(obj: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum EventSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum EventSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecProviderRefPolicyResolution
 */
export enum EventSubscriptionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecProviderRefPolicyResolve
 */
export enum EventSubscriptionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GlobalCluster is the Schema for the GlobalClusters API. Provides an Neptune Global Cluster Resource
 *
 * @schema GlobalCluster
 */
export class GlobalCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GlobalCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'neptune.aws.upbound.io/v1beta1',
    kind: 'GlobalCluster',
  }

  /**
   * Renders a Kubernetes manifest for "GlobalCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GlobalClusterProps): any {
    return {
      ...GlobalCluster.GVK,
      ...toJson_GlobalClusterProps(props),
    };
  }

  /**
   * Defines a "GlobalCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GlobalClusterProps) {
    super(scope, id, {
      ...GlobalCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GlobalCluster.GVK,
      ...toJson_GlobalClusterProps(resolved),
    };
  }
}

/**
 * GlobalCluster is the Schema for the GlobalClusters API. Provides an Neptune Global Cluster Resource
 *
 * @schema GlobalCluster
 */
export interface GlobalClusterProps {
  /**
   * @schema GlobalCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GlobalClusterSpec defines the desired state of GlobalCluster
   *
   * @schema GlobalCluster#spec
   */
  readonly spec: GlobalClusterSpec;

}

/**
 * Converts an object of type 'GlobalClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterProps(obj: GlobalClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GlobalClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalClusterSpec defines the desired state of GlobalCluster
 *
 * @schema GlobalClusterSpec
 */
export interface GlobalClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GlobalClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: GlobalClusterSpecDeletionPolicy;

  /**
   * @schema GlobalClusterSpec#forProvider
   */
  readonly forProvider: GlobalClusterSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GlobalClusterSpec#managementPolicy
   */
  readonly managementPolicy?: GlobalClusterSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GlobalClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: GlobalClusterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema GlobalClusterSpec#providerRef
   */
  readonly providerRef?: GlobalClusterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GlobalClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GlobalClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GlobalClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GlobalClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GlobalClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpec(obj: GlobalClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GlobalClusterSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_GlobalClusterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_GlobalClusterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_GlobalClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GlobalClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GlobalClusterSpecDeletionPolicy
 */
export enum GlobalClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GlobalClusterSpecForProvider
 */
export interface GlobalClusterSpecForProvider {
  /**
   * If the Global Cluster should have deletion protection enabled. The database can't be deleted when this value is set to true. The default is false.
   *
   * @schema GlobalClusterSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Name of the database engine to be used for this DB cluster. Current Valid values: neptune. Conflicts with source_db_cluster_identifier.
   *
   * @schema GlobalClusterSpecForProvider#engine
   */
  readonly engine?: string;

  /**
   * Engine version of the global database. Upgrading the engine version will result in all cluster members being immediately updated and will.
   *
   * @schema GlobalClusterSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GlobalClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon Resource Name (ARN) to use as the primary DB Cluster of the Global Cluster on creation.
   *
   * @schema GlobalClusterSpecForProvider#sourceDbClusterIdentifier
   */
  readonly sourceDbClusterIdentifier?: string;

  /**
   * Reference to a Cluster in neptune to populate sourceDbClusterIdentifier.
   *
   * @schema GlobalClusterSpecForProvider#sourceDbClusterIdentifierRef
   */
  readonly sourceDbClusterIdentifierRef?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRef;

  /**
   * Selector for a Cluster in neptune to populate sourceDbClusterIdentifier.
   *
   * @schema GlobalClusterSpecForProvider#sourceDbClusterIdentifierSelector
   */
  readonly sourceDbClusterIdentifierSelector?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector;

  /**
   * Specifies whether the DB cluster is encrypted. The default is false unless source_db_cluster_identifier is specified and encrypted.
   *
   * @schema GlobalClusterSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProvider(obj: GlobalClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionProtection': obj.deletionProtection,
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'region': obj.region,
    'sourceDbClusterIdentifier': obj.sourceDbClusterIdentifier,
    'sourceDbClusterIdentifierRef': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRef(obj.sourceDbClusterIdentifierRef),
    'sourceDbClusterIdentifierSelector': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector(obj.sourceDbClusterIdentifierSelector),
    'storageEncrypted': obj.storageEncrypted,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GlobalClusterSpecManagementPolicy
 */
export enum GlobalClusterSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GlobalClusterSpecProviderConfigRef
 */
export interface GlobalClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecProviderConfigRef#policy
   */
  readonly policy?: GlobalClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderConfigRef(obj: GlobalClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema GlobalClusterSpecProviderRef
 */
export interface GlobalClusterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecProviderRef#policy
   */
  readonly policy?: GlobalClusterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderRef(obj: GlobalClusterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsTo
 */
export interface GlobalClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GlobalClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GlobalClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsTo(obj: GlobalClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GlobalClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GlobalClusterSpecWriteConnectionSecretToRef
 */
export interface GlobalClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GlobalClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GlobalClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecWriteConnectionSecretToRef(obj: GlobalClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in neptune to populate sourceDbClusterIdentifier.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef#policy
   */
  readonly policy?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRef(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in neptune to populate sourceDbClusterIdentifier.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#policy
   */
  readonly policy?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicy
 */
export interface GlobalClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderConfigRefPolicy(obj: GlobalClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecProviderRefPolicy
 */
export interface GlobalClusterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderRefPolicy(obj: GlobalClusterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface GlobalClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRef(obj: GlobalClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata
 */
export interface GlobalClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToMetadata(obj: GlobalClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicyResolution
 */
export enum GlobalClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicyResolve
 */
export enum GlobalClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecProviderRefPolicyResolution
 */
export enum GlobalClusterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecProviderRefPolicyResolve
 */
export enum GlobalClusterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ParameterGroup is the Schema for the ParameterGroups API. Manages a Neptune Parameter Group
 *
 * @schema ParameterGroup
 */
export class ParameterGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ParameterGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'neptune.aws.upbound.io/v1beta1',
    kind: 'ParameterGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ParameterGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ParameterGroupProps): any {
    return {
      ...ParameterGroup.GVK,
      ...toJson_ParameterGroupProps(props),
    };
  }

  /**
   * Defines a "ParameterGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ParameterGroupProps) {
    super(scope, id, {
      ...ParameterGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ParameterGroup.GVK,
      ...toJson_ParameterGroupProps(resolved),
    };
  }
}

/**
 * ParameterGroup is the Schema for the ParameterGroups API. Manages a Neptune Parameter Group
 *
 * @schema ParameterGroup
 */
export interface ParameterGroupProps {
  /**
   * @schema ParameterGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ParameterGroupSpec defines the desired state of ParameterGroup
   *
   * @schema ParameterGroup#spec
   */
  readonly spec: ParameterGroupSpec;

}

/**
 * Converts an object of type 'ParameterGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupProps(obj: ParameterGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ParameterGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ParameterGroupSpec defines the desired state of ParameterGroup
 *
 * @schema ParameterGroupSpec
 */
export interface ParameterGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ParameterGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: ParameterGroupSpecDeletionPolicy;

  /**
   * @schema ParameterGroupSpec#forProvider
   */
  readonly forProvider: ParameterGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ParameterGroupSpec#managementPolicy
   */
  readonly managementPolicy?: ParameterGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ParameterGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: ParameterGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ParameterGroupSpec#providerRef
   */
  readonly providerRef?: ParameterGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ParameterGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ParameterGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ParameterGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ParameterGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ParameterGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpec(obj: ParameterGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ParameterGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ParameterGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ParameterGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ParameterGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ParameterGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ParameterGroupSpecDeletionPolicy
 */
export enum ParameterGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ParameterGroupSpecForProvider
 */
export interface ParameterGroupSpecForProvider {
  /**
   * The description of the Neptune parameter group.
   *
   * @schema ParameterGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The family of the Neptune parameter group.
   *
   * @schema ParameterGroupSpecForProvider#family
   */
  readonly family?: string;

  /**
   * A list of Neptune parameters to apply.
   *
   * @schema ParameterGroupSpecForProvider#parameter
   */
  readonly parameter?: ParameterGroupSpecForProviderParameter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ParameterGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ParameterGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ParameterGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecForProvider(obj: ParameterGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'family': obj.family,
    'parameter': obj.parameter?.map(y => toJson_ParameterGroupSpecForProviderParameter(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ParameterGroupSpecManagementPolicy
 */
export enum ParameterGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ParameterGroupSpecProviderConfigRef
 */
export interface ParameterGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ParameterGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ParameterGroupSpecProviderConfigRef#policy
   */
  readonly policy?: ParameterGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ParameterGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecProviderConfigRef(obj: ParameterGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ParameterGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ParameterGroupSpecProviderRef
 */
export interface ParameterGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ParameterGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ParameterGroupSpecProviderRef#policy
   */
  readonly policy?: ParameterGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ParameterGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecProviderRef(obj: ParameterGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ParameterGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsTo
 */
export interface ParameterGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ParameterGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ParameterGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsTo(obj: ParameterGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ParameterGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ParameterGroupSpecWriteConnectionSecretToRef
 */
export interface ParameterGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ParameterGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ParameterGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecWriteConnectionSecretToRef(obj: ParameterGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ParameterGroupSpecForProviderParameter
 */
export interface ParameterGroupSpecForProviderParameter {
  /**
   * The apply method of the Neptune parameter. Valid values are immediate and pending-reboot. Defaults to pending-reboot.
   *
   * @default pending-reboot.
   * @schema ParameterGroupSpecForProviderParameter#applyMethod
   */
  readonly applyMethod?: string;

  /**
   * The name of the Neptune parameter group.
   *
   * @schema ParameterGroupSpecForProviderParameter#name
   */
  readonly name: string;

  /**
   * The value of the Neptune parameter.
   *
   * @schema ParameterGroupSpecForProviderParameter#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecForProviderParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecForProviderParameter(obj: ParameterGroupSpecForProviderParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyMethod': obj.applyMethod,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ParameterGroupSpecProviderConfigRefPolicy
 */
export interface ParameterGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ParameterGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ParameterGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ParameterGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ParameterGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ParameterGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecProviderConfigRefPolicy(obj: ParameterGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ParameterGroupSpecProviderRefPolicy
 */
export interface ParameterGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ParameterGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ParameterGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ParameterGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ParameterGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ParameterGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecProviderRefPolicy(obj: ParameterGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface ParameterGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRef(obj: ParameterGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata
 */
export interface ParameterGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsToMetadata(obj: ParameterGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ParameterGroupSpecProviderConfigRefPolicyResolution
 */
export enum ParameterGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ParameterGroupSpecProviderConfigRefPolicyResolve
 */
export enum ParameterGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ParameterGroupSpecProviderRefPolicyResolution
 */
export enum ParameterGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ParameterGroupSpecProviderRefPolicyResolve
 */
export enum ParameterGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SubnetGroup is the Schema for the SubnetGroups API. Provides an Neptune subnet group resource.
 *
 * @schema SubnetGroup
 */
export class SubnetGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SubnetGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'neptune.aws.upbound.io/v1beta1',
    kind: 'SubnetGroup',
  }

  /**
   * Renders a Kubernetes manifest for "SubnetGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubnetGroupProps): any {
    return {
      ...SubnetGroup.GVK,
      ...toJson_SubnetGroupProps(props),
    };
  }

  /**
   * Defines a "SubnetGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubnetGroupProps) {
    super(scope, id, {
      ...SubnetGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SubnetGroup.GVK,
      ...toJson_SubnetGroupProps(resolved),
    };
  }
}

/**
 * SubnetGroup is the Schema for the SubnetGroups API. Provides an Neptune subnet group resource.
 *
 * @schema SubnetGroup
 */
export interface SubnetGroupProps {
  /**
   * @schema SubnetGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SubnetGroupSpec defines the desired state of SubnetGroup
   *
   * @schema SubnetGroup#spec
   */
  readonly spec: SubnetGroupSpec;

}

/**
 * Converts an object of type 'SubnetGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupProps(obj: SubnetGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubnetGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetGroupSpec defines the desired state of SubnetGroup
 *
 * @schema SubnetGroupSpec
 */
export interface SubnetGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SubnetGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: SubnetGroupSpecDeletionPolicy;

  /**
   * @schema SubnetGroupSpec#forProvider
   */
  readonly forProvider: SubnetGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SubnetGroupSpec#managementPolicy
   */
  readonly managementPolicy?: SubnetGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SubnetGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: SubnetGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SubnetGroupSpec#providerRef
   */
  readonly providerRef?: SubnetGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SubnetGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SubnetGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SubnetGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubnetGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SubnetGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpec(obj: SubnetGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubnetGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SubnetGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SubnetGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SubnetGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SubnetGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SubnetGroupSpecDeletionPolicy
 */
export enum SubnetGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SubnetGroupSpecForProvider
 */
export interface SubnetGroupSpecForProvider {
  /**
   * The description of the neptune subnet group.
   *
   * @schema SubnetGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SubnetGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema SubnetGroupSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: SubnetGroupSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema SubnetGroupSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: SubnetGroupSpecForProviderSubnetIdSelector;

  /**
   * A list of VPC subnet IDs.
   *
   * @schema SubnetGroupSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema SubnetGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubnetGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProvider(obj: SubnetGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'region': obj.region,
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_SubnetGroupSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_SubnetGroupSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SubnetGroupSpecManagementPolicy
 */
export enum SubnetGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SubnetGroupSpecProviderConfigRef
 */
export interface SubnetGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecProviderConfigRef#policy
   */
  readonly policy?: SubnetGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderConfigRef(obj: SubnetGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SubnetGroupSpecProviderRef
 */
export interface SubnetGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecProviderRef#policy
   */
  readonly policy?: SubnetGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderRef(obj: SubnetGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsTo
 */
export interface SubnetGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SubnetGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SubnetGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsTo(obj: SubnetGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SubnetGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SubnetGroupSpecWriteConnectionSecretToRef
 */
export interface SubnetGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubnetGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubnetGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecWriteConnectionSecretToRef(obj: SubnetGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefs
 */
export interface SubnetGroupSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: SubnetGroupSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdRefs(obj: SubnetGroupSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelector
 */
export interface SubnetGroupSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: SubnetGroupSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdSelector(obj: SubnetGroupSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetGroupSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicy
 */
export interface SubnetGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderConfigRefPolicy(obj: SubnetGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecProviderRefPolicy
 */
export interface SubnetGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderRefPolicy(obj: SubnetGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface SubnetGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRef(obj: SubnetGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata
 */
export interface SubnetGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToMetadata(obj: SubnetGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicy
 */
export interface SubnetGroupSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdRefsPolicy(obj: SubnetGroupSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicy
 */
export interface SubnetGroupSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdSelectorPolicy(obj: SubnetGroupSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicyResolution
 */
export enum SubnetGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicyResolve
 */
export enum SubnetGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecProviderRefPolicyResolution
 */
export enum SubnetGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecProviderRefPolicyResolve
 */
export enum SubnetGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum SubnetGroupSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum SubnetGroupSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum SubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

