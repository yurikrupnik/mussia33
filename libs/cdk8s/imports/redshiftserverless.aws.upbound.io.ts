// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * EndpointAccess is the Schema for the EndpointAccesss API. Provides a Redshift Serverless Endpoint Access resource.
 *
 * @schema EndpointAccess
 */
export class EndpointAccess extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EndpointAccess"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshiftserverless.aws.upbound.io/v1beta1',
    kind: 'EndpointAccess',
  }

  /**
   * Renders a Kubernetes manifest for "EndpointAccess".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EndpointAccessProps): any {
    return {
      ...EndpointAccess.GVK,
      ...toJson_EndpointAccessProps(props),
    };
  }

  /**
   * Defines a "EndpointAccess" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EndpointAccessProps) {
    super(scope, id, {
      ...EndpointAccess.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EndpointAccess.GVK,
      ...toJson_EndpointAccessProps(resolved),
    };
  }
}

/**
 * EndpointAccess is the Schema for the EndpointAccesss API. Provides a Redshift Serverless Endpoint Access resource.
 *
 * @schema EndpointAccess
 */
export interface EndpointAccessProps {
  /**
   * @schema EndpointAccess#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EndpointAccessSpec defines the desired state of EndpointAccess
   *
   * @schema EndpointAccess#spec
   */
  readonly spec: EndpointAccessSpec;

}

/**
 * Converts an object of type 'EndpointAccessProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessProps(obj: EndpointAccessProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EndpointAccessSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointAccessSpec defines the desired state of EndpointAccess
 *
 * @schema EndpointAccessSpec
 */
export interface EndpointAccessSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EndpointAccessSpec#deletionPolicy
   */
  readonly deletionPolicy?: EndpointAccessSpecDeletionPolicy;

  /**
   * @schema EndpointAccessSpec#forProvider
   */
  readonly forProvider: EndpointAccessSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema EndpointAccessSpec#initProvider
   */
  readonly initProvider?: EndpointAccessSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema EndpointAccessSpec#managementPolicies
   */
  readonly managementPolicies?: EndpointAccessSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EndpointAccessSpec#providerConfigRef
   */
  readonly providerConfigRef?: EndpointAccessSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EndpointAccessSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EndpointAccessSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EndpointAccessSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EndpointAccessSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EndpointAccessSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpec(obj: EndpointAccessSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EndpointAccessSpecForProvider(obj.forProvider),
    'initProvider': toJson_EndpointAccessSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_EndpointAccessSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_EndpointAccessSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EndpointAccessSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EndpointAccessSpecDeletionPolicy
 */
export enum EndpointAccessSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EndpointAccessSpecForProvider
 */
export interface EndpointAccessSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EndpointAccessSpecForProvider#region
   */
  readonly region: string;

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema EndpointAccessSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: EndpointAccessSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema EndpointAccessSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: EndpointAccessSpecForProviderSubnetIdSelector;

  /**
   * An array of VPC subnet IDs to associate with the endpoint.
   *
   * @schema EndpointAccessSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema EndpointAccessSpecForProvider#vpcSecurityGroupIdRefs
   */
  readonly vpcSecurityGroupIdRefs?: EndpointAccessSpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema EndpointAccessSpecForProvider#vpcSecurityGroupIdSelector
   */
  readonly vpcSecurityGroupIdSelector?: EndpointAccessSpecForProviderVpcSecurityGroupIdSelector;

  /**
   * An array of security group IDs to associate with the workgroup.
   *
   * @schema EndpointAccessSpecForProvider#vpcSecurityGroupIds
   */
  readonly vpcSecurityGroupIds?: string[];

  /**
   * The name of the workgroup.
   *
   * @schema EndpointAccessSpecForProvider#workgroupName
   */
  readonly workgroupName?: string;

}

/**
 * Converts an object of type 'EndpointAccessSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecForProvider(obj: EndpointAccessSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_EndpointAccessSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_EndpointAccessSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'vpcSecurityGroupIdRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_EndpointAccessSpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIdSelector': toJson_EndpointAccessSpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIds': obj.vpcSecurityGroupIds?.map(y => y),
    'workgroupName': obj.workgroupName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema EndpointAccessSpecInitProvider
 */
export interface EndpointAccessSpecInitProvider {
  /**
   * The name of the workgroup.
   *
   * @schema EndpointAccessSpecInitProvider#workgroupName
   */
  readonly workgroupName?: string;

}

/**
 * Converts an object of type 'EndpointAccessSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecInitProvider(obj: EndpointAccessSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'workgroupName': obj.workgroupName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema EndpointAccessSpecManagementPolicies
 */
export enum EndpointAccessSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EndpointAccessSpecProviderConfigRef
 */
export interface EndpointAccessSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointAccessSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointAccessSpecProviderConfigRef#policy
   */
  readonly policy?: EndpointAccessSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointAccessSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecProviderConfigRef(obj: EndpointAccessSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointAccessSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EndpointAccessSpecPublishConnectionDetailsTo
 */
export interface EndpointAccessSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EndpointAccessSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EndpointAccessSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EndpointAccessSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EndpointAccessSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EndpointAccessSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EndpointAccessSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecPublishConnectionDetailsTo(obj: EndpointAccessSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EndpointAccessSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EndpointAccessSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EndpointAccessSpecWriteConnectionSecretToRef
 */
export interface EndpointAccessSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EndpointAccessSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EndpointAccessSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EndpointAccessSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecWriteConnectionSecretToRef(obj: EndpointAccessSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema EndpointAccessSpecForProviderSubnetIdRefs
 */
export interface EndpointAccessSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointAccessSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointAccessSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: EndpointAccessSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'EndpointAccessSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecForProviderSubnetIdRefs(obj: EndpointAccessSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointAccessSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema EndpointAccessSpecForProviderSubnetIdSelector
 */
export interface EndpointAccessSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EndpointAccessSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EndpointAccessSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EndpointAccessSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: EndpointAccessSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'EndpointAccessSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecForProviderSubnetIdSelector(obj: EndpointAccessSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EndpointAccessSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdRefs
 */
export interface EndpointAccessSpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'EndpointAccessSpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecForProviderVpcSecurityGroupIdRefs(obj: EndpointAccessSpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
 *
 * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdSelector
 */
export interface EndpointAccessSpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'EndpointAccessSpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecForProviderVpcSecurityGroupIdSelector(obj: EndpointAccessSpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointAccessSpecProviderConfigRefPolicy
 */
export interface EndpointAccessSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointAccessSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointAccessSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointAccessSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointAccessSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointAccessSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecProviderConfigRefPolicy(obj: EndpointAccessSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EndpointAccessSpecPublishConnectionDetailsToConfigRef
 */
export interface EndpointAccessSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointAccessSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointAccessSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointAccessSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecPublishConnectionDetailsToConfigRef(obj: EndpointAccessSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EndpointAccessSpecPublishConnectionDetailsToMetadata
 */
export interface EndpointAccessSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointAccessSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointAccessSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EndpointAccessSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EndpointAccessSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecPublishConnectionDetailsToMetadata(obj: EndpointAccessSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointAccessSpecForProviderSubnetIdRefsPolicy
 */
export interface EndpointAccessSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointAccessSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: EndpointAccessSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointAccessSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: EndpointAccessSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'EndpointAccessSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecForProviderSubnetIdRefsPolicy(obj: EndpointAccessSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EndpointAccessSpecForProviderSubnetIdSelectorPolicy
 */
export interface EndpointAccessSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointAccessSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: EndpointAccessSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointAccessSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: EndpointAccessSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EndpointAccessSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecForProviderSubnetIdSelectorPolicy(obj: EndpointAccessSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicy(obj: EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointAccessSpecProviderConfigRefPolicyResolution
 */
export enum EndpointAccessSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointAccessSpecProviderConfigRefPolicyResolve
 */
export enum EndpointAccessSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicy(obj: EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointAccessSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum EndpointAccessSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointAccessSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum EndpointAccessSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointAccessSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum EndpointAccessSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointAccessSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum EndpointAccessSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum EndpointAccessSpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum EndpointAccessSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EndpointAccessSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RedshiftServerlessNamespace is the Schema for the RedshiftServerlessNamespaces API. Provides a Redshift Serverless Namespace resource.
 *
 * @schema RedshiftServerlessNamespace
 */
export class RedshiftServerlessNamespace extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RedshiftServerlessNamespace"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshiftserverless.aws.upbound.io/v1beta1',
    kind: 'RedshiftServerlessNamespace',
  }

  /**
   * Renders a Kubernetes manifest for "RedshiftServerlessNamespace".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RedshiftServerlessNamespaceProps): any {
    return {
      ...RedshiftServerlessNamespace.GVK,
      ...toJson_RedshiftServerlessNamespaceProps(props),
    };
  }

  /**
   * Defines a "RedshiftServerlessNamespace" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RedshiftServerlessNamespaceProps) {
    super(scope, id, {
      ...RedshiftServerlessNamespace.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RedshiftServerlessNamespace.GVK,
      ...toJson_RedshiftServerlessNamespaceProps(resolved),
    };
  }
}

/**
 * RedshiftServerlessNamespace is the Schema for the RedshiftServerlessNamespaces API. Provides a Redshift Serverless Namespace resource.
 *
 * @schema RedshiftServerlessNamespace
 */
export interface RedshiftServerlessNamespaceProps {
  /**
   * @schema RedshiftServerlessNamespace#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RedshiftServerlessNamespaceSpec defines the desired state of RedshiftServerlessNamespace
   *
   * @schema RedshiftServerlessNamespace#spec
   */
  readonly spec: RedshiftServerlessNamespaceSpec;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceProps(obj: RedshiftServerlessNamespaceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RedshiftServerlessNamespaceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RedshiftServerlessNamespaceSpec defines the desired state of RedshiftServerlessNamespace
 *
 * @schema RedshiftServerlessNamespaceSpec
 */
export interface RedshiftServerlessNamespaceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RedshiftServerlessNamespaceSpec#deletionPolicy
   */
  readonly deletionPolicy?: RedshiftServerlessNamespaceSpecDeletionPolicy;

  /**
   * @schema RedshiftServerlessNamespaceSpec#forProvider
   */
  readonly forProvider: RedshiftServerlessNamespaceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema RedshiftServerlessNamespaceSpec#initProvider
   */
  readonly initProvider?: RedshiftServerlessNamespaceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RedshiftServerlessNamespaceSpec#managementPolicies
   */
  readonly managementPolicies?: RedshiftServerlessNamespaceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RedshiftServerlessNamespaceSpec#providerConfigRef
   */
  readonly providerConfigRef?: RedshiftServerlessNamespaceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RedshiftServerlessNamespaceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RedshiftServerlessNamespaceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RedshiftServerlessNamespaceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RedshiftServerlessNamespaceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpec(obj: RedshiftServerlessNamespaceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RedshiftServerlessNamespaceSpecForProvider(obj.forProvider),
    'initProvider': toJson_RedshiftServerlessNamespaceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RedshiftServerlessNamespaceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RedshiftServerlessNamespaceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RedshiftServerlessNamespaceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RedshiftServerlessNamespaceSpecDeletionPolicy
 */
export enum RedshiftServerlessNamespaceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RedshiftServerlessNamespaceSpecForProvider
 */
export interface RedshiftServerlessNamespaceSpecForProvider {
  /**
   * The password of the administrator for the first database created in the namespace.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#adminUserPasswordSecretRef
   */
  readonly adminUserPasswordSecretRef?: RedshiftServerlessNamespaceSpecForProviderAdminUserPasswordSecretRef;

  /**
   * The username of the administrator for the first database created in the namespace.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#adminUsernameSecretRef
   */
  readonly adminUsernameSecretRef?: RedshiftServerlessNamespaceSpecForProviderAdminUsernameSecretRef;

  /**
   * The name of the first database created in the namespace.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#dbName
   */
  readonly dbName?: string;

  /**
   * The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace. When specifying default_iam_role_arn, it also must be part of iam_roles.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#defaultIamRoleArn
   */
  readonly defaultIamRoleArn?: string;

  /**
   * Reference to a Role in iam to populate defaultIamRoleArn.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#defaultIamRoleArnRef
   */
  readonly defaultIamRoleArnRef?: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRef;

  /**
   * Selector for a Role in iam to populate defaultIamRoleArn.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#defaultIamRoleArnSelector
   */
  readonly defaultIamRoleArnSelector?: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelector;

  /**
   * References to Role in iam to populate iamRoles.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#iamRoleRefs
   */
  readonly iamRoleRefs?: RedshiftServerlessNamespaceSpecForProviderIamRoleRefs[];

  /**
   * Selector for a list of Role in iam to populate iamRoles.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#iamRoleSelector
   */
  readonly iamRoleSelector?: RedshiftServerlessNamespaceSpecForProviderIamRoleSelector;

  /**
   * A list of IAM roles to associate with the namespace.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#iamRoles
   */
  readonly iamRoles?: string[];

  /**
   * The ARN of the Amazon Web Services Key Management Service key used to encrypt your data.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelector;

  /**
   * The types of logs the namespace can export. Available export types are userlog, connectionlog, and useractivitylog.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#logExports
   */
  readonly logExports?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RedshiftServerlessNamespaceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProvider(obj: RedshiftServerlessNamespaceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminUserPasswordSecretRef': toJson_RedshiftServerlessNamespaceSpecForProviderAdminUserPasswordSecretRef(obj.adminUserPasswordSecretRef),
    'adminUsernameSecretRef': toJson_RedshiftServerlessNamespaceSpecForProviderAdminUsernameSecretRef(obj.adminUsernameSecretRef),
    'dbName': obj.dbName,
    'defaultIamRoleArn': obj.defaultIamRoleArn,
    'defaultIamRoleArnRef': toJson_RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRef(obj.defaultIamRoleArnRef),
    'defaultIamRoleArnSelector': toJson_RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelector(obj.defaultIamRoleArnSelector),
    'iamRoleRefs': obj.iamRoleRefs?.map(y => toJson_RedshiftServerlessNamespaceSpecForProviderIamRoleRefs(y)),
    'iamRoleSelector': toJson_RedshiftServerlessNamespaceSpecForProviderIamRoleSelector(obj.iamRoleSelector),
    'iamRoles': obj.iamRoles?.map(y => y),
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'logExports': obj.logExports?.map(y => y),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema RedshiftServerlessNamespaceSpecInitProvider
 */
export interface RedshiftServerlessNamespaceSpecInitProvider {
  /**
   * The name of the first database created in the namespace.
   *
   * @schema RedshiftServerlessNamespaceSpecInitProvider#dbName
   */
  readonly dbName?: string;

  /**
   * The types of logs the namespace can export. Available export types are userlog, connectionlog, and useractivitylog.
   *
   * @schema RedshiftServerlessNamespaceSpecInitProvider#logExports
   */
  readonly logExports?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema RedshiftServerlessNamespaceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecInitProvider(obj: RedshiftServerlessNamespaceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbName': obj.dbName,
    'logExports': obj.logExports?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema RedshiftServerlessNamespaceSpecManagementPolicies
 */
export enum RedshiftServerlessNamespaceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RedshiftServerlessNamespaceSpecProviderConfigRef
 */
export interface RedshiftServerlessNamespaceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RedshiftServerlessNamespaceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RedshiftServerlessNamespaceSpecProviderConfigRef#policy
   */
  readonly policy?: RedshiftServerlessNamespaceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecProviderConfigRef(obj: RedshiftServerlessNamespaceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RedshiftServerlessNamespaceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsTo
 */
export interface RedshiftServerlessNamespaceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RedshiftServerlessNamespaceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecPublishConnectionDetailsTo(obj: RedshiftServerlessNamespaceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RedshiftServerlessNamespaceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RedshiftServerlessNamespaceSpecWriteConnectionSecretToRef
 */
export interface RedshiftServerlessNamespaceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RedshiftServerlessNamespaceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RedshiftServerlessNamespaceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecWriteConnectionSecretToRef(obj: RedshiftServerlessNamespaceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password of the administrator for the first database created in the namespace.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderAdminUserPasswordSecretRef
 */
export interface RedshiftServerlessNamespaceSpecForProviderAdminUserPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderAdminUserPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderAdminUserPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderAdminUserPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderAdminUserPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderAdminUserPasswordSecretRef(obj: RedshiftServerlessNamespaceSpecForProviderAdminUserPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The username of the administrator for the first database created in the namespace.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderAdminUsernameSecretRef
 */
export interface RedshiftServerlessNamespaceSpecForProviderAdminUsernameSecretRef {
  /**
   * The key to select.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderAdminUsernameSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderAdminUsernameSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderAdminUsernameSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderAdminUsernameSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderAdminUsernameSecretRef(obj: RedshiftServerlessNamespaceSpecForProviderAdminUsernameSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate defaultIamRoleArn.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRef
 */
export interface RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRef#policy
   */
  readonly policy?: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRef(obj: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate defaultIamRoleArn.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelector
 */
export interface RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelector#policy
   */
  readonly policy?: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelector(obj: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleRefs
 */
export interface RedshiftServerlessNamespaceSpecForProviderIamRoleRefs {
  /**
   * Name of the referenced object.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleRefs#policy
   */
  readonly policy?: RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicy;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderIamRoleRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderIamRoleRefs(obj: RedshiftServerlessNamespaceSpecForProviderIamRoleRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Role in iam to populate iamRoles.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleSelector
 */
export interface RedshiftServerlessNamespaceSpecForProviderIamRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleSelector#policy
   */
  readonly policy?: RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicy;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderIamRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderIamRoleSelector(obj: RedshiftServerlessNamespaceSpecForProviderIamRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRef
 */
export interface RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRef(obj: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelector
 */
export interface RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelector(obj: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RedshiftServerlessNamespaceSpecProviderConfigRefPolicy
 */
export interface RedshiftServerlessNamespaceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RedshiftServerlessNamespaceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RedshiftServerlessNamespaceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RedshiftServerlessNamespaceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RedshiftServerlessNamespaceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecProviderConfigRefPolicy(obj: RedshiftServerlessNamespaceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRef
 */
export interface RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRef(obj: RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToMetadata
 */
export interface RedshiftServerlessNamespaceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecPublishConnectionDetailsToMetadata(obj: RedshiftServerlessNamespaceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicy
 */
export interface RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicy(obj: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicy
 */
export interface RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicy(obj: RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicy
 */
export interface RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicy#resolution
   */
  readonly resolution?: RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicy#resolve
   */
  readonly resolve?: RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicyResolve;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicy(obj: RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicy
 */
export interface RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicy#resolution
   */
  readonly resolution?: RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicy#resolve
   */
  readonly resolve?: RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicy(obj: RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicy
 */
export interface RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicy(obj: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicy(obj: RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RedshiftServerlessNamespaceSpecProviderConfigRefPolicyResolution
 */
export enum RedshiftServerlessNamespaceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RedshiftServerlessNamespaceSpecProviderConfigRefPolicyResolve
 */
export enum RedshiftServerlessNamespaceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicy(obj: RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicyResolution
 */
export enum RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicyResolve
 */
export enum RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicyResolution
 */
export enum RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicyResolve
 */
export enum RedshiftServerlessNamespaceSpecForProviderDefaultIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicyResolution
 */
export enum RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicyResolve
 */
export enum RedshiftServerlessNamespaceSpecForProviderIamRoleRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicyResolution
 */
export enum RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicyResolve
 */
export enum RedshiftServerlessNamespaceSpecForProviderIamRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum RedshiftServerlessNamespaceSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum RedshiftServerlessNamespaceSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RedshiftServerlessNamespaceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ResourcePolicy is the Schema for the ResourcePolicys API. Provides a Redshift Serverless Resource Policy resource.
 *
 * @schema ResourcePolicy
 */
export class ResourcePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResourcePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshiftserverless.aws.upbound.io/v1beta1',
    kind: 'ResourcePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ResourcePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResourcePolicyProps): any {
    return {
      ...ResourcePolicy.GVK,
      ...toJson_ResourcePolicyProps(props),
    };
  }

  /**
   * Defines a "ResourcePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResourcePolicyProps) {
    super(scope, id, {
      ...ResourcePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResourcePolicy.GVK,
      ...toJson_ResourcePolicyProps(resolved),
    };
  }
}

/**
 * ResourcePolicy is the Schema for the ResourcePolicys API. Provides a Redshift Serverless Resource Policy resource.
 *
 * @schema ResourcePolicy
 */
export interface ResourcePolicyProps {
  /**
   * @schema ResourcePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResourcePolicySpec defines the desired state of ResourcePolicy
   *
   * @schema ResourcePolicy#spec
   */
  readonly spec: ResourcePolicySpec;

}

/**
 * Converts an object of type 'ResourcePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicyProps(obj: ResourcePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResourcePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourcePolicySpec defines the desired state of ResourcePolicy
 *
 * @schema ResourcePolicySpec
 */
export interface ResourcePolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResourcePolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: ResourcePolicySpecDeletionPolicy;

  /**
   * @schema ResourcePolicySpec#forProvider
   */
  readonly forProvider: ResourcePolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ResourcePolicySpec#initProvider
   */
  readonly initProvider?: ResourcePolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ResourcePolicySpec#managementPolicies
   */
  readonly managementPolicies?: ResourcePolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResourcePolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: ResourcePolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResourcePolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResourcePolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResourcePolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResourcePolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResourcePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpec(obj: ResourcePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResourcePolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_ResourcePolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ResourcePolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ResourcePolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResourcePolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResourcePolicySpecDeletionPolicy
 */
export enum ResourcePolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ResourcePolicySpecForProvider
 */
export interface ResourcePolicySpecForProvider {
  /**
   * The policy to create or update. For example, the following policy grants a user authorization to restore a snapshot.
   *
   * @schema ResourcePolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ResourcePolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the account to create or update a resource policy for.
   *
   * @schema ResourcePolicySpecForProvider#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a Snapshot in redshiftserverless to populate resourceArn.
   *
   * @schema ResourcePolicySpecForProvider#resourceArnRef
   */
  readonly resourceArnRef?: ResourcePolicySpecForProviderResourceArnRef;

  /**
   * Selector for a Snapshot in redshiftserverless to populate resourceArn.
   *
   * @schema ResourcePolicySpecForProvider#resourceArnSelector
   */
  readonly resourceArnSelector?: ResourcePolicySpecForProviderResourceArnSelector;

}

/**
 * Converts an object of type 'ResourcePolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecForProvider(obj: ResourcePolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
    'region': obj.region,
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_ResourcePolicySpecForProviderResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_ResourcePolicySpecForProviderResourceArnSelector(obj.resourceArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ResourcePolicySpecInitProvider
 */
export interface ResourcePolicySpecInitProvider {
  /**
   * The policy to create or update. For example, the following policy grants a user authorization to restore a snapshot.
   *
   * @schema ResourcePolicySpecInitProvider#policy
   */
  readonly policy?: string;

}

/**
 * Converts an object of type 'ResourcePolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecInitProvider(obj: ResourcePolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ResourcePolicySpecManagementPolicies
 */
export enum ResourcePolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResourcePolicySpecProviderConfigRef
 */
export interface ResourcePolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourcePolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourcePolicySpecProviderConfigRef#policy
   */
  readonly policy?: ResourcePolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourcePolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecProviderConfigRef(obj: ResourcePolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourcePolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsTo
 */
export interface ResourcePolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResourcePolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResourcePolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResourcePolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecPublishConnectionDetailsTo(obj: ResourcePolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResourcePolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResourcePolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResourcePolicySpecWriteConnectionSecretToRef
 */
export interface ResourcePolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResourcePolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResourcePolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResourcePolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecWriteConnectionSecretToRef(obj: ResourcePolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Snapshot in redshiftserverless to populate resourceArn.
 *
 * @schema ResourcePolicySpecForProviderResourceArnRef
 */
export interface ResourcePolicySpecForProviderResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourcePolicySpecForProviderResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourcePolicySpecForProviderResourceArnRef#policy
   */
  readonly policy?: ResourcePolicySpecForProviderResourceArnRefPolicy;

}

/**
 * Converts an object of type 'ResourcePolicySpecForProviderResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecForProviderResourceArnRef(obj: ResourcePolicySpecForProviderResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourcePolicySpecForProviderResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Snapshot in redshiftserverless to populate resourceArn.
 *
 * @schema ResourcePolicySpecForProviderResourceArnSelector
 */
export interface ResourcePolicySpecForProviderResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResourcePolicySpecForProviderResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResourcePolicySpecForProviderResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResourcePolicySpecForProviderResourceArnSelector#policy
   */
  readonly policy?: ResourcePolicySpecForProviderResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'ResourcePolicySpecForProviderResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecForProviderResourceArnSelector(obj: ResourcePolicySpecForProviderResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResourcePolicySpecForProviderResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourcePolicySpecProviderConfigRefPolicy
 */
export interface ResourcePolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourcePolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResourcePolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourcePolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResourcePolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourcePolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecProviderConfigRefPolicy(obj: ResourcePolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRef
 */
export interface ResourcePolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourcePolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecPublishConnectionDetailsToConfigRef(obj: ResourcePolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsToMetadata
 */
export interface ResourcePolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResourcePolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecPublishConnectionDetailsToMetadata(obj: ResourcePolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourcePolicySpecForProviderResourceArnRefPolicy
 */
export interface ResourcePolicySpecForProviderResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourcePolicySpecForProviderResourceArnRefPolicy#resolution
   */
  readonly resolution?: ResourcePolicySpecForProviderResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourcePolicySpecForProviderResourceArnRefPolicy#resolve
   */
  readonly resolve?: ResourcePolicySpecForProviderResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourcePolicySpecForProviderResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecForProviderResourceArnRefPolicy(obj: ResourcePolicySpecForProviderResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResourcePolicySpecForProviderResourceArnSelectorPolicy
 */
export interface ResourcePolicySpecForProviderResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourcePolicySpecForProviderResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: ResourcePolicySpecForProviderResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourcePolicySpecForProviderResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: ResourcePolicySpecForProviderResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResourcePolicySpecForProviderResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecForProviderResourceArnSelectorPolicy(obj: ResourcePolicySpecForProviderResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourcePolicySpecProviderConfigRefPolicyResolution
 */
export enum ResourcePolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourcePolicySpecProviderConfigRefPolicyResolve
 */
export enum ResourcePolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourcePolicySpecForProviderResourceArnRefPolicyResolution
 */
export enum ResourcePolicySpecForProviderResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourcePolicySpecForProviderResourceArnRefPolicyResolve
 */
export enum ResourcePolicySpecForProviderResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourcePolicySpecForProviderResourceArnSelectorPolicyResolution
 */
export enum ResourcePolicySpecForProviderResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourcePolicySpecForProviderResourceArnSelectorPolicyResolve
 */
export enum ResourcePolicySpecForProviderResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResourcePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Snapshot is the Schema for the Snapshots API. Provides a Redshift Serverless Snapshot resource.
 *
 * @schema Snapshot
 */
export class Snapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Snapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshiftserverless.aws.upbound.io/v1beta1',
    kind: 'Snapshot',
  }

  /**
   * Renders a Kubernetes manifest for "Snapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SnapshotProps): any {
    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(props),
    };
  }

  /**
   * Defines a "Snapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SnapshotProps) {
    super(scope, id, {
      ...Snapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(resolved),
    };
  }
}

/**
 * Snapshot is the Schema for the Snapshots API. Provides a Redshift Serverless Snapshot resource.
 *
 * @schema Snapshot
 */
export interface SnapshotProps {
  /**
   * @schema Snapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SnapshotSpec defines the desired state of Snapshot
   *
   * @schema Snapshot#spec
   */
  readonly spec: SnapshotSpec;

}

/**
 * Converts an object of type 'SnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotProps(obj: SnapshotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SnapshotSpec defines the desired state of Snapshot
 *
 * @schema SnapshotSpec
 */
export interface SnapshotSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SnapshotSpec#deletionPolicy
   */
  readonly deletionPolicy?: SnapshotSpecDeletionPolicy;

  /**
   * @schema SnapshotSpec#forProvider
   */
  readonly forProvider: SnapshotSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SnapshotSpec#initProvider
   */
  readonly initProvider?: SnapshotSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SnapshotSpec#managementPolicies
   */
  readonly managementPolicies?: SnapshotSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SnapshotSpec#providerConfigRef
   */
  readonly providerConfigRef?: SnapshotSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SnapshotSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SnapshotSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SnapshotSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SnapshotSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpec(obj: SnapshotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SnapshotSpecForProvider(obj.forProvider),
    'initProvider': toJson_SnapshotSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SnapshotSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SnapshotSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SnapshotSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SnapshotSpecDeletionPolicy
 */
export enum SnapshotSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SnapshotSpecForProvider
 */
export interface SnapshotSpecForProvider {
  /**
   * The namespace to create a snapshot for.
   *
   * @schema SnapshotSpecForProvider#namespaceName
   */
  readonly namespaceName?: string;

  /**
   * Reference to a Workgroup in redshiftserverless to populate namespaceName.
   *
   * @schema SnapshotSpecForProvider#namespaceNameRef
   */
  readonly namespaceNameRef?: SnapshotSpecForProviderNamespaceNameRef;

  /**
   * Selector for a Workgroup in redshiftserverless to populate namespaceName.
   *
   * @schema SnapshotSpecForProvider#namespaceNameSelector
   */
  readonly namespaceNameSelector?: SnapshotSpecForProviderNamespaceNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SnapshotSpecForProvider#region
   */
  readonly region: string;

  /**
   * How long to retain the created snapshot. Default value is -1.
   *
   * @schema SnapshotSpecForProvider#retentionPeriod
   */
  readonly retentionPeriod?: number;

}

/**
 * Converts an object of type 'SnapshotSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProvider(obj: SnapshotSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceName': obj.namespaceName,
    'namespaceNameRef': toJson_SnapshotSpecForProviderNamespaceNameRef(obj.namespaceNameRef),
    'namespaceNameSelector': toJson_SnapshotSpecForProviderNamespaceNameSelector(obj.namespaceNameSelector),
    'region': obj.region,
    'retentionPeriod': obj.retentionPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SnapshotSpecInitProvider
 */
export interface SnapshotSpecInitProvider {
  /**
   * How long to retain the created snapshot. Default value is -1.
   *
   * @schema SnapshotSpecInitProvider#retentionPeriod
   */
  readonly retentionPeriod?: number;

}

/**
 * Converts an object of type 'SnapshotSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecInitProvider(obj: SnapshotSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'retentionPeriod': obj.retentionPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SnapshotSpecManagementPolicies
 */
export enum SnapshotSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SnapshotSpecProviderConfigRef
 */
export interface SnapshotSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotSpecProviderConfigRef#policy
   */
  readonly policy?: SnapshotSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecProviderConfigRef(obj: SnapshotSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SnapshotSpecPublishConnectionDetailsTo
 */
export interface SnapshotSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SnapshotSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SnapshotSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SnapshotSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SnapshotSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SnapshotSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsTo(obj: SnapshotSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SnapshotSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SnapshotSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SnapshotSpecWriteConnectionSecretToRef
 */
export interface SnapshotSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SnapshotSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SnapshotSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SnapshotSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecWriteConnectionSecretToRef(obj: SnapshotSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workgroup in redshiftserverless to populate namespaceName.
 *
 * @schema SnapshotSpecForProviderNamespaceNameRef
 */
export interface SnapshotSpecForProviderNamespaceNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotSpecForProviderNamespaceNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotSpecForProviderNamespaceNameRef#policy
   */
  readonly policy?: SnapshotSpecForProviderNamespaceNameRefPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderNamespaceNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderNamespaceNameRef(obj: SnapshotSpecForProviderNamespaceNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotSpecForProviderNamespaceNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workgroup in redshiftserverless to populate namespaceName.
 *
 * @schema SnapshotSpecForProviderNamespaceNameSelector
 */
export interface SnapshotSpecForProviderNamespaceNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SnapshotSpecForProviderNamespaceNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SnapshotSpecForProviderNamespaceNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SnapshotSpecForProviderNamespaceNameSelector#policy
   */
  readonly policy?: SnapshotSpecForProviderNamespaceNameSelectorPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderNamespaceNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderNamespaceNameSelector(obj: SnapshotSpecForProviderNamespaceNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SnapshotSpecForProviderNamespaceNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotSpecProviderConfigRefPolicy
 */
export interface SnapshotSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecProviderConfigRefPolicy(obj: SnapshotSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRef
 */
export interface SnapshotSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SnapshotSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsToConfigRef(obj: SnapshotSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToMetadata
 */
export interface SnapshotSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsToMetadata(obj: SnapshotSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SnapshotSpecForProviderNamespaceNameRefPolicy
 */
export interface SnapshotSpecForProviderNamespaceNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecForProviderNamespaceNameRefPolicy#resolution
   */
  readonly resolution?: SnapshotSpecForProviderNamespaceNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecForProviderNamespaceNameRefPolicy#resolve
   */
  readonly resolve?: SnapshotSpecForProviderNamespaceNameRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderNamespaceNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderNamespaceNameRefPolicy(obj: SnapshotSpecForProviderNamespaceNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SnapshotSpecForProviderNamespaceNameSelectorPolicy
 */
export interface SnapshotSpecForProviderNamespaceNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecForProviderNamespaceNameSelectorPolicy#resolution
   */
  readonly resolution?: SnapshotSpecForProviderNamespaceNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecForProviderNamespaceNameSelectorPolicy#resolve
   */
  readonly resolve?: SnapshotSpecForProviderNamespaceNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecForProviderNamespaceNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecForProviderNamespaceNameSelectorPolicy(obj: SnapshotSpecForProviderNamespaceNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecProviderConfigRefPolicyResolution
 */
export enum SnapshotSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecProviderConfigRefPolicyResolve
 */
export enum SnapshotSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SnapshotSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SnapshotSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj: SnapshotSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecForProviderNamespaceNameRefPolicyResolution
 */
export enum SnapshotSpecForProviderNamespaceNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecForProviderNamespaceNameRefPolicyResolve
 */
export enum SnapshotSpecForProviderNamespaceNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecForProviderNamespaceNameSelectorPolicyResolution
 */
export enum SnapshotSpecForProviderNamespaceNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecForProviderNamespaceNameSelectorPolicyResolve
 */
export enum SnapshotSpecForProviderNamespaceNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UsageLimit is the Schema for the UsageLimits API. Provides a Redshift Serverless Usage Limit resource.
 *
 * @schema UsageLimit
 */
export class UsageLimit extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UsageLimit"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshiftserverless.aws.upbound.io/v1beta1',
    kind: 'UsageLimit',
  }

  /**
   * Renders a Kubernetes manifest for "UsageLimit".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UsageLimitProps): any {
    return {
      ...UsageLimit.GVK,
      ...toJson_UsageLimitProps(props),
    };
  }

  /**
   * Defines a "UsageLimit" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UsageLimitProps) {
    super(scope, id, {
      ...UsageLimit.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UsageLimit.GVK,
      ...toJson_UsageLimitProps(resolved),
    };
  }
}

/**
 * UsageLimit is the Schema for the UsageLimits API. Provides a Redshift Serverless Usage Limit resource.
 *
 * @schema UsageLimit
 */
export interface UsageLimitProps {
  /**
   * @schema UsageLimit#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UsageLimitSpec defines the desired state of UsageLimit
   *
   * @schema UsageLimit#spec
   */
  readonly spec: UsageLimitSpec;

}

/**
 * Converts an object of type 'UsageLimitProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitProps(obj: UsageLimitProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UsageLimitSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UsageLimitSpec defines the desired state of UsageLimit
 *
 * @schema UsageLimitSpec
 */
export interface UsageLimitSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UsageLimitSpec#deletionPolicy
   */
  readonly deletionPolicy?: UsageLimitSpecDeletionPolicy;

  /**
   * @schema UsageLimitSpec#forProvider
   */
  readonly forProvider: UsageLimitSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema UsageLimitSpec#initProvider
   */
  readonly initProvider?: UsageLimitSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UsageLimitSpec#managementPolicies
   */
  readonly managementPolicies?: UsageLimitSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UsageLimitSpec#providerConfigRef
   */
  readonly providerConfigRef?: UsageLimitSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UsageLimitSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UsageLimitSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UsageLimitSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UsageLimitSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UsageLimitSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpec(obj: UsageLimitSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UsageLimitSpecForProvider(obj.forProvider),
    'initProvider': toJson_UsageLimitSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UsageLimitSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UsageLimitSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UsageLimitSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UsageLimitSpecDeletionPolicy
 */
export enum UsageLimitSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UsageLimitSpecForProvider
 */
export interface UsageLimitSpecForProvider {
  /**
   * The limit amount. If time-based, this amount is in Redshift Processing Units (RPU) consumed per hour. If data-based, this amount is in terabytes (TB) of data transferred between Regions in cross-account sharing. The value must be a positive number.
   *
   * @schema UsageLimitSpecForProvider#amount
   */
  readonly amount?: number;

  /**
   * The action that Amazon Redshift Serverless takes when the limit is reached. Valid values are log, emit-metric, and deactivate. The default is log.
   *
   * @schema UsageLimitSpecForProvider#breachAction
   */
  readonly breachAction?: string;

  /**
   * The time period that the amount applies to. A weekly period begins on Sunday. Valid values are daily, weekly, and monthly. The default is monthly.
   *
   * @schema UsageLimitSpecForProvider#period
   */
  readonly period?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UsageLimitSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the Amazon Redshift Serverless resource to create the usage limit for.
   *
   * @schema UsageLimitSpecForProvider#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a Workgroup in redshiftserverless to populate resourceArn.
   *
   * @schema UsageLimitSpecForProvider#resourceArnRef
   */
  readonly resourceArnRef?: UsageLimitSpecForProviderResourceArnRef;

  /**
   * Selector for a Workgroup in redshiftserverless to populate resourceArn.
   *
   * @schema UsageLimitSpecForProvider#resourceArnSelector
   */
  readonly resourceArnSelector?: UsageLimitSpecForProviderResourceArnSelector;

  /**
   * The type of Amazon Redshift Serverless usage to create a usage limit for. Valid values are serverless-compute or cross-region-datasharing.
   *
   * @schema UsageLimitSpecForProvider#usageType
   */
  readonly usageType?: string;

}

/**
 * Converts an object of type 'UsageLimitSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecForProvider(obj: UsageLimitSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amount': obj.amount,
    'breachAction': obj.breachAction,
    'period': obj.period,
    'region': obj.region,
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_UsageLimitSpecForProviderResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_UsageLimitSpecForProviderResourceArnSelector(obj.resourceArnSelector),
    'usageType': obj.usageType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema UsageLimitSpecInitProvider
 */
export interface UsageLimitSpecInitProvider {
  /**
   * The limit amount. If time-based, this amount is in Redshift Processing Units (RPU) consumed per hour. If data-based, this amount is in terabytes (TB) of data transferred between Regions in cross-account sharing. The value must be a positive number.
   *
   * @schema UsageLimitSpecInitProvider#amount
   */
  readonly amount?: number;

  /**
   * The action that Amazon Redshift Serverless takes when the limit is reached. Valid values are log, emit-metric, and deactivate. The default is log.
   *
   * @schema UsageLimitSpecInitProvider#breachAction
   */
  readonly breachAction?: string;

  /**
   * The time period that the amount applies to. A weekly period begins on Sunday. Valid values are daily, weekly, and monthly. The default is monthly.
   *
   * @schema UsageLimitSpecInitProvider#period
   */
  readonly period?: string;

  /**
   * The type of Amazon Redshift Serverless usage to create a usage limit for. Valid values are serverless-compute or cross-region-datasharing.
   *
   * @schema UsageLimitSpecInitProvider#usageType
   */
  readonly usageType?: string;

}

/**
 * Converts an object of type 'UsageLimitSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecInitProvider(obj: UsageLimitSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'amount': obj.amount,
    'breachAction': obj.breachAction,
    'period': obj.period,
    'usageType': obj.usageType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UsageLimitSpecManagementPolicies
 */
export enum UsageLimitSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UsageLimitSpecProviderConfigRef
 */
export interface UsageLimitSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsageLimitSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsageLimitSpecProviderConfigRef#policy
   */
  readonly policy?: UsageLimitSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UsageLimitSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecProviderConfigRef(obj: UsageLimitSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsageLimitSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsTo
 */
export interface UsageLimitSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UsageLimitSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UsageLimitSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UsageLimitSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecPublishConnectionDetailsTo(obj: UsageLimitSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UsageLimitSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UsageLimitSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UsageLimitSpecWriteConnectionSecretToRef
 */
export interface UsageLimitSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UsageLimitSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UsageLimitSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UsageLimitSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecWriteConnectionSecretToRef(obj: UsageLimitSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Workgroup in redshiftserverless to populate resourceArn.
 *
 * @schema UsageLimitSpecForProviderResourceArnRef
 */
export interface UsageLimitSpecForProviderResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsageLimitSpecForProviderResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsageLimitSpecForProviderResourceArnRef#policy
   */
  readonly policy?: UsageLimitSpecForProviderResourceArnRefPolicy;

}

/**
 * Converts an object of type 'UsageLimitSpecForProviderResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecForProviderResourceArnRef(obj: UsageLimitSpecForProviderResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsageLimitSpecForProviderResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Workgroup in redshiftserverless to populate resourceArn.
 *
 * @schema UsageLimitSpecForProviderResourceArnSelector
 */
export interface UsageLimitSpecForProviderResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UsageLimitSpecForProviderResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UsageLimitSpecForProviderResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UsageLimitSpecForProviderResourceArnSelector#policy
   */
  readonly policy?: UsageLimitSpecForProviderResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'UsageLimitSpecForProviderResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecForProviderResourceArnSelector(obj: UsageLimitSpecForProviderResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UsageLimitSpecForProviderResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsageLimitSpecProviderConfigRefPolicy
 */
export interface UsageLimitSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsageLimitSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UsageLimitSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsageLimitSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UsageLimitSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsageLimitSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecProviderConfigRefPolicy(obj: UsageLimitSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsToConfigRef
 */
export interface UsageLimitSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UsageLimitSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecPublishConnectionDetailsToConfigRef(obj: UsageLimitSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsToMetadata
 */
export interface UsageLimitSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UsageLimitSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecPublishConnectionDetailsToMetadata(obj: UsageLimitSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UsageLimitSpecForProviderResourceArnRefPolicy
 */
export interface UsageLimitSpecForProviderResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsageLimitSpecForProviderResourceArnRefPolicy#resolution
   */
  readonly resolution?: UsageLimitSpecForProviderResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsageLimitSpecForProviderResourceArnRefPolicy#resolve
   */
  readonly resolve?: UsageLimitSpecForProviderResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'UsageLimitSpecForProviderResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecForProviderResourceArnRefPolicy(obj: UsageLimitSpecForProviderResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UsageLimitSpecForProviderResourceArnSelectorPolicy
 */
export interface UsageLimitSpecForProviderResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsageLimitSpecForProviderResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: UsageLimitSpecForProviderResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsageLimitSpecForProviderResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: UsageLimitSpecForProviderResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UsageLimitSpecForProviderResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecForProviderResourceArnSelectorPolicy(obj: UsageLimitSpecForProviderResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsageLimitSpecProviderConfigRefPolicyResolution
 */
export enum UsageLimitSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsageLimitSpecProviderConfigRefPolicyResolve
 */
export enum UsageLimitSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy(obj: UsageLimitSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsageLimitSpecForProviderResourceArnRefPolicyResolution
 */
export enum UsageLimitSpecForProviderResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsageLimitSpecForProviderResourceArnRefPolicyResolve
 */
export enum UsageLimitSpecForProviderResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsageLimitSpecForProviderResourceArnSelectorPolicyResolution
 */
export enum UsageLimitSpecForProviderResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsageLimitSpecForProviderResourceArnSelectorPolicyResolve
 */
export enum UsageLimitSpecForProviderResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UsageLimitSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Workgroup is the Schema for the Workgroups API. Provides a Redshift Serverless Workgroup resource.
 *
 * @schema Workgroup
 */
export class Workgroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Workgroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'redshiftserverless.aws.upbound.io/v1beta1',
    kind: 'Workgroup',
  }

  /**
   * Renders a Kubernetes manifest for "Workgroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkgroupProps): any {
    return {
      ...Workgroup.GVK,
      ...toJson_WorkgroupProps(props),
    };
  }

  /**
   * Defines a "Workgroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkgroupProps) {
    super(scope, id, {
      ...Workgroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Workgroup.GVK,
      ...toJson_WorkgroupProps(resolved),
    };
  }
}

/**
 * Workgroup is the Schema for the Workgroups API. Provides a Redshift Serverless Workgroup resource.
 *
 * @schema Workgroup
 */
export interface WorkgroupProps {
  /**
   * @schema Workgroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkgroupSpec defines the desired state of Workgroup
   *
   * @schema Workgroup#spec
   */
  readonly spec: WorkgroupSpec;

}

/**
 * Converts an object of type 'WorkgroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupProps(obj: WorkgroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkgroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkgroupSpec defines the desired state of Workgroup
 *
 * @schema WorkgroupSpec
 */
export interface WorkgroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkgroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkgroupSpecDeletionPolicy;

  /**
   * @schema WorkgroupSpec#forProvider
   */
  readonly forProvider: WorkgroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema WorkgroupSpec#initProvider
   */
  readonly initProvider?: WorkgroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WorkgroupSpec#managementPolicies
   */
  readonly managementPolicies?: WorkgroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkgroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkgroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkgroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkgroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkgroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkgroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkgroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpec(obj: WorkgroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkgroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_WorkgroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WorkgroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WorkgroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkgroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkgroupSpecDeletionPolicy
 */
export enum WorkgroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkgroupSpecForProvider
 */
export interface WorkgroupSpecForProvider {
  /**
   * The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).
   *
   * @schema WorkgroupSpecForProvider#baseCapacity
   */
  readonly baseCapacity?: number;

  /**
   * An array of parameters to set for more control over a serverless database. See Config Parameter below.
   *
   * @schema WorkgroupSpecForProvider#configParameter
   */
  readonly configParameter?: WorkgroupSpecForProviderConfigParameter[];

  /**
   * The value that specifies whether to turn on enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC instead of over the internet.
   *
   * @schema WorkgroupSpecForProvider#enhancedVpcRouting
   */
  readonly enhancedVpcRouting?: boolean;

  /**
   * The name of the namespace.
   *
   * @schema WorkgroupSpecForProvider#namespaceName
   */
  readonly namespaceName?: string;

  /**
   * A value that specifies whether the workgroup can be accessed from a public network.
   *
   * @schema WorkgroupSpecForProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WorkgroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * References to SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema WorkgroupSpecForProvider#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: WorkgroupSpecForProviderSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema WorkgroupSpecForProvider#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: WorkgroupSpecForProviderSecurityGroupIdSelector;

  /**
   * An array of security group IDs to associate with the workgroup.
   *
   * @schema WorkgroupSpecForProvider#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema WorkgroupSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: WorkgroupSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema WorkgroupSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: WorkgroupSpecForProviderSubnetIdSelector;

  /**
   * An array of VPC subnet IDs to associate with the workgroup. When set, must contain at least three subnets spanning three Availability Zones. A minimum number of IP addresses is required and scales with the Base Capacity. For more information, see the following AWS document.
   *
   * @schema WorkgroupSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkgroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkgroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProvider(obj: WorkgroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseCapacity': obj.baseCapacity,
    'configParameter': obj.configParameter?.map(y => toJson_WorkgroupSpecForProviderConfigParameter(y)),
    'enhancedVpcRouting': obj.enhancedVpcRouting,
    'namespaceName': obj.namespaceName,
    'publiclyAccessible': obj.publiclyAccessible,
    'region': obj.region,
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_WorkgroupSpecForProviderSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_WorkgroupSpecForProviderSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_WorkgroupSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_WorkgroupSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema WorkgroupSpecInitProvider
 */
export interface WorkgroupSpecInitProvider {
  /**
   * The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).
   *
   * @schema WorkgroupSpecInitProvider#baseCapacity
   */
  readonly baseCapacity?: number;

  /**
   * An array of parameters to set for more control over a serverless database. See Config Parameter below.
   *
   * @schema WorkgroupSpecInitProvider#configParameter
   */
  readonly configParameter?: WorkgroupSpecInitProviderConfigParameter[];

  /**
   * The value that specifies whether to turn on enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC instead of over the internet.
   *
   * @schema WorkgroupSpecInitProvider#enhancedVpcRouting
   */
  readonly enhancedVpcRouting?: boolean;

  /**
   * The name of the namespace.
   *
   * @schema WorkgroupSpecInitProvider#namespaceName
   */
  readonly namespaceName?: string;

  /**
   * A value that specifies whether the workgroup can be accessed from a public network.
   *
   * @schema WorkgroupSpecInitProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkgroupSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkgroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecInitProvider(obj: WorkgroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseCapacity': obj.baseCapacity,
    'configParameter': obj.configParameter?.map(y => toJson_WorkgroupSpecInitProviderConfigParameter(y)),
    'enhancedVpcRouting': obj.enhancedVpcRouting,
    'namespaceName': obj.namespaceName,
    'publiclyAccessible': obj.publiclyAccessible,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WorkgroupSpecManagementPolicies
 */
export enum WorkgroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkgroupSpecProviderConfigRef
 */
export interface WorkgroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkgroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkgroupSpecProviderConfigRef#policy
   */
  readonly policy?: WorkgroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkgroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecProviderConfigRef(obj: WorkgroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkgroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsTo
 */
export interface WorkgroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkgroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkgroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkgroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecPublishConnectionDetailsTo(obj: WorkgroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkgroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkgroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkgroupSpecWriteConnectionSecretToRef
 */
export interface WorkgroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkgroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkgroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkgroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecWriteConnectionSecretToRef(obj: WorkgroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkgroupSpecForProviderConfigParameter
 */
export interface WorkgroupSpecForProviderConfigParameter {
  /**
   * The key of the parameter. The options are datestyle, enable_user_activity_logging, query_group, search_path, and max_query_execution_time.
   *
   * @schema WorkgroupSpecForProviderConfigParameter#parameterKey
   */
  readonly parameterKey?: string;

  /**
   * The value of the parameter to set.
   *
   * @schema WorkgroupSpecForProviderConfigParameter#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderConfigParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderConfigParameter(obj: WorkgroupSpecForProviderConfigParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterKey': obj.parameterKey,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema WorkgroupSpecForProviderSecurityGroupIdRefs
 */
export interface WorkgroupSpecForProviderSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema WorkgroupSpecForProviderSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkgroupSpecForProviderSecurityGroupIdRefs#policy
   */
  readonly policy?: WorkgroupSpecForProviderSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderSecurityGroupIdRefs(obj: WorkgroupSpecForProviderSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkgroupSpecForProviderSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
 *
 * @schema WorkgroupSpecForProviderSecurityGroupIdSelector
 */
export interface WorkgroupSpecForProviderSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkgroupSpecForProviderSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkgroupSpecForProviderSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkgroupSpecForProviderSecurityGroupIdSelector#policy
   */
  readonly policy?: WorkgroupSpecForProviderSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderSecurityGroupIdSelector(obj: WorkgroupSpecForProviderSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkgroupSpecForProviderSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema WorkgroupSpecForProviderSubnetIdRefs
 */
export interface WorkgroupSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema WorkgroupSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkgroupSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: WorkgroupSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderSubnetIdRefs(obj: WorkgroupSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkgroupSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema WorkgroupSpecForProviderSubnetIdSelector
 */
export interface WorkgroupSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkgroupSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkgroupSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkgroupSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: WorkgroupSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderSubnetIdSelector(obj: WorkgroupSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkgroupSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkgroupSpecInitProviderConfigParameter
 */
export interface WorkgroupSpecInitProviderConfigParameter {
  /**
   * The key of the parameter. The options are datestyle, enable_user_activity_logging, query_group, search_path, and max_query_execution_time.
   *
   * @schema WorkgroupSpecInitProviderConfigParameter#parameterKey
   */
  readonly parameterKey?: string;

  /**
   * The value of the parameter to set.
   *
   * @schema WorkgroupSpecInitProviderConfigParameter#parameterValue
   */
  readonly parameterValue?: string;

}

/**
 * Converts an object of type 'WorkgroupSpecInitProviderConfigParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecInitProviderConfigParameter(obj: WorkgroupSpecInitProviderConfigParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterKey': obj.parameterKey,
    'parameterValue': obj.parameterValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkgroupSpecProviderConfigRefPolicy
 */
export interface WorkgroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkgroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkgroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkgroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkgroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkgroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecProviderConfigRefPolicy(obj: WorkgroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkgroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkgroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecPublishConnectionDetailsToConfigRef(obj: WorkgroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsToMetadata
 */
export interface WorkgroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkgroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecPublishConnectionDetailsToMetadata(obj: WorkgroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkgroupSpecForProviderSecurityGroupIdRefsPolicy
 */
export interface WorkgroupSpecForProviderSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkgroupSpecForProviderSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: WorkgroupSpecForProviderSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkgroupSpecForProviderSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: WorkgroupSpecForProviderSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderSecurityGroupIdRefsPolicy(obj: WorkgroupSpecForProviderSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkgroupSpecForProviderSecurityGroupIdSelectorPolicy
 */
export interface WorkgroupSpecForProviderSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkgroupSpecForProviderSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: WorkgroupSpecForProviderSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkgroupSpecForProviderSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: WorkgroupSpecForProviderSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderSecurityGroupIdSelectorPolicy(obj: WorkgroupSpecForProviderSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkgroupSpecForProviderSubnetIdRefsPolicy
 */
export interface WorkgroupSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkgroupSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: WorkgroupSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkgroupSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: WorkgroupSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderSubnetIdRefsPolicy(obj: WorkgroupSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkgroupSpecForProviderSubnetIdSelectorPolicy
 */
export interface WorkgroupSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkgroupSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: WorkgroupSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkgroupSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: WorkgroupSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkgroupSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecForProviderSubnetIdSelectorPolicy(obj: WorkgroupSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkgroupSpecProviderConfigRefPolicyResolution
 */
export enum WorkgroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkgroupSpecProviderConfigRefPolicyResolve
 */
export enum WorkgroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkgroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkgroupSpecForProviderSecurityGroupIdRefsPolicyResolution
 */
export enum WorkgroupSpecForProviderSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkgroupSpecForProviderSecurityGroupIdRefsPolicyResolve
 */
export enum WorkgroupSpecForProviderSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkgroupSpecForProviderSecurityGroupIdSelectorPolicyResolution
 */
export enum WorkgroupSpecForProviderSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkgroupSpecForProviderSecurityGroupIdSelectorPolicyResolve
 */
export enum WorkgroupSpecForProviderSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkgroupSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum WorkgroupSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkgroupSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum WorkgroupSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkgroupSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum WorkgroupSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkgroupSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum WorkgroupSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkgroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

