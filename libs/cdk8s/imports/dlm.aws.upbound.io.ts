// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * LifecyclePolicy is the Schema for the LifecyclePolicys API. Provides a Data Lifecycle Manager (DLM) lifecycle policy for managing snapshots.
 *
 * @schema LifecyclePolicy
 */
export class LifecyclePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LifecyclePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dlm.aws.upbound.io/v1beta1',
    kind: 'LifecyclePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "LifecyclePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LifecyclePolicyProps): any {
    return {
      ...LifecyclePolicy.GVK,
      ...toJson_LifecyclePolicyProps(props),
    };
  }

  /**
   * Defines a "LifecyclePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LifecyclePolicyProps) {
    super(scope, id, {
      ...LifecyclePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LifecyclePolicy.GVK,
      ...toJson_LifecyclePolicyProps(resolved),
    };
  }
}

/**
 * LifecyclePolicy is the Schema for the LifecyclePolicys API. Provides a Data Lifecycle Manager (DLM) lifecycle policy for managing snapshots.
 *
 * @schema LifecyclePolicy
 */
export interface LifecyclePolicyProps {
  /**
   * @schema LifecyclePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LifecyclePolicySpec defines the desired state of LifecyclePolicy
   *
   * @schema LifecyclePolicy#spec
   */
  readonly spec: LifecyclePolicySpec;

}

/**
 * Converts an object of type 'LifecyclePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicyProps(obj: LifecyclePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LifecyclePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LifecyclePolicySpec defines the desired state of LifecyclePolicy
 *
 * @schema LifecyclePolicySpec
 */
export interface LifecyclePolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LifecyclePolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: LifecyclePolicySpecDeletionPolicy;

  /**
   * @schema LifecyclePolicySpec#forProvider
   */
  readonly forProvider: LifecyclePolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LifecyclePolicySpec#managementPolicy
   */
  readonly managementPolicy?: LifecyclePolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LifecyclePolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: LifecyclePolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LifecyclePolicySpec#providerRef
   */
  readonly providerRef?: LifecyclePolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LifecyclePolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LifecyclePolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LifecyclePolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LifecyclePolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LifecyclePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpec(obj: LifecyclePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LifecyclePolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LifecyclePolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LifecyclePolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LifecyclePolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LifecyclePolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LifecyclePolicySpecDeletionPolicy
 */
export enum LifecyclePolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LifecyclePolicySpecForProvider
 */
export interface LifecyclePolicySpecForProvider {
  /**
   * A description for the DLM lifecycle policy.
   *
   * @schema LifecyclePolicySpecForProvider#description
   */
  readonly description?: string;

  /**
   * The ARN of an IAM role that is able to be assumed by the DLM service.
   *
   * @schema LifecyclePolicySpecForProvider#executionRoleArn
   */
  readonly executionRoleArn?: string;

  /**
   * Reference to a Role in iam to populate executionRoleArn.
   *
   * @schema LifecyclePolicySpecForProvider#executionRoleArnRef
   */
  readonly executionRoleArnRef?: LifecyclePolicySpecForProviderExecutionRoleArnRef;

  /**
   * Selector for a Role in iam to populate executionRoleArn.
   *
   * @schema LifecyclePolicySpecForProvider#executionRoleArnSelector
   */
  readonly executionRoleArnSelector?: LifecyclePolicySpecForProviderExecutionRoleArnSelector;

  /**
   * See the policy_details configuration block. Max of 1.
   *
   * @schema LifecyclePolicySpecForProvider#policyDetails
   */
  readonly policyDetails?: LifecyclePolicySpecForProviderPolicyDetails[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LifecyclePolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * Whether the lifecycle policy should be enabled or disabled. ENABLED or DISABLED are valid values. Defaults to ENABLED.
   *
   * @default ENABLED.
   * @schema LifecyclePolicySpecForProvider#state
   */
  readonly state?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema LifecyclePolicySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProvider(obj: LifecyclePolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'executionRoleArn': obj.executionRoleArn,
    'executionRoleArnRef': toJson_LifecyclePolicySpecForProviderExecutionRoleArnRef(obj.executionRoleArnRef),
    'executionRoleArnSelector': toJson_LifecyclePolicySpecForProviderExecutionRoleArnSelector(obj.executionRoleArnSelector),
    'policyDetails': obj.policyDetails?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetails(y)),
    'region': obj.region,
    'state': obj.state,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LifecyclePolicySpecManagementPolicy
 */
export enum LifecyclePolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LifecyclePolicySpecProviderConfigRef
 */
export interface LifecyclePolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecProviderConfigRef#policy
   */
  readonly policy?: LifecyclePolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecProviderConfigRef(obj: LifecyclePolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LifecyclePolicySpecProviderRef
 */
export interface LifecyclePolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecProviderRef#policy
   */
  readonly policy?: LifecyclePolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecProviderRef(obj: LifecyclePolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsTo
 */
export interface LifecyclePolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LifecyclePolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LifecyclePolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsTo(obj: LifecyclePolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LifecyclePolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LifecyclePolicySpecWriteConnectionSecretToRef
 */
export interface LifecyclePolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LifecyclePolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LifecyclePolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecWriteConnectionSecretToRef(obj: LifecyclePolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate executionRoleArn.
 *
 * @schema LifecyclePolicySpecForProviderExecutionRoleArnRef
 */
export interface LifecyclePolicySpecForProviderExecutionRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecForProviderExecutionRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecForProviderExecutionRoleArnRef#policy
   */
  readonly policy?: LifecyclePolicySpecForProviderExecutionRoleArnRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderExecutionRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderExecutionRoleArnRef(obj: LifecyclePolicySpecForProviderExecutionRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecForProviderExecutionRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate executionRoleArn.
 *
 * @schema LifecyclePolicySpecForProviderExecutionRoleArnSelector
 */
export interface LifecyclePolicySpecForProviderExecutionRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LifecyclePolicySpecForProviderExecutionRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LifecyclePolicySpecForProviderExecutionRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LifecyclePolicySpecForProviderExecutionRoleArnSelector#policy
   */
  readonly policy?: LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderExecutionRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderExecutionRoleArnSelector(obj: LifecyclePolicySpecForProviderExecutionRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetails
 */
export interface LifecyclePolicySpecForProviderPolicyDetails {
  /**
   * The actions to be performed when the event-based policy is triggered. You can specify only one action per policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the action configuration block.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetails#action
   */
  readonly action?: LifecyclePolicySpecForProviderPolicyDetailsAction[];

  /**
   * The event that triggers the event-based policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the event_source configuration block.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetails#eventSource
   */
  readonly eventSource?: LifecyclePolicySpecForProviderPolicyDetailsEventSource[];

  /**
   * A set of optional parameters for snapshot and AMI lifecycle policies. See the parameters configuration block.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetails#parameters
   */
  readonly parameters?: LifecyclePolicySpecForProviderPolicyDetailsParameters[];

  /**
   * The valid target resource types and actions a policy can manage. Specify EBS_SNAPSHOT_MANAGEMENT to create a lifecycle policy that manages the lifecycle of Amazon EBS snapshots. Specify IMAGE_MANAGEMENT to create a lifecycle policy that manages the lifecycle of EBS-backed AMIs. Specify EVENT_BASED_POLICY to create an event-based policy that performs specific actions when a defined event occurs in your AWS account. Default value is EBS_SNAPSHOT_MANAGEMENT.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetails#policyType
   */
  readonly policyType?: string;

  /**
   * The location of the resources to backup. If the source resources are located in an AWS Region, specify CLOUD. If the source resources are located on an Outpost in your account, specify OUTPOST. If you specify OUTPOST, Amazon Data Lifecycle Manager backs up all resources of the specified type with matching target tags across all of the Outposts in your account. Valid values are CLOUD and OUTPOST.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetails#resourceLocations
   */
  readonly resourceLocations?: string[];

  /**
   * A list of resource types that should be targeted by the lifecycle policy. Valid values are VOLUME and INSTANCE.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetails#resourceTypes
   */
  readonly resourceTypes?: string[];

  /**
   * See the schedule configuration block.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetails#schedule
   */
  readonly schedule?: LifecyclePolicySpecForProviderPolicyDetailsSchedule[];

  /**
   * A map of tag keys and their values. Any resources that match the resource_types and are tagged with any of these tags will be targeted.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetails#targetTags
   */
  readonly targetTags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetails(obj: LifecyclePolicySpecForProviderPolicyDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsAction(y)),
    'eventSource': obj.eventSource?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsEventSource(y)),
    'parameters': obj.parameters?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsParameters(y)),
    'policyType': obj.policyType,
    'resourceLocations': obj.resourceLocations?.map(y => y),
    'resourceTypes': obj.resourceTypes?.map(y => y),
    'schedule': obj.schedule?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsSchedule(y)),
    'targetTags': ((obj.targetTags) === undefined) ? undefined : (Object.entries(obj.targetTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecProviderConfigRefPolicy
 */
export interface LifecyclePolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecProviderConfigRefPolicy(obj: LifecyclePolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecProviderRefPolicy
 */
export interface LifecyclePolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecProviderRefPolicy(obj: LifecyclePolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRef
 */
export interface LifecyclePolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRef(obj: LifecyclePolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata
 */
export interface LifecyclePolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsToMetadata(obj: LifecyclePolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecForProviderExecutionRoleArnRefPolicy
 */
export interface LifecyclePolicySpecForProviderExecutionRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecForProviderExecutionRoleArnRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecForProviderExecutionRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecForProviderExecutionRoleArnRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecForProviderExecutionRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderExecutionRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderExecutionRoleArnRefPolicy(obj: LifecyclePolicySpecForProviderExecutionRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicy
 */
export interface LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicy(obj: LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsAction
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsAction {
  /**
   * The rule for copying shared snapshots across Regions. See the cross_region_copy configuration block.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsAction#crossRegionCopy
   */
  readonly crossRegionCopy: LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopy[];

  /**
   * A descriptive name for the action.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsAction#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsAction(obj: LifecyclePolicySpecForProviderPolicyDetailsAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'crossRegionCopy': obj.crossRegionCopy?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopy(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsEventSource
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsEventSource {
  /**
   * A set of optional parameters for snapshot and AMI lifecycle policies. See the parameters configuration block.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsEventSource#parameters
   */
  readonly parameters: LifecyclePolicySpecForProviderPolicyDetailsEventSourceParameters[];

  /**
   * The source of the event. Currently only managed CloudWatch Events rules are supported. Valid values are MANAGED_CWE.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsEventSource#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsEventSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsEventSource(obj: LifecyclePolicySpecForProviderPolicyDetailsEventSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameters': obj.parameters?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsEventSourceParameters(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsParameters
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsParameters {
  /**
   * Indicates whether to exclude the root volume from snapshots created using CreateSnapshots. The default is false.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsParameters#excludeBootVolume
   */
  readonly excludeBootVolume?: boolean;

  /**
   * Applies to AMI lifecycle policies only. Indicates whether targeted instances are rebooted when the lifecycle policy runs. true indicates that targeted instances are not rebooted when the policy runs. false indicates that target instances are rebooted when the policy runs. The default is true (instances are not rebooted).
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsParameters#noReboot
   */
  readonly noReboot?: boolean;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsParameters(obj: LifecyclePolicySpecForProviderPolicyDetailsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'excludeBootVolume': obj.excludeBootVolume,
    'noReboot': obj.noReboot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsSchedule
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsSchedule {
  /**
   * Copy all user-defined tags on a source volume to snapshots of the volume created by this policy.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsSchedule#copyTags
   */
  readonly copyTags?: boolean;

  /**
   * See the create_rule block. Max of 1 per schedule.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsSchedule#createRule
   */
  readonly createRule: LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule[];

  /**
   * See the cross_region_copy_rule block. Max of 3 per schedule.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsSchedule#crossRegionCopyRule
   */
  readonly crossRegionCopyRule?: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule[];

  /**
   * See the deprecate_rule block. Max of 1 per schedule.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsSchedule#deprecateRule
   */
  readonly deprecateRule?: LifecyclePolicySpecForProviderPolicyDetailsScheduleDeprecateRule[];

  /**
   * See the fast_restore_rule block. Max of 1 per schedule.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsSchedule#fastRestoreRule
   */
  readonly fastRestoreRule?: LifecyclePolicySpecForProviderPolicyDetailsScheduleFastRestoreRule[];

  /**
   * A descriptive name for the action.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsSchedule#name
   */
  readonly name: string;

  /**
   * Specifies the retention rule for cross-Region snapshot copies. See the retain_rule block. Max of 1 per action.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsSchedule#retainRule
   */
  readonly retainRule: LifecyclePolicySpecForProviderPolicyDetailsScheduleRetainRule[];

  /**
   * See the share_rule block. Max of 1 per schedule.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsSchedule#shareRule
   */
  readonly shareRule?: LifecyclePolicySpecForProviderPolicyDetailsScheduleShareRule[];

  /**
   * A map of tag keys and their values. DLM lifecycle policies will already tag the snapshot with the tags on the volume. This configuration adds extra tags on top of these.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsSchedule#tagsToAdd
   */
  readonly tagsToAdd?: { [key: string]: string };

  /**
   * A map of tag keys and variable values, where the values are determined when the policy is executed. Only $(instance-id) or $(timestamp) are valid values. Can only be used when resource_types is INSTANCE.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsSchedule#variableTags
   */
  readonly variableTags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsSchedule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsSchedule(obj: LifecyclePolicySpecForProviderPolicyDetailsSchedule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'copyTags': obj.copyTags,
    'createRule': obj.createRule?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule(y)),
    'crossRegionCopyRule': obj.crossRegionCopyRule?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule(y)),
    'deprecateRule': obj.deprecateRule?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleDeprecateRule(y)),
    'fastRestoreRule': obj.fastRestoreRule?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleFastRestoreRule(y)),
    'name': obj.name,
    'retainRule': obj.retainRule?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleRetainRule(y)),
    'shareRule': obj.shareRule?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleShareRule(y)),
    'tagsToAdd': ((obj.tagsToAdd) === undefined) ? undefined : (Object.entries(obj.tagsToAdd).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'variableTags': ((obj.variableTags) === undefined) ? undefined : (Object.entries(obj.variableTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecProviderConfigRefPolicyResolution
 */
export enum LifecyclePolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecProviderConfigRefPolicyResolve
 */
export enum LifecyclePolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecProviderRefPolicyResolution
 */
export enum LifecyclePolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecProviderRefPolicyResolve
 */
export enum LifecyclePolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecForProviderExecutionRoleArnRefPolicyResolution
 */
export enum LifecyclePolicySpecForProviderExecutionRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecForProviderExecutionRoleArnRefPolicyResolve
 */
export enum LifecyclePolicySpecForProviderExecutionRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicyResolution
 */
export enum LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicyResolve
 */
export enum LifecyclePolicySpecForProviderExecutionRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopy
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopy {
  /**
   * The encryption settings for the copied snapshot. See the encryption_configuration block. Max of 1 per action.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopy#encryptionConfiguration
   */
  readonly encryptionConfiguration: LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyEncryptionConfiguration[];

  /**
   * Specifies the retention rule for cross-Region snapshot copies. See the retain_rule block. Max of 1 per action.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopy#retainRule
   */
  readonly retainRule?: LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyRetainRule[];

  /**
   * The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopy#target
   */
  readonly target: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopy(obj: LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyEncryptionConfiguration(y)),
    'retainRule': obj.retainRule?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyRetainRule(y)),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsEventSourceParameters
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsEventSourceParameters {
  /**
   * The snapshot description that can trigger the policy. The description pattern is specified using a regular expression. The policy runs only if a snapshot with a description that matches the specified pattern is shared with your account.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsEventSourceParameters#descriptionRegex
   */
  readonly descriptionRegex: string;

  /**
   * The type of event. Currently, only shareSnapshot events are supported.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsEventSourceParameters#eventType
   */
  readonly eventType: string;

  /**
   * The IDs of the AWS accounts that can trigger policy by sharing snapshots with your account. The policy only runs if one of the specified AWS accounts shares a snapshot with your account.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsEventSourceParameters#snapshotOwner
   */
  readonly snapshotOwner: string[];

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsEventSourceParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsEventSourceParameters(obj: LifecyclePolicySpecForProviderPolicyDetailsEventSourceParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'descriptionRegex': obj.descriptionRegex,
    'eventType': obj.eventType,
    'snapshotOwner': obj.snapshotOwner?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule {
  /**
   * The schedule, as a Cron expression. The schedule interval must be between 1 hour and 1 year.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule#cronExpression
   */
  readonly cronExpression?: string;

  /**
   * How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule#interval
   */
  readonly interval?: number;

  /**
   * The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule#intervalUnit
   */
  readonly intervalUnit?: string;

  /**
   * Specifies the destination for snapshots created by the policy. To create snapshots in the same Region as the source resource, specify CLOUD. To create snapshots on the same Outpost as the source resource, specify OUTPOST_LOCAL. If you omit this parameter, CLOUD is used by default. If the policy targets resources in an AWS Region, then you must create snapshots in the same Region as the source resource. If the policy targets resources on an Outpost, then you can create snapshots on the same Outpost as the source resource, or in the Region of that Outpost. Valid values are CLOUD and OUTPOST_LOCAL.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule#location
   */
  readonly location?: string;

  /**
   * A list of times in 24 hour clock format that sets when the lifecycle policy should be evaluated. Max of 1.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule#times
   */
  readonly times?: string[];

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleCreateRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cronExpression': obj.cronExpression,
    'interval': obj.interval,
    'intervalUnit': obj.intervalUnit,
    'location': obj.location,
    'times': obj.times?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule {
  /**
   * The Amazon Resource Name (ARN) of the AWS KMS key to use for EBS encryption. If this parameter is not specified, the default KMS key for the account is used.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule#cmkArn
   */
  readonly cmkArn?: string;

  /**
   * Reference to a Key in kms to populate cmkArn.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule#cmkArnRef
   */
  readonly cmkArnRef?: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRef;

  /**
   * Selector for a Key in kms to populate cmkArn.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule#cmkArnSelector
   */
  readonly cmkArnSelector?: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelector;

  /**
   * Copy all user-defined tags on a source volume to snapshots of the volume created by this policy.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule#copyTags
   */
  readonly copyTags?: boolean;

  /**
   * See the deprecate_rule block. Max of 1 per schedule.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule#deprecateRule
   */
  readonly deprecateRule?: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule[];

  /**
   * To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this parameter is false or when encryption by default is not enabled.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule#encrypted
   */
  readonly encrypted: boolean;

  /**
   * Specifies the retention rule for cross-Region snapshot copies. See the retain_rule block. Max of 1 per action.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule#retainRule
   */
  readonly retainRule?: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleRetainRule[];

  /**
   * The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule#target
   */
  readonly target: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cmkArn': obj.cmkArn,
    'cmkArnRef': toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRef(obj.cmkArnRef),
    'cmkArnSelector': toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelector(obj.cmkArnSelector),
    'copyTags': obj.copyTags,
    'deprecateRule': obj.deprecateRule?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule(y)),
    'encrypted': obj.encrypted,
    'retainRule': obj.retainRule?.map(y => toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleRetainRule(y)),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleDeprecateRule
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleDeprecateRule {
  /**
   * Specifies the number of oldest AMIs to deprecate. Must be an integer between 1 and 1000.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleDeprecateRule#count
   */
  readonly count?: number;

  /**
   * How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleDeprecateRule#interval
   */
  readonly interval?: number;

  /**
   * The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleDeprecateRule#intervalUnit
   */
  readonly intervalUnit?: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleDeprecateRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleDeprecateRule(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleDeprecateRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'interval': obj.interval,
    'intervalUnit': obj.intervalUnit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleFastRestoreRule
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleFastRestoreRule {
  /**
   * The Availability Zones in which to enable fast snapshot restore.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleFastRestoreRule#availabilityZones
   */
  readonly availabilityZones: string[];

  /**
   * Specifies the number of oldest AMIs to deprecate. Must be an integer between 1 and 1000.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleFastRestoreRule#count
   */
  readonly count?: number;

  /**
   * How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleFastRestoreRule#interval
   */
  readonly interval?: number;

  /**
   * The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleFastRestoreRule#intervalUnit
   */
  readonly intervalUnit?: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleFastRestoreRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleFastRestoreRule(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleFastRestoreRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'count': obj.count,
    'interval': obj.interval,
    'intervalUnit': obj.intervalUnit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleRetainRule
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleRetainRule {
  /**
   * Specifies the number of oldest AMIs to deprecate. Must be an integer between 1 and 1000.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleRetainRule#count
   */
  readonly count?: number;

  /**
   * How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleRetainRule#interval
   */
  readonly interval?: number;

  /**
   * The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleRetainRule#intervalUnit
   */
  readonly intervalUnit?: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleRetainRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleRetainRule(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleRetainRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'interval': obj.interval,
    'intervalUnit': obj.intervalUnit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleShareRule
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleShareRule {
  /**
   * The IDs of the AWS accounts with which to share the snapshots.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleShareRule#targetAccounts
   */
  readonly targetAccounts: string[];

  /**
   * How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleShareRule#unshareInterval
   */
  readonly unshareInterval?: number;

  /**
   * The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleShareRule#unshareIntervalUnit
   */
  readonly unshareIntervalUnit?: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleShareRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleShareRule(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleShareRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'targetAccounts': obj.targetAccounts?.map(y => y),
    'unshareInterval': obj.unshareInterval,
    'unshareIntervalUnit': obj.unshareIntervalUnit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyEncryptionConfiguration
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyEncryptionConfiguration {
  /**
   * The Amazon Resource Name (ARN) of the AWS KMS key to use for EBS encryption. If this parameter is not specified, the default KMS key for the account is used.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyEncryptionConfiguration#cmkArn
   */
  readonly cmkArn?: string;

  /**
   * To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this parameter is false or when encryption by default is not enabled.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyEncryptionConfiguration#encrypted
   */
  readonly encrypted?: boolean;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyEncryptionConfiguration(obj: LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cmkArn': obj.cmkArn,
    'encrypted': obj.encrypted,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyRetainRule
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyRetainRule {
  /**
   * How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyRetainRule#interval
   */
  readonly interval: number;

  /**
   * The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyRetainRule#intervalUnit
   */
  readonly intervalUnit: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyRetainRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyRetainRule(obj: LifecyclePolicySpecForProviderPolicyDetailsActionCrossRegionCopyRetainRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'intervalUnit': obj.intervalUnit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate cmkArn.
 *
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRef
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRef#policy
   */
  readonly policy?: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRef(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate cmkArn.
 *
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelector
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelector#policy
   */
  readonly policy?: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelector(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule {
  /**
   * How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule#interval
   */
  readonly interval: number;

  /**
   * The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule#intervalUnit
   */
  readonly intervalUnit: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleDeprecateRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'intervalUnit': obj.intervalUnit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleRetainRule
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleRetainRule {
  /**
   * How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleRetainRule#interval
   */
  readonly interval: number;

  /**
   * The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleRetainRule#intervalUnit
   */
  readonly intervalUnit: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleRetainRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleRetainRule(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleRetainRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'intervalUnit': obj.intervalUnit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicy
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicy(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicy
 */
export interface LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicy(obj: LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicyResolution
 */
export enum LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicyResolve
 */
export enum LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicyResolution
 */
export enum LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicyResolve
 */
export enum LifecyclePolicySpecForProviderPolicyDetailsScheduleCrossRegionCopyRuleCmkArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

