// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * LifecyclePolicy is the Schema for the LifecyclePolicys API. Manages an ECR repository lifecycle policy.
 *
 * @schema LifecyclePolicy
 */
export class LifecyclePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LifecyclePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.upbound.io/v1beta1',
    kind: 'LifecyclePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "LifecyclePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LifecyclePolicyProps): any {
    return {
      ...LifecyclePolicy.GVK,
      ...toJson_LifecyclePolicyProps(props),
    };
  }

  /**
   * Defines a "LifecyclePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LifecyclePolicyProps) {
    super(scope, id, {
      ...LifecyclePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LifecyclePolicy.GVK,
      ...toJson_LifecyclePolicyProps(resolved),
    };
  }
}

/**
 * LifecyclePolicy is the Schema for the LifecyclePolicys API. Manages an ECR repository lifecycle policy.
 *
 * @schema LifecyclePolicy
 */
export interface LifecyclePolicyProps {
  /**
   * @schema LifecyclePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LifecyclePolicySpec defines the desired state of LifecyclePolicy
   *
   * @schema LifecyclePolicy#spec
   */
  readonly spec: LifecyclePolicySpec;

}

/**
 * Converts an object of type 'LifecyclePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicyProps(obj: LifecyclePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LifecyclePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LifecyclePolicySpec defines the desired state of LifecyclePolicy
 *
 * @schema LifecyclePolicySpec
 */
export interface LifecyclePolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LifecyclePolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: LifecyclePolicySpecDeletionPolicy;

  /**
   * @schema LifecyclePolicySpec#forProvider
   */
  readonly forProvider: LifecyclePolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LifecyclePolicySpec#managementPolicy
   */
  readonly managementPolicy?: LifecyclePolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LifecyclePolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: LifecyclePolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LifecyclePolicySpec#providerRef
   */
  readonly providerRef?: LifecyclePolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LifecyclePolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LifecyclePolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LifecyclePolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LifecyclePolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LifecyclePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpec(obj: LifecyclePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LifecyclePolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LifecyclePolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LifecyclePolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LifecyclePolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LifecyclePolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LifecyclePolicySpecDeletionPolicy
 */
export enum LifecyclePolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LifecyclePolicySpecForProvider
 */
export interface LifecyclePolicySpecForProvider {
  /**
   * The policy document. This is a JSON formatted string. See more details about Policy Parameters in the official AWS docs.
   *
   * @schema LifecyclePolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LifecyclePolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * Name of the repository to apply the policy.
   *
   * @schema LifecyclePolicySpecForProvider#repository
   */
  readonly repository?: string;

  /**
   * Reference to a Repository in ecr to populate repository.
   *
   * @schema LifecyclePolicySpecForProvider#repositoryRef
   */
  readonly repositoryRef?: LifecyclePolicySpecForProviderRepositoryRef;

  /**
   * Selector for a Repository in ecr to populate repository.
   *
   * @schema LifecyclePolicySpecForProvider#repositorySelector
   */
  readonly repositorySelector?: LifecyclePolicySpecForProviderRepositorySelector;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProvider(obj: LifecyclePolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
    'region': obj.region,
    'repository': obj.repository,
    'repositoryRef': toJson_LifecyclePolicySpecForProviderRepositoryRef(obj.repositoryRef),
    'repositorySelector': toJson_LifecyclePolicySpecForProviderRepositorySelector(obj.repositorySelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LifecyclePolicySpecManagementPolicy
 */
export enum LifecyclePolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LifecyclePolicySpecProviderConfigRef
 */
export interface LifecyclePolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecProviderConfigRef#policy
   */
  readonly policy?: LifecyclePolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecProviderConfigRef(obj: LifecyclePolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LifecyclePolicySpecProviderRef
 */
export interface LifecyclePolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecProviderRef#policy
   */
  readonly policy?: LifecyclePolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecProviderRef(obj: LifecyclePolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsTo
 */
export interface LifecyclePolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LifecyclePolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LifecyclePolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsTo(obj: LifecyclePolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LifecyclePolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LifecyclePolicySpecWriteConnectionSecretToRef
 */
export interface LifecyclePolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LifecyclePolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LifecyclePolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecWriteConnectionSecretToRef(obj: LifecyclePolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Repository in ecr to populate repository.
 *
 * @schema LifecyclePolicySpecForProviderRepositoryRef
 */
export interface LifecyclePolicySpecForProviderRepositoryRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryRef#policy
   */
  readonly policy?: LifecyclePolicySpecForProviderRepositoryRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderRepositoryRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderRepositoryRef(obj: LifecyclePolicySpecForProviderRepositoryRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecForProviderRepositoryRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Repository in ecr to populate repository.
 *
 * @schema LifecyclePolicySpecForProviderRepositorySelector
 */
export interface LifecyclePolicySpecForProviderRepositorySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LifecyclePolicySpecForProviderRepositorySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LifecyclePolicySpecForProviderRepositorySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LifecyclePolicySpecForProviderRepositorySelector#policy
   */
  readonly policy?: LifecyclePolicySpecForProviderRepositorySelectorPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderRepositorySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderRepositorySelector(obj: LifecyclePolicySpecForProviderRepositorySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LifecyclePolicySpecForProviderRepositorySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecProviderConfigRefPolicy
 */
export interface LifecyclePolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecProviderConfigRefPolicy(obj: LifecyclePolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecProviderRefPolicy
 */
export interface LifecyclePolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecProviderRefPolicy(obj: LifecyclePolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRef
 */
export interface LifecyclePolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRef(obj: LifecyclePolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata
 */
export interface LifecyclePolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsToMetadata(obj: LifecyclePolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecForProviderRepositoryRefPolicy
 */
export interface LifecyclePolicySpecForProviderRepositoryRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecForProviderRepositoryRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecForProviderRepositoryRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecForProviderRepositoryRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderRepositoryRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderRepositoryRefPolicy(obj: LifecyclePolicySpecForProviderRepositoryRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LifecyclePolicySpecForProviderRepositorySelectorPolicy
 */
export interface LifecyclePolicySpecForProviderRepositorySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecForProviderRepositorySelectorPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecForProviderRepositorySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecForProviderRepositorySelectorPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecForProviderRepositorySelectorPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecForProviderRepositorySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecForProviderRepositorySelectorPolicy(obj: LifecyclePolicySpecForProviderRepositorySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecProviderConfigRefPolicyResolution
 */
export enum LifecyclePolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecProviderConfigRefPolicyResolve
 */
export enum LifecyclePolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecProviderRefPolicyResolution
 */
export enum LifecyclePolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecProviderRefPolicyResolve
 */
export enum LifecyclePolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecForProviderRepositoryRefPolicyResolution
 */
export enum LifecyclePolicySpecForProviderRepositoryRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecForProviderRepositoryRefPolicyResolve
 */
export enum LifecyclePolicySpecForProviderRepositoryRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecForProviderRepositorySelectorPolicyResolution
 */
export enum LifecyclePolicySpecForProviderRepositorySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecForProviderRepositorySelectorPolicyResolve
 */
export enum LifecyclePolicySpecForProviderRepositorySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LifecyclePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PullThroughCacheRule is the Schema for the PullThroughCacheRules API. Provides an Elastic Container Registry Pull Through Cache Rule.
 *
 * @schema PullThroughCacheRule
 */
export class PullThroughCacheRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PullThroughCacheRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.upbound.io/v1beta1',
    kind: 'PullThroughCacheRule',
  }

  /**
   * Renders a Kubernetes manifest for "PullThroughCacheRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PullThroughCacheRuleProps): any {
    return {
      ...PullThroughCacheRule.GVK,
      ...toJson_PullThroughCacheRuleProps(props),
    };
  }

  /**
   * Defines a "PullThroughCacheRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PullThroughCacheRuleProps) {
    super(scope, id, {
      ...PullThroughCacheRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PullThroughCacheRule.GVK,
      ...toJson_PullThroughCacheRuleProps(resolved),
    };
  }
}

/**
 * PullThroughCacheRule is the Schema for the PullThroughCacheRules API. Provides an Elastic Container Registry Pull Through Cache Rule.
 *
 * @schema PullThroughCacheRule
 */
export interface PullThroughCacheRuleProps {
  /**
   * @schema PullThroughCacheRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PullThroughCacheRuleSpec defines the desired state of PullThroughCacheRule
   *
   * @schema PullThroughCacheRule#spec
   */
  readonly spec: PullThroughCacheRuleSpec;

}

/**
 * Converts an object of type 'PullThroughCacheRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleProps(obj: PullThroughCacheRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PullThroughCacheRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PullThroughCacheRuleSpec defines the desired state of PullThroughCacheRule
 *
 * @schema PullThroughCacheRuleSpec
 */
export interface PullThroughCacheRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PullThroughCacheRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: PullThroughCacheRuleSpecDeletionPolicy;

  /**
   * @schema PullThroughCacheRuleSpec#forProvider
   */
  readonly forProvider: PullThroughCacheRuleSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PullThroughCacheRuleSpec#managementPolicy
   */
  readonly managementPolicy?: PullThroughCacheRuleSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PullThroughCacheRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: PullThroughCacheRuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PullThroughCacheRuleSpec#providerRef
   */
  readonly providerRef?: PullThroughCacheRuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PullThroughCacheRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PullThroughCacheRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PullThroughCacheRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PullThroughCacheRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PullThroughCacheRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleSpec(obj: PullThroughCacheRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PullThroughCacheRuleSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PullThroughCacheRuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PullThroughCacheRuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PullThroughCacheRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PullThroughCacheRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PullThroughCacheRuleSpecDeletionPolicy
 */
export enum PullThroughCacheRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PullThroughCacheRuleSpecForProvider
 */
export interface PullThroughCacheRuleSpecForProvider {
  /**
   * The repository name prefix to use when caching images from the source registry.
   *
   * @schema PullThroughCacheRuleSpecForProvider#ecrRepositoryPrefix
   */
  readonly ecrRepositoryPrefix?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PullThroughCacheRuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * The registry URL of the upstream public registry to use as the source.
   *
   * @schema PullThroughCacheRuleSpecForProvider#upstreamRegistryUrl
   */
  readonly upstreamRegistryUrl?: string;

}

/**
 * Converts an object of type 'PullThroughCacheRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleSpecForProvider(obj: PullThroughCacheRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ecrRepositoryPrefix': obj.ecrRepositoryPrefix,
    'region': obj.region,
    'upstreamRegistryUrl': obj.upstreamRegistryUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PullThroughCacheRuleSpecManagementPolicy
 */
export enum PullThroughCacheRuleSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PullThroughCacheRuleSpecProviderConfigRef
 */
export interface PullThroughCacheRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PullThroughCacheRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PullThroughCacheRuleSpecProviderConfigRef#policy
   */
  readonly policy?: PullThroughCacheRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PullThroughCacheRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleSpecProviderConfigRef(obj: PullThroughCacheRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PullThroughCacheRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PullThroughCacheRuleSpecProviderRef
 */
export interface PullThroughCacheRuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PullThroughCacheRuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PullThroughCacheRuleSpecProviderRef#policy
   */
  readonly policy?: PullThroughCacheRuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PullThroughCacheRuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleSpecProviderRef(obj: PullThroughCacheRuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PullThroughCacheRuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PullThroughCacheRuleSpecPublishConnectionDetailsTo
 */
export interface PullThroughCacheRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PullThroughCacheRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PullThroughCacheRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PullThroughCacheRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PullThroughCacheRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PullThroughCacheRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleSpecPublishConnectionDetailsTo(obj: PullThroughCacheRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PullThroughCacheRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PullThroughCacheRuleSpecWriteConnectionSecretToRef
 */
export interface PullThroughCacheRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PullThroughCacheRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PullThroughCacheRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PullThroughCacheRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleSpecWriteConnectionSecretToRef(obj: PullThroughCacheRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PullThroughCacheRuleSpecProviderConfigRefPolicy
 */
export interface PullThroughCacheRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PullThroughCacheRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PullThroughCacheRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PullThroughCacheRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PullThroughCacheRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PullThroughCacheRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleSpecProviderConfigRefPolicy(obj: PullThroughCacheRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PullThroughCacheRuleSpecProviderRefPolicy
 */
export interface PullThroughCacheRuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PullThroughCacheRuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PullThroughCacheRuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PullThroughCacheRuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PullThroughCacheRuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PullThroughCacheRuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleSpecProviderRefPolicy(obj: PullThroughCacheRuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRef(obj: PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToMetadata
 */
export interface PullThroughCacheRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PullThroughCacheRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleSpecPublishConnectionDetailsToMetadata(obj: PullThroughCacheRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PullThroughCacheRuleSpecProviderConfigRefPolicyResolution
 */
export enum PullThroughCacheRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PullThroughCacheRuleSpecProviderConfigRefPolicyResolve
 */
export enum PullThroughCacheRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PullThroughCacheRuleSpecProviderRefPolicyResolution
 */
export enum PullThroughCacheRuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PullThroughCacheRuleSpecProviderRefPolicyResolve
 */
export enum PullThroughCacheRuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PullThroughCacheRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RegistryPolicy is the Schema for the RegistryPolicys API. Provides an Elastic Container Registry Policy.
 *
 * @schema RegistryPolicy
 */
export class RegistryPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RegistryPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.upbound.io/v1beta1',
    kind: 'RegistryPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "RegistryPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RegistryPolicyProps): any {
    return {
      ...RegistryPolicy.GVK,
      ...toJson_RegistryPolicyProps(props),
    };
  }

  /**
   * Defines a "RegistryPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RegistryPolicyProps) {
    super(scope, id, {
      ...RegistryPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RegistryPolicy.GVK,
      ...toJson_RegistryPolicyProps(resolved),
    };
  }
}

/**
 * RegistryPolicy is the Schema for the RegistryPolicys API. Provides an Elastic Container Registry Policy.
 *
 * @schema RegistryPolicy
 */
export interface RegistryPolicyProps {
  /**
   * @schema RegistryPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RegistryPolicySpec defines the desired state of RegistryPolicy
   *
   * @schema RegistryPolicy#spec
   */
  readonly spec: RegistryPolicySpec;

}

/**
 * Converts an object of type 'RegistryPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicyProps(obj: RegistryPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RegistryPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RegistryPolicySpec defines the desired state of RegistryPolicy
 *
 * @schema RegistryPolicySpec
 */
export interface RegistryPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RegistryPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: RegistryPolicySpecDeletionPolicy;

  /**
   * @schema RegistryPolicySpec#forProvider
   */
  readonly forProvider: RegistryPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RegistryPolicySpec#managementPolicy
   */
  readonly managementPolicy?: RegistryPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RegistryPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: RegistryPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RegistryPolicySpec#providerRef
   */
  readonly providerRef?: RegistryPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RegistryPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RegistryPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RegistryPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RegistryPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RegistryPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicySpec(obj: RegistryPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RegistryPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RegistryPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RegistryPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RegistryPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RegistryPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RegistryPolicySpecDeletionPolicy
 */
export enum RegistryPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RegistryPolicySpecForProvider
 */
export interface RegistryPolicySpecForProvider {
  /**
   * The policy document. This is a JSON formatted string
   *
   * @schema RegistryPolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RegistryPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'RegistryPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicySpecForProvider(obj: RegistryPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RegistryPolicySpecManagementPolicy
 */
export enum RegistryPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RegistryPolicySpecProviderConfigRef
 */
export interface RegistryPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistryPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistryPolicySpecProviderConfigRef#policy
   */
  readonly policy?: RegistryPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RegistryPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicySpecProviderConfigRef(obj: RegistryPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistryPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RegistryPolicySpecProviderRef
 */
export interface RegistryPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistryPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistryPolicySpecProviderRef#policy
   */
  readonly policy?: RegistryPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RegistryPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicySpecProviderRef(obj: RegistryPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistryPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RegistryPolicySpecPublishConnectionDetailsTo
 */
export interface RegistryPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RegistryPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RegistryPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RegistryPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RegistryPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RegistryPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RegistryPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicySpecPublishConnectionDetailsTo(obj: RegistryPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RegistryPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RegistryPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RegistryPolicySpecWriteConnectionSecretToRef
 */
export interface RegistryPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RegistryPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RegistryPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RegistryPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicySpecWriteConnectionSecretToRef(obj: RegistryPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegistryPolicySpecProviderConfigRefPolicy
 */
export interface RegistryPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistryPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RegistryPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistryPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RegistryPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistryPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicySpecProviderConfigRefPolicy(obj: RegistryPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegistryPolicySpecProviderRefPolicy
 */
export interface RegistryPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistryPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: RegistryPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistryPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: RegistryPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistryPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicySpecProviderRefPolicy(obj: RegistryPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RegistryPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface RegistryPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistryPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistryPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RegistryPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicySpecPublishConnectionDetailsToConfigRef(obj: RegistryPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RegistryPolicySpecPublishConnectionDetailsToMetadata
 */
export interface RegistryPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegistryPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegistryPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RegistryPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RegistryPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicySpecPublishConnectionDetailsToMetadata(obj: RegistryPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistryPolicySpecProviderConfigRefPolicyResolution
 */
export enum RegistryPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistryPolicySpecProviderConfigRefPolicyResolve
 */
export enum RegistryPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistryPolicySpecProviderRefPolicyResolution
 */
export enum RegistryPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistryPolicySpecProviderRefPolicyResolve
 */
export enum RegistryPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RegistryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RegistryScanningConfiguration is the Schema for the RegistryScanningConfigurations API. Provides an Elastic Container Registry Scanning Configuration.
 *
 * @schema RegistryScanningConfiguration
 */
export class RegistryScanningConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RegistryScanningConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.upbound.io/v1beta1',
    kind: 'RegistryScanningConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "RegistryScanningConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RegistryScanningConfigurationProps): any {
    return {
      ...RegistryScanningConfiguration.GVK,
      ...toJson_RegistryScanningConfigurationProps(props),
    };
  }

  /**
   * Defines a "RegistryScanningConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RegistryScanningConfigurationProps) {
    super(scope, id, {
      ...RegistryScanningConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RegistryScanningConfiguration.GVK,
      ...toJson_RegistryScanningConfigurationProps(resolved),
    };
  }
}

/**
 * RegistryScanningConfiguration is the Schema for the RegistryScanningConfigurations API. Provides an Elastic Container Registry Scanning Configuration.
 *
 * @schema RegistryScanningConfiguration
 */
export interface RegistryScanningConfigurationProps {
  /**
   * @schema RegistryScanningConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RegistryScanningConfigurationSpec defines the desired state of RegistryScanningConfiguration
   *
   * @schema RegistryScanningConfiguration#spec
   */
  readonly spec: RegistryScanningConfigurationSpec;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationProps(obj: RegistryScanningConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RegistryScanningConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RegistryScanningConfigurationSpec defines the desired state of RegistryScanningConfiguration
 *
 * @schema RegistryScanningConfigurationSpec
 */
export interface RegistryScanningConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RegistryScanningConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: RegistryScanningConfigurationSpecDeletionPolicy;

  /**
   * @schema RegistryScanningConfigurationSpec#forProvider
   */
  readonly forProvider: RegistryScanningConfigurationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RegistryScanningConfigurationSpec#managementPolicy
   */
  readonly managementPolicy?: RegistryScanningConfigurationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RegistryScanningConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: RegistryScanningConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RegistryScanningConfigurationSpec#providerRef
   */
  readonly providerRef?: RegistryScanningConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RegistryScanningConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RegistryScanningConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RegistryScanningConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RegistryScanningConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpec(obj: RegistryScanningConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RegistryScanningConfigurationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RegistryScanningConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RegistryScanningConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RegistryScanningConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RegistryScanningConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RegistryScanningConfigurationSpecDeletionPolicy
 */
export enum RegistryScanningConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RegistryScanningConfigurationSpecForProvider
 */
export interface RegistryScanningConfigurationSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RegistryScanningConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * One or multiple blocks specifying scanning rules to determine which repository filters are used and at what frequency scanning will occur. See below for schema.
   *
   * @schema RegistryScanningConfigurationSpecForProvider#rule
   */
  readonly rule?: RegistryScanningConfigurationSpecForProviderRule[];

  /**
   * the scanning type to set for the registry. Can be either ENHANCED or BASIC.
   *
   * @schema RegistryScanningConfigurationSpecForProvider#scanType
   */
  readonly scanType?: string;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecForProvider(obj: RegistryScanningConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'rule': obj.rule?.map(y => toJson_RegistryScanningConfigurationSpecForProviderRule(y)),
    'scanType': obj.scanType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RegistryScanningConfigurationSpecManagementPolicy
 */
export enum RegistryScanningConfigurationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RegistryScanningConfigurationSpecProviderConfigRef
 */
export interface RegistryScanningConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistryScanningConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistryScanningConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: RegistryScanningConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecProviderConfigRef(obj: RegistryScanningConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistryScanningConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RegistryScanningConfigurationSpecProviderRef
 */
export interface RegistryScanningConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistryScanningConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistryScanningConfigurationSpecProviderRef#policy
   */
  readonly policy?: RegistryScanningConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecProviderRef(obj: RegistryScanningConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistryScanningConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsTo
 */
export interface RegistryScanningConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RegistryScanningConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecPublishConnectionDetailsTo(obj: RegistryScanningConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RegistryScanningConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RegistryScanningConfigurationSpecWriteConnectionSecretToRef
 */
export interface RegistryScanningConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RegistryScanningConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RegistryScanningConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecWriteConnectionSecretToRef(obj: RegistryScanningConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RegistryScanningConfigurationSpecForProviderRule
 */
export interface RegistryScanningConfigurationSpecForProviderRule {
  /**
   * One or more repository filter blocks, containing a filter  and a filter_type .
   *
   * @schema RegistryScanningConfigurationSpecForProviderRule#repositoryFilter
   */
  readonly repositoryFilter: RegistryScanningConfigurationSpecForProviderRuleRepositoryFilter[];

  /**
   * The frequency that scans are performed at for a private registry. Can be SCAN_ON_PUSH, CONTINUOUS_SCAN, or MANUAL.
   *
   * @schema RegistryScanningConfigurationSpecForProviderRule#scanFrequency
   */
  readonly scanFrequency: string;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecForProviderRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecForProviderRule(obj: RegistryScanningConfigurationSpecForProviderRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repositoryFilter': obj.repositoryFilter?.map(y => toJson_RegistryScanningConfigurationSpecForProviderRuleRepositoryFilter(y)),
    'scanFrequency': obj.scanFrequency,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegistryScanningConfigurationSpecProviderConfigRefPolicy
 */
export interface RegistryScanningConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistryScanningConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RegistryScanningConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistryScanningConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RegistryScanningConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecProviderConfigRefPolicy(obj: RegistryScanningConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegistryScanningConfigurationSpecProviderRefPolicy
 */
export interface RegistryScanningConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistryScanningConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RegistryScanningConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistryScanningConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RegistryScanningConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecProviderRefPolicy(obj: RegistryScanningConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRef(obj: RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface RegistryScanningConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecPublishConnectionDetailsToMetadata(obj: RegistryScanningConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RegistryScanningConfigurationSpecForProviderRuleRepositoryFilter
 */
export interface RegistryScanningConfigurationSpecForProviderRuleRepositoryFilter {
  /**
   * @schema RegistryScanningConfigurationSpecForProviderRuleRepositoryFilter#filter
   */
  readonly filter: string;

  /**
   * @schema RegistryScanningConfigurationSpecForProviderRuleRepositoryFilter#filterType
   */
  readonly filterType: string;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecForProviderRuleRepositoryFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecForProviderRuleRepositoryFilter(obj: RegistryScanningConfigurationSpecForProviderRuleRepositoryFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter,
    'filterType': obj.filterType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistryScanningConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum RegistryScanningConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistryScanningConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum RegistryScanningConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistryScanningConfigurationSpecProviderRefPolicyResolution
 */
export enum RegistryScanningConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistryScanningConfigurationSpecProviderRefPolicyResolve
 */
export enum RegistryScanningConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RegistryScanningConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReplicationConfiguration is the Schema for the ReplicationConfigurations API. Provides an Elastic Container Registry Replication Configuration.
 *
 * @schema ReplicationConfiguration
 */
export class ReplicationConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReplicationConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.upbound.io/v1beta1',
    kind: 'ReplicationConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "ReplicationConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicationConfigurationProps): any {
    return {
      ...ReplicationConfiguration.GVK,
      ...toJson_ReplicationConfigurationProps(props),
    };
  }

  /**
   * Defines a "ReplicationConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReplicationConfigurationProps) {
    super(scope, id, {
      ...ReplicationConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReplicationConfiguration.GVK,
      ...toJson_ReplicationConfigurationProps(resolved),
    };
  }
}

/**
 * ReplicationConfiguration is the Schema for the ReplicationConfigurations API. Provides an Elastic Container Registry Replication Configuration.
 *
 * @schema ReplicationConfiguration
 */
export interface ReplicationConfigurationProps {
  /**
   * @schema ReplicationConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReplicationConfigurationSpec defines the desired state of ReplicationConfiguration
   *
   * @schema ReplicationConfiguration#spec
   */
  readonly spec: ReplicationConfigurationSpec;

}

/**
 * Converts an object of type 'ReplicationConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationProps(obj: ReplicationConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReplicationConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicationConfigurationSpec defines the desired state of ReplicationConfiguration
 *
 * @schema ReplicationConfigurationSpec
 */
export interface ReplicationConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicationConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReplicationConfigurationSpecDeletionPolicy;

  /**
   * @schema ReplicationConfigurationSpec#forProvider
   */
  readonly forProvider: ReplicationConfigurationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicationConfigurationSpec#managementPolicy
   */
  readonly managementPolicy?: ReplicationConfigurationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReplicationConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReplicationConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReplicationConfigurationSpec#providerRef
   */
  readonly providerRef?: ReplicationConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReplicationConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReplicationConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReplicationConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReplicationConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpec(obj: ReplicationConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReplicationConfigurationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ReplicationConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReplicationConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReplicationConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReplicationConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicationConfigurationSpecDeletionPolicy
 */
export enum ReplicationConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReplicationConfigurationSpecForProvider
 */
export interface ReplicationConfigurationSpecForProvider {
  /**
   * A Region to replicate to. Region is the region you'd like your resource to be created in.
   *
   * @schema ReplicationConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Replication configuration for a registry. See Replication Configuration.
   *
   * @schema ReplicationConfigurationSpecForProvider#replicationConfiguration
   */
  readonly replicationConfiguration?: ReplicationConfigurationSpecForProviderReplicationConfiguration[];

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecForProvider(obj: ReplicationConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'replicationConfiguration': obj.replicationConfiguration?.map(y => toJson_ReplicationConfigurationSpecForProviderReplicationConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicationConfigurationSpecManagementPolicy
 */
export enum ReplicationConfigurationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReplicationConfigurationSpecProviderConfigRef
 */
export interface ReplicationConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: ReplicationConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecProviderConfigRef(obj: ReplicationConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReplicationConfigurationSpecProviderRef
 */
export interface ReplicationConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationConfigurationSpecProviderRef#policy
   */
  readonly policy?: ReplicationConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecProviderRef(obj: ReplicationConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsTo
 */
export interface ReplicationConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReplicationConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecPublishConnectionDetailsTo(obj: ReplicationConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReplicationConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReplicationConfigurationSpecWriteConnectionSecretToRef
 */
export interface ReplicationConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReplicationConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReplicationConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecWriteConnectionSecretToRef(obj: ReplicationConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationConfigurationSpecForProviderReplicationConfiguration
 */
export interface ReplicationConfigurationSpecForProviderReplicationConfiguration {
  /**
   * The replication rules for a replication configuration. A maximum of 10 are allowed per replication_configuration. See Rule
   *
   * @schema ReplicationConfigurationSpecForProviderReplicationConfiguration#rule
   */
  readonly rule: ReplicationConfigurationSpecForProviderReplicationConfigurationRule[];

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecForProviderReplicationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecForProviderReplicationConfiguration(obj: ReplicationConfigurationSpecForProviderReplicationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rule': obj.rule?.map(y => toJson_ReplicationConfigurationSpecForProviderReplicationConfigurationRule(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationConfigurationSpecProviderConfigRefPolicy
 */
export interface ReplicationConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicationConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicationConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecProviderConfigRefPolicy(obj: ReplicationConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationConfigurationSpecProviderRefPolicy
 */
export interface ReplicationConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReplicationConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReplicationConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecProviderRefPolicy(obj: ReplicationConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef(obj: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface ReplicationConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecPublishConnectionDetailsToMetadata(obj: ReplicationConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationConfigurationSpecForProviderReplicationConfigurationRule
 */
export interface ReplicationConfigurationSpecForProviderReplicationConfigurationRule {
  /**
   * the details of a replication destination. A maximum of 25 are allowed per rule. See Destination.
   *
   * @schema ReplicationConfigurationSpecForProviderReplicationConfigurationRule#destination
   */
  readonly destination: ReplicationConfigurationSpecForProviderReplicationConfigurationRuleDestination[];

  /**
   * filters for a replication rule. See Repository Filter.
   *
   * @schema ReplicationConfigurationSpecForProviderReplicationConfigurationRule#repositoryFilter
   */
  readonly repositoryFilter?: ReplicationConfigurationSpecForProviderReplicationConfigurationRuleRepositoryFilter[];

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecForProviderReplicationConfigurationRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecForProviderReplicationConfigurationRule(obj: ReplicationConfigurationSpecForProviderReplicationConfigurationRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': obj.destination?.map(y => toJson_ReplicationConfigurationSpecForProviderReplicationConfigurationRuleDestination(y)),
    'repositoryFilter': obj.repositoryFilter?.map(y => toJson_ReplicationConfigurationSpecForProviderReplicationConfigurationRuleRepositoryFilter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum ReplicationConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum ReplicationConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationConfigurationSpecProviderRefPolicyResolution
 */
export enum ReplicationConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationConfigurationSpecProviderRefPolicyResolve
 */
export enum ReplicationConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationConfigurationSpecForProviderReplicationConfigurationRuleDestination
 */
export interface ReplicationConfigurationSpecForProviderReplicationConfigurationRuleDestination {
  /**
   * A Region to replicate to.
   *
   * @schema ReplicationConfigurationSpecForProviderReplicationConfigurationRuleDestination#region
   */
  readonly region: string;

  /**
   * The account ID of the destination registry to replicate to.
   *
   * @schema ReplicationConfigurationSpecForProviderReplicationConfigurationRuleDestination#registryId
   */
  readonly registryId: string;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecForProviderReplicationConfigurationRuleDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecForProviderReplicationConfigurationRuleDestination(obj: ReplicationConfigurationSpecForProviderReplicationConfigurationRuleDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'registryId': obj.registryId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicationConfigurationSpecForProviderReplicationConfigurationRuleRepositoryFilter
 */
export interface ReplicationConfigurationSpecForProviderReplicationConfigurationRuleRepositoryFilter {
  /**
   * The repository filter details.
   *
   * @schema ReplicationConfigurationSpecForProviderReplicationConfigurationRuleRepositoryFilter#filter
   */
  readonly filter: string;

  /**
   * The repository filter type. The only supported value is PREFIX_MATCH, which is a repository name prefix specified with the filter parameter.
   *
   * @schema ReplicationConfigurationSpecForProviderReplicationConfigurationRuleRepositoryFilter#filterType
   */
  readonly filterType: string;

}

/**
 * Converts an object of type 'ReplicationConfigurationSpecForProviderReplicationConfigurationRuleRepositoryFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationConfigurationSpecForProviderReplicationConfigurationRuleRepositoryFilter(obj: ReplicationConfigurationSpecForProviderReplicationConfigurationRuleRepositoryFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter,
    'filterType': obj.filterType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReplicationConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Repository is the Schema for the Repositorys API. Provides an Elastic Container Registry Repository.
 *
 * @schema Repository
 */
export class Repository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Repository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.upbound.io/v1beta1',
    kind: 'Repository',
  }

  /**
   * Renders a Kubernetes manifest for "Repository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RepositoryProps): any {
    return {
      ...Repository.GVK,
      ...toJson_RepositoryProps(props),
    };
  }

  /**
   * Defines a "Repository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RepositoryProps) {
    super(scope, id, {
      ...Repository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Repository.GVK,
      ...toJson_RepositoryProps(resolved),
    };
  }
}

/**
 * Repository is the Schema for the Repositorys API. Provides an Elastic Container Registry Repository.
 *
 * @schema Repository
 */
export interface RepositoryProps {
  /**
   * @schema Repository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RepositorySpec defines the desired state of Repository
   *
   * @schema Repository#spec
   */
  readonly spec: RepositorySpec;

}

/**
 * Converts an object of type 'RepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryProps(obj: RepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepositorySpec defines the desired state of Repository
 *
 * @schema RepositorySpec
 */
export interface RepositorySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RepositorySpec#deletionPolicy
   */
  readonly deletionPolicy?: RepositorySpecDeletionPolicy;

  /**
   * @schema RepositorySpec#forProvider
   */
  readonly forProvider: RepositorySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RepositorySpec#managementPolicy
   */
  readonly managementPolicy?: RepositorySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RepositorySpec#providerConfigRef
   */
  readonly providerConfigRef?: RepositorySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RepositorySpec#providerRef
   */
  readonly providerRef?: RepositorySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RepositorySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RepositorySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RepositorySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RepositorySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpec(obj: RepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RepositorySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RepositorySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RepositorySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RepositorySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RepositorySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RepositorySpecDeletionPolicy
 */
export enum RepositorySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RepositorySpecForProvider
 */
export interface RepositorySpecForProvider {
  /**
   * Encryption configuration for the repository. See below for schema.
   *
   * @schema RepositorySpecForProvider#encryptionConfiguration
   */
  readonly encryptionConfiguration?: RepositorySpecForProviderEncryptionConfiguration[];

  /**
   * If true, will delete the repository even if it contains images. Defaults to false.
   *
   * @default false.
   * @schema RepositorySpecForProvider#forceDelete
   */
  readonly forceDelete?: boolean;

  /**
   * Configuration block that defines image scanning configuration for the repository. By default, image scanning must be manually triggered. See the ECR User Guide for more information about image scanning.
   *
   * @schema RepositorySpecForProvider#imageScanningConfiguration
   */
  readonly imageScanningConfiguration?: RepositorySpecForProviderImageScanningConfiguration[];

  /**
   * The tag mutability setting for the repository. Must be one of: MUTABLE or IMMUTABLE. Defaults to MUTABLE.
   *
   * @default MUTABLE.
   * @schema RepositorySpecForProvider#imageTagMutability
   */
  readonly imageTagMutability?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RepositorySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RepositorySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RepositorySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProvider(obj: RepositorySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionConfiguration': obj.encryptionConfiguration?.map(y => toJson_RepositorySpecForProviderEncryptionConfiguration(y)),
    'forceDelete': obj.forceDelete,
    'imageScanningConfiguration': obj.imageScanningConfiguration?.map(y => toJson_RepositorySpecForProviderImageScanningConfiguration(y)),
    'imageTagMutability': obj.imageTagMutability,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RepositorySpecManagementPolicy
 */
export enum RepositorySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RepositorySpecProviderConfigRef
 */
export interface RepositorySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecProviderConfigRef#policy
   */
  readonly policy?: RepositorySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderConfigRef(obj: RepositorySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RepositorySpecProviderRef
 */
export interface RepositorySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecProviderRef#policy
   */
  readonly policy?: RepositorySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderRef(obj: RepositorySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RepositorySpecPublishConnectionDetailsTo
 */
export interface RepositorySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RepositorySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RepositorySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RepositorySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsTo(obj: RepositorySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RepositorySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RepositorySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RepositorySpecWriteConnectionSecretToRef
 */
export interface RepositorySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RepositorySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositorySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositorySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecWriteConnectionSecretToRef(obj: RepositorySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RepositorySpecForProviderEncryptionConfiguration
 */
export interface RepositorySpecForProviderEncryptionConfiguration {
  /**
   * The encryption type to use for the repository. Valid values are AES256 or KMS. Defaults to AES256.
   *
   * @default AES256.
   * @schema RepositorySpecForProviderEncryptionConfiguration#encryptionType
   */
  readonly encryptionType?: string;

  /**
   * The ARN of the KMS key to use when encryption_type is KMS. If not specified, uses the default AWS managed key for ECR.
   *
   * @schema RepositorySpecForProviderEncryptionConfiguration#kmsKey
   */
  readonly kmsKey?: string;

  /**
   * Reference to a Key in kms to populate kmsKey.
   *
   * @schema RepositorySpecForProviderEncryptionConfiguration#kmsKeyRef
   */
  readonly kmsKeyRef?: RepositorySpecForProviderEncryptionConfigurationKmsKeyRef;

  /**
   * Selector for a Key in kms to populate kmsKey.
   *
   * @schema RepositorySpecForProviderEncryptionConfiguration#kmsKeySelector
   */
  readonly kmsKeySelector?: RepositorySpecForProviderEncryptionConfigurationKmsKeySelector;

}

/**
 * Converts an object of type 'RepositorySpecForProviderEncryptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderEncryptionConfiguration(obj: RepositorySpecForProviderEncryptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'encryptionType': obj.encryptionType,
    'kmsKey': obj.kmsKey,
    'kmsKeyRef': toJson_RepositorySpecForProviderEncryptionConfigurationKmsKeyRef(obj.kmsKeyRef),
    'kmsKeySelector': toJson_RepositorySpecForProviderEncryptionConfigurationKmsKeySelector(obj.kmsKeySelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RepositorySpecForProviderImageScanningConfiguration
 */
export interface RepositorySpecForProviderImageScanningConfiguration {
  /**
   * Indicates whether images are scanned after being pushed to the repository (true) or not scanned (false).
   *
   * @schema RepositorySpecForProviderImageScanningConfiguration#scanOnPush
   */
  readonly scanOnPush: boolean;

}

/**
 * Converts an object of type 'RepositorySpecForProviderImageScanningConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderImageScanningConfiguration(obj: RepositorySpecForProviderImageScanningConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scanOnPush': obj.scanOnPush,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecProviderConfigRefPolicy
 */
export interface RepositorySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderConfigRefPolicy(obj: RepositorySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecProviderRefPolicy
 */
export interface RepositorySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecProviderRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecProviderRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecProviderRefPolicy(obj: RepositorySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRef
 */
export interface RepositorySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RepositorySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToConfigRef(obj: RepositorySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RepositorySpecPublishConnectionDetailsToMetadata
 */
export interface RepositorySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RepositorySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToMetadata(obj: RepositorySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKey.
 *
 * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeyRef
 */
export interface RepositorySpecForProviderEncryptionConfigurationKmsKeyRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeyRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeyRef#policy
   */
  readonly policy?: RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicy;

}

/**
 * Converts an object of type 'RepositorySpecForProviderEncryptionConfigurationKmsKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderEncryptionConfigurationKmsKeyRef(obj: RepositorySpecForProviderEncryptionConfigurationKmsKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKey.
 *
 * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeySelector
 */
export interface RepositorySpecForProviderEncryptionConfigurationKmsKeySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeySelector#policy
   */
  readonly policy?: RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicy;

}

/**
 * Converts an object of type 'RepositorySpecForProviderEncryptionConfigurationKmsKeySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderEncryptionConfigurationKmsKeySelector(obj: RepositorySpecForProviderEncryptionConfigurationKmsKeySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecProviderConfigRefPolicyResolution
 */
export enum RepositorySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecProviderConfigRefPolicyResolve
 */
export enum RepositorySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecProviderRefPolicyResolution
 */
export enum RepositorySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecProviderRefPolicyResolve
 */
export enum RepositorySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RepositorySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecPublishConnectionDetailsToConfigRefPolicy(obj: RepositorySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicy
 */
export interface RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicy#resolution
   */
  readonly resolution?: RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicy#resolve
   */
  readonly resolve?: RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicy(obj: RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicy
 */
export interface RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicy#resolution
   */
  readonly resolution?: RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicy#resolve
   */
  readonly resolve?: RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicy(obj: RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RepositorySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicyResolution
 */
export enum RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicyResolve
 */
export enum RepositorySpecForProviderEncryptionConfigurationKmsKeyRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicyResolution
 */
export enum RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicyResolve
 */
export enum RepositorySpecForProviderEncryptionConfigurationKmsKeySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RepositoryPolicy is the Schema for the RepositoryPolicys API. Provides an Elastic Container Registry Repository Policy.
 *
 * @schema RepositoryPolicy
 */
export class RepositoryPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RepositoryPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecr.aws.upbound.io/v1beta1',
    kind: 'RepositoryPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "RepositoryPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RepositoryPolicyProps): any {
    return {
      ...RepositoryPolicy.GVK,
      ...toJson_RepositoryPolicyProps(props),
    };
  }

  /**
   * Defines a "RepositoryPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RepositoryPolicyProps) {
    super(scope, id, {
      ...RepositoryPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RepositoryPolicy.GVK,
      ...toJson_RepositoryPolicyProps(resolved),
    };
  }
}

/**
 * RepositoryPolicy is the Schema for the RepositoryPolicys API. Provides an Elastic Container Registry Repository Policy.
 *
 * @schema RepositoryPolicy
 */
export interface RepositoryPolicyProps {
  /**
   * @schema RepositoryPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RepositoryPolicySpec defines the desired state of RepositoryPolicy
   *
   * @schema RepositoryPolicy#spec
   */
  readonly spec: RepositoryPolicySpec;

}

/**
 * Converts an object of type 'RepositoryPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicyProps(obj: RepositoryPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RepositoryPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RepositoryPolicySpec defines the desired state of RepositoryPolicy
 *
 * @schema RepositoryPolicySpec
 */
export interface RepositoryPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RepositoryPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: RepositoryPolicySpecDeletionPolicy;

  /**
   * @schema RepositoryPolicySpec#forProvider
   */
  readonly forProvider: RepositoryPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RepositoryPolicySpec#managementPolicy
   */
  readonly managementPolicy?: RepositoryPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RepositoryPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: RepositoryPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RepositoryPolicySpec#providerRef
   */
  readonly providerRef?: RepositoryPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RepositoryPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RepositoryPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RepositoryPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RepositoryPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RepositoryPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpec(obj: RepositoryPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RepositoryPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_RepositoryPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RepositoryPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RepositoryPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RepositoryPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RepositoryPolicySpecDeletionPolicy
 */
export enum RepositoryPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RepositoryPolicySpecForProvider
 */
export interface RepositoryPolicySpecForProvider {
  /**
   * The policy document. This is a JSON formatted string
   *
   * @schema RepositoryPolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RepositoryPolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * Name of the repository to apply the policy.
   *
   * @schema RepositoryPolicySpecForProvider#repository
   */
  readonly repository?: string;

  /**
   * Reference to a Repository in ecr to populate repository.
   *
   * @schema RepositoryPolicySpecForProvider#repositoryRef
   */
  readonly repositoryRef?: RepositoryPolicySpecForProviderRepositoryRef;

  /**
   * Selector for a Repository in ecr to populate repository.
   *
   * @schema RepositoryPolicySpecForProvider#repositorySelector
   */
  readonly repositorySelector?: RepositoryPolicySpecForProviderRepositorySelector;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProvider(obj: RepositoryPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
    'region': obj.region,
    'repository': obj.repository,
    'repositoryRef': toJson_RepositoryPolicySpecForProviderRepositoryRef(obj.repositoryRef),
    'repositorySelector': toJson_RepositoryPolicySpecForProviderRepositorySelector(obj.repositorySelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RepositoryPolicySpecManagementPolicy
 */
export enum RepositoryPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RepositoryPolicySpecProviderConfigRef
 */
export interface RepositoryPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicySpecProviderConfigRef#policy
   */
  readonly policy?: RepositoryPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecProviderConfigRef(obj: RepositoryPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RepositoryPolicySpecProviderRef
 */
export interface RepositoryPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicySpecProviderRef#policy
   */
  readonly policy?: RepositoryPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecProviderRef(obj: RepositoryPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsTo
 */
export interface RepositoryPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RepositoryPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RepositoryPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RepositoryPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecPublishConnectionDetailsTo(obj: RepositoryPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RepositoryPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RepositoryPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RepositoryPolicySpecWriteConnectionSecretToRef
 */
export interface RepositoryPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RepositoryPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RepositoryPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RepositoryPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecWriteConnectionSecretToRef(obj: RepositoryPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Repository in ecr to populate repository.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryRef
 */
export interface RepositoryPolicySpecForProviderRepositoryRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryRef#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderRepositoryRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderRepositoryRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderRepositoryRef(obj: RepositoryPolicySpecForProviderRepositoryRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicySpecForProviderRepositoryRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Repository in ecr to populate repository.
 *
 * @schema RepositoryPolicySpecForProviderRepositorySelector
 */
export interface RepositoryPolicySpecForProviderRepositorySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RepositoryPolicySpecForProviderRepositorySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RepositoryPolicySpecForProviderRepositorySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RepositoryPolicySpecForProviderRepositorySelector#policy
   */
  readonly policy?: RepositoryPolicySpecForProviderRepositorySelectorPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderRepositorySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderRepositorySelector(obj: RepositoryPolicySpecForProviderRepositorySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RepositoryPolicySpecForProviderRepositorySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicySpecProviderConfigRefPolicy
 */
export interface RepositoryPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecProviderConfigRefPolicy(obj: RepositoryPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicySpecProviderRefPolicy
 */
export interface RepositoryPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecProviderRefPolicy(obj: RepositoryPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface RepositoryPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RepositoryPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecPublishConnectionDetailsToConfigRef(obj: RepositoryPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsToMetadata
 */
export interface RepositoryPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RepositoryPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecPublishConnectionDetailsToMetadata(obj: RepositoryPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryRefPolicy
 */
export interface RepositoryPolicySpecForProviderRepositoryRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderRepositoryRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderRepositoryRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderRepositoryRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderRepositoryRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderRepositoryRefPolicy(obj: RepositoryPolicySpecForProviderRepositoryRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RepositoryPolicySpecForProviderRepositorySelectorPolicy
 */
export interface RepositoryPolicySpecForProviderRepositorySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecForProviderRepositorySelectorPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecForProviderRepositorySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecForProviderRepositorySelectorPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecForProviderRepositorySelectorPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecForProviderRepositorySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecForProviderRepositorySelectorPolicy(obj: RepositoryPolicySpecForProviderRepositorySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecProviderConfigRefPolicyResolution
 */
export enum RepositoryPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecProviderConfigRefPolicyResolve
 */
export enum RepositoryPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecProviderRefPolicyResolution
 */
export enum RepositoryPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecProviderRefPolicyResolve
 */
export enum RepositoryPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryRefPolicyResolution
 */
export enum RepositoryPolicySpecForProviderRepositoryRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderRepositoryRefPolicyResolve
 */
export enum RepositoryPolicySpecForProviderRepositoryRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecForProviderRepositorySelectorPolicyResolution
 */
export enum RepositoryPolicySpecForProviderRepositorySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecForProviderRepositorySelectorPolicyResolve
 */
export enum RepositoryPolicySpecForProviderRepositorySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RepositoryPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

