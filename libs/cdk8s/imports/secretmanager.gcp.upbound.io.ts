// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Secret is the Schema for the Secrets API. A Secret is a logical secret whose value and versions can be accessed.
 *
 * @schema Secret
 */
export class Secret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Secret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretmanager.gcp.upbound.io/v1beta1',
    kind: 'Secret',
  }

  /**
   * Renders a Kubernetes manifest for "Secret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretProps): any {
    return {
      ...Secret.GVK,
      ...toJson_SecretProps(props),
    };
  }

  /**
   * Defines a "Secret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretProps) {
    super(scope, id, {
      ...Secret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Secret.GVK,
      ...toJson_SecretProps(resolved),
    };
  }
}

/**
 * Secret is the Schema for the Secrets API. A Secret is a logical secret whose value and versions can be accessed.
 *
 * @schema Secret
 */
export interface SecretProps {
  /**
   * @schema Secret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretSpec defines the desired state of Secret
   *
   * @schema Secret#spec
   */
  readonly spec: SecretSpec;

}

/**
 * Converts an object of type 'SecretProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretProps(obj: SecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretSpec defines the desired state of Secret
 *
 * @schema SecretSpec
 */
export interface SecretSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecretSpecDeletionPolicy;

  /**
   * @schema SecretSpec#forProvider
   */
  readonly forProvider: SecretSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SecretSpec#initProvider
   */
  readonly initProvider?: SecretSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SecretSpec#managementPolicies
   */
  readonly managementPolicies?: SecretSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecretSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecretSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecretSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecretSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecretSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecretSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecretSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpec(obj: SecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecretSpecForProvider(obj.forProvider),
    'initProvider': toJson_SecretSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SecretSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SecretSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecretSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretSpecDeletionPolicy
 */
export enum SecretSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SecretSpecForProvider
 */
export interface SecretSpecForProvider {
  /**
   * Timestamp in UTC when the Secret is scheduled to expire. This is always provided on output, regardless of what was sent on input. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema SecretSpecForProvider#expireTime
   */
  readonly expireTime?: string;

  /**
   * The labels assigned to this Secret. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}-]{0,62} Label values must be between 0 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}-]{0,63} No more than 64 labels can be assigned to a given resource. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema SecretSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema SecretSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The replication policy of the secret data attached to the Secret. It cannot be changed after the Secret has been created. Structure is documented below.
   *
   * @schema SecretSpecForProvider#replication
   */
  readonly replication?: SecretSpecForProviderReplication[];

  /**
   * The rotation time and period for a Secret. At next_rotation_time, Secret Manager will send a Pub/Sub notification to the topics configured on the Secret. topics must be set to configure rotation. Structure is documented below.
   *
   * @schema SecretSpecForProvider#rotation
   */
  readonly rotation?: SecretSpecForProviderRotation[];

  /**
   * A list of up to 10 Pub/Sub topics to which messages are published when control plane operations are called on the secret or its versions. Structure is documented below.
   *
   * @schema SecretSpecForProvider#topics
   */
  readonly topics?: SecretSpecForProviderTopics[];

  /**
   * The TTL for the Secret. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema SecretSpecForProvider#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'SecretSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProvider(obj: SecretSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expireTime': obj.expireTime,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
    'replication': obj.replication?.map(y => toJson_SecretSpecForProviderReplication(y)),
    'rotation': obj.rotation?.map(y => toJson_SecretSpecForProviderRotation(y)),
    'topics': obj.topics?.map(y => toJson_SecretSpecForProviderTopics(y)),
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SecretSpecInitProvider
 */
export interface SecretSpecInitProvider {
  /**
   * Timestamp in UTC when the Secret is scheduled to expire. This is always provided on output, regardless of what was sent on input. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema SecretSpecInitProvider#expireTime
   */
  readonly expireTime?: string;

  /**
   * The labels assigned to this Secret. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}-]{0,62} Label values must be between 0 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}-]{0,63} No more than 64 labels can be assigned to a given resource. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema SecretSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema SecretSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The replication policy of the secret data attached to the Secret. It cannot be changed after the Secret has been created. Structure is documented below.
   *
   * @schema SecretSpecInitProvider#replication
   */
  readonly replication?: SecretSpecInitProviderReplication[];

  /**
   * The rotation time and period for a Secret. At next_rotation_time, Secret Manager will send a Pub/Sub notification to the topics configured on the Secret. topics must be set to configure rotation. Structure is documented below.
   *
   * @schema SecretSpecInitProvider#rotation
   */
  readonly rotation?: SecretSpecInitProviderRotation[];

  /**
   * A list of up to 10 Pub/Sub topics to which messages are published when control plane operations are called on the secret or its versions. Structure is documented below.
   *
   * @schema SecretSpecInitProvider#topics
   */
  readonly topics?: SecretSpecInitProviderTopics[];

  /**
   * The TTL for the Secret. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema SecretSpecInitProvider#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'SecretSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecInitProvider(obj: SecretSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expireTime': obj.expireTime,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
    'replication': obj.replication?.map(y => toJson_SecretSpecInitProviderReplication(y)),
    'rotation': obj.rotation?.map(y => toJson_SecretSpecInitProviderRotation(y)),
    'topics': obj.topics?.map(y => toJson_SecretSpecInitProviderTopics(y)),
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SecretSpecManagementPolicies
 */
export enum SecretSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecretSpecProviderConfigRef
 */
export interface SecretSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretSpecProviderConfigRef#policy
   */
  readonly policy?: SecretSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecProviderConfigRef(obj: SecretSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecretSpecPublishConnectionDetailsTo
 */
export interface SecretSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecretSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecretSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecretSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecretSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecretSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsTo(obj: SecretSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecretSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecretSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecretSpecWriteConnectionSecretToRef
 */
export interface SecretSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecretSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecWriteConnectionSecretToRef(obj: SecretSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecForProviderReplication
 */
export interface SecretSpecForProviderReplication {
  /**
   * The Secret will automatically be replicated without any restrictions.
   *
   * @schema SecretSpecForProviderReplication#automatic
   */
  readonly automatic?: boolean;

  /**
   * The Secret will be replicated to the regions specified by the user. Structure is documented below.
   *
   * @schema SecretSpecForProviderReplication#userManaged
   */
  readonly userManaged?: SecretSpecForProviderReplicationUserManaged[];

}

/**
 * Converts an object of type 'SecretSpecForProviderReplication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderReplication(obj: SecretSpecForProviderReplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automatic': obj.automatic,
    'userManaged': obj.userManaged?.map(y => toJson_SecretSpecForProviderReplicationUserManaged(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecForProviderRotation
 */
export interface SecretSpecForProviderRotation {
  /**
   * Timestamp in UTC at which the Secret is scheduled to rotate. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema SecretSpecForProviderRotation#nextRotationTime
   */
  readonly nextRotationTime?: string;

  /**
   * The Duration between rotation notifications. Must be in seconds and at least 3600s (1h) and at most 3153600000s (100 years). If rotationPeriod is set, next_rotation_time must be set. next_rotation_time will be advanced by this period when the service automatically sends rotation notifications.
   *
   * @schema SecretSpecForProviderRotation#rotationPeriod
   */
  readonly rotationPeriod?: string;

}

/**
 * Converts an object of type 'SecretSpecForProviderRotation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderRotation(obj: SecretSpecForProviderRotation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nextRotationTime': obj.nextRotationTime,
    'rotationPeriod': obj.rotationPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecForProviderTopics
 */
export interface SecretSpecForProviderTopics {
  /**
   * The resource name of the Pub/Sub topic that will be published to, in the following format: projects//topics/. For publication to succeed, the Secret Manager Service Agent service account must have pubsub.publisher permissions on the topic.
   *
   * @schema SecretSpecForProviderTopics#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'SecretSpecForProviderTopics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderTopics(obj: SecretSpecForProviderTopics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecInitProviderReplication
 */
export interface SecretSpecInitProviderReplication {
  /**
   * The Secret will automatically be replicated without any restrictions.
   *
   * @schema SecretSpecInitProviderReplication#automatic
   */
  readonly automatic?: boolean;

  /**
   * The Secret will be replicated to the regions specified by the user. Structure is documented below.
   *
   * @schema SecretSpecInitProviderReplication#userManaged
   */
  readonly userManaged?: SecretSpecInitProviderReplicationUserManaged[];

}

/**
 * Converts an object of type 'SecretSpecInitProviderReplication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecInitProviderReplication(obj: SecretSpecInitProviderReplication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automatic': obj.automatic,
    'userManaged': obj.userManaged?.map(y => toJson_SecretSpecInitProviderReplicationUserManaged(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecInitProviderRotation
 */
export interface SecretSpecInitProviderRotation {
  /**
   * Timestamp in UTC at which the Secret is scheduled to rotate. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
   *
   * @schema SecretSpecInitProviderRotation#nextRotationTime
   */
  readonly nextRotationTime?: string;

  /**
   * The Duration between rotation notifications. Must be in seconds and at least 3600s (1h) and at most 3153600000s (100 years). If rotationPeriod is set, next_rotation_time must be set. next_rotation_time will be advanced by this period when the service automatically sends rotation notifications.
   *
   * @schema SecretSpecInitProviderRotation#rotationPeriod
   */
  readonly rotationPeriod?: string;

}

/**
 * Converts an object of type 'SecretSpecInitProviderRotation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecInitProviderRotation(obj: SecretSpecInitProviderRotation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nextRotationTime': obj.nextRotationTime,
    'rotationPeriod': obj.rotationPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecInitProviderTopics
 */
export interface SecretSpecInitProviderTopics {
  /**
   * The resource name of the Pub/Sub topic that will be published to, in the following format: projects//topics/. For publication to succeed, the Secret Manager Service Agent service account must have pubsub.publisher permissions on the topic.
   *
   * @schema SecretSpecInitProviderTopics#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'SecretSpecInitProviderTopics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecInitProviderTopics(obj: SecretSpecInitProviderTopics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretSpecProviderConfigRefPolicy
 */
export interface SecretSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecretSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecretSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecProviderConfigRefPolicy(obj: SecretSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRef
 */
export interface SecretSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecretSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsToConfigRef(obj: SecretSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecretSpecPublishConnectionDetailsToMetadata
 */
export interface SecretSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecretSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsToMetadata(obj: SecretSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecForProviderReplicationUserManaged
 */
export interface SecretSpecForProviderReplicationUserManaged {
  /**
   * The list of Replicas for this Secret. Cannot be empty. Structure is documented below.
   *
   * @schema SecretSpecForProviderReplicationUserManaged#replicas
   */
  readonly replicas?: SecretSpecForProviderReplicationUserManagedReplicas[];

}

/**
 * Converts an object of type 'SecretSpecForProviderReplicationUserManaged' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderReplicationUserManaged(obj: SecretSpecForProviderReplicationUserManaged | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicas': obj.replicas?.map(y => toJson_SecretSpecForProviderReplicationUserManagedReplicas(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecInitProviderReplicationUserManaged
 */
export interface SecretSpecInitProviderReplicationUserManaged {
  /**
   * The list of Replicas for this Secret. Cannot be empty. Structure is documented below.
   *
   * @schema SecretSpecInitProviderReplicationUserManaged#replicas
   */
  readonly replicas?: SecretSpecInitProviderReplicationUserManagedReplicas[];

}

/**
 * Converts an object of type 'SecretSpecInitProviderReplicationUserManaged' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecInitProviderReplicationUserManaged(obj: SecretSpecInitProviderReplicationUserManaged | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicas': obj.replicas?.map(y => toJson_SecretSpecInitProviderReplicationUserManagedReplicas(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretSpecProviderConfigRefPolicyResolution
 */
export enum SecretSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretSpecProviderConfigRefPolicyResolve
 */
export enum SecretSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecretSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecretSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecretSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecretSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecForProviderReplicationUserManagedReplicas
 */
export interface SecretSpecForProviderReplicationUserManagedReplicas {
  /**
   * Customer Managed Encryption for the secret. Structure is documented below.
   *
   * @schema SecretSpecForProviderReplicationUserManagedReplicas#customerManagedEncryption
   */
  readonly customerManagedEncryption?: SecretSpecForProviderReplicationUserManagedReplicasCustomerManagedEncryption[];

  /**
   * The canonical IDs of the location to replicate data. For example: "us-east1".
   *
   * @schema SecretSpecForProviderReplicationUserManagedReplicas#location
   */
  readonly location?: string;

}

/**
 * Converts an object of type 'SecretSpecForProviderReplicationUserManagedReplicas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderReplicationUserManagedReplicas(obj: SecretSpecForProviderReplicationUserManagedReplicas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerManagedEncryption': obj.customerManagedEncryption?.map(y => toJson_SecretSpecForProviderReplicationUserManagedReplicasCustomerManagedEncryption(y)),
    'location': obj.location,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecInitProviderReplicationUserManagedReplicas
 */
export interface SecretSpecInitProviderReplicationUserManagedReplicas {
  /**
   * Customer Managed Encryption for the secret. Structure is documented below.
   *
   * @schema SecretSpecInitProviderReplicationUserManagedReplicas#customerManagedEncryption
   */
  readonly customerManagedEncryption?: SecretSpecInitProviderReplicationUserManagedReplicasCustomerManagedEncryption[];

  /**
   * The canonical IDs of the location to replicate data. For example: "us-east1".
   *
   * @schema SecretSpecInitProviderReplicationUserManagedReplicas#location
   */
  readonly location?: string;

}

/**
 * Converts an object of type 'SecretSpecInitProviderReplicationUserManagedReplicas' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecInitProviderReplicationUserManagedReplicas(obj: SecretSpecInitProviderReplicationUserManagedReplicas | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerManagedEncryption': obj.customerManagedEncryption?.map(y => toJson_SecretSpecInitProviderReplicationUserManagedReplicasCustomerManagedEncryption(y)),
    'location': obj.location,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecretSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecretSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema SecretSpecForProviderReplicationUserManagedReplicasCustomerManagedEncryption
 */
export interface SecretSpecForProviderReplicationUserManagedReplicasCustomerManagedEncryption {
  /**
   * Describes the Cloud KMS encryption key that will be used to protect destination secret.
   *
   * @schema SecretSpecForProviderReplicationUserManagedReplicasCustomerManagedEncryption#kmsKeyName
   */
  readonly kmsKeyName?: string;

}

/**
 * Converts an object of type 'SecretSpecForProviderReplicationUserManagedReplicasCustomerManagedEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderReplicationUserManagedReplicasCustomerManagedEncryption(obj: SecretSpecForProviderReplicationUserManagedReplicasCustomerManagedEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecInitProviderReplicationUserManagedReplicasCustomerManagedEncryption
 */
export interface SecretSpecInitProviderReplicationUserManagedReplicasCustomerManagedEncryption {
  /**
   * Describes the Cloud KMS encryption key that will be used to protect destination secret.
   *
   * @schema SecretSpecInitProviderReplicationUserManagedReplicasCustomerManagedEncryption#kmsKeyName
   */
  readonly kmsKeyName?: string;

}

/**
 * Converts an object of type 'SecretSpecInitProviderReplicationUserManagedReplicasCustomerManagedEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecInitProviderReplicationUserManagedReplicasCustomerManagedEncryption(obj: SecretSpecInitProviderReplicationUserManagedReplicasCustomerManagedEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyName': obj.kmsKeyName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * SecretIAMMember is the Schema for the SecretIAMMembers API. <no value>
 *
 * @schema SecretIAMMember
 */
export class SecretIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretmanager.gcp.upbound.io/v1beta1',
    kind: 'SecretIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "SecretIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretIamMemberProps): any {
    return {
      ...SecretIamMember.GVK,
      ...toJson_SecretIamMemberProps(props),
    };
  }

  /**
   * Defines a "SecretIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretIamMemberProps) {
    super(scope, id, {
      ...SecretIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretIamMember.GVK,
      ...toJson_SecretIamMemberProps(resolved),
    };
  }
}

/**
 * SecretIAMMember is the Schema for the SecretIAMMembers API. <no value>
 *
 * @schema SecretIAMMember
 */
export interface SecretIamMemberProps {
  /**
   * @schema SecretIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretIAMMemberSpec defines the desired state of SecretIAMMember
   *
   * @schema SecretIAMMember#spec
   */
  readonly spec: SecretIamMemberSpec;

}

/**
 * Converts an object of type 'SecretIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberProps(obj: SecretIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretIAMMemberSpec defines the desired state of SecretIAMMember
 *
 * @schema SecretIamMemberSpec
 */
export interface SecretIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecretIamMemberSpecDeletionPolicy;

  /**
   * @schema SecretIamMemberSpec#forProvider
   */
  readonly forProvider: SecretIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SecretIamMemberSpec#initProvider
   */
  readonly initProvider?: SecretIamMemberSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SecretIamMemberSpec#managementPolicies
   */
  readonly managementPolicies?: SecretIamMemberSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecretIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecretIamMemberSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecretIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecretIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecretIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecretIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecretIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpec(obj: SecretIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecretIamMemberSpecForProvider(obj.forProvider),
    'initProvider': toJson_SecretIamMemberSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SecretIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SecretIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecretIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretIamMemberSpecDeletionPolicy
 */
export enum SecretIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SecretIamMemberSpecForProvider
 */
export interface SecretIamMemberSpecForProvider {
  /**
   * @schema SecretIamMemberSpecForProvider#condition
   */
  readonly condition?: SecretIamMemberSpecForProviderCondition[];

  /**
   * @schema SecretIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema SecretIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema SecretIamMemberSpecForProvider#role
   */
  readonly role?: string;

  /**
   * @schema SecretIamMemberSpecForProvider#secretId
   */
  readonly secretId?: string;

  /**
   * Reference to a Secret to populate secretId.
   *
   * @schema SecretIamMemberSpecForProvider#secretIdRef
   */
  readonly secretIdRef?: SecretIamMemberSpecForProviderSecretIdRef;

  /**
   * Selector for a Secret to populate secretId.
   *
   * @schema SecretIamMemberSpecForProvider#secretIdSelector
   */
  readonly secretIdSelector?: SecretIamMemberSpecForProviderSecretIdSelector;

}

/**
 * Converts an object of type 'SecretIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecForProvider(obj: SecretIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_SecretIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
    'secretId': obj.secretId,
    'secretIdRef': toJson_SecretIamMemberSpecForProviderSecretIdRef(obj.secretIdRef),
    'secretIdSelector': toJson_SecretIamMemberSpecForProviderSecretIdSelector(obj.secretIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SecretIamMemberSpecInitProvider
 */
export interface SecretIamMemberSpecInitProvider {
  /**
   * @schema SecretIamMemberSpecInitProvider#condition
   */
  readonly condition?: SecretIamMemberSpecInitProviderCondition[];

  /**
   * @schema SecretIamMemberSpecInitProvider#member
   */
  readonly member?: string;

  /**
   * @schema SecretIamMemberSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * @schema SecretIamMemberSpecInitProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'SecretIamMemberSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecInitProvider(obj: SecretIamMemberSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_SecretIamMemberSpecInitProviderCondition(y)),
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SecretIamMemberSpecManagementPolicies
 */
export enum SecretIamMemberSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecretIamMemberSpecProviderConfigRef
 */
export interface SecretIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: SecretIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecProviderConfigRef(obj: SecretIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecretIamMemberSpecPublishConnectionDetailsTo
 */
export interface SecretIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecretIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecretIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecretIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecretIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecretIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecretIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecPublishConnectionDetailsTo(obj: SecretIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecretIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecretIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecretIamMemberSpecWriteConnectionSecretToRef
 */
export interface SecretIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecretIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecWriteConnectionSecretToRef(obj: SecretIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretIamMemberSpecForProviderCondition
 */
export interface SecretIamMemberSpecForProviderCondition {
  /**
   * @schema SecretIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema SecretIamMemberSpecForProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema SecretIamMemberSpecForProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'SecretIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecForProviderCondition(obj: SecretIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret to populate secretId.
 *
 * @schema SecretIamMemberSpecForProviderSecretIdRef
 */
export interface SecretIamMemberSpecForProviderSecretIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretIamMemberSpecForProviderSecretIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretIamMemberSpecForProviderSecretIdRef#policy
   */
  readonly policy?: SecretIamMemberSpecForProviderSecretIdRefPolicy;

}

/**
 * Converts an object of type 'SecretIamMemberSpecForProviderSecretIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecForProviderSecretIdRef(obj: SecretIamMemberSpecForProviderSecretIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretIamMemberSpecForProviderSecretIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret to populate secretId.
 *
 * @schema SecretIamMemberSpecForProviderSecretIdSelector
 */
export interface SecretIamMemberSpecForProviderSecretIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecretIamMemberSpecForProviderSecretIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecretIamMemberSpecForProviderSecretIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecretIamMemberSpecForProviderSecretIdSelector#policy
   */
  readonly policy?: SecretIamMemberSpecForProviderSecretIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecretIamMemberSpecForProviderSecretIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecForProviderSecretIdSelector(obj: SecretIamMemberSpecForProviderSecretIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecretIamMemberSpecForProviderSecretIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretIamMemberSpecInitProviderCondition
 */
export interface SecretIamMemberSpecInitProviderCondition {
  /**
   * @schema SecretIamMemberSpecInitProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema SecretIamMemberSpecInitProviderCondition#expression
   */
  readonly expression?: string;

  /**
   * @schema SecretIamMemberSpecInitProviderCondition#title
   */
  readonly title?: string;

}

/**
 * Converts an object of type 'SecretIamMemberSpecInitProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecInitProviderCondition(obj: SecretIamMemberSpecInitProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretIamMemberSpecProviderConfigRefPolicy
 */
export interface SecretIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecretIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecretIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecProviderConfigRefPolicy(obj: SecretIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecretIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface SecretIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecPublishConnectionDetailsToConfigRef(obj: SecretIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecretIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface SecretIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecretIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecPublishConnectionDetailsToMetadata(obj: SecretIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretIamMemberSpecForProviderSecretIdRefPolicy
 */
export interface SecretIamMemberSpecForProviderSecretIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretIamMemberSpecForProviderSecretIdRefPolicy#resolution
   */
  readonly resolution?: SecretIamMemberSpecForProviderSecretIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretIamMemberSpecForProviderSecretIdRefPolicy#resolve
   */
  readonly resolve?: SecretIamMemberSpecForProviderSecretIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretIamMemberSpecForProviderSecretIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecForProviderSecretIdRefPolicy(obj: SecretIamMemberSpecForProviderSecretIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecretIamMemberSpecForProviderSecretIdSelectorPolicy
 */
export interface SecretIamMemberSpecForProviderSecretIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretIamMemberSpecForProviderSecretIdSelectorPolicy#resolution
   */
  readonly resolution?: SecretIamMemberSpecForProviderSecretIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretIamMemberSpecForProviderSecretIdSelectorPolicy#resolve
   */
  readonly resolve?: SecretIamMemberSpecForProviderSecretIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecretIamMemberSpecForProviderSecretIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecForProviderSecretIdSelectorPolicy(obj: SecretIamMemberSpecForProviderSecretIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum SecretIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum SecretIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretIamMemberSpecForProviderSecretIdRefPolicyResolution
 */
export enum SecretIamMemberSpecForProviderSecretIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretIamMemberSpecForProviderSecretIdRefPolicyResolve
 */
export enum SecretIamMemberSpecForProviderSecretIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretIamMemberSpecForProviderSecretIdSelectorPolicyResolution
 */
export enum SecretIamMemberSpecForProviderSecretIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretIamMemberSpecForProviderSecretIdSelectorPolicyResolve
 */
export enum SecretIamMemberSpecForProviderSecretIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecretIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SecretVersion is the Schema for the SecretVersions API. A secret version resource.
 *
 * @schema SecretVersion
 */
export class SecretVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretmanager.gcp.upbound.io/v1beta1',
    kind: 'SecretVersion',
  }

  /**
   * Renders a Kubernetes manifest for "SecretVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretVersionProps): any {
    return {
      ...SecretVersion.GVK,
      ...toJson_SecretVersionProps(props),
    };
  }

  /**
   * Defines a "SecretVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretVersionProps) {
    super(scope, id, {
      ...SecretVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretVersion.GVK,
      ...toJson_SecretVersionProps(resolved),
    };
  }
}

/**
 * SecretVersion is the Schema for the SecretVersions API. A secret version resource.
 *
 * @schema SecretVersion
 */
export interface SecretVersionProps {
  /**
   * @schema SecretVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretVersionSpec defines the desired state of SecretVersion
   *
   * @schema SecretVersion#spec
   */
  readonly spec: SecretVersionSpec;

}

/**
 * Converts an object of type 'SecretVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionProps(obj: SecretVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretVersionSpec defines the desired state of SecretVersion
 *
 * @schema SecretVersionSpec
 */
export interface SecretVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecretVersionSpecDeletionPolicy;

  /**
   * @schema SecretVersionSpec#forProvider
   */
  readonly forProvider: SecretVersionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SecretVersionSpec#initProvider
   */
  readonly initProvider?: SecretVersionSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SecretVersionSpec#managementPolicies
   */
  readonly managementPolicies?: SecretVersionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecretVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecretVersionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecretVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecretVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecretVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecretVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecretVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpec(obj: SecretVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecretVersionSpecForProvider(obj.forProvider),
    'initProvider': toJson_SecretVersionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SecretVersionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SecretVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecretVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretVersionSpecDeletionPolicy
 */
export enum SecretVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SecretVersionSpecForProvider
 */
export interface SecretVersionSpecForProvider {
  /**
   * The current state of the SecretVersion.
   *
   * @schema SecretVersionSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Secret Manager secret resource
   *
   * @schema SecretVersionSpecForProvider#secret
   */
  readonly secret?: string;

  /**
   * The secret data. Must be no larger than 64KiB.
   *
   * @schema SecretVersionSpecForProvider#secretDataSecretRef
   */
  readonly secretDataSecretRef?: SecretVersionSpecForProviderSecretDataSecretRef;

  /**
   * Reference to a Secret to populate secret.
   *
   * @schema SecretVersionSpecForProvider#secretRef
   */
  readonly secretRef?: SecretVersionSpecForProviderSecretRef;

  /**
   * Selector for a Secret to populate secret.
   *
   * @schema SecretVersionSpecForProvider#secretSelector
   */
  readonly secretSelector?: SecretVersionSpecForProviderSecretSelector;

}

/**
 * Converts an object of type 'SecretVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProvider(obj: SecretVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'secret': obj.secret,
    'secretDataSecretRef': toJson_SecretVersionSpecForProviderSecretDataSecretRef(obj.secretDataSecretRef),
    'secretRef': toJson_SecretVersionSpecForProviderSecretRef(obj.secretRef),
    'secretSelector': toJson_SecretVersionSpecForProviderSecretSelector(obj.secretSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SecretVersionSpecInitProvider
 */
export interface SecretVersionSpecInitProvider {
  /**
   * The current state of the SecretVersion.
   *
   * @schema SecretVersionSpecInitProvider#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'SecretVersionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecInitProvider(obj: SecretVersionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SecretVersionSpecManagementPolicies
 */
export enum SecretVersionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecretVersionSpecProviderConfigRef
 */
export interface SecretVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretVersionSpecProviderConfigRef#policy
   */
  readonly policy?: SecretVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecProviderConfigRef(obj: SecretVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsTo
 */
export interface SecretVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecretVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecretVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecretVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecPublishConnectionDetailsTo(obj: SecretVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecretVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecretVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecretVersionSpecWriteConnectionSecretToRef
 */
export interface SecretVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecretVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecWriteConnectionSecretToRef(obj: SecretVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret data. Must be no larger than 64KiB.
 *
 * @schema SecretVersionSpecForProviderSecretDataSecretRef
 */
export interface SecretVersionSpecForProviderSecretDataSecretRef {
  /**
   * The key to select.
   *
   * @schema SecretVersionSpecForProviderSecretDataSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema SecretVersionSpecForProviderSecretDataSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretVersionSpecForProviderSecretDataSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretVersionSpecForProviderSecretDataSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProviderSecretDataSecretRef(obj: SecretVersionSpecForProviderSecretDataSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret to populate secret.
 *
 * @schema SecretVersionSpecForProviderSecretRef
 */
export interface SecretVersionSpecForProviderSecretRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretVersionSpecForProviderSecretRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretVersionSpecForProviderSecretRef#policy
   */
  readonly policy?: SecretVersionSpecForProviderSecretRefPolicy;

}

/**
 * Converts an object of type 'SecretVersionSpecForProviderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProviderSecretRef(obj: SecretVersionSpecForProviderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretVersionSpecForProviderSecretRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret to populate secret.
 *
 * @schema SecretVersionSpecForProviderSecretSelector
 */
export interface SecretVersionSpecForProviderSecretSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecretVersionSpecForProviderSecretSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecretVersionSpecForProviderSecretSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecretVersionSpecForProviderSecretSelector#policy
   */
  readonly policy?: SecretVersionSpecForProviderSecretSelectorPolicy;

}

/**
 * Converts an object of type 'SecretVersionSpecForProviderSecretSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProviderSecretSelector(obj: SecretVersionSpecForProviderSecretSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecretVersionSpecForProviderSecretSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretVersionSpecProviderConfigRefPolicy
 */
export interface SecretVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecretVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecretVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecProviderConfigRefPolicy(obj: SecretVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface SecretVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecPublishConnectionDetailsToConfigRef(obj: SecretVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsToMetadata
 */
export interface SecretVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecPublishConnectionDetailsToMetadata(obj: SecretVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretVersionSpecForProviderSecretRefPolicy
 */
export interface SecretVersionSpecForProviderSecretRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretVersionSpecForProviderSecretRefPolicy#resolution
   */
  readonly resolution?: SecretVersionSpecForProviderSecretRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretVersionSpecForProviderSecretRefPolicy#resolve
   */
  readonly resolve?: SecretVersionSpecForProviderSecretRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretVersionSpecForProviderSecretRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProviderSecretRefPolicy(obj: SecretVersionSpecForProviderSecretRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecretVersionSpecForProviderSecretSelectorPolicy
 */
export interface SecretVersionSpecForProviderSecretSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretVersionSpecForProviderSecretSelectorPolicy#resolution
   */
  readonly resolution?: SecretVersionSpecForProviderSecretSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretVersionSpecForProviderSecretSelectorPolicy#resolve
   */
  readonly resolve?: SecretVersionSpecForProviderSecretSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecretVersionSpecForProviderSecretSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProviderSecretSelectorPolicy(obj: SecretVersionSpecForProviderSecretSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretVersionSpecProviderConfigRefPolicyResolution
 */
export enum SecretVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretVersionSpecProviderConfigRefPolicyResolve
 */
export enum SecretVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretVersionSpecForProviderSecretRefPolicyResolution
 */
export enum SecretVersionSpecForProviderSecretRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretVersionSpecForProviderSecretRefPolicyResolve
 */
export enum SecretVersionSpecForProviderSecretRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretVersionSpecForProviderSecretSelectorPolicyResolution
 */
export enum SecretVersionSpecForProviderSecretSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretVersionSpecForProviderSecretSelectorPolicyResolve
 */
export enum SecretVersionSpecForProviderSecretSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

