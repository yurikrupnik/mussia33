// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Feature is the Schema for the Features API. Provides a CloudWatch Evidently Feature resource.
 *
 * @schema Feature
 */
export class Feature extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Feature"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'evidently.aws.upbound.io/v1beta1',
    kind: 'Feature',
  }

  /**
   * Renders a Kubernetes manifest for "Feature".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FeatureProps): any {
    return {
      ...Feature.GVK,
      ...toJson_FeatureProps(props),
    };
  }

  /**
   * Defines a "Feature" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FeatureProps) {
    super(scope, id, {
      ...Feature.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Feature.GVK,
      ...toJson_FeatureProps(resolved),
    };
  }
}

/**
 * Feature is the Schema for the Features API. Provides a CloudWatch Evidently Feature resource.
 *
 * @schema Feature
 */
export interface FeatureProps {
  /**
   * @schema Feature#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FeatureSpec defines the desired state of Feature
   *
   * @schema Feature#spec
   */
  readonly spec: FeatureSpec;

}

/**
 * Converts an object of type 'FeatureProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureProps(obj: FeatureProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FeatureSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FeatureSpec defines the desired state of Feature
 *
 * @schema FeatureSpec
 */
export interface FeatureSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FeatureSpec#deletionPolicy
   */
  readonly deletionPolicy?: FeatureSpecDeletionPolicy;

  /**
   * @schema FeatureSpec#forProvider
   */
  readonly forProvider: FeatureSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema FeatureSpec#managementPolicy
   */
  readonly managementPolicy?: FeatureSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FeatureSpec#providerConfigRef
   */
  readonly providerConfigRef?: FeatureSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FeatureSpec#providerRef
   */
  readonly providerRef?: FeatureSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FeatureSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FeatureSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FeatureSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FeatureSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FeatureSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpec(obj: FeatureSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FeatureSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_FeatureSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FeatureSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FeatureSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FeatureSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FeatureSpecDeletionPolicy
 */
export enum FeatureSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FeatureSpecForProvider
 */
export interface FeatureSpecForProvider {
  /**
   * The name of the variation to use as the default variation. The default variation is served to users who are not allocated to any ongoing launches or experiments of this feature. This variation must also be listed in the variations structure. If you omit default_variation, the first variation listed in the variations structure is used as the default variation.
   *
   * @schema FeatureSpecForProvider#defaultVariation
   */
  readonly defaultVariation?: string;

  /**
   * Specifies the description of the feature.
   *
   * @schema FeatureSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specify users that should always be served a specific variation of a feature. Each user is specified by a key-value pair . For each key, specify a user by entering their user ID, account ID, or some other identifier. For the value, specify the name of the variation that they are to be served.
   *
   * @schema FeatureSpecForProvider#entityOverrides
   */
  readonly entityOverrides?: { [key: string]: string };

  /**
   * Specify ALL_RULES to activate the traffic allocation specified by any ongoing launches or experiments. Specify DEFAULT_VARIATION to serve the default variation to all users instead.
   *
   * @schema FeatureSpecForProvider#evaluationStrategy
   */
  readonly evaluationStrategy?: string;

  /**
   * The name or ARN of the project that is to contain the new feature.
   *
   * @schema FeatureSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reference to a Project in evidently to populate project.
   *
   * @schema FeatureSpecForProvider#projectRef
   */
  readonly projectRef?: FeatureSpecForProviderProjectRef;

  /**
   * Selector for a Project in evidently to populate project.
   *
   * @schema FeatureSpecForProvider#projectSelector
   */
  readonly projectSelector?: FeatureSpecForProviderProjectSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FeatureSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema FeatureSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * One or more blocks that contain the configuration of the feature's different variations. Detailed below
   *
   * @schema FeatureSpecForProvider#variations
   */
  readonly variations?: FeatureSpecForProviderVariations[];

}

/**
 * Converts an object of type 'FeatureSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecForProvider(obj: FeatureSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultVariation': obj.defaultVariation,
    'description': obj.description,
    'entityOverrides': ((obj.entityOverrides) === undefined) ? undefined : (Object.entries(obj.entityOverrides).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'evaluationStrategy': obj.evaluationStrategy,
    'project': obj.project,
    'projectRef': toJson_FeatureSpecForProviderProjectRef(obj.projectRef),
    'projectSelector': toJson_FeatureSpecForProviderProjectSelector(obj.projectSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'variations': obj.variations?.map(y => toJson_FeatureSpecForProviderVariations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema FeatureSpecManagementPolicy
 */
export enum FeatureSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FeatureSpecProviderConfigRef
 */
export interface FeatureSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeatureSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeatureSpecProviderConfigRef#policy
   */
  readonly policy?: FeatureSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FeatureSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecProviderConfigRef(obj: FeatureSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeatureSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FeatureSpecProviderRef
 */
export interface FeatureSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeatureSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeatureSpecProviderRef#policy
   */
  readonly policy?: FeatureSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FeatureSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecProviderRef(obj: FeatureSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeatureSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FeatureSpecPublishConnectionDetailsTo
 */
export interface FeatureSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FeatureSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FeatureSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FeatureSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FeatureSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FeatureSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FeatureSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecPublishConnectionDetailsTo(obj: FeatureSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FeatureSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FeatureSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FeatureSpecWriteConnectionSecretToRef
 */
export interface FeatureSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FeatureSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FeatureSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FeatureSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecWriteConnectionSecretToRef(obj: FeatureSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project in evidently to populate project.
 *
 * @schema FeatureSpecForProviderProjectRef
 */
export interface FeatureSpecForProviderProjectRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeatureSpecForProviderProjectRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeatureSpecForProviderProjectRef#policy
   */
  readonly policy?: FeatureSpecForProviderProjectRefPolicy;

}

/**
 * Converts an object of type 'FeatureSpecForProviderProjectRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecForProviderProjectRef(obj: FeatureSpecForProviderProjectRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeatureSpecForProviderProjectRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project in evidently to populate project.
 *
 * @schema FeatureSpecForProviderProjectSelector
 */
export interface FeatureSpecForProviderProjectSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FeatureSpecForProviderProjectSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FeatureSpecForProviderProjectSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FeatureSpecForProviderProjectSelector#policy
   */
  readonly policy?: FeatureSpecForProviderProjectSelectorPolicy;

}

/**
 * Converts an object of type 'FeatureSpecForProviderProjectSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecForProviderProjectSelector(obj: FeatureSpecForProviderProjectSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FeatureSpecForProviderProjectSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureSpecForProviderVariations
 */
export interface FeatureSpecForProviderVariations {
  /**
   * The name of the variation. Minimum length of 1. Maximum length of 127.
   *
   * @schema FeatureSpecForProviderVariations#name
   */
  readonly name: string;

  /**
   * A block that specifies the value assigned to this variation. Detailed below
   *
   * @schema FeatureSpecForProviderVariations#value
   */
  readonly value: FeatureSpecForProviderVariationsValue[];

}

/**
 * Converts an object of type 'FeatureSpecForProviderVariations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecForProviderVariations(obj: FeatureSpecForProviderVariations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value?.map(y => toJson_FeatureSpecForProviderVariationsValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FeatureSpecProviderConfigRefPolicy
 */
export interface FeatureSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeatureSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FeatureSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeatureSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FeatureSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FeatureSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecProviderConfigRefPolicy(obj: FeatureSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FeatureSpecProviderRefPolicy
 */
export interface FeatureSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeatureSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FeatureSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeatureSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FeatureSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FeatureSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecProviderRefPolicy(obj: FeatureSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FeatureSpecPublishConnectionDetailsToConfigRef
 */
export interface FeatureSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FeatureSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FeatureSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FeatureSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FeatureSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecPublishConnectionDetailsToConfigRef(obj: FeatureSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FeatureSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FeatureSpecPublishConnectionDetailsToMetadata
 */
export interface FeatureSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FeatureSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FeatureSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FeatureSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FeatureSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecPublishConnectionDetailsToMetadata(obj: FeatureSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FeatureSpecForProviderProjectRefPolicy
 */
export interface FeatureSpecForProviderProjectRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeatureSpecForProviderProjectRefPolicy#resolution
   */
  readonly resolution?: FeatureSpecForProviderProjectRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeatureSpecForProviderProjectRefPolicy#resolve
   */
  readonly resolve?: FeatureSpecForProviderProjectRefPolicyResolve;

}

/**
 * Converts an object of type 'FeatureSpecForProviderProjectRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecForProviderProjectRefPolicy(obj: FeatureSpecForProviderProjectRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FeatureSpecForProviderProjectSelectorPolicy
 */
export interface FeatureSpecForProviderProjectSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeatureSpecForProviderProjectSelectorPolicy#resolution
   */
  readonly resolution?: FeatureSpecForProviderProjectSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeatureSpecForProviderProjectSelectorPolicy#resolve
   */
  readonly resolve?: FeatureSpecForProviderProjectSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FeatureSpecForProviderProjectSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecForProviderProjectSelectorPolicy(obj: FeatureSpecForProviderProjectSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FeatureSpecForProviderVariationsValue
 */
export interface FeatureSpecForProviderVariationsValue {
  /**
   * If this feature uses the Boolean variation type, this field contains the Boolean value of this variation.
   *
   * @schema FeatureSpecForProviderVariationsValue#boolValue
   */
  readonly boolValue?: string;

  /**
   * If this feature uses the double integer variation type, this field contains the double integer value of this variation.
   *
   * @schema FeatureSpecForProviderVariationsValue#doubleValue
   */
  readonly doubleValue?: string;

  /**
   * If this feature uses the long variation type, this field contains the long value of this variation. Minimum value of -9007199254740991. Maximum value of 9007199254740991.
   *
   * @schema FeatureSpecForProviderVariationsValue#longValue
   */
  readonly longValue?: string;

  /**
   * If this feature uses the string variation type, this field contains the string value of this variation. Minimum length of 0. Maximum length of 512.
   *
   * @schema FeatureSpecForProviderVariationsValue#stringValue
   */
  readonly stringValue?: string;

}

/**
 * Converts an object of type 'FeatureSpecForProviderVariationsValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecForProviderVariationsValue(obj: FeatureSpecForProviderVariationsValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'boolValue': obj.boolValue,
    'doubleValue': obj.doubleValue,
    'longValue': obj.longValue,
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeatureSpecProviderConfigRefPolicyResolution
 */
export enum FeatureSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeatureSpecProviderConfigRefPolicyResolve
 */
export enum FeatureSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeatureSpecProviderRefPolicyResolution
 */
export enum FeatureSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeatureSpecProviderRefPolicyResolve
 */
export enum FeatureSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FeatureSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FeatureSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FeatureSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FeatureSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FeatureSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FeatureSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FeatureSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FeatureSpecPublishConnectionDetailsToConfigRefPolicy(obj: FeatureSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeatureSpecForProviderProjectRefPolicyResolution
 */
export enum FeatureSpecForProviderProjectRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeatureSpecForProviderProjectRefPolicyResolve
 */
export enum FeatureSpecForProviderProjectRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeatureSpecForProviderProjectSelectorPolicyResolution
 */
export enum FeatureSpecForProviderProjectSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeatureSpecForProviderProjectSelectorPolicyResolve
 */
export enum FeatureSpecForProviderProjectSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FeatureSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FeatureSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FeatureSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FeatureSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Project is the Schema for the Projects API. Provides a CloudWatch Evidently Project resource.
 *
 * @schema Project
 */
export class Project extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Project"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'evidently.aws.upbound.io/v1beta1',
    kind: 'Project',
  }

  /**
   * Renders a Kubernetes manifest for "Project".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectProps): any {
    return {
      ...Project.GVK,
      ...toJson_ProjectProps(props),
    };
  }

  /**
   * Defines a "Project" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectProps) {
    super(scope, id, {
      ...Project.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Project.GVK,
      ...toJson_ProjectProps(resolved),
    };
  }
}

/**
 * Project is the Schema for the Projects API. Provides a CloudWatch Evidently Project resource.
 *
 * @schema Project
 */
export interface ProjectProps {
  /**
   * @schema Project#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectSpec defines the desired state of Project
   *
   * @schema Project#spec
   */
  readonly spec: ProjectSpec;

}

/**
 * Converts an object of type 'ProjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectProps(obj: ProjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectSpec defines the desired state of Project
 *
 * @schema ProjectSpec
 */
export interface ProjectSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectSpecDeletionPolicy;

  /**
   * @schema ProjectSpec#forProvider
   */
  readonly forProvider: ProjectSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectSpec#managementPolicy
   */
  readonly managementPolicy?: ProjectSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ProjectSpec#providerRef
   */
  readonly providerRef?: ProjectSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpec(obj: ProjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ProjectSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ProjectSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ProjectSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectSpecDeletionPolicy
 */
export enum ProjectSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectSpecForProvider
 */
export interface ProjectSpecForProvider {
  /**
   * A block that contains information about where Evidently is to store evaluation events for longer term storage, if you choose to do so. If you choose not to store these events, Evidently deletes them after using them to produce metrics and other experiment results that you can view. See below.
   *
   * @schema ProjectSpecForProvider#dataDelivery
   */
  readonly dataDelivery?: ProjectSpecForProviderDataDelivery[];

  /**
   * Specifies the description of the project.
   *
   * @schema ProjectSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A name for the project.
   *
   * @schema ProjectSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProjectSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ProjectSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ProjectSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProvider(obj: ProjectSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataDelivery': obj.dataDelivery?.map(y => toJson_ProjectSpecForProviderDataDelivery(y)),
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectSpecManagementPolicy
 */
export enum ProjectSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectSpecProviderConfigRef
 */
export interface ProjectSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderConfigRef(obj: ProjectSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ProjectSpecProviderRef
 */
export interface ProjectSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecProviderRef#policy
   */
  readonly policy?: ProjectSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderRef(obj: ProjectSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectSpecPublishConnectionDetailsTo
 */
export interface ProjectSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsTo(obj: ProjectSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectSpecWriteConnectionSecretToRef
 */
export interface ProjectSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecWriteConnectionSecretToRef(obj: ProjectSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectSpecForProviderDataDelivery
 */
export interface ProjectSpecForProviderDataDelivery {
  /**
   * A block that defines the CloudWatch Log Group that stores the evaluation events. See below.
   *
   * @schema ProjectSpecForProviderDataDelivery#cloudwatchLogs
   */
  readonly cloudwatchLogs?: ProjectSpecForProviderDataDeliveryCloudwatchLogs[];

  /**
   * A block that defines the S3 bucket and prefix that stores the evaluation events. See below.
   *
   * @schema ProjectSpecForProviderDataDelivery#s3Destination
   */
  readonly s3Destination?: ProjectSpecForProviderDataDeliveryS3Destination[];

}

/**
 * Converts an object of type 'ProjectSpecForProviderDataDelivery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderDataDelivery(obj: ProjectSpecForProviderDataDelivery | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLogs': obj.cloudwatchLogs?.map(y => toJson_ProjectSpecForProviderDataDeliveryCloudwatchLogs(y)),
    's3Destination': obj.s3Destination?.map(y => toJson_ProjectSpecForProviderDataDeliveryS3Destination(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecProviderConfigRefPolicy
 */
export interface ProjectSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderConfigRefPolicy(obj: ProjectSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecProviderRefPolicy
 */
export interface ProjectSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderRefPolicy(obj: ProjectSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToConfigRef(obj: ProjectSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToMetadata(obj: ProjectSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectSpecForProviderDataDeliveryCloudwatchLogs
 */
export interface ProjectSpecForProviderDataDeliveryCloudwatchLogs {
  /**
   * The name of the log group where the project stores evaluation events.
   *
   * @schema ProjectSpecForProviderDataDeliveryCloudwatchLogs#logGroup
   */
  readonly logGroup?: string;

}

/**
 * Converts an object of type 'ProjectSpecForProviderDataDeliveryCloudwatchLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderDataDeliveryCloudwatchLogs(obj: ProjectSpecForProviderDataDeliveryCloudwatchLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logGroup': obj.logGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectSpecForProviderDataDeliveryS3Destination
 */
export interface ProjectSpecForProviderDataDeliveryS3Destination {
  /**
   * The name of the bucket in which Evidently stores evaluation events.
   *
   * @schema ProjectSpecForProviderDataDeliveryS3Destination#bucket
   */
  readonly bucket?: string;

  /**
   * The bucket prefix in which Evidently stores evaluation events.
   *
   * @schema ProjectSpecForProviderDataDeliveryS3Destination#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'ProjectSpecForProviderDataDeliveryS3Destination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProviderDataDeliveryS3Destination(obj: ProjectSpecForProviderDataDeliveryS3Destination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecProviderConfigRefPolicyResolution
 */
export enum ProjectSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecProviderConfigRefPolicyResolve
 */
export enum ProjectSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecProviderRefPolicyResolution
 */
export enum ProjectSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecProviderRefPolicyResolve
 */
export enum ProjectSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Segment is the Schema for the Segments API. Provides a CloudWatch Evidently Segment resource.
 *
 * @schema Segment
 */
export class Segment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Segment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'evidently.aws.upbound.io/v1beta1',
    kind: 'Segment',
  }

  /**
   * Renders a Kubernetes manifest for "Segment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SegmentProps): any {
    return {
      ...Segment.GVK,
      ...toJson_SegmentProps(props),
    };
  }

  /**
   * Defines a "Segment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SegmentProps) {
    super(scope, id, {
      ...Segment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Segment.GVK,
      ...toJson_SegmentProps(resolved),
    };
  }
}

/**
 * Segment is the Schema for the Segments API. Provides a CloudWatch Evidently Segment resource.
 *
 * @schema Segment
 */
export interface SegmentProps {
  /**
   * @schema Segment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SegmentSpec defines the desired state of Segment
   *
   * @schema Segment#spec
   */
  readonly spec: SegmentSpec;

}

/**
 * Converts an object of type 'SegmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentProps(obj: SegmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SegmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SegmentSpec defines the desired state of Segment
 *
 * @schema SegmentSpec
 */
export interface SegmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SegmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: SegmentSpecDeletionPolicy;

  /**
   * @schema SegmentSpec#forProvider
   */
  readonly forProvider: SegmentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SegmentSpec#managementPolicy
   */
  readonly managementPolicy?: SegmentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SegmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: SegmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SegmentSpec#providerRef
   */
  readonly providerRef?: SegmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SegmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SegmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SegmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SegmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SegmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentSpec(obj: SegmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SegmentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SegmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SegmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SegmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SegmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SegmentSpecDeletionPolicy
 */
export enum SegmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SegmentSpecForProvider
 */
export interface SegmentSpecForProvider {
  /**
   * Specifies the description of the segment.
   *
   * @schema SegmentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The pattern to use for the segment. For more information about pattern syntax, see Segment rule pattern syntax.
   *
   * @schema SegmentSpecForProvider#pattern
   */
  readonly pattern?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SegmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema SegmentSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SegmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentSpecForProvider(obj: SegmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'pattern': obj.pattern,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SegmentSpecManagementPolicy
 */
export enum SegmentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SegmentSpecProviderConfigRef
 */
export interface SegmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SegmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SegmentSpecProviderConfigRef#policy
   */
  readonly policy?: SegmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SegmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentSpecProviderConfigRef(obj: SegmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SegmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SegmentSpecProviderRef
 */
export interface SegmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SegmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SegmentSpecProviderRef#policy
   */
  readonly policy?: SegmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SegmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentSpecProviderRef(obj: SegmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SegmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SegmentSpecPublishConnectionDetailsTo
 */
export interface SegmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SegmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SegmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SegmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SegmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SegmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SegmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentSpecPublishConnectionDetailsTo(obj: SegmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SegmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SegmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SegmentSpecWriteConnectionSecretToRef
 */
export interface SegmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SegmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SegmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SegmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentSpecWriteConnectionSecretToRef(obj: SegmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SegmentSpecProviderConfigRefPolicy
 */
export interface SegmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SegmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SegmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SegmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SegmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SegmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentSpecProviderConfigRefPolicy(obj: SegmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SegmentSpecProviderRefPolicy
 */
export interface SegmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SegmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SegmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SegmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SegmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SegmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentSpecProviderRefPolicy(obj: SegmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SegmentSpecPublishConnectionDetailsToConfigRef
 */
export interface SegmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SegmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SegmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SegmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SegmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentSpecPublishConnectionDetailsToConfigRef(obj: SegmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SegmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SegmentSpecPublishConnectionDetailsToMetadata
 */
export interface SegmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SegmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SegmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SegmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SegmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentSpecPublishConnectionDetailsToMetadata(obj: SegmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SegmentSpecProviderConfigRefPolicyResolution
 */
export enum SegmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SegmentSpecProviderConfigRefPolicyResolve
 */
export enum SegmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SegmentSpecProviderRefPolicyResolution
 */
export enum SegmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SegmentSpecProviderRefPolicyResolve
 */
export enum SegmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SegmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SegmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SegmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SegmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SegmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SegmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SegmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SegmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: SegmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SegmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SegmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SegmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SegmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

