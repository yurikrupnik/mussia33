// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DevicePool is the Schema for the DevicePools API. Provides a Devicefarm device_pool
 *
 * @schema DevicePool
 */
export class DevicePool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DevicePool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'devicefarm.aws.upbound.io/v1beta1',
    kind: 'DevicePool',
  }

  /**
   * Renders a Kubernetes manifest for "DevicePool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DevicePoolProps): any {
    return {
      ...DevicePool.GVK,
      ...toJson_DevicePoolProps(props),
    };
  }

  /**
   * Defines a "DevicePool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DevicePoolProps) {
    super(scope, id, {
      ...DevicePool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DevicePool.GVK,
      ...toJson_DevicePoolProps(resolved),
    };
  }
}

/**
 * DevicePool is the Schema for the DevicePools API. Provides a Devicefarm device_pool
 *
 * @schema DevicePool
 */
export interface DevicePoolProps {
  /**
   * @schema DevicePool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DevicePoolSpec defines the desired state of DevicePool
   *
   * @schema DevicePool#spec
   */
  readonly spec: DevicePoolSpec;

}

/**
 * Converts an object of type 'DevicePoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolProps(obj: DevicePoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DevicePoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DevicePoolSpec defines the desired state of DevicePool
 *
 * @schema DevicePoolSpec
 */
export interface DevicePoolSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DevicePoolSpec#deletionPolicy
   */
  readonly deletionPolicy?: DevicePoolSpecDeletionPolicy;

  /**
   * @schema DevicePoolSpec#forProvider
   */
  readonly forProvider: DevicePoolSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DevicePoolSpec#initProvider
   */
  readonly initProvider?: DevicePoolSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DevicePoolSpec#managementPolicies
   */
  readonly managementPolicies?: DevicePoolSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DevicePoolSpec#providerConfigRef
   */
  readonly providerConfigRef?: DevicePoolSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DevicePoolSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DevicePoolSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DevicePoolSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DevicePoolSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DevicePoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpec(obj: DevicePoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DevicePoolSpecForProvider(obj.forProvider),
    'initProvider': toJson_DevicePoolSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DevicePoolSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DevicePoolSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DevicePoolSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DevicePoolSpecDeletionPolicy
 */
export enum DevicePoolSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DevicePoolSpecForProvider
 */
export interface DevicePoolSpecForProvider {
  /**
   * The device pool's description.
   *
   * @schema DevicePoolSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The number of devices that Device Farm can add to your device pool.
   *
   * @schema DevicePoolSpecForProvider#maxDevices
   */
  readonly maxDevices?: number;

  /**
   * The name of the Device Pool
   *
   * @schema DevicePoolSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The ARN of the project for the device pool.
   *
   * @schema DevicePoolSpecForProvider#projectArn
   */
  readonly projectArn?: string;

  /**
   * Reference to a Project in devicefarm to populate projectArn.
   *
   * @schema DevicePoolSpecForProvider#projectArnRef
   */
  readonly projectArnRef?: DevicePoolSpecForProviderProjectArnRef;

  /**
   * Selector for a Project in devicefarm to populate projectArn.
   *
   * @schema DevicePoolSpecForProvider#projectArnSelector
   */
  readonly projectArnSelector?: DevicePoolSpecForProviderProjectArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DevicePoolSpecForProvider#region
   */
  readonly region: string;

  /**
   * The device pool's rules. See Rule.
   *
   * @schema DevicePoolSpecForProvider#rule
   */
  readonly rule?: DevicePoolSpecForProviderRule[];

  /**
   * Key-value map of resource tags.
   *
   * @schema DevicePoolSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DevicePoolSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecForProvider(obj: DevicePoolSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'maxDevices': obj.maxDevices,
    'name': obj.name,
    'projectArn': obj.projectArn,
    'projectArnRef': toJson_DevicePoolSpecForProviderProjectArnRef(obj.projectArnRef),
    'projectArnSelector': toJson_DevicePoolSpecForProviderProjectArnSelector(obj.projectArnSelector),
    'region': obj.region,
    'rule': obj.rule?.map(y => toJson_DevicePoolSpecForProviderRule(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DevicePoolSpecInitProvider
 */
export interface DevicePoolSpecInitProvider {
  /**
   * The device pool's description.
   *
   * @schema DevicePoolSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The number of devices that Device Farm can add to your device pool.
   *
   * @schema DevicePoolSpecInitProvider#maxDevices
   */
  readonly maxDevices?: number;

  /**
   * The name of the Device Pool
   *
   * @schema DevicePoolSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The device pool's rules. See Rule.
   *
   * @schema DevicePoolSpecInitProvider#rule
   */
  readonly rule?: DevicePoolSpecInitProviderRule[];

  /**
   * Key-value map of resource tags.
   *
   * @schema DevicePoolSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DevicePoolSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecInitProvider(obj: DevicePoolSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'maxDevices': obj.maxDevices,
    'name': obj.name,
    'rule': obj.rule?.map(y => toJson_DevicePoolSpecInitProviderRule(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DevicePoolSpecManagementPolicies
 */
export enum DevicePoolSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DevicePoolSpecProviderConfigRef
 */
export interface DevicePoolSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DevicePoolSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DevicePoolSpecProviderConfigRef#policy
   */
  readonly policy?: DevicePoolSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DevicePoolSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecProviderConfigRef(obj: DevicePoolSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DevicePoolSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DevicePoolSpecPublishConnectionDetailsTo
 */
export interface DevicePoolSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DevicePoolSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DevicePoolSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DevicePoolSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DevicePoolSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DevicePoolSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DevicePoolSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecPublishConnectionDetailsTo(obj: DevicePoolSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DevicePoolSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DevicePoolSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DevicePoolSpecWriteConnectionSecretToRef
 */
export interface DevicePoolSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DevicePoolSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DevicePoolSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DevicePoolSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecWriteConnectionSecretToRef(obj: DevicePoolSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project in devicefarm to populate projectArn.
 *
 * @schema DevicePoolSpecForProviderProjectArnRef
 */
export interface DevicePoolSpecForProviderProjectArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DevicePoolSpecForProviderProjectArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DevicePoolSpecForProviderProjectArnRef#policy
   */
  readonly policy?: DevicePoolSpecForProviderProjectArnRefPolicy;

}

/**
 * Converts an object of type 'DevicePoolSpecForProviderProjectArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecForProviderProjectArnRef(obj: DevicePoolSpecForProviderProjectArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DevicePoolSpecForProviderProjectArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project in devicefarm to populate projectArn.
 *
 * @schema DevicePoolSpecForProviderProjectArnSelector
 */
export interface DevicePoolSpecForProviderProjectArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DevicePoolSpecForProviderProjectArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DevicePoolSpecForProviderProjectArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DevicePoolSpecForProviderProjectArnSelector#policy
   */
  readonly policy?: DevicePoolSpecForProviderProjectArnSelectorPolicy;

}

/**
 * Converts an object of type 'DevicePoolSpecForProviderProjectArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecForProviderProjectArnSelector(obj: DevicePoolSpecForProviderProjectArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DevicePoolSpecForProviderProjectArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DevicePoolSpecForProviderRule
 */
export interface DevicePoolSpecForProviderRule {
  /**
   * The rule's stringified attribute. Valid values are: APPIUM_VERSION, ARN, AVAILABILITY, FLEET_TYPE, FORM_FACTOR, INSTANCE_ARN, INSTANCE_LABELS, MANUFACTURER, MODEL, OS_VERSION, PLATFORM, REMOTE_ACCESS_ENABLED, REMOTE_DEBUG_ENABLED.
   *
   * @schema DevicePoolSpecForProviderRule#attribute
   */
  readonly attribute?: string;

  /**
   * Specifies how Device Farm compares the rule's attribute to the value. For the operators that are supported by each attribute. Valid values are: EQUALS, NOT_IN, IN, GREATER_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN, LESS_THAN_OR_EQUALS, CONTAINS.
   *
   * @schema DevicePoolSpecForProviderRule#operator
   */
  readonly operator?: string;

  /**
   * The rule's value.
   *
   * @schema DevicePoolSpecForProviderRule#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DevicePoolSpecForProviderRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecForProviderRule(obj: DevicePoolSpecForProviderRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attribute': obj.attribute,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DevicePoolSpecInitProviderRule
 */
export interface DevicePoolSpecInitProviderRule {
  /**
   * The rule's stringified attribute. Valid values are: APPIUM_VERSION, ARN, AVAILABILITY, FLEET_TYPE, FORM_FACTOR, INSTANCE_ARN, INSTANCE_LABELS, MANUFACTURER, MODEL, OS_VERSION, PLATFORM, REMOTE_ACCESS_ENABLED, REMOTE_DEBUG_ENABLED.
   *
   * @schema DevicePoolSpecInitProviderRule#attribute
   */
  readonly attribute?: string;

  /**
   * Specifies how Device Farm compares the rule's attribute to the value. For the operators that are supported by each attribute. Valid values are: EQUALS, NOT_IN, IN, GREATER_THAN, GREATER_THAN_OR_EQUALS, LESS_THAN, LESS_THAN_OR_EQUALS, CONTAINS.
   *
   * @schema DevicePoolSpecInitProviderRule#operator
   */
  readonly operator?: string;

  /**
   * The rule's value.
   *
   * @schema DevicePoolSpecInitProviderRule#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DevicePoolSpecInitProviderRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecInitProviderRule(obj: DevicePoolSpecInitProviderRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attribute': obj.attribute,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DevicePoolSpecProviderConfigRefPolicy
 */
export interface DevicePoolSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DevicePoolSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DevicePoolSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DevicePoolSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DevicePoolSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DevicePoolSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecProviderConfigRefPolicy(obj: DevicePoolSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DevicePoolSpecPublishConnectionDetailsToConfigRef
 */
export interface DevicePoolSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DevicePoolSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DevicePoolSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DevicePoolSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DevicePoolSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecPublishConnectionDetailsToConfigRef(obj: DevicePoolSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DevicePoolSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DevicePoolSpecPublishConnectionDetailsToMetadata
 */
export interface DevicePoolSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DevicePoolSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DevicePoolSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DevicePoolSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DevicePoolSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecPublishConnectionDetailsToMetadata(obj: DevicePoolSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DevicePoolSpecForProviderProjectArnRefPolicy
 */
export interface DevicePoolSpecForProviderProjectArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DevicePoolSpecForProviderProjectArnRefPolicy#resolution
   */
  readonly resolution?: DevicePoolSpecForProviderProjectArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DevicePoolSpecForProviderProjectArnRefPolicy#resolve
   */
  readonly resolve?: DevicePoolSpecForProviderProjectArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DevicePoolSpecForProviderProjectArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecForProviderProjectArnRefPolicy(obj: DevicePoolSpecForProviderProjectArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DevicePoolSpecForProviderProjectArnSelectorPolicy
 */
export interface DevicePoolSpecForProviderProjectArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DevicePoolSpecForProviderProjectArnSelectorPolicy#resolution
   */
  readonly resolution?: DevicePoolSpecForProviderProjectArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DevicePoolSpecForProviderProjectArnSelectorPolicy#resolve
   */
  readonly resolve?: DevicePoolSpecForProviderProjectArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DevicePoolSpecForProviderProjectArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecForProviderProjectArnSelectorPolicy(obj: DevicePoolSpecForProviderProjectArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DevicePoolSpecProviderConfigRefPolicyResolution
 */
export enum DevicePoolSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DevicePoolSpecProviderConfigRefPolicyResolve
 */
export enum DevicePoolSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DevicePoolSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DevicePoolSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DevicePoolSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DevicePoolSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DevicePoolSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DevicePoolSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DevicePoolSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DevicePoolSpecPublishConnectionDetailsToConfigRefPolicy(obj: DevicePoolSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DevicePoolSpecForProviderProjectArnRefPolicyResolution
 */
export enum DevicePoolSpecForProviderProjectArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DevicePoolSpecForProviderProjectArnRefPolicyResolve
 */
export enum DevicePoolSpecForProviderProjectArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DevicePoolSpecForProviderProjectArnSelectorPolicyResolution
 */
export enum DevicePoolSpecForProviderProjectArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DevicePoolSpecForProviderProjectArnSelectorPolicyResolve
 */
export enum DevicePoolSpecForProviderProjectArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DevicePoolSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DevicePoolSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DevicePoolSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DevicePoolSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InstanceProfile is the Schema for the InstanceProfiles API. Provides a Devicefarm instance profile
 *
 * @schema InstanceProfile
 */
export class InstanceProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InstanceProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'devicefarm.aws.upbound.io/v1beta1',
    kind: 'InstanceProfile',
  }

  /**
   * Renders a Kubernetes manifest for "InstanceProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceProfileProps): any {
    return {
      ...InstanceProfile.GVK,
      ...toJson_InstanceProfileProps(props),
    };
  }

  /**
   * Defines a "InstanceProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceProfileProps) {
    super(scope, id, {
      ...InstanceProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InstanceProfile.GVK,
      ...toJson_InstanceProfileProps(resolved),
    };
  }
}

/**
 * InstanceProfile is the Schema for the InstanceProfiles API. Provides a Devicefarm instance profile
 *
 * @schema InstanceProfile
 */
export interface InstanceProfileProps {
  /**
   * @schema InstanceProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceProfileSpec defines the desired state of InstanceProfile
   *
   * @schema InstanceProfile#spec
   */
  readonly spec: InstanceProfileSpec;

}

/**
 * Converts an object of type 'InstanceProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProfileProps(obj: InstanceProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceProfileSpec defines the desired state of InstanceProfile
 *
 * @schema InstanceProfileSpec
 */
export interface InstanceProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceProfileSpecDeletionPolicy;

  /**
   * @schema InstanceProfileSpec#forProvider
   */
  readonly forProvider: InstanceProfileSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema InstanceProfileSpec#initProvider
   */
  readonly initProvider?: InstanceProfileSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InstanceProfileSpec#managementPolicies
   */
  readonly managementPolicies?: InstanceProfileSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceProfileSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProfileSpec(obj: InstanceProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceProfileSpecForProvider(obj.forProvider),
    'initProvider': toJson_InstanceProfileSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InstanceProfileSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InstanceProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceProfileSpecDeletionPolicy
 */
export enum InstanceProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceProfileSpecForProvider
 */
export interface InstanceProfileSpecForProvider {
  /**
   * The description of the instance profile.
   *
   * @schema InstanceProfileSpecForProvider#description
   */
  readonly description?: string;

  /**
   * An array of strings that specifies the list of app packages that should not be cleaned up from the device after a test run.
   *
   * @schema InstanceProfileSpecForProvider#excludeAppPackagesFromCleanup
   */
  readonly excludeAppPackagesFromCleanup?: string[];

  /**
   * The name for the instance profile.
   *
   * @schema InstanceProfileSpecForProvider#name
   */
  readonly name?: string;

  /**
   * When set to true, Device Farm removes app packages after a test run. The default value is false for private devices.
   *
   * @schema InstanceProfileSpecForProvider#packageCleanup
   */
  readonly packageCleanup?: boolean;

  /**
   * When set to true, Device Farm reboots the instance after a test run. The default value is true.
   *
   * @schema InstanceProfileSpecForProvider#rebootAfterUse
   */
  readonly rebootAfterUse?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InstanceProfileSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema InstanceProfileSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'InstanceProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProfileSpecForProvider(obj: InstanceProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'excludeAppPackagesFromCleanup': obj.excludeAppPackagesFromCleanup?.map(y => y),
    'name': obj.name,
    'packageCleanup': obj.packageCleanup,
    'rebootAfterUse': obj.rebootAfterUse,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema InstanceProfileSpecInitProvider
 */
export interface InstanceProfileSpecInitProvider {
  /**
   * The description of the instance profile.
   *
   * @schema InstanceProfileSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * An array of strings that specifies the list of app packages that should not be cleaned up from the device after a test run.
   *
   * @schema InstanceProfileSpecInitProvider#excludeAppPackagesFromCleanup
   */
  readonly excludeAppPackagesFromCleanup?: string[];

  /**
   * The name for the instance profile.
   *
   * @schema InstanceProfileSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * When set to true, Device Farm removes app packages after a test run. The default value is false for private devices.
   *
   * @schema InstanceProfileSpecInitProvider#packageCleanup
   */
  readonly packageCleanup?: boolean;

  /**
   * When set to true, Device Farm reboots the instance after a test run. The default value is true.
   *
   * @schema InstanceProfileSpecInitProvider#rebootAfterUse
   */
  readonly rebootAfterUse?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema InstanceProfileSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'InstanceProfileSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProfileSpecInitProvider(obj: InstanceProfileSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'excludeAppPackagesFromCleanup': obj.excludeAppPackagesFromCleanup?.map(y => y),
    'name': obj.name,
    'packageCleanup': obj.packageCleanup,
    'rebootAfterUse': obj.rebootAfterUse,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema InstanceProfileSpecManagementPolicies
 */
export enum InstanceProfileSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceProfileSpecProviderConfigRef
 */
export interface InstanceProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceProfileSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProfileSpecProviderConfigRef(obj: InstanceProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceProfileSpecPublishConnectionDetailsTo
 */
export interface InstanceProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProfileSpecPublishConnectionDetailsTo(obj: InstanceProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceProfileSpecWriteConnectionSecretToRef
 */
export interface InstanceProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProfileSpecWriteConnectionSecretToRef(obj: InstanceProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceProfileSpecProviderConfigRefPolicy
 */
export interface InstanceProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProfileSpecProviderConfigRefPolicy(obj: InstanceProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProfileSpecPublishConnectionDetailsToConfigRef(obj: InstanceProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceProfileSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProfileSpecPublishConnectionDetailsToMetadata(obj: InstanceProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceProfileSpecProviderConfigRefPolicyResolution
 */
export enum InstanceProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceProfileSpecProviderConfigRefPolicyResolve
 */
export enum InstanceProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * NetworkProfile is the Schema for the NetworkProfiles API. Provides a Devicefarm network profile
 *
 * @schema NetworkProfile
 */
export class NetworkProfile extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NetworkProfile"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'devicefarm.aws.upbound.io/v1beta1',
    kind: 'NetworkProfile',
  }

  /**
   * Renders a Kubernetes manifest for "NetworkProfile".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NetworkProfileProps): any {
    return {
      ...NetworkProfile.GVK,
      ...toJson_NetworkProfileProps(props),
    };
  }

  /**
   * Defines a "NetworkProfile" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NetworkProfileProps) {
    super(scope, id, {
      ...NetworkProfile.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NetworkProfile.GVK,
      ...toJson_NetworkProfileProps(resolved),
    };
  }
}

/**
 * NetworkProfile is the Schema for the NetworkProfiles API. Provides a Devicefarm network profile
 *
 * @schema NetworkProfile
 */
export interface NetworkProfileProps {
  /**
   * @schema NetworkProfile#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NetworkProfileSpec defines the desired state of NetworkProfile
   *
   * @schema NetworkProfile#spec
   */
  readonly spec: NetworkProfileSpec;

}

/**
 * Converts an object of type 'NetworkProfileProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileProps(obj: NetworkProfileProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NetworkProfileSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NetworkProfileSpec defines the desired state of NetworkProfile
 *
 * @schema NetworkProfileSpec
 */
export interface NetworkProfileSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NetworkProfileSpec#deletionPolicy
   */
  readonly deletionPolicy?: NetworkProfileSpecDeletionPolicy;

  /**
   * @schema NetworkProfileSpec#forProvider
   */
  readonly forProvider: NetworkProfileSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema NetworkProfileSpec#initProvider
   */
  readonly initProvider?: NetworkProfileSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema NetworkProfileSpec#managementPolicies
   */
  readonly managementPolicies?: NetworkProfileSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NetworkProfileSpec#providerConfigRef
   */
  readonly providerConfigRef?: NetworkProfileSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NetworkProfileSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NetworkProfileSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NetworkProfileSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NetworkProfileSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NetworkProfileSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpec(obj: NetworkProfileSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NetworkProfileSpecForProvider(obj.forProvider),
    'initProvider': toJson_NetworkProfileSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_NetworkProfileSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_NetworkProfileSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NetworkProfileSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NetworkProfileSpecDeletionPolicy
 */
export enum NetworkProfileSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NetworkProfileSpecForProvider
 */
export interface NetworkProfileSpecForProvider {
  /**
   * The description of the network profile.
   *
   * @schema NetworkProfileSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The data throughput rate in bits per second, as an integer from 0 to 104857600. Default value is 104857600.
   *
   * @schema NetworkProfileSpecForProvider#downlinkBandwidthBits
   */
  readonly downlinkBandwidthBits?: number;

  /**
   * Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
   *
   * @schema NetworkProfileSpecForProvider#downlinkDelayMs
   */
  readonly downlinkDelayMs?: number;

  /**
   * Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
   *
   * @schema NetworkProfileSpecForProvider#downlinkJitterMs
   */
  readonly downlinkJitterMs?: number;

  /**
   * Proportion of received packets that fail to arrive from 0 to 100 percent.
   *
   * @schema NetworkProfileSpecForProvider#downlinkLossPercent
   */
  readonly downlinkLossPercent?: number;

  /**
   * The name for the network profile.
   *
   * @schema NetworkProfileSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The ARN of the project for the network profile.
   *
   * @schema NetworkProfileSpecForProvider#projectArn
   */
  readonly projectArn?: string;

  /**
   * Reference to a Project in devicefarm to populate projectArn.
   *
   * @schema NetworkProfileSpecForProvider#projectArnRef
   */
  readonly projectArnRef?: NetworkProfileSpecForProviderProjectArnRef;

  /**
   * Selector for a Project in devicefarm to populate projectArn.
   *
   * @schema NetworkProfileSpecForProvider#projectArnSelector
   */
  readonly projectArnSelector?: NetworkProfileSpecForProviderProjectArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema NetworkProfileSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema NetworkProfileSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The type of network profile to create. Valid values are listed are PRIVATE and CURATED.
   *
   * @schema NetworkProfileSpecForProvider#type
   */
  readonly type?: string;

  /**
   * The data throughput rate in bits per second, as an integer from 0 to 104857600. Default value is 104857600.
   *
   * @schema NetworkProfileSpecForProvider#uplinkBandwidthBits
   */
  readonly uplinkBandwidthBits?: number;

  /**
   * Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
   *
   * @schema NetworkProfileSpecForProvider#uplinkDelayMs
   */
  readonly uplinkDelayMs?: number;

  /**
   * Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
   *
   * @schema NetworkProfileSpecForProvider#uplinkJitterMs
   */
  readonly uplinkJitterMs?: number;

  /**
   * Proportion of received packets that fail to arrive from 0 to 100 percent.
   *
   * @schema NetworkProfileSpecForProvider#uplinkLossPercent
   */
  readonly uplinkLossPercent?: number;

}

/**
 * Converts an object of type 'NetworkProfileSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecForProvider(obj: NetworkProfileSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'downlinkBandwidthBits': obj.downlinkBandwidthBits,
    'downlinkDelayMs': obj.downlinkDelayMs,
    'downlinkJitterMs': obj.downlinkJitterMs,
    'downlinkLossPercent': obj.downlinkLossPercent,
    'name': obj.name,
    'projectArn': obj.projectArn,
    'projectArnRef': toJson_NetworkProfileSpecForProviderProjectArnRef(obj.projectArnRef),
    'projectArnSelector': toJson_NetworkProfileSpecForProviderProjectArnSelector(obj.projectArnSelector),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
    'uplinkBandwidthBits': obj.uplinkBandwidthBits,
    'uplinkDelayMs': obj.uplinkDelayMs,
    'uplinkJitterMs': obj.uplinkJitterMs,
    'uplinkLossPercent': obj.uplinkLossPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema NetworkProfileSpecInitProvider
 */
export interface NetworkProfileSpecInitProvider {
  /**
   * The description of the network profile.
   *
   * @schema NetworkProfileSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The data throughput rate in bits per second, as an integer from 0 to 104857600. Default value is 104857600.
   *
   * @schema NetworkProfileSpecInitProvider#downlinkBandwidthBits
   */
  readonly downlinkBandwidthBits?: number;

  /**
   * Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
   *
   * @schema NetworkProfileSpecInitProvider#downlinkDelayMs
   */
  readonly downlinkDelayMs?: number;

  /**
   * Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
   *
   * @schema NetworkProfileSpecInitProvider#downlinkJitterMs
   */
  readonly downlinkJitterMs?: number;

  /**
   * Proportion of received packets that fail to arrive from 0 to 100 percent.
   *
   * @schema NetworkProfileSpecInitProvider#downlinkLossPercent
   */
  readonly downlinkLossPercent?: number;

  /**
   * The name for the network profile.
   *
   * @schema NetworkProfileSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema NetworkProfileSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The type of network profile to create. Valid values are listed are PRIVATE and CURATED.
   *
   * @schema NetworkProfileSpecInitProvider#type
   */
  readonly type?: string;

  /**
   * The data throughput rate in bits per second, as an integer from 0 to 104857600. Default value is 104857600.
   *
   * @schema NetworkProfileSpecInitProvider#uplinkBandwidthBits
   */
  readonly uplinkBandwidthBits?: number;

  /**
   * Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
   *
   * @schema NetworkProfileSpecInitProvider#uplinkDelayMs
   */
  readonly uplinkDelayMs?: number;

  /**
   * Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
   *
   * @schema NetworkProfileSpecInitProvider#uplinkJitterMs
   */
  readonly uplinkJitterMs?: number;

  /**
   * Proportion of received packets that fail to arrive from 0 to 100 percent.
   *
   * @schema NetworkProfileSpecInitProvider#uplinkLossPercent
   */
  readonly uplinkLossPercent?: number;

}

/**
 * Converts an object of type 'NetworkProfileSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecInitProvider(obj: NetworkProfileSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'downlinkBandwidthBits': obj.downlinkBandwidthBits,
    'downlinkDelayMs': obj.downlinkDelayMs,
    'downlinkJitterMs': obj.downlinkJitterMs,
    'downlinkLossPercent': obj.downlinkLossPercent,
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
    'uplinkBandwidthBits': obj.uplinkBandwidthBits,
    'uplinkDelayMs': obj.uplinkDelayMs,
    'uplinkJitterMs': obj.uplinkJitterMs,
    'uplinkLossPercent': obj.uplinkLossPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema NetworkProfileSpecManagementPolicies
 */
export enum NetworkProfileSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NetworkProfileSpecProviderConfigRef
 */
export interface NetworkProfileSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NetworkProfileSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NetworkProfileSpecProviderConfigRef#policy
   */
  readonly policy?: NetworkProfileSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NetworkProfileSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecProviderConfigRef(obj: NetworkProfileSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NetworkProfileSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NetworkProfileSpecPublishConnectionDetailsTo
 */
export interface NetworkProfileSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NetworkProfileSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NetworkProfileSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NetworkProfileSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NetworkProfileSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NetworkProfileSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NetworkProfileSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecPublishConnectionDetailsTo(obj: NetworkProfileSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NetworkProfileSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NetworkProfileSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NetworkProfileSpecWriteConnectionSecretToRef
 */
export interface NetworkProfileSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NetworkProfileSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NetworkProfileSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NetworkProfileSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecWriteConnectionSecretToRef(obj: NetworkProfileSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project in devicefarm to populate projectArn.
 *
 * @schema NetworkProfileSpecForProviderProjectArnRef
 */
export interface NetworkProfileSpecForProviderProjectArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema NetworkProfileSpecForProviderProjectArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NetworkProfileSpecForProviderProjectArnRef#policy
   */
  readonly policy?: NetworkProfileSpecForProviderProjectArnRefPolicy;

}

/**
 * Converts an object of type 'NetworkProfileSpecForProviderProjectArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecForProviderProjectArnRef(obj: NetworkProfileSpecForProviderProjectArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NetworkProfileSpecForProviderProjectArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project in devicefarm to populate projectArn.
 *
 * @schema NetworkProfileSpecForProviderProjectArnSelector
 */
export interface NetworkProfileSpecForProviderProjectArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NetworkProfileSpecForProviderProjectArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NetworkProfileSpecForProviderProjectArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NetworkProfileSpecForProviderProjectArnSelector#policy
   */
  readonly policy?: NetworkProfileSpecForProviderProjectArnSelectorPolicy;

}

/**
 * Converts an object of type 'NetworkProfileSpecForProviderProjectArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecForProviderProjectArnSelector(obj: NetworkProfileSpecForProviderProjectArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NetworkProfileSpecForProviderProjectArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NetworkProfileSpecProviderConfigRefPolicy
 */
export interface NetworkProfileSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NetworkProfileSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NetworkProfileSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NetworkProfileSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NetworkProfileSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NetworkProfileSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecProviderConfigRefPolicy(obj: NetworkProfileSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NetworkProfileSpecPublishConnectionDetailsToConfigRef
 */
export interface NetworkProfileSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NetworkProfileSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NetworkProfileSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NetworkProfileSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecPublishConnectionDetailsToConfigRef(obj: NetworkProfileSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NetworkProfileSpecPublishConnectionDetailsToMetadata
 */
export interface NetworkProfileSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NetworkProfileSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NetworkProfileSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NetworkProfileSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NetworkProfileSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecPublishConnectionDetailsToMetadata(obj: NetworkProfileSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NetworkProfileSpecForProviderProjectArnRefPolicy
 */
export interface NetworkProfileSpecForProviderProjectArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NetworkProfileSpecForProviderProjectArnRefPolicy#resolution
   */
  readonly resolution?: NetworkProfileSpecForProviderProjectArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NetworkProfileSpecForProviderProjectArnRefPolicy#resolve
   */
  readonly resolve?: NetworkProfileSpecForProviderProjectArnRefPolicyResolve;

}

/**
 * Converts an object of type 'NetworkProfileSpecForProviderProjectArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecForProviderProjectArnRefPolicy(obj: NetworkProfileSpecForProviderProjectArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NetworkProfileSpecForProviderProjectArnSelectorPolicy
 */
export interface NetworkProfileSpecForProviderProjectArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NetworkProfileSpecForProviderProjectArnSelectorPolicy#resolution
   */
  readonly resolution?: NetworkProfileSpecForProviderProjectArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NetworkProfileSpecForProviderProjectArnSelectorPolicy#resolve
   */
  readonly resolve?: NetworkProfileSpecForProviderProjectArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NetworkProfileSpecForProviderProjectArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecForProviderProjectArnSelectorPolicy(obj: NetworkProfileSpecForProviderProjectArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NetworkProfileSpecProviderConfigRefPolicyResolution
 */
export enum NetworkProfileSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NetworkProfileSpecProviderConfigRefPolicyResolve
 */
export enum NetworkProfileSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicy(obj: NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NetworkProfileSpecForProviderProjectArnRefPolicyResolution
 */
export enum NetworkProfileSpecForProviderProjectArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NetworkProfileSpecForProviderProjectArnRefPolicyResolve
 */
export enum NetworkProfileSpecForProviderProjectArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NetworkProfileSpecForProviderProjectArnSelectorPolicyResolution
 */
export enum NetworkProfileSpecForProviderProjectArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NetworkProfileSpecForProviderProjectArnSelectorPolicyResolve
 */
export enum NetworkProfileSpecForProviderProjectArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NetworkProfileSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Project is the Schema for the Projects API. Provides a Devicefarm project
 *
 * @schema Project
 */
export class Project extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Project"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'devicefarm.aws.upbound.io/v1beta1',
    kind: 'Project',
  }

  /**
   * Renders a Kubernetes manifest for "Project".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectProps): any {
    return {
      ...Project.GVK,
      ...toJson_ProjectProps(props),
    };
  }

  /**
   * Defines a "Project" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectProps) {
    super(scope, id, {
      ...Project.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Project.GVK,
      ...toJson_ProjectProps(resolved),
    };
  }
}

/**
 * Project is the Schema for the Projects API. Provides a Devicefarm project
 *
 * @schema Project
 */
export interface ProjectProps {
  /**
   * @schema Project#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectSpec defines the desired state of Project
   *
   * @schema Project#spec
   */
  readonly spec: ProjectSpec;

}

/**
 * Converts an object of type 'ProjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectProps(obj: ProjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectSpec defines the desired state of Project
 *
 * @schema ProjectSpec
 */
export interface ProjectSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProjectSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectSpecDeletionPolicy;

  /**
   * @schema ProjectSpec#forProvider
   */
  readonly forProvider: ProjectSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ProjectSpec#initProvider
   */
  readonly initProvider?: ProjectSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ProjectSpec#managementPolicies
   */
  readonly managementPolicies?: ProjectSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpec(obj: ProjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectSpecForProvider(obj.forProvider),
    'initProvider': toJson_ProjectSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ProjectSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ProjectSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProjectSpecDeletionPolicy
 */
export enum ProjectSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectSpecForProvider
 */
export interface ProjectSpecForProvider {
  /**
   * Sets the execution timeout value (in minutes) for a project. All test runs in this project use the specified execution timeout value unless overridden when scheduling a run.
   *
   * @schema ProjectSpecForProvider#defaultJobTimeoutMinutes
   */
  readonly defaultJobTimeoutMinutes?: number;

  /**
   * The name of the project
   *
   * @schema ProjectSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProjectSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ProjectSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ProjectSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecForProvider(obj: ProjectSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultJobTimeoutMinutes': obj.defaultJobTimeoutMinutes,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ProjectSpecInitProvider
 */
export interface ProjectSpecInitProvider {
  /**
   * Sets the execution timeout value (in minutes) for a project. All test runs in this project use the specified execution timeout value unless overridden when scheduling a run.
   *
   * @schema ProjectSpecInitProvider#defaultJobTimeoutMinutes
   */
  readonly defaultJobTimeoutMinutes?: number;

  /**
   * The name of the project
   *
   * @schema ProjectSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ProjectSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ProjectSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecInitProvider(obj: ProjectSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultJobTimeoutMinutes': obj.defaultJobTimeoutMinutes,
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ProjectSpecManagementPolicies
 */
export enum ProjectSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectSpecProviderConfigRef
 */
export interface ProjectSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderConfigRef(obj: ProjectSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectSpecPublishConnectionDetailsTo
 */
export interface ProjectSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsTo(obj: ProjectSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectSpecWriteConnectionSecretToRef
 */
export interface ProjectSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecWriteConnectionSecretToRef(obj: ProjectSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecProviderConfigRefPolicy
 */
export interface ProjectSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecProviderConfigRefPolicy(obj: ProjectSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToConfigRef(obj: ProjectSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToMetadata(obj: ProjectSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecProviderConfigRefPolicyResolution
 */
export enum ProjectSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecProviderConfigRefPolicyResolve
 */
export enum ProjectSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TestGridProject is the Schema for the TestGridProjects API. Provides a Devicefarm test_grid_project
 *
 * @schema TestGridProject
 */
export class TestGridProject extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TestGridProject"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'devicefarm.aws.upbound.io/v1beta1',
    kind: 'TestGridProject',
  }

  /**
   * Renders a Kubernetes manifest for "TestGridProject".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TestGridProjectProps): any {
    return {
      ...TestGridProject.GVK,
      ...toJson_TestGridProjectProps(props),
    };
  }

  /**
   * Defines a "TestGridProject" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TestGridProjectProps) {
    super(scope, id, {
      ...TestGridProject.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TestGridProject.GVK,
      ...toJson_TestGridProjectProps(resolved),
    };
  }
}

/**
 * TestGridProject is the Schema for the TestGridProjects API. Provides a Devicefarm test_grid_project
 *
 * @schema TestGridProject
 */
export interface TestGridProjectProps {
  /**
   * @schema TestGridProject#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TestGridProjectSpec defines the desired state of TestGridProject
   *
   * @schema TestGridProject#spec
   */
  readonly spec: TestGridProjectSpec;

}

/**
 * Converts an object of type 'TestGridProjectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectProps(obj: TestGridProjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TestGridProjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TestGridProjectSpec defines the desired state of TestGridProject
 *
 * @schema TestGridProjectSpec
 */
export interface TestGridProjectSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TestGridProjectSpec#deletionPolicy
   */
  readonly deletionPolicy?: TestGridProjectSpecDeletionPolicy;

  /**
   * @schema TestGridProjectSpec#forProvider
   */
  readonly forProvider: TestGridProjectSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TestGridProjectSpec#initProvider
   */
  readonly initProvider?: TestGridProjectSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TestGridProjectSpec#managementPolicies
   */
  readonly managementPolicies?: TestGridProjectSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TestGridProjectSpec#providerConfigRef
   */
  readonly providerConfigRef?: TestGridProjectSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TestGridProjectSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TestGridProjectSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TestGridProjectSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TestGridProjectSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TestGridProjectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpec(obj: TestGridProjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TestGridProjectSpecForProvider(obj.forProvider),
    'initProvider': toJson_TestGridProjectSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TestGridProjectSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TestGridProjectSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TestGridProjectSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TestGridProjectSpecDeletionPolicy
 */
export enum TestGridProjectSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TestGridProjectSpecForProvider
 */
export interface TestGridProjectSpecForProvider {
  /**
   * Human-readable description of the project.
   *
   * @schema TestGridProjectSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the Selenium testing project.
   *
   * @schema TestGridProjectSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TestGridProjectSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TestGridProjectSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The VPC security groups and subnets that are attached to a project. See VPC Config below.
   *
   * @schema TestGridProjectSpecForProvider#vpcConfig
   */
  readonly vpcConfig?: TestGridProjectSpecForProviderVpcConfig[];

}

/**
 * Converts an object of type 'TestGridProjectSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProvider(obj: TestGridProjectSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcConfig': obj.vpcConfig?.map(y => toJson_TestGridProjectSpecForProviderVpcConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TestGridProjectSpecInitProvider
 */
export interface TestGridProjectSpecInitProvider {
  /**
   * Human-readable description of the project.
   *
   * @schema TestGridProjectSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The name of the Selenium testing project.
   *
   * @schema TestGridProjectSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TestGridProjectSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The VPC security groups and subnets that are attached to a project. See VPC Config below.
   *
   * @schema TestGridProjectSpecInitProvider#vpcConfig
   */
  readonly vpcConfig?: any[];

}

/**
 * Converts an object of type 'TestGridProjectSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecInitProvider(obj: TestGridProjectSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcConfig': obj.vpcConfig?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TestGridProjectSpecManagementPolicies
 */
export enum TestGridProjectSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TestGridProjectSpecProviderConfigRef
 */
export interface TestGridProjectSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TestGridProjectSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TestGridProjectSpecProviderConfigRef#policy
   */
  readonly policy?: TestGridProjectSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TestGridProjectSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecProviderConfigRef(obj: TestGridProjectSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TestGridProjectSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TestGridProjectSpecPublishConnectionDetailsTo
 */
export interface TestGridProjectSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TestGridProjectSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TestGridProjectSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TestGridProjectSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TestGridProjectSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TestGridProjectSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TestGridProjectSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecPublishConnectionDetailsTo(obj: TestGridProjectSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TestGridProjectSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TestGridProjectSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TestGridProjectSpecWriteConnectionSecretToRef
 */
export interface TestGridProjectSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TestGridProjectSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TestGridProjectSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TestGridProjectSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecWriteConnectionSecretToRef(obj: TestGridProjectSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TestGridProjectSpecForProviderVpcConfig
 */
export interface TestGridProjectSpecForProviderVpcConfig {
  /**
   * References to SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema TestGridProjectSpecForProviderVpcConfig#securityGroupIdRefs
   */
  readonly securityGroupIdRefs?: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
   *
   * @schema TestGridProjectSpecForProviderVpcConfig#securityGroupIdSelector
   */
  readonly securityGroupIdSelector?: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelector;

  /**
   * A list of VPC security group IDs in your Amazon VPC.
   *
   * @schema TestGridProjectSpecForProviderVpcConfig#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema TestGridProjectSpecForProviderVpcConfig#subnetIdRefs
   */
  readonly subnetIdRefs?: TestGridProjectSpecForProviderVpcConfigSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema TestGridProjectSpecForProviderVpcConfig#subnetIdSelector
   */
  readonly subnetIdSelector?: TestGridProjectSpecForProviderVpcConfigSubnetIdSelector;

  /**
   * A list of VPC subnet IDs in your Amazon VPC.
   *
   * @schema TestGridProjectSpecForProviderVpcConfig#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * The ID of the Amazon VPC.
   *
   * @schema TestGridProjectSpecForProviderVpcConfig#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema TestGridProjectSpecForProviderVpcConfig#vpcIdRef
   */
  readonly vpcIdRef?: TestGridProjectSpecForProviderVpcConfigVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema TestGridProjectSpecForProviderVpcConfig#vpcIdSelector
   */
  readonly vpcIdSelector?: TestGridProjectSpecForProviderVpcConfigVpcIdSelector;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfig(obj: TestGridProjectSpecForProviderVpcConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'securityGroupIdRefs': obj.securityGroupIdRefs?.map(y => toJson_TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefs(y)),
    'securityGroupIdSelector': toJson_TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelector(obj.securityGroupIdSelector),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_TestGridProjectSpecForProviderVpcConfigSubnetIdRefs(y)),
    'subnetIdSelector': toJson_TestGridProjectSpecForProviderVpcConfigSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_TestGridProjectSpecForProviderVpcConfigVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_TestGridProjectSpecForProviderVpcConfigVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TestGridProjectSpecProviderConfigRefPolicy
 */
export interface TestGridProjectSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TestGridProjectSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TestGridProjectSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TestGridProjectSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TestGridProjectSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TestGridProjectSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecProviderConfigRefPolicy(obj: TestGridProjectSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TestGridProjectSpecPublishConnectionDetailsToConfigRef
 */
export interface TestGridProjectSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TestGridProjectSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TestGridProjectSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TestGridProjectSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecPublishConnectionDetailsToConfigRef(obj: TestGridProjectSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TestGridProjectSpecPublishConnectionDetailsToMetadata
 */
export interface TestGridProjectSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TestGridProjectSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TestGridProjectSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TestGridProjectSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TestGridProjectSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecPublishConnectionDetailsToMetadata(obj: TestGridProjectSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefs
 */
export interface TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefs#policy
   */
  readonly policy?: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefs(obj: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroupIds.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelector
 */
export interface TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelector#policy
   */
  readonly policy?: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelector(obj: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdRefs
 */
export interface TestGridProjectSpecForProviderVpcConfigSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdRefs#policy
   */
  readonly policy?: TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigSubnetIdRefs(obj: TestGridProjectSpecForProviderVpcConfigSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdSelector
 */
export interface TestGridProjectSpecForProviderVpcConfigSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdSelector#policy
   */
  readonly policy?: TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigSubnetIdSelector(obj: TestGridProjectSpecForProviderVpcConfigSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigVpcIdRef
 */
export interface TestGridProjectSpecForProviderVpcConfigVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigVpcIdRef#policy
   */
  readonly policy?: TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicy;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigVpcIdRef(obj: TestGridProjectSpecForProviderVpcConfigVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigVpcIdSelector
 */
export interface TestGridProjectSpecForProviderVpcConfigVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigVpcIdSelector#policy
   */
  readonly policy?: TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigVpcIdSelector(obj: TestGridProjectSpecForProviderVpcConfigVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TestGridProjectSpecProviderConfigRefPolicyResolution
 */
export enum TestGridProjectSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TestGridProjectSpecProviderConfigRefPolicyResolve
 */
export enum TestGridProjectSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicy(obj: TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicy
 */
export interface TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicy(obj: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy
 */
export interface TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy(obj: TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicy
 */
export interface TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicy(obj: TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicy
 */
export interface TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicy(obj: TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicy
 */
export interface TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicy#resolution
   */
  readonly resolution?: TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicy#resolve
   */
  readonly resolve?: TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicy(obj: TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicy
 */
export interface TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicy(obj: TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TestGridProjectSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution
 */
export enum TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve
 */
export enum TestGridProjectSpecForProviderVpcConfigSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution
 */
export enum TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve
 */
export enum TestGridProjectSpecForProviderVpcConfigSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicyResolution
 */
export enum TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicyResolve
 */
export enum TestGridProjectSpecForProviderVpcConfigSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution
 */
export enum TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve
 */
export enum TestGridProjectSpecForProviderVpcConfigSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicyResolution
 */
export enum TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicyResolve
 */
export enum TestGridProjectSpecForProviderVpcConfigVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicyResolution
 */
export enum TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicyResolve
 */
export enum TestGridProjectSpecForProviderVpcConfigVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Upload is the Schema for the Uploads API. Provides a Devicefarm upload
 *
 * @schema Upload
 */
export class Upload extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Upload"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'devicefarm.aws.upbound.io/v1beta1',
    kind: 'Upload',
  }

  /**
   * Renders a Kubernetes manifest for "Upload".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UploadProps): any {
    return {
      ...Upload.GVK,
      ...toJson_UploadProps(props),
    };
  }

  /**
   * Defines a "Upload" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UploadProps) {
    super(scope, id, {
      ...Upload.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Upload.GVK,
      ...toJson_UploadProps(resolved),
    };
  }
}

/**
 * Upload is the Schema for the Uploads API. Provides a Devicefarm upload
 *
 * @schema Upload
 */
export interface UploadProps {
  /**
   * @schema Upload#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UploadSpec defines the desired state of Upload
   *
   * @schema Upload#spec
   */
  readonly spec: UploadSpec;

}

/**
 * Converts an object of type 'UploadProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadProps(obj: UploadProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UploadSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UploadSpec defines the desired state of Upload
 *
 * @schema UploadSpec
 */
export interface UploadSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UploadSpec#deletionPolicy
   */
  readonly deletionPolicy?: UploadSpecDeletionPolicy;

  /**
   * @schema UploadSpec#forProvider
   */
  readonly forProvider: UploadSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema UploadSpec#initProvider
   */
  readonly initProvider?: UploadSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UploadSpec#managementPolicies
   */
  readonly managementPolicies?: UploadSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UploadSpec#providerConfigRef
   */
  readonly providerConfigRef?: UploadSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UploadSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UploadSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UploadSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UploadSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UploadSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpec(obj: UploadSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UploadSpecForProvider(obj.forProvider),
    'initProvider': toJson_UploadSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UploadSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UploadSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UploadSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UploadSpecDeletionPolicy
 */
export enum UploadSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UploadSpecForProvider
 */
export interface UploadSpecForProvider {
  /**
   * The upload's content type (for example, application/octet-stream).
   *
   * @schema UploadSpecForProvider#contentType
   */
  readonly contentType?: string;

  /**
   * The upload's file name. The name should not contain any forward slashes (/). If you are uploading an iOS app, the file name must end with the .ipa extension. If you are uploading an Android app, the file name must end with the .apk extension. For all others, the file name must end with the .zip file extension.
   *
   * @schema UploadSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The ARN of the project for the upload.
   *
   * @schema UploadSpecForProvider#projectArn
   */
  readonly projectArn?: string;

  /**
   * Reference to a Project in devicefarm to populate projectArn.
   *
   * @schema UploadSpecForProvider#projectArnRef
   */
  readonly projectArnRef?: UploadSpecForProviderProjectArnRef;

  /**
   * Selector for a Project in devicefarm to populate projectArn.
   *
   * @schema UploadSpecForProvider#projectArnSelector
   */
  readonly projectArnSelector?: UploadSpecForProviderProjectArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UploadSpecForProvider#region
   */
  readonly region: string;

  /**
   * The upload's upload type. See AWS Docs for valid list of values.
   *
   * @schema UploadSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UploadSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecForProvider(obj: UploadSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentType': obj.contentType,
    'name': obj.name,
    'projectArn': obj.projectArn,
    'projectArnRef': toJson_UploadSpecForProviderProjectArnRef(obj.projectArnRef),
    'projectArnSelector': toJson_UploadSpecForProviderProjectArnSelector(obj.projectArnSelector),
    'region': obj.region,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema UploadSpecInitProvider
 */
export interface UploadSpecInitProvider {
  /**
   * The upload's content type (for example, application/octet-stream).
   *
   * @schema UploadSpecInitProvider#contentType
   */
  readonly contentType?: string;

  /**
   * The upload's file name. The name should not contain any forward slashes (/). If you are uploading an iOS app, the file name must end with the .ipa extension. If you are uploading an Android app, the file name must end with the .apk extension. For all others, the file name must end with the .zip file extension.
   *
   * @schema UploadSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The upload's upload type. See AWS Docs for valid list of values.
   *
   * @schema UploadSpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UploadSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecInitProvider(obj: UploadSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentType': obj.contentType,
    'name': obj.name,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UploadSpecManagementPolicies
 */
export enum UploadSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UploadSpecProviderConfigRef
 */
export interface UploadSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UploadSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UploadSpecProviderConfigRef#policy
   */
  readonly policy?: UploadSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UploadSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecProviderConfigRef(obj: UploadSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UploadSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UploadSpecPublishConnectionDetailsTo
 */
export interface UploadSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UploadSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UploadSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UploadSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UploadSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UploadSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UploadSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecPublishConnectionDetailsTo(obj: UploadSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UploadSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UploadSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UploadSpecWriteConnectionSecretToRef
 */
export interface UploadSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UploadSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UploadSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UploadSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecWriteConnectionSecretToRef(obj: UploadSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Project in devicefarm to populate projectArn.
 *
 * @schema UploadSpecForProviderProjectArnRef
 */
export interface UploadSpecForProviderProjectArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema UploadSpecForProviderProjectArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UploadSpecForProviderProjectArnRef#policy
   */
  readonly policy?: UploadSpecForProviderProjectArnRefPolicy;

}

/**
 * Converts an object of type 'UploadSpecForProviderProjectArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecForProviderProjectArnRef(obj: UploadSpecForProviderProjectArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UploadSpecForProviderProjectArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Project in devicefarm to populate projectArn.
 *
 * @schema UploadSpecForProviderProjectArnSelector
 */
export interface UploadSpecForProviderProjectArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UploadSpecForProviderProjectArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UploadSpecForProviderProjectArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UploadSpecForProviderProjectArnSelector#policy
   */
  readonly policy?: UploadSpecForProviderProjectArnSelectorPolicy;

}

/**
 * Converts an object of type 'UploadSpecForProviderProjectArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecForProviderProjectArnSelector(obj: UploadSpecForProviderProjectArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UploadSpecForProviderProjectArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UploadSpecProviderConfigRefPolicy
 */
export interface UploadSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UploadSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UploadSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UploadSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UploadSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UploadSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecProviderConfigRefPolicy(obj: UploadSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UploadSpecPublishConnectionDetailsToConfigRef
 */
export interface UploadSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UploadSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UploadSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UploadSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UploadSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecPublishConnectionDetailsToConfigRef(obj: UploadSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UploadSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UploadSpecPublishConnectionDetailsToMetadata
 */
export interface UploadSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UploadSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UploadSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UploadSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UploadSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecPublishConnectionDetailsToMetadata(obj: UploadSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UploadSpecForProviderProjectArnRefPolicy
 */
export interface UploadSpecForProviderProjectArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UploadSpecForProviderProjectArnRefPolicy#resolution
   */
  readonly resolution?: UploadSpecForProviderProjectArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UploadSpecForProviderProjectArnRefPolicy#resolve
   */
  readonly resolve?: UploadSpecForProviderProjectArnRefPolicyResolve;

}

/**
 * Converts an object of type 'UploadSpecForProviderProjectArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecForProviderProjectArnRefPolicy(obj: UploadSpecForProviderProjectArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UploadSpecForProviderProjectArnSelectorPolicy
 */
export interface UploadSpecForProviderProjectArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UploadSpecForProviderProjectArnSelectorPolicy#resolution
   */
  readonly resolution?: UploadSpecForProviderProjectArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UploadSpecForProviderProjectArnSelectorPolicy#resolve
   */
  readonly resolve?: UploadSpecForProviderProjectArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UploadSpecForProviderProjectArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecForProviderProjectArnSelectorPolicy(obj: UploadSpecForProviderProjectArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UploadSpecProviderConfigRefPolicyResolution
 */
export enum UploadSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UploadSpecProviderConfigRefPolicyResolve
 */
export enum UploadSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UploadSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UploadSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UploadSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UploadSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UploadSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UploadSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UploadSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UploadSpecPublishConnectionDetailsToConfigRefPolicy(obj: UploadSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UploadSpecForProviderProjectArnRefPolicyResolution
 */
export enum UploadSpecForProviderProjectArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UploadSpecForProviderProjectArnRefPolicyResolve
 */
export enum UploadSpecForProviderProjectArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UploadSpecForProviderProjectArnSelectorPolicyResolution
 */
export enum UploadSpecForProviderProjectArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UploadSpecForProviderProjectArnSelectorPolicyResolve
 */
export enum UploadSpecForProviderProjectArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UploadSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UploadSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UploadSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UploadSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

