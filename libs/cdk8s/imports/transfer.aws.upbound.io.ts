// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Server is the Schema for the Servers API. Provides a AWS Transfer Server resource.
 *
 * @schema Server
 */
export class Server extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Server"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'transfer.aws.upbound.io/v1beta1',
    kind: 'Server',
  }

  /**
   * Renders a Kubernetes manifest for "Server".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServerProps): any {
    return {
      ...Server.GVK,
      ...toJson_ServerProps(props),
    };
  }

  /**
   * Defines a "Server" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServerProps) {
    super(scope, id, {
      ...Server.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Server.GVK,
      ...toJson_ServerProps(resolved),
    };
  }
}

/**
 * Server is the Schema for the Servers API. Provides a AWS Transfer Server resource.
 *
 * @schema Server
 */
export interface ServerProps {
  /**
   * @schema Server#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServerSpec defines the desired state of Server
   *
   * @schema Server#spec
   */
  readonly spec: ServerSpec;

}

/**
 * Converts an object of type 'ServerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerProps(obj: ServerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServerSpec defines the desired state of Server
 *
 * @schema ServerSpec
 */
export interface ServerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServerSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServerSpecDeletionPolicy;

  /**
   * @schema ServerSpec#forProvider
   */
  readonly forProvider: ServerSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ServerSpec#initProvider
   */
  readonly initProvider?: ServerSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServerSpec#managementPolicies
   */
  readonly managementPolicies?: ServerSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServerSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServerSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpec(obj: ServerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServerSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServerSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServerSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServerSpecDeletionPolicy
 */
export enum ServerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServerSpecForProvider
 */
export interface ServerSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the AWS Certificate Manager (ACM) certificate. This is required when protocols is set to FTPS
   *
   * @schema ServerSpecForProvider#certificate
   */
  readonly certificate?: string;

  /**
   * Reference to a Certificate in acm to populate certificate.
   *
   * @schema ServerSpecForProvider#certificateRef
   */
  readonly certificateRef?: ServerSpecForProviderCertificateRef;

  /**
   * Selector for a Certificate in acm to populate certificate.
   *
   * @schema ServerSpecForProvider#certificateSelector
   */
  readonly certificateSelector?: ServerSpecForProviderCertificateSelector;

  /**
   * The directory service ID of the directory service you want to connect to with an identity_provider_type of AWS_DIRECTORY_SERVICE.
   *
   * @schema ServerSpecForProvider#directoryId
   */
  readonly directoryId?: string;

  /**
   * Reference to a Directory in ds to populate directoryId.
   *
   * @schema ServerSpecForProvider#directoryIdRef
   */
  readonly directoryIdRef?: ServerSpecForProviderDirectoryIdRef;

  /**
   * Selector for a Directory in ds to populate directoryId.
   *
   * @schema ServerSpecForProvider#directoryIdSelector
   */
  readonly directoryIdSelector?: ServerSpecForProviderDirectoryIdSelector;

  /**
   * The domain of the storage system that is used for file transfers. Valid values are: S3 and EFS. The default value is S3.
   *
   * @schema ServerSpecForProvider#domain
   */
  readonly domain?: string;

  /**
   * The virtual private cloud (VPC) endpoint settings that you want to configure for your SFTP server. Fields documented below.
   *
   * @schema ServerSpecForProvider#endpointDetails
   */
  readonly endpointDetails?: ServerSpecForProviderEndpointDetails[];

  /**
   * The type of endpoint that you want your SFTP server connect to. If you connect to a VPC (or VPC_ENDPOINT), your SFTP server isn't accessible over the public internet. If you want to connect your SFTP server via public internet, set PUBLIC.  Defaults to PUBLIC.
   *
   * @default PUBLIC.
   * @schema ServerSpecForProvider#endpointType
   */
  readonly endpointType?: string;

  /**
   * A boolean that indicates all users associated with the server should be deleted so that the Server can be destroyed without error. The default value is false. This option only applies to servers configured with a SERVICE_MANAGED identity_provider_type.
   *
   * @schema ServerSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The ARN for a lambda function to use for the Identity provider.
   *
   * @schema ServerSpecForProvider#function
   */
  readonly function?: string;

  /**
   * RSA, ECDSA, or ED25519 private key (e.g., as generated by the ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key, ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key or ssh-keygen -t ed25519 -N "" -f my-new-server-key commands).
   *
   * @schema ServerSpecForProvider#hostKeySecretRef
   */
  readonly hostKeySecretRef?: ServerSpecForProviderHostKeySecretRef;

  /**
   * The mode of authentication enabled for this service. The default value is SERVICE_MANAGED, which allows you to store and access SFTP user credentials within the service. API_GATEWAY indicates that user authentication requires a call to an API Gateway endpoint URL provided by you to integrate an identity provider of your choice. Using AWS_DIRECTORY_SERVICE will allow for authentication against AWS Managed Active Directory or Microsoft Active Directory in your on-premises environment, or in AWS using AD Connectors. Use the AWS_LAMBDA value to directly use a Lambda function as your identity provider. If you choose this value, you must specify the ARN for the lambda function in the function argument.
   *
   * @schema ServerSpecForProvider#identityProviderType
   */
  readonly identityProviderType?: string;

  /**
   * Amazon Resource Name (ARN) of the IAM role used to authenticate the user account with an identity_provider_type of API_GATEWAY.
   *
   * @schema ServerSpecForProvider#invocationRole
   */
  readonly invocationRole?: string;

  /**
   * Amazon Resource Name (ARN) of an IAM role that allows the service to write your SFTP users’ activity to your Amazon CloudWatch logs for monitoring and auditing purposes.
   *
   * @schema ServerSpecForProvider#loggingRole
   */
  readonly loggingRole?: string;

  /**
   * Specify a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
   *
   * @schema ServerSpecForProvider#postAuthenticationLoginBannerSecretRef
   */
  readonly postAuthenticationLoginBannerSecretRef?: ServerSpecForProviderPostAuthenticationLoginBannerSecretRef;

  /**
   * Specify a string to display when users connect to a server. This string is displayed before the user authenticates.
   *
   * @schema ServerSpecForProvider#preAuthenticationLoginBannerSecretRef
   */
  readonly preAuthenticationLoginBannerSecretRef?: ServerSpecForProviderPreAuthenticationLoginBannerSecretRef;

  /**
   * The protocol settings that are configured for your server.
   *
   * @schema ServerSpecForProvider#protocolDetails
   */
  readonly protocolDetails?: ServerSpecForProviderProtocolDetails[];

  /**
   * Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. This defaults to SFTP . The available protocols are:
   *
   * @schema ServerSpecForProvider#protocols
   */
  readonly protocols?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ServerSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the name of the security policy that is attached to the server. Possible values are TransferSecurityPolicy-2018-11, TransferSecurityPolicy-2020-06, TransferSecurityPolicy-FIPS-2020-06 and TransferSecurityPolicy-2022-03. Default value is: TransferSecurityPolicy-2018-11.
   *
   * @schema ServerSpecForProvider#securityPolicyName
   */
  readonly securityPolicyName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ServerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * - URL of the service endpoint used to authenticate users with an identity_provider_type of API_GATEWAY.
   *
   * @schema ServerSpecForProvider#url
   */
  readonly url?: string;

  /**
   * Specifies the workflow details. See Workflow Details below.
   *
   * @schema ServerSpecForProvider#workflowDetails
   */
  readonly workflowDetails?: ServerSpecForProviderWorkflowDetails[];

}

/**
 * Converts an object of type 'ServerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProvider(obj: ServerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'certificateRef': toJson_ServerSpecForProviderCertificateRef(obj.certificateRef),
    'certificateSelector': toJson_ServerSpecForProviderCertificateSelector(obj.certificateSelector),
    'directoryId': obj.directoryId,
    'directoryIdRef': toJson_ServerSpecForProviderDirectoryIdRef(obj.directoryIdRef),
    'directoryIdSelector': toJson_ServerSpecForProviderDirectoryIdSelector(obj.directoryIdSelector),
    'domain': obj.domain,
    'endpointDetails': obj.endpointDetails?.map(y => toJson_ServerSpecForProviderEndpointDetails(y)),
    'endpointType': obj.endpointType,
    'forceDestroy': obj.forceDestroy,
    'function': obj.function,
    'hostKeySecretRef': toJson_ServerSpecForProviderHostKeySecretRef(obj.hostKeySecretRef),
    'identityProviderType': obj.identityProviderType,
    'invocationRole': obj.invocationRole,
    'loggingRole': obj.loggingRole,
    'postAuthenticationLoginBannerSecretRef': toJson_ServerSpecForProviderPostAuthenticationLoginBannerSecretRef(obj.postAuthenticationLoginBannerSecretRef),
    'preAuthenticationLoginBannerSecretRef': toJson_ServerSpecForProviderPreAuthenticationLoginBannerSecretRef(obj.preAuthenticationLoginBannerSecretRef),
    'protocolDetails': obj.protocolDetails?.map(y => toJson_ServerSpecForProviderProtocolDetails(y)),
    'protocols': obj.protocols?.map(y => y),
    'region': obj.region,
    'securityPolicyName': obj.securityPolicyName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'url': obj.url,
    'workflowDetails': obj.workflowDetails?.map(y => toJson_ServerSpecForProviderWorkflowDetails(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ServerSpecInitProvider
 */
export interface ServerSpecInitProvider {
  /**
   * The domain of the storage system that is used for file transfers. Valid values are: S3 and EFS. The default value is S3.
   *
   * @schema ServerSpecInitProvider#domain
   */
  readonly domain?: string;

  /**
   * The virtual private cloud (VPC) endpoint settings that you want to configure for your SFTP server. Fields documented below.
   *
   * @schema ServerSpecInitProvider#endpointDetails
   */
  readonly endpointDetails?: ServerSpecInitProviderEndpointDetails[];

  /**
   * The type of endpoint that you want your SFTP server connect to. If you connect to a VPC (or VPC_ENDPOINT), your SFTP server isn't accessible over the public internet. If you want to connect your SFTP server via public internet, set PUBLIC.  Defaults to PUBLIC.
   *
   * @default PUBLIC.
   * @schema ServerSpecInitProvider#endpointType
   */
  readonly endpointType?: string;

  /**
   * A boolean that indicates all users associated with the server should be deleted so that the Server can be destroyed without error. The default value is false. This option only applies to servers configured with a SERVICE_MANAGED identity_provider_type.
   *
   * @schema ServerSpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * The ARN for a lambda function to use for the Identity provider.
   *
   * @schema ServerSpecInitProvider#function
   */
  readonly function?: string;

  /**
   * The mode of authentication enabled for this service. The default value is SERVICE_MANAGED, which allows you to store and access SFTP user credentials within the service. API_GATEWAY indicates that user authentication requires a call to an API Gateway endpoint URL provided by you to integrate an identity provider of your choice. Using AWS_DIRECTORY_SERVICE will allow for authentication against AWS Managed Active Directory or Microsoft Active Directory in your on-premises environment, or in AWS using AD Connectors. Use the AWS_LAMBDA value to directly use a Lambda function as your identity provider. If you choose this value, you must specify the ARN for the lambda function in the function argument.
   *
   * @schema ServerSpecInitProvider#identityProviderType
   */
  readonly identityProviderType?: string;

  /**
   * Amazon Resource Name (ARN) of the IAM role used to authenticate the user account with an identity_provider_type of API_GATEWAY.
   *
   * @schema ServerSpecInitProvider#invocationRole
   */
  readonly invocationRole?: string;

  /**
   * Amazon Resource Name (ARN) of an IAM role that allows the service to write your SFTP users’ activity to your Amazon CloudWatch logs for monitoring and auditing purposes.
   *
   * @schema ServerSpecInitProvider#loggingRole
   */
  readonly loggingRole?: string;

  /**
   * The protocol settings that are configured for your server.
   *
   * @schema ServerSpecInitProvider#protocolDetails
   */
  readonly protocolDetails?: ServerSpecInitProviderProtocolDetails[];

  /**
   * Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. This defaults to SFTP . The available protocols are:
   *
   * @schema ServerSpecInitProvider#protocols
   */
  readonly protocols?: string[];

  /**
   * Specifies the name of the security policy that is attached to the server. Possible values are TransferSecurityPolicy-2018-11, TransferSecurityPolicy-2020-06, TransferSecurityPolicy-FIPS-2020-06 and TransferSecurityPolicy-2022-03. Default value is: TransferSecurityPolicy-2018-11.
   *
   * @schema ServerSpecInitProvider#securityPolicyName
   */
  readonly securityPolicyName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ServerSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * - URL of the service endpoint used to authenticate users with an identity_provider_type of API_GATEWAY.
   *
   * @schema ServerSpecInitProvider#url
   */
  readonly url?: string;

  /**
   * Specifies the workflow details. See Workflow Details below.
   *
   * @schema ServerSpecInitProvider#workflowDetails
   */
  readonly workflowDetails?: ServerSpecInitProviderWorkflowDetails[];

}

/**
 * Converts an object of type 'ServerSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecInitProvider(obj: ServerSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'endpointDetails': obj.endpointDetails?.map(y => toJson_ServerSpecInitProviderEndpointDetails(y)),
    'endpointType': obj.endpointType,
    'forceDestroy': obj.forceDestroy,
    'function': obj.function,
    'identityProviderType': obj.identityProviderType,
    'invocationRole': obj.invocationRole,
    'loggingRole': obj.loggingRole,
    'protocolDetails': obj.protocolDetails?.map(y => toJson_ServerSpecInitProviderProtocolDetails(y)),
    'protocols': obj.protocols?.map(y => y),
    'securityPolicyName': obj.securityPolicyName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'url': obj.url,
    'workflowDetails': obj.workflowDetails?.map(y => toJson_ServerSpecInitProviderWorkflowDetails(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServerSpecManagementPolicies
 */
export enum ServerSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServerSpecProviderConfigRef
 */
export interface ServerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecProviderConfigRef#policy
   */
  readonly policy?: ServerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecProviderConfigRef(obj: ServerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServerSpecPublishConnectionDetailsTo
 */
export interface ServerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecPublishConnectionDetailsTo(obj: ServerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServerSpecWriteConnectionSecretToRef
 */
export interface ServerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecWriteConnectionSecretToRef(obj: ServerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Certificate in acm to populate certificate.
 *
 * @schema ServerSpecForProviderCertificateRef
 */
export interface ServerSpecForProviderCertificateRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecForProviderCertificateRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecForProviderCertificateRef#policy
   */
  readonly policy?: ServerSpecForProviderCertificateRefPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderCertificateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderCertificateRef(obj: ServerSpecForProviderCertificateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecForProviderCertificateRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Certificate in acm to populate certificate.
 *
 * @schema ServerSpecForProviderCertificateSelector
 */
export interface ServerSpecForProviderCertificateSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServerSpecForProviderCertificateSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServerSpecForProviderCertificateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServerSpecForProviderCertificateSelector#policy
   */
  readonly policy?: ServerSpecForProviderCertificateSelectorPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderCertificateSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderCertificateSelector(obj: ServerSpecForProviderCertificateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServerSpecForProviderCertificateSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Directory in ds to populate directoryId.
 *
 * @schema ServerSpecForProviderDirectoryIdRef
 */
export interface ServerSpecForProviderDirectoryIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecForProviderDirectoryIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecForProviderDirectoryIdRef#policy
   */
  readonly policy?: ServerSpecForProviderDirectoryIdRefPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderDirectoryIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderDirectoryIdRef(obj: ServerSpecForProviderDirectoryIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecForProviderDirectoryIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Directory in ds to populate directoryId.
 *
 * @schema ServerSpecForProviderDirectoryIdSelector
 */
export interface ServerSpecForProviderDirectoryIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServerSpecForProviderDirectoryIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServerSpecForProviderDirectoryIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServerSpecForProviderDirectoryIdSelector#policy
   */
  readonly policy?: ServerSpecForProviderDirectoryIdSelectorPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderDirectoryIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderDirectoryIdSelector(obj: ServerSpecForProviderDirectoryIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServerSpecForProviderDirectoryIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecForProviderEndpointDetails
 */
export interface ServerSpecForProviderEndpointDetails {
  /**
   * A list of address allocation IDs that are required to attach an Elastic IP address to your SFTP server's endpoint. This property can only be used when endpoint_type is set to VPC.
   *
   * @schema ServerSpecForProviderEndpointDetails#addressAllocationIds
   */
  readonly addressAllocationIds?: string[];

  /**
   * A list of security groups IDs that are available to attach to your server's endpoint. If no security groups are specified, the VPC's default security groups are automatically assigned to your endpoint. This property can only be used when endpoint_type is set to VPC.
   *
   * @schema ServerSpecForProviderEndpointDetails#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * A list of subnet IDs that are required to host your SFTP server endpoint in your VPC. This property can only be used when endpoint_type is set to VPC.
   *
   * @schema ServerSpecForProviderEndpointDetails#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * The ID of the VPC endpoint. This property can only be used when endpoint_type is set to VPC_ENDPOINT
   *
   * @schema ServerSpecForProviderEndpointDetails#vpcEndpointId
   */
  readonly vpcEndpointId?: string;

  /**
   * The VPC ID of the virtual private cloud in which the SFTP server's endpoint will be hosted. This property can only be used when endpoint_type is set to VPC.
   *
   * @schema ServerSpecForProviderEndpointDetails#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema ServerSpecForProviderEndpointDetails#vpcIdRef
   */
  readonly vpcIdRef?: ServerSpecForProviderEndpointDetailsVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema ServerSpecForProviderEndpointDetails#vpcIdSelector
   */
  readonly vpcIdSelector?: ServerSpecForProviderEndpointDetailsVpcIdSelector;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetails(obj: ServerSpecForProviderEndpointDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressAllocationIds': obj.addressAllocationIds?.map(y => y),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
    'vpcEndpointId': obj.vpcEndpointId,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_ServerSpecForProviderEndpointDetailsVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_ServerSpecForProviderEndpointDetailsVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RSA, ECDSA, or ED25519 private key (e.g., as generated by the ssh-keygen -t rsa -b 2048 -N "" -m PEM -f my-new-server-key, ssh-keygen -t ecdsa -b 256 -N "" -m PEM -f my-new-server-key or ssh-keygen -t ed25519 -N "" -f my-new-server-key commands).
 *
 * @schema ServerSpecForProviderHostKeySecretRef
 */
export interface ServerSpecForProviderHostKeySecretRef {
  /**
   * The key to select.
   *
   * @schema ServerSpecForProviderHostKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ServerSpecForProviderHostKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServerSpecForProviderHostKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServerSpecForProviderHostKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderHostKeySecretRef(obj: ServerSpecForProviderHostKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify a string to display when users connect to a server. This string is displayed after the user authenticates. The SFTP protocol does not support post-authentication display banners.
 *
 * @schema ServerSpecForProviderPostAuthenticationLoginBannerSecretRef
 */
export interface ServerSpecForProviderPostAuthenticationLoginBannerSecretRef {
  /**
   * The key to select.
   *
   * @schema ServerSpecForProviderPostAuthenticationLoginBannerSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ServerSpecForProviderPostAuthenticationLoginBannerSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServerSpecForProviderPostAuthenticationLoginBannerSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServerSpecForProviderPostAuthenticationLoginBannerSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderPostAuthenticationLoginBannerSecretRef(obj: ServerSpecForProviderPostAuthenticationLoginBannerSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify a string to display when users connect to a server. This string is displayed before the user authenticates.
 *
 * @schema ServerSpecForProviderPreAuthenticationLoginBannerSecretRef
 */
export interface ServerSpecForProviderPreAuthenticationLoginBannerSecretRef {
  /**
   * The key to select.
   *
   * @schema ServerSpecForProviderPreAuthenticationLoginBannerSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ServerSpecForProviderPreAuthenticationLoginBannerSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServerSpecForProviderPreAuthenticationLoginBannerSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServerSpecForProviderPreAuthenticationLoginBannerSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderPreAuthenticationLoginBannerSecretRef(obj: ServerSpecForProviderPreAuthenticationLoginBannerSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecForProviderProtocolDetails
 */
export interface ServerSpecForProviderProtocolDetails {
  /**
   * Indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
   *
   * @schema ServerSpecForProviderProtocolDetails#as2Transports
   */
  readonly as2Transports?: string[];

  /**
   * Indicates passive mode, for FTP and FTPS protocols. Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer.
   *
   * @schema ServerSpecForProviderProtocolDetails#passiveIp
   */
  readonly passiveIp?: string;

  /**
   * Use to ignore the error that is generated when the client attempts to use SETSTAT on a file you are uploading to an S3 bucket. Valid values: DEFAULT, ENABLE_NO_OP.
   *
   * @schema ServerSpecForProviderProtocolDetails#setStatOption
   */
  readonly setStatOption?: string;

  /**
   * A property used with Transfer Family servers that use the FTPS protocol. Provides a mechanism to resume or share a negotiated secret key between the control and data connection for an FTPS session. Valid values: DISABLED, ENABLED, ENFORCED.
   *
   * @schema ServerSpecForProviderProtocolDetails#tlsSessionResumptionMode
   */
  readonly tlsSessionResumptionMode?: string;

}

/**
 * Converts an object of type 'ServerSpecForProviderProtocolDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderProtocolDetails(obj: ServerSpecForProviderProtocolDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'as2Transports': obj.as2Transports?.map(y => y),
    'passiveIp': obj.passiveIp,
    'setStatOption': obj.setStatOption,
    'tlsSessionResumptionMode': obj.tlsSessionResumptionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecForProviderWorkflowDetails
 */
export interface ServerSpecForProviderWorkflowDetails {
  /**
   * A trigger that starts a workflow if a file is only partially uploaded. See Workflow Detail below.
   *
   * @schema ServerSpecForProviderWorkflowDetails#onPartialUpload
   */
  readonly onPartialUpload?: ServerSpecForProviderWorkflowDetailsOnPartialUpload[];

  /**
   * A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. See Workflow Detail below.
   *
   * @schema ServerSpecForProviderWorkflowDetails#onUpload
   */
  readonly onUpload?: ServerSpecForProviderWorkflowDetailsOnUpload[];

}

/**
 * Converts an object of type 'ServerSpecForProviderWorkflowDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderWorkflowDetails(obj: ServerSpecForProviderWorkflowDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onPartialUpload': obj.onPartialUpload?.map(y => toJson_ServerSpecForProviderWorkflowDetailsOnPartialUpload(y)),
    'onUpload': obj.onUpload?.map(y => toJson_ServerSpecForProviderWorkflowDetailsOnUpload(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecInitProviderEndpointDetails
 */
export interface ServerSpecInitProviderEndpointDetails {
  /**
   * A list of address allocation IDs that are required to attach an Elastic IP address to your SFTP server's endpoint. This property can only be used when endpoint_type is set to VPC.
   *
   * @schema ServerSpecInitProviderEndpointDetails#addressAllocationIds
   */
  readonly addressAllocationIds?: string[];

  /**
   * A list of security groups IDs that are available to attach to your server's endpoint. If no security groups are specified, the VPC's default security groups are automatically assigned to your endpoint. This property can only be used when endpoint_type is set to VPC.
   *
   * @schema ServerSpecInitProviderEndpointDetails#securityGroupIds
   */
  readonly securityGroupIds?: string[];

  /**
   * A list of subnet IDs that are required to host your SFTP server endpoint in your VPC. This property can only be used when endpoint_type is set to VPC.
   *
   * @schema ServerSpecInitProviderEndpointDetails#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * The ID of the VPC endpoint. This property can only be used when endpoint_type is set to VPC_ENDPOINT
   *
   * @schema ServerSpecInitProviderEndpointDetails#vpcEndpointId
   */
  readonly vpcEndpointId?: string;

}

/**
 * Converts an object of type 'ServerSpecInitProviderEndpointDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecInitProviderEndpointDetails(obj: ServerSpecInitProviderEndpointDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addressAllocationIds': obj.addressAllocationIds?.map(y => y),
    'securityGroupIds': obj.securityGroupIds?.map(y => y),
    'subnetIds': obj.subnetIds?.map(y => y),
    'vpcEndpointId': obj.vpcEndpointId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecInitProviderProtocolDetails
 */
export interface ServerSpecInitProviderProtocolDetails {
  /**
   * Indicates the transport method for the AS2 messages. Currently, only HTTP is supported.
   *
   * @schema ServerSpecInitProviderProtocolDetails#as2Transports
   */
  readonly as2Transports?: string[];

  /**
   * Indicates passive mode, for FTP and FTPS protocols. Enter a single IPv4 address, such as the public IP address of a firewall, router, or load balancer.
   *
   * @schema ServerSpecInitProviderProtocolDetails#passiveIp
   */
  readonly passiveIp?: string;

  /**
   * Use to ignore the error that is generated when the client attempts to use SETSTAT on a file you are uploading to an S3 bucket. Valid values: DEFAULT, ENABLE_NO_OP.
   *
   * @schema ServerSpecInitProviderProtocolDetails#setStatOption
   */
  readonly setStatOption?: string;

  /**
   * A property used with Transfer Family servers that use the FTPS protocol. Provides a mechanism to resume or share a negotiated secret key between the control and data connection for an FTPS session. Valid values: DISABLED, ENABLED, ENFORCED.
   *
   * @schema ServerSpecInitProviderProtocolDetails#tlsSessionResumptionMode
   */
  readonly tlsSessionResumptionMode?: string;

}

/**
 * Converts an object of type 'ServerSpecInitProviderProtocolDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecInitProviderProtocolDetails(obj: ServerSpecInitProviderProtocolDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'as2Transports': obj.as2Transports?.map(y => y),
    'passiveIp': obj.passiveIp,
    'setStatOption': obj.setStatOption,
    'tlsSessionResumptionMode': obj.tlsSessionResumptionMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecInitProviderWorkflowDetails
 */
export interface ServerSpecInitProviderWorkflowDetails {
  /**
   * A trigger that starts a workflow if a file is only partially uploaded. See Workflow Detail below.
   *
   * @schema ServerSpecInitProviderWorkflowDetails#onPartialUpload
   */
  readonly onPartialUpload?: ServerSpecInitProviderWorkflowDetailsOnPartialUpload[];

  /**
   * A trigger that starts a workflow: the workflow begins to execute after a file is uploaded. See Workflow Detail below.
   *
   * @schema ServerSpecInitProviderWorkflowDetails#onUpload
   */
  readonly onUpload?: ServerSpecInitProviderWorkflowDetailsOnUpload[];

}

/**
 * Converts an object of type 'ServerSpecInitProviderWorkflowDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecInitProviderWorkflowDetails(obj: ServerSpecInitProviderWorkflowDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onPartialUpload': obj.onPartialUpload?.map(y => toJson_ServerSpecInitProviderWorkflowDetailsOnPartialUpload(y)),
    'onUpload': obj.onUpload?.map(y => toJson_ServerSpecInitProviderWorkflowDetailsOnUpload(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServerSpecProviderConfigRefPolicy
 */
export interface ServerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecProviderConfigRefPolicy(obj: ServerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServerSpecPublishConnectionDetailsToConfigRef
 */
export interface ServerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecPublishConnectionDetailsToConfigRef(obj: ServerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServerSpecPublishConnectionDetailsToMetadata
 */
export interface ServerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecPublishConnectionDetailsToMetadata(obj: ServerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServerSpecForProviderCertificateRefPolicy
 */
export interface ServerSpecForProviderCertificateRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderCertificateRefPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderCertificateRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderCertificateRefPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderCertificateRefPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderCertificateRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderCertificateRefPolicy(obj: ServerSpecForProviderCertificateRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServerSpecForProviderCertificateSelectorPolicy
 */
export interface ServerSpecForProviderCertificateSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderCertificateSelectorPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderCertificateSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderCertificateSelectorPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderCertificateSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderCertificateSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderCertificateSelectorPolicy(obj: ServerSpecForProviderCertificateSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServerSpecForProviderDirectoryIdRefPolicy
 */
export interface ServerSpecForProviderDirectoryIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderDirectoryIdRefPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderDirectoryIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderDirectoryIdRefPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderDirectoryIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderDirectoryIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderDirectoryIdRefPolicy(obj: ServerSpecForProviderDirectoryIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServerSpecForProviderDirectoryIdSelectorPolicy
 */
export interface ServerSpecForProviderDirectoryIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderDirectoryIdSelectorPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderDirectoryIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderDirectoryIdSelectorPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderDirectoryIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderDirectoryIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderDirectoryIdSelectorPolicy(obj: ServerSpecForProviderDirectoryIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdRef
 */
export interface ServerSpecForProviderEndpointDetailsVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdRef#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsVpcIdRefPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcIdRef(obj: ServerSpecForProviderEndpointDetailsVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServerSpecForProviderEndpointDetailsVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdSelector
 */
export interface ServerSpecForProviderEndpointDetailsVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdSelector#policy
   */
  readonly policy?: ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcIdSelector(obj: ServerSpecForProviderEndpointDetailsVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecForProviderWorkflowDetailsOnPartialUpload
 */
export interface ServerSpecForProviderWorkflowDetailsOnPartialUpload {
  /**
   * Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
   *
   * @schema ServerSpecForProviderWorkflowDetailsOnPartialUpload#executionRole
   */
  readonly executionRole?: string;

  /**
   * A unique identifier for the workflow.
   *
   * @schema ServerSpecForProviderWorkflowDetailsOnPartialUpload#workflowId
   */
  readonly workflowId?: string;

}

/**
 * Converts an object of type 'ServerSpecForProviderWorkflowDetailsOnPartialUpload' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderWorkflowDetailsOnPartialUpload(obj: ServerSpecForProviderWorkflowDetailsOnPartialUpload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionRole': obj.executionRole,
    'workflowId': obj.workflowId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecForProviderWorkflowDetailsOnUpload
 */
export interface ServerSpecForProviderWorkflowDetailsOnUpload {
  /**
   * Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
   *
   * @schema ServerSpecForProviderWorkflowDetailsOnUpload#executionRole
   */
  readonly executionRole?: string;

  /**
   * A unique identifier for the workflow.
   *
   * @schema ServerSpecForProviderWorkflowDetailsOnUpload#workflowId
   */
  readonly workflowId?: string;

}

/**
 * Converts an object of type 'ServerSpecForProviderWorkflowDetailsOnUpload' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderWorkflowDetailsOnUpload(obj: ServerSpecForProviderWorkflowDetailsOnUpload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionRole': obj.executionRole,
    'workflowId': obj.workflowId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecInitProviderWorkflowDetailsOnPartialUpload
 */
export interface ServerSpecInitProviderWorkflowDetailsOnPartialUpload {
  /**
   * Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
   *
   * @schema ServerSpecInitProviderWorkflowDetailsOnPartialUpload#executionRole
   */
  readonly executionRole?: string;

  /**
   * A unique identifier for the workflow.
   *
   * @schema ServerSpecInitProviderWorkflowDetailsOnPartialUpload#workflowId
   */
  readonly workflowId?: string;

}

/**
 * Converts an object of type 'ServerSpecInitProviderWorkflowDetailsOnPartialUpload' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecInitProviderWorkflowDetailsOnPartialUpload(obj: ServerSpecInitProviderWorkflowDetailsOnPartialUpload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionRole': obj.executionRole,
    'workflowId': obj.workflowId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServerSpecInitProviderWorkflowDetailsOnUpload
 */
export interface ServerSpecInitProviderWorkflowDetailsOnUpload {
  /**
   * Includes the necessary permissions for S3, EFS, and Lambda operations that Transfer can assume, so that all workflow steps can operate on the required resources.
   *
   * @schema ServerSpecInitProviderWorkflowDetailsOnUpload#executionRole
   */
  readonly executionRole?: string;

  /**
   * A unique identifier for the workflow.
   *
   * @schema ServerSpecInitProviderWorkflowDetailsOnUpload#workflowId
   */
  readonly workflowId?: string;

}

/**
 * Converts an object of type 'ServerSpecInitProviderWorkflowDetailsOnUpload' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecInitProviderWorkflowDetailsOnUpload(obj: ServerSpecInitProviderWorkflowDetailsOnUpload | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executionRole': obj.executionRole,
    'workflowId': obj.workflowId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecProviderConfigRefPolicyResolution
 */
export enum ServerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecProviderConfigRefPolicyResolve
 */
export enum ServerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderCertificateRefPolicyResolution
 */
export enum ServerSpecForProviderCertificateRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderCertificateRefPolicyResolve
 */
export enum ServerSpecForProviderCertificateRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderCertificateSelectorPolicyResolution
 */
export enum ServerSpecForProviderCertificateSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderCertificateSelectorPolicyResolve
 */
export enum ServerSpecForProviderCertificateSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderDirectoryIdRefPolicyResolution
 */
export enum ServerSpecForProviderDirectoryIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderDirectoryIdRefPolicyResolve
 */
export enum ServerSpecForProviderDirectoryIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderDirectoryIdSelectorPolicyResolution
 */
export enum ServerSpecForProviderDirectoryIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderDirectoryIdSelectorPolicyResolve
 */
export enum ServerSpecForProviderDirectoryIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdRefPolicy
 */
export interface ServerSpecForProviderEndpointDetailsVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdRefPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdRefPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcIdRefPolicy(obj: ServerSpecForProviderEndpointDetailsVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy
 */
export interface ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy(obj: ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolution
 */
export enum ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolve
 */
export enum ServerSpecForProviderEndpointDetailsVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SSHKey is the Schema for the SSHKeys API. Provides a AWS Transfer SSH Public Key resource.
 *
 * @schema SSHKey
 */
export class SshKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SSHKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'transfer.aws.upbound.io/v1beta1',
    kind: 'SSHKey',
  }

  /**
   * Renders a Kubernetes manifest for "SSHKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SshKeyProps): any {
    return {
      ...SshKey.GVK,
      ...toJson_SshKeyProps(props),
    };
  }

  /**
   * Defines a "SSHKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SshKeyProps) {
    super(scope, id, {
      ...SshKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SshKey.GVK,
      ...toJson_SshKeyProps(resolved),
    };
  }
}

/**
 * SSHKey is the Schema for the SSHKeys API. Provides a AWS Transfer SSH Public Key resource.
 *
 * @schema SSHKey
 */
export interface SshKeyProps {
  /**
   * @schema SSHKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SSHKeySpec defines the desired state of SSHKey
   *
   * @schema SSHKey#spec
   */
  readonly spec: SshKeySpec;

}

/**
 * Converts an object of type 'SshKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeyProps(obj: SshKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SshKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SSHKeySpec defines the desired state of SSHKey
 *
 * @schema SshKeySpec
 */
export interface SshKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SshKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: SshKeySpecDeletionPolicy;

  /**
   * @schema SshKeySpec#forProvider
   */
  readonly forProvider: SshKeySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SshKeySpec#initProvider
   */
  readonly initProvider?: SshKeySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SshKeySpec#managementPolicies
   */
  readonly managementPolicies?: SshKeySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SshKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: SshKeySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SshKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SshKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SshKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SshKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SshKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpec(obj: SshKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SshKeySpecForProvider(obj.forProvider),
    'initProvider': toJson_SshKeySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SshKeySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SshKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SshKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SshKeySpecDeletionPolicy
 */
export enum SshKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SshKeySpecForProvider
 */
export interface SshKeySpecForProvider {
  /**
   * (Requirement) The public key portion of an SSH key pair.
   *
   * @schema SshKeySpecForProvider#body
   */
  readonly body?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SshKeySpecForProvider#region
   */
  readonly region: string;

  /**
   * (Requirement) The Server ID of the Transfer Server (e.g., s-12345678)
   *
   * @schema SshKeySpecForProvider#serverId
   */
  readonly serverId?: string;

  /**
   * Reference to a Server in transfer to populate serverId.
   *
   * @schema SshKeySpecForProvider#serverIdRef
   */
  readonly serverIdRef?: SshKeySpecForProviderServerIdRef;

  /**
   * Selector for a Server in transfer to populate serverId.
   *
   * @schema SshKeySpecForProvider#serverIdSelector
   */
  readonly serverIdSelector?: SshKeySpecForProviderServerIdSelector;

  /**
   * (Requirement) The name of the user account that is assigned to one or more servers.
   *
   * @schema SshKeySpecForProvider#userName
   */
  readonly userName?: string;

  /**
   * Reference to a User in transfer to populate userName.
   *
   * @schema SshKeySpecForProvider#userNameRef
   */
  readonly userNameRef?: SshKeySpecForProviderUserNameRef;

  /**
   * Selector for a User in transfer to populate userName.
   *
   * @schema SshKeySpecForProvider#userNameSelector
   */
  readonly userNameSelector?: SshKeySpecForProviderUserNameSelector;

}

/**
 * Converts an object of type 'SshKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecForProvider(obj: SshKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'region': obj.region,
    'serverId': obj.serverId,
    'serverIdRef': toJson_SshKeySpecForProviderServerIdRef(obj.serverIdRef),
    'serverIdSelector': toJson_SshKeySpecForProviderServerIdSelector(obj.serverIdSelector),
    'userName': obj.userName,
    'userNameRef': toJson_SshKeySpecForProviderUserNameRef(obj.userNameRef),
    'userNameSelector': toJson_SshKeySpecForProviderUserNameSelector(obj.userNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SshKeySpecInitProvider
 */
export interface SshKeySpecInitProvider {
  /**
   * (Requirement) The public key portion of an SSH key pair.
   *
   * @schema SshKeySpecInitProvider#body
   */
  readonly body?: string;

}

/**
 * Converts an object of type 'SshKeySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecInitProvider(obj: SshKeySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SshKeySpecManagementPolicies
 */
export enum SshKeySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SshKeySpecProviderConfigRef
 */
export interface SshKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SshKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SshKeySpecProviderConfigRef#policy
   */
  readonly policy?: SshKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SshKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecProviderConfigRef(obj: SshKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SshKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SshKeySpecPublishConnectionDetailsTo
 */
export interface SshKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SshKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SshKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SshKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SshKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SshKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SshKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecPublishConnectionDetailsTo(obj: SshKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SshKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SshKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SshKeySpecWriteConnectionSecretToRef
 */
export interface SshKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SshKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SshKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SshKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecWriteConnectionSecretToRef(obj: SshKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Server in transfer to populate serverId.
 *
 * @schema SshKeySpecForProviderServerIdRef
 */
export interface SshKeySpecForProviderServerIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SshKeySpecForProviderServerIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SshKeySpecForProviderServerIdRef#policy
   */
  readonly policy?: SshKeySpecForProviderServerIdRefPolicy;

}

/**
 * Converts an object of type 'SshKeySpecForProviderServerIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecForProviderServerIdRef(obj: SshKeySpecForProviderServerIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SshKeySpecForProviderServerIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Server in transfer to populate serverId.
 *
 * @schema SshKeySpecForProviderServerIdSelector
 */
export interface SshKeySpecForProviderServerIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SshKeySpecForProviderServerIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SshKeySpecForProviderServerIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SshKeySpecForProviderServerIdSelector#policy
   */
  readonly policy?: SshKeySpecForProviderServerIdSelectorPolicy;

}

/**
 * Converts an object of type 'SshKeySpecForProviderServerIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecForProviderServerIdSelector(obj: SshKeySpecForProviderServerIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SshKeySpecForProviderServerIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a User in transfer to populate userName.
 *
 * @schema SshKeySpecForProviderUserNameRef
 */
export interface SshKeySpecForProviderUserNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema SshKeySpecForProviderUserNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SshKeySpecForProviderUserNameRef#policy
   */
  readonly policy?: SshKeySpecForProviderUserNameRefPolicy;

}

/**
 * Converts an object of type 'SshKeySpecForProviderUserNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecForProviderUserNameRef(obj: SshKeySpecForProviderUserNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SshKeySpecForProviderUserNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a User in transfer to populate userName.
 *
 * @schema SshKeySpecForProviderUserNameSelector
 */
export interface SshKeySpecForProviderUserNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SshKeySpecForProviderUserNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SshKeySpecForProviderUserNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SshKeySpecForProviderUserNameSelector#policy
   */
  readonly policy?: SshKeySpecForProviderUserNameSelectorPolicy;

}

/**
 * Converts an object of type 'SshKeySpecForProviderUserNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecForProviderUserNameSelector(obj: SshKeySpecForProviderUserNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SshKeySpecForProviderUserNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SshKeySpecProviderConfigRefPolicy
 */
export interface SshKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SshKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SshKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SshKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SshKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SshKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecProviderConfigRefPolicy(obj: SshKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SshKeySpecPublishConnectionDetailsToConfigRef
 */
export interface SshKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SshKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SshKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SshKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SshKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecPublishConnectionDetailsToConfigRef(obj: SshKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SshKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SshKeySpecPublishConnectionDetailsToMetadata
 */
export interface SshKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SshKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SshKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SshKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SshKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecPublishConnectionDetailsToMetadata(obj: SshKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SshKeySpecForProviderServerIdRefPolicy
 */
export interface SshKeySpecForProviderServerIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SshKeySpecForProviderServerIdRefPolicy#resolution
   */
  readonly resolution?: SshKeySpecForProviderServerIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SshKeySpecForProviderServerIdRefPolicy#resolve
   */
  readonly resolve?: SshKeySpecForProviderServerIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SshKeySpecForProviderServerIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecForProviderServerIdRefPolicy(obj: SshKeySpecForProviderServerIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SshKeySpecForProviderServerIdSelectorPolicy
 */
export interface SshKeySpecForProviderServerIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SshKeySpecForProviderServerIdSelectorPolicy#resolution
   */
  readonly resolution?: SshKeySpecForProviderServerIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SshKeySpecForProviderServerIdSelectorPolicy#resolve
   */
  readonly resolve?: SshKeySpecForProviderServerIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SshKeySpecForProviderServerIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecForProviderServerIdSelectorPolicy(obj: SshKeySpecForProviderServerIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SshKeySpecForProviderUserNameRefPolicy
 */
export interface SshKeySpecForProviderUserNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SshKeySpecForProviderUserNameRefPolicy#resolution
   */
  readonly resolution?: SshKeySpecForProviderUserNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SshKeySpecForProviderUserNameRefPolicy#resolve
   */
  readonly resolve?: SshKeySpecForProviderUserNameRefPolicyResolve;

}

/**
 * Converts an object of type 'SshKeySpecForProviderUserNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecForProviderUserNameRefPolicy(obj: SshKeySpecForProviderUserNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SshKeySpecForProviderUserNameSelectorPolicy
 */
export interface SshKeySpecForProviderUserNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SshKeySpecForProviderUserNameSelectorPolicy#resolution
   */
  readonly resolution?: SshKeySpecForProviderUserNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SshKeySpecForProviderUserNameSelectorPolicy#resolve
   */
  readonly resolve?: SshKeySpecForProviderUserNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SshKeySpecForProviderUserNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecForProviderUserNameSelectorPolicy(obj: SshKeySpecForProviderUserNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SshKeySpecProviderConfigRefPolicyResolution
 */
export enum SshKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SshKeySpecProviderConfigRefPolicyResolve
 */
export enum SshKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SshKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SshKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SshKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SshKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SshKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SshKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SshKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SshKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: SshKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SshKeySpecForProviderServerIdRefPolicyResolution
 */
export enum SshKeySpecForProviderServerIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SshKeySpecForProviderServerIdRefPolicyResolve
 */
export enum SshKeySpecForProviderServerIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SshKeySpecForProviderServerIdSelectorPolicyResolution
 */
export enum SshKeySpecForProviderServerIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SshKeySpecForProviderServerIdSelectorPolicyResolve
 */
export enum SshKeySpecForProviderServerIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SshKeySpecForProviderUserNameRefPolicyResolution
 */
export enum SshKeySpecForProviderUserNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SshKeySpecForProviderUserNameRefPolicyResolve
 */
export enum SshKeySpecForProviderUserNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SshKeySpecForProviderUserNameSelectorPolicyResolution
 */
export enum SshKeySpecForProviderUserNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SshKeySpecForProviderUserNameSelectorPolicyResolve
 */
export enum SshKeySpecForProviderUserNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SshKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SshKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SshKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SshKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Tag is the Schema for the Tags API. Manages an individual Transfer Family resource tag
 *
 * @schema Tag
 */
export class Tag extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Tag"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'transfer.aws.upbound.io/v1beta1',
    kind: 'Tag',
  }

  /**
   * Renders a Kubernetes manifest for "Tag".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TagProps): any {
    return {
      ...Tag.GVK,
      ...toJson_TagProps(props),
    };
  }

  /**
   * Defines a "Tag" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TagProps) {
    super(scope, id, {
      ...Tag.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Tag.GVK,
      ...toJson_TagProps(resolved),
    };
  }
}

/**
 * Tag is the Schema for the Tags API. Manages an individual Transfer Family resource tag
 *
 * @schema Tag
 */
export interface TagProps {
  /**
   * @schema Tag#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TagSpec defines the desired state of Tag
   *
   * @schema Tag#spec
   */
  readonly spec: TagSpec;

}

/**
 * Converts an object of type 'TagProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagProps(obj: TagProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TagSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TagSpec defines the desired state of Tag
 *
 * @schema TagSpec
 */
export interface TagSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TagSpec#deletionPolicy
   */
  readonly deletionPolicy?: TagSpecDeletionPolicy;

  /**
   * @schema TagSpec#forProvider
   */
  readonly forProvider: TagSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TagSpec#initProvider
   */
  readonly initProvider?: TagSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TagSpec#managementPolicies
   */
  readonly managementPolicies?: TagSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TagSpec#providerConfigRef
   */
  readonly providerConfigRef?: TagSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TagSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TagSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TagSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TagSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TagSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpec(obj: TagSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TagSpecForProvider(obj.forProvider),
    'initProvider': toJson_TagSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TagSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TagSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TagSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TagSpecDeletionPolicy
 */
export enum TagSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TagSpecForProvider
 */
export interface TagSpecForProvider {
  /**
   * Tag name.
   *
   * @schema TagSpecForProvider#key
   */
  readonly key?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TagSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon Resource Name (ARN) of the Transfer Family resource to tag.
   *
   * @schema TagSpecForProvider#resourceArn
   */
  readonly resourceArn?: string;

  /**
   * Reference to a Server in transfer to populate resourceArn.
   *
   * @schema TagSpecForProvider#resourceArnRef
   */
  readonly resourceArnRef?: TagSpecForProviderResourceArnRef;

  /**
   * Selector for a Server in transfer to populate resourceArn.
   *
   * @schema TagSpecForProvider#resourceArnSelector
   */
  readonly resourceArnSelector?: TagSpecForProviderResourceArnSelector;

  /**
   * Tag value.
   *
   * @schema TagSpecForProvider#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TagSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProvider(obj: TagSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'region': obj.region,
    'resourceArn': obj.resourceArn,
    'resourceArnRef': toJson_TagSpecForProviderResourceArnRef(obj.resourceArnRef),
    'resourceArnSelector': toJson_TagSpecForProviderResourceArnSelector(obj.resourceArnSelector),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TagSpecInitProvider
 */
export interface TagSpecInitProvider {
  /**
   * Tag name.
   *
   * @schema TagSpecInitProvider#key
   */
  readonly key?: string;

  /**
   * Tag value.
   *
   * @schema TagSpecInitProvider#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TagSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecInitProvider(obj: TagSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TagSpecManagementPolicies
 */
export enum TagSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TagSpecProviderConfigRef
 */
export interface TagSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagSpecProviderConfigRef#policy
   */
  readonly policy?: TagSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TagSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecProviderConfigRef(obj: TagSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TagSpecPublishConnectionDetailsTo
 */
export interface TagSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TagSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TagSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TagSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TagSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TagSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsTo(obj: TagSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TagSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TagSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TagSpecWriteConnectionSecretToRef
 */
export interface TagSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TagSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TagSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TagSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecWriteConnectionSecretToRef(obj: TagSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Server in transfer to populate resourceArn.
 *
 * @schema TagSpecForProviderResourceArnRef
 */
export interface TagSpecForProviderResourceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagSpecForProviderResourceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagSpecForProviderResourceArnRef#policy
   */
  readonly policy?: TagSpecForProviderResourceArnRefPolicy;

}

/**
 * Converts an object of type 'TagSpecForProviderResourceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderResourceArnRef(obj: TagSpecForProviderResourceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagSpecForProviderResourceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Server in transfer to populate resourceArn.
 *
 * @schema TagSpecForProviderResourceArnSelector
 */
export interface TagSpecForProviderResourceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TagSpecForProviderResourceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TagSpecForProviderResourceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TagSpecForProviderResourceArnSelector#policy
   */
  readonly policy?: TagSpecForProviderResourceArnSelectorPolicy;

}

/**
 * Converts an object of type 'TagSpecForProviderResourceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderResourceArnSelector(obj: TagSpecForProviderResourceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TagSpecForProviderResourceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagSpecProviderConfigRefPolicy
 */
export interface TagSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TagSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TagSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecProviderConfigRefPolicy(obj: TagSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRef
 */
export interface TagSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TagSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsToConfigRef(obj: TagSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TagSpecPublishConnectionDetailsToMetadata
 */
export interface TagSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TagSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsToMetadata(obj: TagSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagSpecForProviderResourceArnRefPolicy
 */
export interface TagSpecForProviderResourceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecForProviderResourceArnRefPolicy#resolution
   */
  readonly resolution?: TagSpecForProviderResourceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecForProviderResourceArnRefPolicy#resolve
   */
  readonly resolve?: TagSpecForProviderResourceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecForProviderResourceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderResourceArnRefPolicy(obj: TagSpecForProviderResourceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TagSpecForProviderResourceArnSelectorPolicy
 */
export interface TagSpecForProviderResourceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecForProviderResourceArnSelectorPolicy#resolution
   */
  readonly resolution?: TagSpecForProviderResourceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecForProviderResourceArnSelectorPolicy#resolve
   */
  readonly resolve?: TagSpecForProviderResourceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecForProviderResourceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderResourceArnSelectorPolicy(obj: TagSpecForProviderResourceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecProviderConfigRefPolicyResolution
 */
export enum TagSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecProviderConfigRefPolicyResolve
 */
export enum TagSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TagSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TagSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TagSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsToConfigRefPolicy(obj: TagSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecForProviderResourceArnRefPolicyResolution
 */
export enum TagSpecForProviderResourceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecForProviderResourceArnRefPolicyResolve
 */
export enum TagSpecForProviderResourceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecForProviderResourceArnSelectorPolicyResolution
 */
export enum TagSpecForProviderResourceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecForProviderResourceArnSelectorPolicyResolve
 */
export enum TagSpecForProviderResourceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TagSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TagSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * User is the Schema for the Users API. Provides a AWS Transfer User resource.
 *
 * @schema User
 */
export class User extends ApiObject {
  /**
   * Returns the apiVersion and kind for "User"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'transfer.aws.upbound.io/v1beta1',
    kind: 'User',
  }

  /**
   * Renders a Kubernetes manifest for "User".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserProps): any {
    return {
      ...User.GVK,
      ...toJson_UserProps(props),
    };
  }

  /**
   * Defines a "User" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserProps) {
    super(scope, id, {
      ...User.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...User.GVK,
      ...toJson_UserProps(resolved),
    };
  }
}

/**
 * User is the Schema for the Users API. Provides a AWS Transfer User resource.
 *
 * @schema User
 */
export interface UserProps {
  /**
   * @schema User#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserSpec defines the desired state of User
   *
   * @schema User#spec
   */
  readonly spec: UserSpec;

}

/**
 * Converts an object of type 'UserProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProps(obj: UserProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserSpec defines the desired state of User
 *
 * @schema UserSpec
 */
export interface UserSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserSpecDeletionPolicy;

  /**
   * @schema UserSpec#forProvider
   */
  readonly forProvider: UserSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema UserSpec#initProvider
   */
  readonly initProvider?: UserSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UserSpec#managementPolicies
   */
  readonly managementPolicies?: UserSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpec(obj: UserSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserSpecForProvider(obj.forProvider),
    'initProvider': toJson_UserSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UserSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UserSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserSpecDeletionPolicy
 */
export enum UserSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserSpecForProvider
 */
export interface UserSpecForProvider {
  /**
   * The landing directory (folder) for a user when they log in to the server using their SFTP client.  It should begin with a /.  The first item in the path is the name of the home bucket (accessible as ${Transfer:HomeBucket} in the policy) and the rest is the home directory (accessible as ${Transfer:HomeDirectory} in the policy). For example, /example-bucket-1234/username would set the home bucket to example-bucket-1234 and the home directory to username.
   *
   * @schema UserSpecForProvider#homeDirectory
   */
  readonly homeDirectory?: string;

  /**
   * Logical directory mappings that specify what S3 paths and keys should be visible to your user and how you want to make them visible. See Home Directory Mappings below.
   *
   * @schema UserSpecForProvider#homeDirectoryMappings
   */
  readonly homeDirectoryMappings?: UserSpecForProviderHomeDirectoryMappings[];

  /**
   * The type of landing directory (folder) you mapped for your users' home directory. Valid values are PATH and LOGICAL.
   *
   * @schema UserSpecForProvider#homeDirectoryType
   */
  readonly homeDirectoryType?: string;

  /**
   * An IAM JSON policy document that scopes down user access to portions of their Amazon S3 bucket. IAM variables you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}.  These are evaluated on-the-fly when navigating the bucket.
   *
   * @schema UserSpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. See Posix Profile below.
   *
   * @schema UserSpecForProvider#posixProfile
   */
  readonly posixProfile?: UserSpecForProviderPosixProfile[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon Resource Name (ARN) of an IAM role that allows the service to controls your user’s access to your Amazon S3 bucket.
   *
   * @schema UserSpecForProvider#role
   */
  readonly role?: string;

  /**
   * Reference to a Role in iam to populate role.
   *
   * @schema UserSpecForProvider#roleRef
   */
  readonly roleRef?: UserSpecForProviderRoleRef;

  /**
   * Selector for a Role in iam to populate role.
   *
   * @schema UserSpecForProvider#roleSelector
   */
  readonly roleSelector?: UserSpecForProviderRoleSelector;

  /**
   * The Server ID of the Transfer Server (e.g., s-12345678)
   *
   * @schema UserSpecForProvider#serverId
   */
  readonly serverId?: string;

  /**
   * Reference to a Server to populate serverId.
   *
   * @schema UserSpecForProvider#serverIdRef
   */
  readonly serverIdRef?: UserSpecForProviderServerIdRef;

  /**
   * Selector for a Server to populate serverId.
   *
   * @schema UserSpecForProvider#serverIdSelector
   */
  readonly serverIdSelector?: UserSpecForProviderServerIdSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema UserSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'UserSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProvider(obj: UserSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'homeDirectory': obj.homeDirectory,
    'homeDirectoryMappings': obj.homeDirectoryMappings?.map(y => toJson_UserSpecForProviderHomeDirectoryMappings(y)),
    'homeDirectoryType': obj.homeDirectoryType,
    'policy': obj.policy,
    'posixProfile': obj.posixProfile?.map(y => toJson_UserSpecForProviderPosixProfile(y)),
    'region': obj.region,
    'role': obj.role,
    'roleRef': toJson_UserSpecForProviderRoleRef(obj.roleRef),
    'roleSelector': toJson_UserSpecForProviderRoleSelector(obj.roleSelector),
    'serverId': obj.serverId,
    'serverIdRef': toJson_UserSpecForProviderServerIdRef(obj.serverIdRef),
    'serverIdSelector': toJson_UserSpecForProviderServerIdSelector(obj.serverIdSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema UserSpecInitProvider
 */
export interface UserSpecInitProvider {
  /**
   * The landing directory (folder) for a user when they log in to the server using their SFTP client.  It should begin with a /.  The first item in the path is the name of the home bucket (accessible as ${Transfer:HomeBucket} in the policy) and the rest is the home directory (accessible as ${Transfer:HomeDirectory} in the policy). For example, /example-bucket-1234/username would set the home bucket to example-bucket-1234 and the home directory to username.
   *
   * @schema UserSpecInitProvider#homeDirectory
   */
  readonly homeDirectory?: string;

  /**
   * Logical directory mappings that specify what S3 paths and keys should be visible to your user and how you want to make them visible. See Home Directory Mappings below.
   *
   * @schema UserSpecInitProvider#homeDirectoryMappings
   */
  readonly homeDirectoryMappings?: UserSpecInitProviderHomeDirectoryMappings[];

  /**
   * The type of landing directory (folder) you mapped for your users' home directory. Valid values are PATH and LOGICAL.
   *
   * @schema UserSpecInitProvider#homeDirectoryType
   */
  readonly homeDirectoryType?: string;

  /**
   * An IAM JSON policy document that scopes down user access to portions of their Amazon S3 bucket. IAM variables you can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and ${Transfer:HomeBucket}.  These are evaluated on-the-fly when navigating the bucket.
   *
   * @schema UserSpecInitProvider#policy
   */
  readonly policy?: string;

  /**
   * Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems. See Posix Profile below.
   *
   * @schema UserSpecInitProvider#posixProfile
   */
  readonly posixProfile?: UserSpecInitProviderPosixProfile[];

  /**
   * Key-value map of resource tags.
   *
   * @schema UserSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'UserSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecInitProvider(obj: UserSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'homeDirectory': obj.homeDirectory,
    'homeDirectoryMappings': obj.homeDirectoryMappings?.map(y => toJson_UserSpecInitProviderHomeDirectoryMappings(y)),
    'homeDirectoryType': obj.homeDirectoryType,
    'policy': obj.policy,
    'posixProfile': obj.posixProfile?.map(y => toJson_UserSpecInitProviderPosixProfile(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema UserSpecManagementPolicies
 */
export enum UserSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserSpecProviderConfigRef
 */
export interface UserSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecProviderConfigRef#policy
   */
  readonly policy?: UserSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRef(obj: UserSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserSpecPublishConnectionDetailsTo
 */
export interface UserSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsTo(obj: UserSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserSpecWriteConnectionSecretToRef
 */
export interface UserSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecWriteConnectionSecretToRef(obj: UserSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderHomeDirectoryMappings
 */
export interface UserSpecForProviderHomeDirectoryMappings {
  /**
   * Represents an entry and a target.
   *
   * @schema UserSpecForProviderHomeDirectoryMappings#entry
   */
  readonly entry?: string;

  /**
   * Represents the map target.
   *
   * @schema UserSpecForProviderHomeDirectoryMappings#target
   */
  readonly target?: string;

}

/**
 * Converts an object of type 'UserSpecForProviderHomeDirectoryMappings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderHomeDirectoryMappings(obj: UserSpecForProviderHomeDirectoryMappings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entry': obj.entry,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderPosixProfile
 */
export interface UserSpecForProviderPosixProfile {
  /**
   * The POSIX group ID used for all EFS operations by this user.
   *
   * @schema UserSpecForProviderPosixProfile#gid
   */
  readonly gid?: number;

  /**
   * The secondary POSIX group IDs used for all EFS operations by this user.
   *
   * @schema UserSpecForProviderPosixProfile#secondaryGids
   */
  readonly secondaryGids?: number[];

  /**
   * The POSIX user ID used for all EFS operations by this user.
   *
   * @schema UserSpecForProviderPosixProfile#uid
   */
  readonly uid?: number;

}

/**
 * Converts an object of type 'UserSpecForProviderPosixProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderPosixProfile(obj: UserSpecForProviderPosixProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gid': obj.gid,
    'secondaryGids': obj.secondaryGids?.map(y => y),
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate role.
 *
 * @schema UserSpecForProviderRoleRef
 */
export interface UserSpecForProviderRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecForProviderRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecForProviderRoleRef#policy
   */
  readonly policy?: UserSpecForProviderRoleRefPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoleRef(obj: UserSpecForProviderRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecForProviderRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate role.
 *
 * @schema UserSpecForProviderRoleSelector
 */
export interface UserSpecForProviderRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserSpecForProviderRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserSpecForProviderRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserSpecForProviderRoleSelector#policy
   */
  readonly policy?: UserSpecForProviderRoleSelectorPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoleSelector(obj: UserSpecForProviderRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserSpecForProviderRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Server to populate serverId.
 *
 * @schema UserSpecForProviderServerIdRef
 */
export interface UserSpecForProviderServerIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecForProviderServerIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecForProviderServerIdRef#policy
   */
  readonly policy?: UserSpecForProviderServerIdRefPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderServerIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderServerIdRef(obj: UserSpecForProviderServerIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecForProviderServerIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Server to populate serverId.
 *
 * @schema UserSpecForProviderServerIdSelector
 */
export interface UserSpecForProviderServerIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserSpecForProviderServerIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserSpecForProviderServerIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserSpecForProviderServerIdSelector#policy
   */
  readonly policy?: UserSpecForProviderServerIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderServerIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderServerIdSelector(obj: UserSpecForProviderServerIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserSpecForProviderServerIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecInitProviderHomeDirectoryMappings
 */
export interface UserSpecInitProviderHomeDirectoryMappings {
  /**
   * Represents an entry and a target.
   *
   * @schema UserSpecInitProviderHomeDirectoryMappings#entry
   */
  readonly entry?: string;

  /**
   * Represents the map target.
   *
   * @schema UserSpecInitProviderHomeDirectoryMappings#target
   */
  readonly target?: string;

}

/**
 * Converts an object of type 'UserSpecInitProviderHomeDirectoryMappings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecInitProviderHomeDirectoryMappings(obj: UserSpecInitProviderHomeDirectoryMappings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entry': obj.entry,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecInitProviderPosixProfile
 */
export interface UserSpecInitProviderPosixProfile {
  /**
   * The POSIX group ID used for all EFS operations by this user.
   *
   * @schema UserSpecInitProviderPosixProfile#gid
   */
  readonly gid?: number;

  /**
   * The secondary POSIX group IDs used for all EFS operations by this user.
   *
   * @schema UserSpecInitProviderPosixProfile#secondaryGids
   */
  readonly secondaryGids?: number[];

  /**
   * The POSIX user ID used for all EFS operations by this user.
   *
   * @schema UserSpecInitProviderPosixProfile#uid
   */
  readonly uid?: number;

}

/**
 * Converts an object of type 'UserSpecInitProviderPosixProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecInitProviderPosixProfile(obj: UserSpecInitProviderPosixProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gid': obj.gid,
    'secondaryGids': obj.secondaryGids?.map(y => y),
    'uid': obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecProviderConfigRefPolicy
 */
export interface UserSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRefPolicy(obj: UserSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRef
 */
export interface UserSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRef(obj: UserSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserSpecPublishConnectionDetailsToMetadata
 */
export interface UserSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToMetadata(obj: UserSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecForProviderRoleRefPolicy
 */
export interface UserSpecForProviderRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderRoleRefPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderRoleRefPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoleRefPolicy(obj: UserSpecForProviderRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserSpecForProviderRoleSelectorPolicy
 */
export interface UserSpecForProviderRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderRoleSelectorPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderRoleSelectorPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderRoleSelectorPolicy(obj: UserSpecForProviderRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecForProviderServerIdRefPolicy
 */
export interface UserSpecForProviderServerIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderServerIdRefPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderServerIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderServerIdRefPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderServerIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderServerIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderServerIdRefPolicy(obj: UserSpecForProviderServerIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserSpecForProviderServerIdSelectorPolicy
 */
export interface UserSpecForProviderServerIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderServerIdSelectorPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderServerIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderServerIdSelectorPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderServerIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderServerIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderServerIdSelectorPolicy(obj: UserSpecForProviderServerIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecProviderConfigRefPolicyResolution
 */
export enum UserSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecProviderConfigRefPolicyResolve
 */
export enum UserSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderRoleRefPolicyResolution
 */
export enum UserSpecForProviderRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderRoleRefPolicyResolve
 */
export enum UserSpecForProviderRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderRoleSelectorPolicyResolution
 */
export enum UserSpecForProviderRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderRoleSelectorPolicyResolve
 */
export enum UserSpecForProviderRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderServerIdRefPolicyResolution
 */
export enum UserSpecForProviderServerIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderServerIdRefPolicyResolve
 */
export enum UserSpecForProviderServerIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderServerIdSelectorPolicyResolution
 */
export enum UserSpecForProviderServerIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderServerIdSelectorPolicyResolve
 */
export enum UserSpecForProviderServerIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Workflow is the Schema for the Workflows API. Provides a AWS Transfer Workflow resource.
 *
 * @schema Workflow
 */
export class Workflow extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Workflow"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'transfer.aws.upbound.io/v1beta1',
    kind: 'Workflow',
  }

  /**
   * Renders a Kubernetes manifest for "Workflow".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkflowProps): any {
    return {
      ...Workflow.GVK,
      ...toJson_WorkflowProps(props),
    };
  }

  /**
   * Defines a "Workflow" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkflowProps) {
    super(scope, id, {
      ...Workflow.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Workflow.GVK,
      ...toJson_WorkflowProps(resolved),
    };
  }
}

/**
 * Workflow is the Schema for the Workflows API. Provides a AWS Transfer Workflow resource.
 *
 * @schema Workflow
 */
export interface WorkflowProps {
  /**
   * @schema Workflow#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WorkflowSpec defines the desired state of Workflow
   *
   * @schema Workflow#spec
   */
  readonly spec: WorkflowSpec;

}

/**
 * Converts an object of type 'WorkflowProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowProps(obj: WorkflowProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkflowSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkflowSpec defines the desired state of Workflow
 *
 * @schema WorkflowSpec
 */
export interface WorkflowSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema WorkflowSpec#deletionPolicy
   */
  readonly deletionPolicy?: WorkflowSpecDeletionPolicy;

  /**
   * @schema WorkflowSpec#forProvider
   */
  readonly forProvider: WorkflowSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema WorkflowSpec#initProvider
   */
  readonly initProvider?: WorkflowSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema WorkflowSpec#managementPolicies
   */
  readonly managementPolicies?: WorkflowSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WorkflowSpec#providerConfigRef
   */
  readonly providerConfigRef?: WorkflowSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WorkflowSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WorkflowSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WorkflowSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WorkflowSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WorkflowSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpec(obj: WorkflowSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WorkflowSpecForProvider(obj.forProvider),
    'initProvider': toJson_WorkflowSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_WorkflowSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_WorkflowSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WorkflowSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema WorkflowSpecDeletionPolicy
 */
export enum WorkflowSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WorkflowSpecForProvider
 */
export interface WorkflowSpecForProvider {
  /**
   * A textual description for the workflow.
   *
   * @schema WorkflowSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Specifies the steps (actions) to take if errors are encountered during execution of the workflow. See Workflow Steps below.
   *
   * @schema WorkflowSpecForProvider#onExceptionSteps
   */
  readonly onExceptionSteps?: WorkflowSpecForProviderOnExceptionSteps[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WorkflowSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the details for the steps that are in the specified workflow. See Workflow Steps below.
   *
   * @schema WorkflowSpecForProvider#steps
   */
  readonly steps?: WorkflowSpecForProviderSteps[];

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkflowSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkflowSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProvider(obj: WorkflowSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'onExceptionSteps': obj.onExceptionSteps?.map(y => toJson_WorkflowSpecForProviderOnExceptionSteps(y)),
    'region': obj.region,
    'steps': obj.steps?.map(y => toJson_WorkflowSpecForProviderSteps(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema WorkflowSpecInitProvider
 */
export interface WorkflowSpecInitProvider {
  /**
   * A textual description for the workflow.
   *
   * @schema WorkflowSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Specifies the steps (actions) to take if errors are encountered during execution of the workflow. See Workflow Steps below.
   *
   * @schema WorkflowSpecInitProvider#onExceptionSteps
   */
  readonly onExceptionSteps?: WorkflowSpecInitProviderOnExceptionSteps[];

  /**
   * Specifies the details for the steps that are in the specified workflow. See Workflow Steps below.
   *
   * @schema WorkflowSpecInitProvider#steps
   */
  readonly steps?: WorkflowSpecInitProviderSteps[];

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkflowSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkflowSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProvider(obj: WorkflowSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'onExceptionSteps': obj.onExceptionSteps?.map(y => toJson_WorkflowSpecInitProviderOnExceptionSteps(y)),
    'steps': obj.steps?.map(y => toJson_WorkflowSpecInitProviderSteps(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema WorkflowSpecManagementPolicies
 */
export enum WorkflowSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WorkflowSpecProviderConfigRef
 */
export interface WorkflowSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkflowSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkflowSpecProviderConfigRef#policy
   */
  readonly policy?: WorkflowSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkflowSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecProviderConfigRef(obj: WorkflowSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkflowSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WorkflowSpecPublishConnectionDetailsTo
 */
export interface WorkflowSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WorkflowSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WorkflowSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WorkflowSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WorkflowSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WorkflowSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WorkflowSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecPublishConnectionDetailsTo(obj: WorkflowSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WorkflowSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WorkflowSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WorkflowSpecWriteConnectionSecretToRef
 */
export interface WorkflowSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WorkflowSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WorkflowSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WorkflowSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecWriteConnectionSecretToRef(obj: WorkflowSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionSteps
 */
export interface WorkflowSpecForProviderOnExceptionSteps {
  /**
   * Details for a step that performs a file copy. See Copy Step Details below.
   *
   * @schema WorkflowSpecForProviderOnExceptionSteps#copyStepDetails
   */
  readonly copyStepDetails?: WorkflowSpecForProviderOnExceptionStepsCopyStepDetails[];

  /**
   * Details for a step that invokes a lambda function.
   *
   * @schema WorkflowSpecForProviderOnExceptionSteps#customStepDetails
   */
  readonly customStepDetails?: WorkflowSpecForProviderOnExceptionStepsCustomStepDetails[];

  /**
   * Details for a step that decrypts the file.
   *
   * @schema WorkflowSpecForProviderOnExceptionSteps#decryptStepDetails
   */
  readonly decryptStepDetails?: WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails[];

  /**
   * Details for a step that deletes the file.
   *
   * @schema WorkflowSpecForProviderOnExceptionSteps#deleteStepDetails
   */
  readonly deleteStepDetails?: WorkflowSpecForProviderOnExceptionStepsDeleteStepDetails[];

  /**
   * Details for a step that creates one or more tags.
   *
   * @schema WorkflowSpecForProviderOnExceptionSteps#tagStepDetails
   */
  readonly tagStepDetails?: WorkflowSpecForProviderOnExceptionStepsTagStepDetails[];

  /**
   * One of the following step types are supported. COPY, CUSTOM, DECRYPT, DELETE, and TAG.
   *
   * @schema WorkflowSpecForProviderOnExceptionSteps#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionSteps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionSteps(obj: WorkflowSpecForProviderOnExceptionSteps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'copyStepDetails': obj.copyStepDetails?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsCopyStepDetails(y)),
    'customStepDetails': obj.customStepDetails?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsCustomStepDetails(y)),
    'decryptStepDetails': obj.decryptStepDetails?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails(y)),
    'deleteStepDetails': obj.deleteStepDetails?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsDeleteStepDetails(y)),
    'tagStepDetails': obj.tagStepDetails?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsTagStepDetails(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderSteps
 */
export interface WorkflowSpecForProviderSteps {
  /**
   * Details for a step that performs a file copy. See Copy Step Details below.
   *
   * @schema WorkflowSpecForProviderSteps#copyStepDetails
   */
  readonly copyStepDetails?: WorkflowSpecForProviderStepsCopyStepDetails[];

  /**
   * Details for a step that invokes a lambda function.
   *
   * @schema WorkflowSpecForProviderSteps#customStepDetails
   */
  readonly customStepDetails?: WorkflowSpecForProviderStepsCustomStepDetails[];

  /**
   * Details for a step that decrypts the file.
   *
   * @schema WorkflowSpecForProviderSteps#decryptStepDetails
   */
  readonly decryptStepDetails?: WorkflowSpecForProviderStepsDecryptStepDetails[];

  /**
   * Details for a step that deletes the file.
   *
   * @schema WorkflowSpecForProviderSteps#deleteStepDetails
   */
  readonly deleteStepDetails?: WorkflowSpecForProviderStepsDeleteStepDetails[];

  /**
   * Details for a step that creates one or more tags.
   *
   * @schema WorkflowSpecForProviderSteps#tagStepDetails
   */
  readonly tagStepDetails?: WorkflowSpecForProviderStepsTagStepDetails[];

  /**
   * One of the following step types are supported. COPY, CUSTOM, DECRYPT, DELETE, and TAG.
   *
   * @schema WorkflowSpecForProviderSteps#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderSteps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderSteps(obj: WorkflowSpecForProviderSteps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'copyStepDetails': obj.copyStepDetails?.map(y => toJson_WorkflowSpecForProviderStepsCopyStepDetails(y)),
    'customStepDetails': obj.customStepDetails?.map(y => toJson_WorkflowSpecForProviderStepsCustomStepDetails(y)),
    'decryptStepDetails': obj.decryptStepDetails?.map(y => toJson_WorkflowSpecForProviderStepsDecryptStepDetails(y)),
    'deleteStepDetails': obj.deleteStepDetails?.map(y => toJson_WorkflowSpecForProviderStepsDeleteStepDetails(y)),
    'tagStepDetails': obj.tagStepDetails?.map(y => toJson_WorkflowSpecForProviderStepsTagStepDetails(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionSteps
 */
export interface WorkflowSpecInitProviderOnExceptionSteps {
  /**
   * Details for a step that performs a file copy. See Copy Step Details below.
   *
   * @schema WorkflowSpecInitProviderOnExceptionSteps#copyStepDetails
   */
  readonly copyStepDetails?: WorkflowSpecInitProviderOnExceptionStepsCopyStepDetails[];

  /**
   * Details for a step that invokes a lambda function.
   *
   * @schema WorkflowSpecInitProviderOnExceptionSteps#customStepDetails
   */
  readonly customStepDetails?: WorkflowSpecInitProviderOnExceptionStepsCustomStepDetails[];

  /**
   * Details for a step that decrypts the file.
   *
   * @schema WorkflowSpecInitProviderOnExceptionSteps#decryptStepDetails
   */
  readonly decryptStepDetails?: WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails[];

  /**
   * Details for a step that deletes the file.
   *
   * @schema WorkflowSpecInitProviderOnExceptionSteps#deleteStepDetails
   */
  readonly deleteStepDetails?: WorkflowSpecInitProviderOnExceptionStepsDeleteStepDetails[];

  /**
   * Details for a step that creates one or more tags.
   *
   * @schema WorkflowSpecInitProviderOnExceptionSteps#tagStepDetails
   */
  readonly tagStepDetails?: WorkflowSpecInitProviderOnExceptionStepsTagStepDetails[];

  /**
   * One of the following step types are supported. COPY, CUSTOM, DECRYPT, DELETE, and TAG.
   *
   * @schema WorkflowSpecInitProviderOnExceptionSteps#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionSteps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionSteps(obj: WorkflowSpecInitProviderOnExceptionSteps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'copyStepDetails': obj.copyStepDetails?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsCopyStepDetails(y)),
    'customStepDetails': obj.customStepDetails?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsCustomStepDetails(y)),
    'decryptStepDetails': obj.decryptStepDetails?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails(y)),
    'deleteStepDetails': obj.deleteStepDetails?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsDeleteStepDetails(y)),
    'tagStepDetails': obj.tagStepDetails?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsTagStepDetails(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderSteps
 */
export interface WorkflowSpecInitProviderSteps {
  /**
   * Details for a step that performs a file copy. See Copy Step Details below.
   *
   * @schema WorkflowSpecInitProviderSteps#copyStepDetails
   */
  readonly copyStepDetails?: WorkflowSpecInitProviderStepsCopyStepDetails[];

  /**
   * Details for a step that invokes a lambda function.
   *
   * @schema WorkflowSpecInitProviderSteps#customStepDetails
   */
  readonly customStepDetails?: WorkflowSpecInitProviderStepsCustomStepDetails[];

  /**
   * Details for a step that decrypts the file.
   *
   * @schema WorkflowSpecInitProviderSteps#decryptStepDetails
   */
  readonly decryptStepDetails?: WorkflowSpecInitProviderStepsDecryptStepDetails[];

  /**
   * Details for a step that deletes the file.
   *
   * @schema WorkflowSpecInitProviderSteps#deleteStepDetails
   */
  readonly deleteStepDetails?: WorkflowSpecInitProviderStepsDeleteStepDetails[];

  /**
   * Details for a step that creates one or more tags.
   *
   * @schema WorkflowSpecInitProviderSteps#tagStepDetails
   */
  readonly tagStepDetails?: WorkflowSpecInitProviderStepsTagStepDetails[];

  /**
   * One of the following step types are supported. COPY, CUSTOM, DECRYPT, DELETE, and TAG.
   *
   * @schema WorkflowSpecInitProviderSteps#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderSteps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderSteps(obj: WorkflowSpecInitProviderSteps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'copyStepDetails': obj.copyStepDetails?.map(y => toJson_WorkflowSpecInitProviderStepsCopyStepDetails(y)),
    'customStepDetails': obj.customStepDetails?.map(y => toJson_WorkflowSpecInitProviderStepsCustomStepDetails(y)),
    'decryptStepDetails': obj.decryptStepDetails?.map(y => toJson_WorkflowSpecInitProviderStepsDecryptStepDetails(y)),
    'deleteStepDetails': obj.deleteStepDetails?.map(y => toJson_WorkflowSpecInitProviderStepsDeleteStepDetails(y)),
    'tagStepDetails': obj.tagStepDetails?.map(y => toJson_WorkflowSpecInitProviderStepsTagStepDetails(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkflowSpecProviderConfigRefPolicy
 */
export interface WorkflowSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkflowSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WorkflowSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkflowSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WorkflowSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkflowSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecProviderConfigRefPolicy(obj: WorkflowSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WorkflowSpecPublishConnectionDetailsToConfigRef
 */
export interface WorkflowSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WorkflowSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WorkflowSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecPublishConnectionDetailsToConfigRef(obj: WorkflowSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkflowSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WorkflowSpecPublishConnectionDetailsToMetadata
 */
export interface WorkflowSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkflowSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecPublishConnectionDetailsToMetadata(obj: WorkflowSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetails
 */
export interface WorkflowSpecForProviderOnExceptionStepsCopyStepDetails {
  /**
   * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetails#destinationFileLocation
   */
  readonly destinationFileLocation?: WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation[];

  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetails#name
   */
  readonly name?: string;

  /**
   * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE. Valid values are TRUE and FALSE.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetails#overwriteExisting
   */
  readonly overwriteExisting?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsCopyStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsCopyStepDetails(obj: WorkflowSpecForProviderOnExceptionStepsCopyStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationFileLocation': obj.destinationFileLocation?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation(y)),
    'name': obj.name,
    'overwriteExisting': obj.overwriteExisting,
    'sourceFileLocation': obj.sourceFileLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsCustomStepDetails
 */
export interface WorkflowSpecForProviderOnExceptionStepsCustomStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCustomStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCustomStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * The ARN for the lambda function that is being called.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCustomStepDetails#target
   */
  readonly target?: string;

  /**
   * Timeout, in seconds, for the step.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCustomStepDetails#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsCustomStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsCustomStepDetails(obj: WorkflowSpecForProviderOnExceptionStepsCustomStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
    'target': obj.target,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails
 */
export interface WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails {
  /**
   * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails#destinationFileLocation
   */
  readonly destinationFileLocation?: WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation[];

  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails#name
   */
  readonly name?: string;

  /**
   * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE. Valid values are TRUE and FALSE.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails#overwriteExisting
   */
  readonly overwriteExisting?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * One of the following step types are supported. COPY, CUSTOM, DECRYPT, DELETE, and TAG.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails(obj: WorkflowSpecForProviderOnExceptionStepsDecryptStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationFileLocation': obj.destinationFileLocation?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation(y)),
    'name': obj.name,
    'overwriteExisting': obj.overwriteExisting,
    'sourceFileLocation': obj.sourceFileLocation,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsDeleteStepDetails
 */
export interface WorkflowSpecForProviderOnExceptionStepsDeleteStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDeleteStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDeleteStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsDeleteStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsDeleteStepDetails(obj: WorkflowSpecForProviderOnExceptionStepsDeleteStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsTagStepDetails
 */
export interface WorkflowSpecForProviderOnExceptionStepsTagStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsTagStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsTagStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsTagStepDetails#tags
   */
  readonly tags?: WorkflowSpecForProviderOnExceptionStepsTagStepDetailsTags[];

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsTagStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsTagStepDetails(obj: WorkflowSpecForProviderOnExceptionStepsTagStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
    'tags': obj.tags?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsTagStepDetailsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsCopyStepDetails
 */
export interface WorkflowSpecForProviderStepsCopyStepDetails {
  /**
   * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
   *
   * @schema WorkflowSpecForProviderStepsCopyStepDetails#destinationFileLocation
   */
  readonly destinationFileLocation?: WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocation[];

  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecForProviderStepsCopyStepDetails#name
   */
  readonly name?: string;

  /**
   * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE. Valid values are TRUE and FALSE.
   *
   * @schema WorkflowSpecForProviderStepsCopyStepDetails#overwriteExisting
   */
  readonly overwriteExisting?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecForProviderStepsCopyStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsCopyStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsCopyStepDetails(obj: WorkflowSpecForProviderStepsCopyStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationFileLocation': obj.destinationFileLocation?.map(y => toJson_WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocation(y)),
    'name': obj.name,
    'overwriteExisting': obj.overwriteExisting,
    'sourceFileLocation': obj.sourceFileLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsCustomStepDetails
 */
export interface WorkflowSpecForProviderStepsCustomStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * The ARN for the lambda function that is being called.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetails#target
   */
  readonly target?: string;

  /**
   * Reference to a Function in lambda to populate target.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetails#targetRef
   */
  readonly targetRef?: WorkflowSpecForProviderStepsCustomStepDetailsTargetRef;

  /**
   * Selector for a Function in lambda to populate target.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetails#targetSelector
   */
  readonly targetSelector?: WorkflowSpecForProviderStepsCustomStepDetailsTargetSelector;

  /**
   * Timeout, in seconds, for the step.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetails#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsCustomStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsCustomStepDetails(obj: WorkflowSpecForProviderStepsCustomStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
    'target': obj.target,
    'targetRef': toJson_WorkflowSpecForProviderStepsCustomStepDetailsTargetRef(obj.targetRef),
    'targetSelector': toJson_WorkflowSpecForProviderStepsCustomStepDetailsTargetSelector(obj.targetSelector),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsDecryptStepDetails
 */
export interface WorkflowSpecForProviderStepsDecryptStepDetails {
  /**
   * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
   *
   * @schema WorkflowSpecForProviderStepsDecryptStepDetails#destinationFileLocation
   */
  readonly destinationFileLocation?: WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocation[];

  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecForProviderStepsDecryptStepDetails#name
   */
  readonly name?: string;

  /**
   * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE. Valid values are TRUE and FALSE.
   *
   * @schema WorkflowSpecForProviderStepsDecryptStepDetails#overwriteExisting
   */
  readonly overwriteExisting?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecForProviderStepsDecryptStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * One of the following step types are supported. COPY, CUSTOM, DECRYPT, DELETE, and TAG.
   *
   * @schema WorkflowSpecForProviderStepsDecryptStepDetails#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsDecryptStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsDecryptStepDetails(obj: WorkflowSpecForProviderStepsDecryptStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationFileLocation': obj.destinationFileLocation?.map(y => toJson_WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocation(y)),
    'name': obj.name,
    'overwriteExisting': obj.overwriteExisting,
    'sourceFileLocation': obj.sourceFileLocation,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsDeleteStepDetails
 */
export interface WorkflowSpecForProviderStepsDeleteStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecForProviderStepsDeleteStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecForProviderStepsDeleteStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsDeleteStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsDeleteStepDetails(obj: WorkflowSpecForProviderStepsDeleteStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsTagStepDetails
 */
export interface WorkflowSpecForProviderStepsTagStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecForProviderStepsTagStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecForProviderStepsTagStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkflowSpecForProviderStepsTagStepDetails#tags
   */
  readonly tags?: WorkflowSpecForProviderStepsTagStepDetailsTags[];

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsTagStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsTagStepDetails(obj: WorkflowSpecForProviderStepsTagStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
    'tags': obj.tags?.map(y => toJson_WorkflowSpecForProviderStepsTagStepDetailsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetails
 */
export interface WorkflowSpecInitProviderOnExceptionStepsCopyStepDetails {
  /**
   * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetails#destinationFileLocation
   */
  readonly destinationFileLocation?: WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation[];

  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetails#name
   */
  readonly name?: string;

  /**
   * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE. Valid values are TRUE and FALSE.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetails#overwriteExisting
   */
  readonly overwriteExisting?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsCopyStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsCopyStepDetails(obj: WorkflowSpecInitProviderOnExceptionStepsCopyStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationFileLocation': obj.destinationFileLocation?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation(y)),
    'name': obj.name,
    'overwriteExisting': obj.overwriteExisting,
    'sourceFileLocation': obj.sourceFileLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsCustomStepDetails
 */
export interface WorkflowSpecInitProviderOnExceptionStepsCustomStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCustomStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCustomStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * The ARN for the lambda function that is being called.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCustomStepDetails#target
   */
  readonly target?: string;

  /**
   * Timeout, in seconds, for the step.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCustomStepDetails#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsCustomStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsCustomStepDetails(obj: WorkflowSpecInitProviderOnExceptionStepsCustomStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
    'target': obj.target,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails
 */
export interface WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails {
  /**
   * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails#destinationFileLocation
   */
  readonly destinationFileLocation?: WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation[];

  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails#name
   */
  readonly name?: string;

  /**
   * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE. Valid values are TRUE and FALSE.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails#overwriteExisting
   */
  readonly overwriteExisting?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * One of the following step types are supported. COPY, CUSTOM, DECRYPT, DELETE, and TAG.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails(obj: WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationFileLocation': obj.destinationFileLocation?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation(y)),
    'name': obj.name,
    'overwriteExisting': obj.overwriteExisting,
    'sourceFileLocation': obj.sourceFileLocation,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsDeleteStepDetails
 */
export interface WorkflowSpecInitProviderOnExceptionStepsDeleteStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDeleteStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDeleteStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsDeleteStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsDeleteStepDetails(obj: WorkflowSpecInitProviderOnExceptionStepsDeleteStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsTagStepDetails
 */
export interface WorkflowSpecInitProviderOnExceptionStepsTagStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsTagStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsTagStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsTagStepDetails#tags
   */
  readonly tags?: WorkflowSpecInitProviderOnExceptionStepsTagStepDetailsTags[];

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsTagStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsTagStepDetails(obj: WorkflowSpecInitProviderOnExceptionStepsTagStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
    'tags': obj.tags?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsTagStepDetailsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsCopyStepDetails
 */
export interface WorkflowSpecInitProviderStepsCopyStepDetails {
  /**
   * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
   *
   * @schema WorkflowSpecInitProviderStepsCopyStepDetails#destinationFileLocation
   */
  readonly destinationFileLocation?: WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocation[];

  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecInitProviderStepsCopyStepDetails#name
   */
  readonly name?: string;

  /**
   * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE. Valid values are TRUE and FALSE.
   *
   * @schema WorkflowSpecInitProviderStepsCopyStepDetails#overwriteExisting
   */
  readonly overwriteExisting?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecInitProviderStepsCopyStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsCopyStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsCopyStepDetails(obj: WorkflowSpecInitProviderStepsCopyStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationFileLocation': obj.destinationFileLocation?.map(y => toJson_WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocation(y)),
    'name': obj.name,
    'overwriteExisting': obj.overwriteExisting,
    'sourceFileLocation': obj.sourceFileLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsCustomStepDetails
 */
export interface WorkflowSpecInitProviderStepsCustomStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecInitProviderStepsCustomStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecInitProviderStepsCustomStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * Timeout, in seconds, for the step.
   *
   * @schema WorkflowSpecInitProviderStepsCustomStepDetails#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsCustomStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsCustomStepDetails(obj: WorkflowSpecInitProviderStepsCustomStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsDecryptStepDetails
 */
export interface WorkflowSpecInitProviderStepsDecryptStepDetails {
  /**
   * Specifies the location for the file being copied. Use ${Transfer:username} in this field to parametrize the destination prefix by username.
   *
   * @schema WorkflowSpecInitProviderStepsDecryptStepDetails#destinationFileLocation
   */
  readonly destinationFileLocation?: WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocation[];

  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecInitProviderStepsDecryptStepDetails#name
   */
  readonly name?: string;

  /**
   * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE. Valid values are TRUE and FALSE.
   *
   * @schema WorkflowSpecInitProviderStepsDecryptStepDetails#overwriteExisting
   */
  readonly overwriteExisting?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecInitProviderStepsDecryptStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * One of the following step types are supported. COPY, CUSTOM, DECRYPT, DELETE, and TAG.
   *
   * @schema WorkflowSpecInitProviderStepsDecryptStepDetails#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsDecryptStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsDecryptStepDetails(obj: WorkflowSpecInitProviderStepsDecryptStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationFileLocation': obj.destinationFileLocation?.map(y => toJson_WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocation(y)),
    'name': obj.name,
    'overwriteExisting': obj.overwriteExisting,
    'sourceFileLocation': obj.sourceFileLocation,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsDeleteStepDetails
 */
export interface WorkflowSpecInitProviderStepsDeleteStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecInitProviderStepsDeleteStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecInitProviderStepsDeleteStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsDeleteStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsDeleteStepDetails(obj: WorkflowSpecInitProviderStepsDeleteStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsTagStepDetails
 */
export interface WorkflowSpecInitProviderStepsTagStepDetails {
  /**
   * The name of the step, used as an identifier.
   *
   * @schema WorkflowSpecInitProviderStepsTagStepDetails#name
   */
  readonly name?: string;

  /**
   * Specifies which file to use as input to the workflow step: either the output from the previous step, or the originally uploaded file for the workflow. Enter ${previous.file} to use the previous file as the input. In this case, this workflow step uses the output file from the previous workflow step as input. This is the default value. Enter ${original.file} to use the originally-uploaded file location as input for this step.
   *
   * @schema WorkflowSpecInitProviderStepsTagStepDetails#sourceFileLocation
   */
  readonly sourceFileLocation?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema WorkflowSpecInitProviderStepsTagStepDetails#tags
   */
  readonly tags?: WorkflowSpecInitProviderStepsTagStepDetailsTags[];

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsTagStepDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsTagStepDetails(obj: WorkflowSpecInitProviderStepsTagStepDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'sourceFileLocation': obj.sourceFileLocation,
    'tags': obj.tags?.map(y => toJson_WorkflowSpecInitProviderStepsTagStepDetailsTags(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkflowSpecProviderConfigRefPolicyResolution
 */
export enum WorkflowSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkflowSpecProviderConfigRefPolicyResolve
 */
export enum WorkflowSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WorkflowSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WorkflowSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkflowSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkflowSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecPublishConnectionDetailsToConfigRefPolicy(obj: WorkflowSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation
 */
export interface WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation {
  /**
   * Specifies the details for the EFS file being copied.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation#efsFileLocation
   */
  readonly efsFileLocation?: WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation[];

  /**
   * Specifies the details for the S3 file being copied.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation#s3FileLocation
   */
  readonly s3FileLocation?: WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation[];

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation(obj: WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'efsFileLocation': obj.efsFileLocation?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation(y)),
    's3FileLocation': obj.s3FileLocation?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation
 */
export interface WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation {
  /**
   * Specifies the details for the EFS file being copied.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation#efsFileLocation
   */
  readonly efsFileLocation?: WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation[];

  /**
   * Specifies the details for the S3 file being copied.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation#s3FileLocation
   */
  readonly s3FileLocation?: WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation[];

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation(obj: WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'efsFileLocation': obj.efsFileLocation?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation(y)),
    's3FileLocation': obj.s3FileLocation?.map(y => toJson_WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsTagStepDetailsTags
 */
export interface WorkflowSpecForProviderOnExceptionStepsTagStepDetailsTags {
  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsTagStepDetailsTags#key
   */
  readonly key?: string;

  /**
   * The value that corresponds to the key.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsTagStepDetailsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsTagStepDetailsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsTagStepDetailsTags(obj: WorkflowSpecForProviderOnExceptionStepsTagStepDetailsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocation
 */
export interface WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocation {
  /**
   * Specifies the details for the EFS file being copied.
   *
   * @schema WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocation#efsFileLocation
   */
  readonly efsFileLocation?: WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation[];

  /**
   * Specifies the details for the S3 file being copied.
   *
   * @schema WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocation#s3FileLocation
   */
  readonly s3FileLocation?: WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation[];

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocation(obj: WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'efsFileLocation': obj.efsFileLocation?.map(y => toJson_WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation(y)),
    's3FileLocation': obj.s3FileLocation?.map(y => toJson_WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate target.
 *
 * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetRef
 */
export interface WorkflowSpecForProviderStepsCustomStepDetailsTargetRef {
  /**
   * Name of the referenced object.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetRef#policy
   */
  readonly policy?: WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicy;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsCustomStepDetailsTargetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsCustomStepDetailsTargetRef(obj: WorkflowSpecForProviderStepsCustomStepDetailsTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate target.
 *
 * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetSelector
 */
export interface WorkflowSpecForProviderStepsCustomStepDetailsTargetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetSelector#policy
   */
  readonly policy?: WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicy;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsCustomStepDetailsTargetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsCustomStepDetailsTargetSelector(obj: WorkflowSpecForProviderStepsCustomStepDetailsTargetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocation
 */
export interface WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocation {
  /**
   * Specifies the details for the EFS file being copied.
   *
   * @schema WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocation#efsFileLocation
   */
  readonly efsFileLocation?: WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation[];

  /**
   * Specifies the details for the S3 file being copied.
   *
   * @schema WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocation#s3FileLocation
   */
  readonly s3FileLocation?: WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation[];

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocation(obj: WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'efsFileLocation': obj.efsFileLocation?.map(y => toJson_WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation(y)),
    's3FileLocation': obj.s3FileLocation?.map(y => toJson_WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsTagStepDetailsTags
 */
export interface WorkflowSpecForProviderStepsTagStepDetailsTags {
  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecForProviderStepsTagStepDetailsTags#key
   */
  readonly key?: string;

  /**
   * The value that corresponds to the key.
   *
   * @schema WorkflowSpecForProviderStepsTagStepDetailsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsTagStepDetailsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsTagStepDetailsTags(obj: WorkflowSpecForProviderStepsTagStepDetailsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation
 */
export interface WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation {
  /**
   * Specifies the details for the EFS file being copied.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation#efsFileLocation
   */
  readonly efsFileLocation?: WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation[];

  /**
   * Specifies the details for the S3 file being copied.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation#s3FileLocation
   */
  readonly s3FileLocation?: WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation[];

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation(obj: WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'efsFileLocation': obj.efsFileLocation?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation(y)),
    's3FileLocation': obj.s3FileLocation?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation
 */
export interface WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation {
  /**
   * Specifies the details for the EFS file being copied.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation#efsFileLocation
   */
  readonly efsFileLocation?: WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation[];

  /**
   * Specifies the details for the S3 file being copied.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation#s3FileLocation
   */
  readonly s3FileLocation?: WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation[];

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation(obj: WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'efsFileLocation': obj.efsFileLocation?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation(y)),
    's3FileLocation': obj.s3FileLocation?.map(y => toJson_WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsTagStepDetailsTags
 */
export interface WorkflowSpecInitProviderOnExceptionStepsTagStepDetailsTags {
  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsTagStepDetailsTags#key
   */
  readonly key?: string;

  /**
   * The value that corresponds to the key.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsTagStepDetailsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsTagStepDetailsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsTagStepDetailsTags(obj: WorkflowSpecInitProviderOnExceptionStepsTagStepDetailsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocation
 */
export interface WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocation {
  /**
   * Specifies the details for the EFS file being copied.
   *
   * @schema WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocation#efsFileLocation
   */
  readonly efsFileLocation?: WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation[];

  /**
   * Specifies the details for the S3 file being copied.
   *
   * @schema WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocation#s3FileLocation
   */
  readonly s3FileLocation?: WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation[];

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocation(obj: WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'efsFileLocation': obj.efsFileLocation?.map(y => toJson_WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation(y)),
    's3FileLocation': obj.s3FileLocation?.map(y => toJson_WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocation
 */
export interface WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocation {
  /**
   * Specifies the details for the EFS file being copied.
   *
   * @schema WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocation#efsFileLocation
   */
  readonly efsFileLocation?: WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation[];

  /**
   * Specifies the details for the S3 file being copied.
   *
   * @schema WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocation#s3FileLocation
   */
  readonly s3FileLocation?: WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation[];

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocation(obj: WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'efsFileLocation': obj.efsFileLocation?.map(y => toJson_WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation(y)),
    's3FileLocation': obj.s3FileLocation?.map(y => toJson_WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsTagStepDetailsTags
 */
export interface WorkflowSpecInitProviderStepsTagStepDetailsTags {
  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecInitProviderStepsTagStepDetailsTags#key
   */
  readonly key?: string;

  /**
   * The value that corresponds to the key.
   *
   * @schema WorkflowSpecInitProviderStepsTagStepDetailsTags#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsTagStepDetailsTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsTagStepDetailsTags(obj: WorkflowSpecInitProviderStepsTagStepDetailsTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WorkflowSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation
 */
export interface WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation {
  /**
   * The ID of the file system, assigned by Amazon EFS.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * The pathname for the folder being used by a workflow.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation(obj: WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemId': obj.fileSystemId,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation
 */
export interface WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation {
  /**
   * Specifies the S3 bucket for the customer input file.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation#bucket
   */
  readonly bucket?: string;

  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation(obj: WorkflowSpecForProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation
 */
export interface WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation {
  /**
   * The ID of the file system, assigned by Amazon EFS.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * The pathname for the folder being used by a workflow.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation(obj: WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemId': obj.fileSystemId,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation
 */
export interface WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation {
  /**
   * Specifies the S3 bucket for the customer input file.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation#bucket
   */
  readonly bucket?: string;

  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation(obj: WorkflowSpecForProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation
 */
export interface WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation {
  /**
   * The ID of the file system, assigned by Amazon EFS.
   *
   * @schema WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * The pathname for the folder being used by a workflow.
   *
   * @schema WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation(obj: WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemId': obj.fileSystemId,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation
 */
export interface WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation {
  /**
   * Specifies the S3 bucket for the customer input file.
   *
   * @schema WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation#bucket
   */
  readonly bucket?: string;

  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation(obj: WorkflowSpecForProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicy
 */
export interface WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicy#resolution
   */
  readonly resolution?: WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicy#resolve
   */
  readonly resolve?: WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicyResolve;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicy(obj: WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicy
 */
export interface WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicy#resolution
   */
  readonly resolution?: WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicy#resolve
   */
  readonly resolve?: WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicy(obj: WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation
 */
export interface WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation {
  /**
   * The ID of the file system, assigned by Amazon EFS.
   *
   * @schema WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * The pathname for the folder being used by a workflow.
   *
   * @schema WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation(obj: WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemId': obj.fileSystemId,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation
 */
export interface WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation {
  /**
   * Specifies the S3 bucket for the customer input file.
   *
   * @schema WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation#bucket
   */
  readonly bucket?: string;

  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation(obj: WorkflowSpecForProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation
 */
export interface WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation {
  /**
   * The ID of the file system, assigned by Amazon EFS.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * The pathname for the folder being used by a workflow.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation(obj: WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationEfsFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemId': obj.fileSystemId,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation
 */
export interface WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation {
  /**
   * Specifies the S3 bucket for the customer input file.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation#bucket
   */
  readonly bucket?: string;

  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation(obj: WorkflowSpecInitProviderOnExceptionStepsCopyStepDetailsDestinationFileLocationS3FileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation
 */
export interface WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation {
  /**
   * The ID of the file system, assigned by Amazon EFS.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * The pathname for the folder being used by a workflow.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation(obj: WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemId': obj.fileSystemId,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation
 */
export interface WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation {
  /**
   * Specifies the S3 bucket for the customer input file.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation#bucket
   */
  readonly bucket?: string;

  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation(obj: WorkflowSpecInitProviderOnExceptionStepsDecryptStepDetailsDestinationFileLocationS3FileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation
 */
export interface WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation {
  /**
   * The ID of the file system, assigned by Amazon EFS.
   *
   * @schema WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * The pathname for the folder being used by a workflow.
   *
   * @schema WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation(obj: WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationEfsFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemId': obj.fileSystemId,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation
 */
export interface WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation {
  /**
   * Specifies the S3 bucket for the customer input file.
   *
   * @schema WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation#bucket
   */
  readonly bucket?: string;

  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation(obj: WorkflowSpecInitProviderStepsCopyStepDetailsDestinationFileLocationS3FileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation
 */
export interface WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation {
  /**
   * The ID of the file system, assigned by Amazon EFS.
   *
   * @schema WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * The pathname for the folder being used by a workflow.
   *
   * @schema WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation(obj: WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationEfsFileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileSystemId': obj.fileSystemId,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation
 */
export interface WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation {
  /**
   * Specifies the S3 bucket for the customer input file.
   *
   * @schema WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation#bucket
   */
  readonly bucket?: string;

  /**
   * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
   *
   * @schema WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation#key
   */
  readonly key?: string;

}

/**
 * Converts an object of type 'WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation(obj: WorkflowSpecInitProviderStepsDecryptStepDetailsDestinationFileLocationS3FileLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicyResolution
 */
export enum WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicyResolve
 */
export enum WorkflowSpecForProviderStepsCustomStepDetailsTargetRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicyResolution
 */
export enum WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicyResolve
 */
export enum WorkflowSpecForProviderStepsCustomStepDetailsTargetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

