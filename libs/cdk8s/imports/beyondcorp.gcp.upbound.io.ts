// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AppConnection is the Schema for the AppConnections API. A BeyondCorp AppConnection resource represents a BeyondCorp protected AppConnection to a remote application.
 *
 * @schema AppConnection
 */
export class AppConnection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AppConnection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'beyondcorp.gcp.upbound.io/v1beta1',
    kind: 'AppConnection',
  }

  /**
   * Renders a Kubernetes manifest for "AppConnection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppConnectionProps): any {
    return {
      ...AppConnection.GVK,
      ...toJson_AppConnectionProps(props),
    };
  }

  /**
   * Defines a "AppConnection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppConnectionProps) {
    super(scope, id, {
      ...AppConnection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AppConnection.GVK,
      ...toJson_AppConnectionProps(resolved),
    };
  }
}

/**
 * AppConnection is the Schema for the AppConnections API. A BeyondCorp AppConnection resource represents a BeyondCorp protected AppConnection to a remote application.
 *
 * @schema AppConnection
 */
export interface AppConnectionProps {
  /**
   * @schema AppConnection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppConnectionSpec defines the desired state of AppConnection
   *
   * @schema AppConnection#spec
   */
  readonly spec: AppConnectionSpec;

}

/**
 * Converts an object of type 'AppConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionProps(obj: AppConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppConnectionSpec defines the desired state of AppConnection
 *
 * @schema AppConnectionSpec
 */
export interface AppConnectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppConnectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: AppConnectionSpecDeletionPolicy;

  /**
   * @schema AppConnectionSpec#forProvider
   */
  readonly forProvider: AppConnectionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AppConnectionSpec#initProvider
   */
  readonly initProvider?: AppConnectionSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AppConnectionSpec#managementPolicies
   */
  readonly managementPolicies?: AppConnectionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppConnectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: AppConnectionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppConnectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppConnectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppConnectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppConnectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpec(obj: AppConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppConnectionSpecForProvider(obj.forProvider),
    'initProvider': toJson_AppConnectionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AppConnectionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AppConnectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppConnectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppConnectionSpecDeletionPolicy
 */
export enum AppConnectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppConnectionSpecForProvider
 */
export interface AppConnectionSpecForProvider {
  /**
   * Address of the remote application endpoint for the BeyondCorp AppConnection. Structure is documented below.
   *
   * @schema AppConnectionSpecForProvider#applicationEndpoint
   */
  readonly applicationEndpoint?: AppConnectionSpecForProviderApplicationEndpoint[];

  /**
   * List of AppConnectors that are authorised to be associated with this AppConnection
   *
   * @schema AppConnectionSpecForProvider#connectors
   */
  readonly connectors?: string[];

  /**
   * An arbitrary user-provided name for the AppConnection.
   *
   * @schema AppConnectionSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Gateway used by the AppConnection. Structure is documented below.
   *
   * @schema AppConnectionSpecForProvider#gateway
   */
  readonly gateway?: AppConnectionSpecForProviderGateway[];

  /**
   * Resource labels to represent user provided metadata.
   *
   * @schema AppConnectionSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * ID of the AppConnection.
   *
   * @schema AppConnectionSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AppConnectionSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region of the AppConnection.
   *
   * @schema AppConnectionSpecForProvider#region
   */
  readonly region?: string;

  /**
   * The type of hosting used by the gateway. Refer to https://cloud.google.com/beyondcorp/docs/reference/rest/v1/projects.locations.appConnections#Type_1 for a list of possible values.
   *
   * @schema AppConnectionSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppConnectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecForProvider(obj: AppConnectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationEndpoint': obj.applicationEndpoint?.map(y => toJson_AppConnectionSpecForProviderApplicationEndpoint(y)),
    'connectors': obj.connectors?.map(y => y),
    'displayName': obj.displayName,
    'gateway': obj.gateway?.map(y => toJson_AppConnectionSpecForProviderGateway(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'project': obj.project,
    'region': obj.region,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AppConnectionSpecInitProvider
 */
export interface AppConnectionSpecInitProvider {
  /**
   * Address of the remote application endpoint for the BeyondCorp AppConnection. Structure is documented below.
   *
   * @schema AppConnectionSpecInitProvider#applicationEndpoint
   */
  readonly applicationEndpoint?: AppConnectionSpecInitProviderApplicationEndpoint[];

  /**
   * List of AppConnectors that are authorised to be associated with this AppConnection
   *
   * @schema AppConnectionSpecInitProvider#connectors
   */
  readonly connectors?: string[];

  /**
   * An arbitrary user-provided name for the AppConnection.
   *
   * @schema AppConnectionSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Gateway used by the AppConnection. Structure is documented below.
   *
   * @schema AppConnectionSpecInitProvider#gateway
   */
  readonly gateway?: AppConnectionSpecInitProviderGateway[];

  /**
   * Resource labels to represent user provided metadata.
   *
   * @schema AppConnectionSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * ID of the AppConnection.
   *
   * @schema AppConnectionSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AppConnectionSpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The region of the AppConnection.
   *
   * @schema AppConnectionSpecInitProvider#region
   */
  readonly region?: string;

  /**
   * The type of hosting used by the gateway. Refer to https://cloud.google.com/beyondcorp/docs/reference/rest/v1/projects.locations.appConnections#Type_1 for a list of possible values.
   *
   * @schema AppConnectionSpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppConnectionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecInitProvider(obj: AppConnectionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationEndpoint': obj.applicationEndpoint?.map(y => toJson_AppConnectionSpecInitProviderApplicationEndpoint(y)),
    'connectors': obj.connectors?.map(y => y),
    'displayName': obj.displayName,
    'gateway': obj.gateway?.map(y => toJson_AppConnectionSpecInitProviderGateway(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'project': obj.project,
    'region': obj.region,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AppConnectionSpecManagementPolicies
 */
export enum AppConnectionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppConnectionSpecProviderConfigRef
 */
export interface AppConnectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppConnectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppConnectionSpecProviderConfigRef#policy
   */
  readonly policy?: AppConnectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppConnectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecProviderConfigRef(obj: AppConnectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppConnectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppConnectionSpecPublishConnectionDetailsTo
 */
export interface AppConnectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppConnectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppConnectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppConnectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppConnectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppConnectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppConnectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecPublishConnectionDetailsTo(obj: AppConnectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppConnectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppConnectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppConnectionSpecWriteConnectionSecretToRef
 */
export interface AppConnectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppConnectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppConnectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppConnectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecWriteConnectionSecretToRef(obj: AppConnectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppConnectionSpecForProviderApplicationEndpoint
 */
export interface AppConnectionSpecForProviderApplicationEndpoint {
  /**
   * Hostname or IP address of the remote application endpoint.
   *
   * @schema AppConnectionSpecForProviderApplicationEndpoint#host
   */
  readonly host?: string;

  /**
   * Port of the remote application endpoint.
   *
   * @schema AppConnectionSpecForProviderApplicationEndpoint#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'AppConnectionSpecForProviderApplicationEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecForProviderApplicationEndpoint(obj: AppConnectionSpecForProviderApplicationEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppConnectionSpecForProviderGateway
 */
export interface AppConnectionSpecForProviderGateway {
  /**
   * AppGateway name in following format: projects/{project_id}/locations/{locationId}/appgateways/{gateway_id}.
   *
   * @schema AppConnectionSpecForProviderGateway#appGateway
   */
  readonly appGateway?: string;

  /**
   * Reference to a AppGateway in beyondcorp to populate appGateway.
   *
   * @schema AppConnectionSpecForProviderGateway#appGatewayRef
   */
  readonly appGatewayRef?: AppConnectionSpecForProviderGatewayAppGatewayRef;

  /**
   * Selector for a AppGateway in beyondcorp to populate appGateway.
   *
   * @schema AppConnectionSpecForProviderGateway#appGatewaySelector
   */
  readonly appGatewaySelector?: AppConnectionSpecForProviderGatewayAppGatewaySelector;

  /**
   * The type of hosting used by the gateway. Refer to https://cloud.google.com/beyondcorp/docs/reference/rest/v1/projects.locations.appConnections#Type_1 for a list of possible values.
   *
   * @schema AppConnectionSpecForProviderGateway#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppConnectionSpecForProviderGateway' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecForProviderGateway(obj: AppConnectionSpecForProviderGateway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appGateway': obj.appGateway,
    'appGatewayRef': toJson_AppConnectionSpecForProviderGatewayAppGatewayRef(obj.appGatewayRef),
    'appGatewaySelector': toJson_AppConnectionSpecForProviderGatewayAppGatewaySelector(obj.appGatewaySelector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppConnectionSpecInitProviderApplicationEndpoint
 */
export interface AppConnectionSpecInitProviderApplicationEndpoint {
  /**
   * Hostname or IP address of the remote application endpoint.
   *
   * @schema AppConnectionSpecInitProviderApplicationEndpoint#host
   */
  readonly host?: string;

  /**
   * Port of the remote application endpoint.
   *
   * @schema AppConnectionSpecInitProviderApplicationEndpoint#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'AppConnectionSpecInitProviderApplicationEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecInitProviderApplicationEndpoint(obj: AppConnectionSpecInitProviderApplicationEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppConnectionSpecInitProviderGateway
 */
export interface AppConnectionSpecInitProviderGateway {
  /**
   * The type of hosting used by the gateway. Refer to https://cloud.google.com/beyondcorp/docs/reference/rest/v1/projects.locations.appConnections#Type_1 for a list of possible values.
   *
   * @schema AppConnectionSpecInitProviderGateway#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppConnectionSpecInitProviderGateway' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecInitProviderGateway(obj: AppConnectionSpecInitProviderGateway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppConnectionSpecProviderConfigRefPolicy
 */
export interface AppConnectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppConnectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppConnectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppConnectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppConnectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppConnectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecProviderConfigRefPolicy(obj: AppConnectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppConnectionSpecPublishConnectionDetailsToConfigRef
 */
export interface AppConnectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppConnectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppConnectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppConnectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppConnectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecPublishConnectionDetailsToConfigRef(obj: AppConnectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppConnectionSpecPublishConnectionDetailsToMetadata
 */
export interface AppConnectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppConnectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppConnectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppConnectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppConnectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecPublishConnectionDetailsToMetadata(obj: AppConnectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AppGateway in beyondcorp to populate appGateway.
 *
 * @schema AppConnectionSpecForProviderGatewayAppGatewayRef
 */
export interface AppConnectionSpecForProviderGatewayAppGatewayRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppConnectionSpecForProviderGatewayAppGatewayRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppConnectionSpecForProviderGatewayAppGatewayRef#policy
   */
  readonly policy?: AppConnectionSpecForProviderGatewayAppGatewayRefPolicy;

}

/**
 * Converts an object of type 'AppConnectionSpecForProviderGatewayAppGatewayRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecForProviderGatewayAppGatewayRef(obj: AppConnectionSpecForProviderGatewayAppGatewayRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppConnectionSpecForProviderGatewayAppGatewayRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AppGateway in beyondcorp to populate appGateway.
 *
 * @schema AppConnectionSpecForProviderGatewayAppGatewaySelector
 */
export interface AppConnectionSpecForProviderGatewayAppGatewaySelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AppConnectionSpecForProviderGatewayAppGatewaySelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AppConnectionSpecForProviderGatewayAppGatewaySelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AppConnectionSpecForProviderGatewayAppGatewaySelector#policy
   */
  readonly policy?: AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicy;

}

/**
 * Converts an object of type 'AppConnectionSpecForProviderGatewayAppGatewaySelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecForProviderGatewayAppGatewaySelector(obj: AppConnectionSpecForProviderGatewayAppGatewaySelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppConnectionSpecProviderConfigRefPolicyResolution
 */
export enum AppConnectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppConnectionSpecProviderConfigRefPolicyResolve
 */
export enum AppConnectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppConnectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppConnectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppConnectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: AppConnectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppConnectionSpecForProviderGatewayAppGatewayRefPolicy
 */
export interface AppConnectionSpecForProviderGatewayAppGatewayRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppConnectionSpecForProviderGatewayAppGatewayRefPolicy#resolution
   */
  readonly resolution?: AppConnectionSpecForProviderGatewayAppGatewayRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppConnectionSpecForProviderGatewayAppGatewayRefPolicy#resolve
   */
  readonly resolve?: AppConnectionSpecForProviderGatewayAppGatewayRefPolicyResolve;

}

/**
 * Converts an object of type 'AppConnectionSpecForProviderGatewayAppGatewayRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecForProviderGatewayAppGatewayRefPolicy(obj: AppConnectionSpecForProviderGatewayAppGatewayRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicy
 */
export interface AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicy#resolution
   */
  readonly resolution?: AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicy#resolve
   */
  readonly resolve?: AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicyResolve;

}

/**
 * Converts an object of type 'AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicy(obj: AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppConnectionSpecForProviderGatewayAppGatewayRefPolicyResolution
 */
export enum AppConnectionSpecForProviderGatewayAppGatewayRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppConnectionSpecForProviderGatewayAppGatewayRefPolicyResolve
 */
export enum AppConnectionSpecForProviderGatewayAppGatewayRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicyResolution
 */
export enum AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicyResolve
 */
export enum AppConnectionSpecForProviderGatewayAppGatewaySelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * AppConnector is the Schema for the AppConnectors API. A BeyondCorp AppConnector resource represents an application facing component deployed proximal to and with direct access to the application instances.
 *
 * @schema AppConnector
 */
export class AppConnector extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AppConnector"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'beyondcorp.gcp.upbound.io/v1beta1',
    kind: 'AppConnector',
  }

  /**
   * Renders a Kubernetes manifest for "AppConnector".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppConnectorProps): any {
    return {
      ...AppConnector.GVK,
      ...toJson_AppConnectorProps(props),
    };
  }

  /**
   * Defines a "AppConnector" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppConnectorProps) {
    super(scope, id, {
      ...AppConnector.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AppConnector.GVK,
      ...toJson_AppConnectorProps(resolved),
    };
  }
}

/**
 * AppConnector is the Schema for the AppConnectors API. A BeyondCorp AppConnector resource represents an application facing component deployed proximal to and with direct access to the application instances.
 *
 * @schema AppConnector
 */
export interface AppConnectorProps {
  /**
   * @schema AppConnector#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppConnectorSpec defines the desired state of AppConnector
   *
   * @schema AppConnector#spec
   */
  readonly spec: AppConnectorSpec;

}

/**
 * Converts an object of type 'AppConnectorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorProps(obj: AppConnectorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppConnectorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppConnectorSpec defines the desired state of AppConnector
 *
 * @schema AppConnectorSpec
 */
export interface AppConnectorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppConnectorSpec#deletionPolicy
   */
  readonly deletionPolicy?: AppConnectorSpecDeletionPolicy;

  /**
   * @schema AppConnectorSpec#forProvider
   */
  readonly forProvider: AppConnectorSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AppConnectorSpec#initProvider
   */
  readonly initProvider?: AppConnectorSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AppConnectorSpec#managementPolicies
   */
  readonly managementPolicies?: AppConnectorSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppConnectorSpec#providerConfigRef
   */
  readonly providerConfigRef?: AppConnectorSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppConnectorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppConnectorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppConnectorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppConnectorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppConnectorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpec(obj: AppConnectorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppConnectorSpecForProvider(obj.forProvider),
    'initProvider': toJson_AppConnectorSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AppConnectorSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AppConnectorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppConnectorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppConnectorSpecDeletionPolicy
 */
export enum AppConnectorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppConnectorSpecForProvider
 */
export interface AppConnectorSpecForProvider {
  /**
   * An arbitrary user-provided name for the AppConnector.
   *
   * @schema AppConnectorSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Resource labels to represent user provided metadata.
   *
   * @schema AppConnectorSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Principal information about the Identity of the AppConnector. Structure is documented below.
   *
   * @schema AppConnectorSpecForProvider#principalInfo
   */
  readonly principalInfo?: AppConnectorSpecForProviderPrincipalInfo[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AppConnectorSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region of the AppConnector.
   *
   * @schema AppConnectorSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AppConnectorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecForProvider(obj: AppConnectorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'principalInfo': obj.principalInfo?.map(y => toJson_AppConnectorSpecForProviderPrincipalInfo(y)),
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AppConnectorSpecInitProvider
 */
export interface AppConnectorSpecInitProvider {
  /**
   * An arbitrary user-provided name for the AppConnector.
   *
   * @schema AppConnectorSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Resource labels to represent user provided metadata.
   *
   * @schema AppConnectorSpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Principal information about the Identity of the AppConnector. Structure is documented below.
   *
   * @schema AppConnectorSpecInitProvider#principalInfo
   */
  readonly principalInfo?: AppConnectorSpecInitProviderPrincipalInfo[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AppConnectorSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'AppConnectorSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecInitProvider(obj: AppConnectorSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'principalInfo': obj.principalInfo?.map(y => toJson_AppConnectorSpecInitProviderPrincipalInfo(y)),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AppConnectorSpecManagementPolicies
 */
export enum AppConnectorSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppConnectorSpecProviderConfigRef
 */
export interface AppConnectorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppConnectorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppConnectorSpecProviderConfigRef#policy
   */
  readonly policy?: AppConnectorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppConnectorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecProviderConfigRef(obj: AppConnectorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppConnectorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppConnectorSpecPublishConnectionDetailsTo
 */
export interface AppConnectorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppConnectorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppConnectorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppConnectorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppConnectorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppConnectorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppConnectorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecPublishConnectionDetailsTo(obj: AppConnectorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppConnectorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppConnectorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppConnectorSpecWriteConnectionSecretToRef
 */
export interface AppConnectorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppConnectorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppConnectorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppConnectorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecWriteConnectionSecretToRef(obj: AppConnectorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppConnectorSpecForProviderPrincipalInfo
 */
export interface AppConnectorSpecForProviderPrincipalInfo {
  /**
   * ServiceAccount represents a GCP service account. Structure is documented below.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfo#serviceAccount
   */
  readonly serviceAccount?: AppConnectorSpecForProviderPrincipalInfoServiceAccount[];

}

/**
 * Converts an object of type 'AppConnectorSpecForProviderPrincipalInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecForProviderPrincipalInfo(obj: AppConnectorSpecForProviderPrincipalInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccount': obj.serviceAccount?.map(y => toJson_AppConnectorSpecForProviderPrincipalInfoServiceAccount(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppConnectorSpecInitProviderPrincipalInfo
 */
export interface AppConnectorSpecInitProviderPrincipalInfo {
  /**
   * ServiceAccount represents a GCP service account. Structure is documented below.
   *
   * @schema AppConnectorSpecInitProviderPrincipalInfo#serviceAccount
   */
  readonly serviceAccount?: any[];

}

/**
 * Converts an object of type 'AppConnectorSpecInitProviderPrincipalInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecInitProviderPrincipalInfo(obj: AppConnectorSpecInitProviderPrincipalInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccount': obj.serviceAccount?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppConnectorSpecProviderConfigRefPolicy
 */
export interface AppConnectorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppConnectorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppConnectorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppConnectorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppConnectorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppConnectorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecProviderConfigRefPolicy(obj: AppConnectorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppConnectorSpecPublishConnectionDetailsToConfigRef
 */
export interface AppConnectorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppConnectorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppConnectorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppConnectorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppConnectorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecPublishConnectionDetailsToConfigRef(obj: AppConnectorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppConnectorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppConnectorSpecPublishConnectionDetailsToMetadata
 */
export interface AppConnectorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppConnectorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppConnectorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppConnectorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppConnectorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecPublishConnectionDetailsToMetadata(obj: AppConnectorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccount
 */
export interface AppConnectorSpecForProviderPrincipalInfoServiceAccount {
  /**
   * Email address of the service account.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccount#email
   */
  readonly email?: string;

  /**
   * Reference to a ServiceAccount in cloudplatform to populate email.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccount#emailRef
   */
  readonly emailRef?: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRef;

  /**
   * Selector for a ServiceAccount in cloudplatform to populate email.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccount#emailSelector
   */
  readonly emailSelector?: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelector;

}

/**
 * Converts an object of type 'AppConnectorSpecForProviderPrincipalInfoServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecForProviderPrincipalInfoServiceAccount(obj: AppConnectorSpecForProviderPrincipalInfoServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'email': obj.email,
    'emailRef': toJson_AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRef(obj.emailRef),
    'emailSelector': toJson_AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelector(obj.emailSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppConnectorSpecProviderConfigRefPolicyResolution
 */
export enum AppConnectorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppConnectorSpecProviderConfigRefPolicyResolve
 */
export enum AppConnectorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppConnectorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppConnectorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppConnectorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppConnectorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppConnectorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecPublishConnectionDetailsToConfigRefPolicy(obj: AppConnectorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ServiceAccount in cloudplatform to populate email.
 *
 * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRef
 */
export interface AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRef#policy
   */
  readonly policy?: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicy;

}

/**
 * Converts an object of type 'AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRef(obj: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ServiceAccount in cloudplatform to populate email.
 *
 * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelector
 */
export interface AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelector#policy
   */
  readonly policy?: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicy;

}

/**
 * Converts an object of type 'AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelector(obj: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppConnectorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicy
 */
export interface AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicy#resolution
   */
  readonly resolution?: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicy#resolve
   */
  readonly resolve?: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicyResolve;

}

/**
 * Converts an object of type 'AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicy(obj: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicy
 */
export interface AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicy#resolution
   */
  readonly resolution?: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicy#resolve
   */
  readonly resolve?: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicy(obj: AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicyResolution
 */
export enum AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicyResolve
 */
export enum AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicyResolution
 */
export enum AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicyResolve
 */
export enum AppConnectorSpecForProviderPrincipalInfoServiceAccountEmailSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * AppGateway is the Schema for the AppGateways API. A BeyondCorp AppGateway resource represents a BeyondCorp protected AppGateway to a remote application.
 *
 * @schema AppGateway
 */
export class AppGateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AppGateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'beyondcorp.gcp.upbound.io/v1beta1',
    kind: 'AppGateway',
  }

  /**
   * Renders a Kubernetes manifest for "AppGateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppGatewayProps): any {
    return {
      ...AppGateway.GVK,
      ...toJson_AppGatewayProps(props),
    };
  }

  /**
   * Defines a "AppGateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppGatewayProps) {
    super(scope, id, {
      ...AppGateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AppGateway.GVK,
      ...toJson_AppGatewayProps(resolved),
    };
  }
}

/**
 * AppGateway is the Schema for the AppGateways API. A BeyondCorp AppGateway resource represents a BeyondCorp protected AppGateway to a remote application.
 *
 * @schema AppGateway
 */
export interface AppGatewayProps {
  /**
   * @schema AppGateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppGatewaySpec defines the desired state of AppGateway
   *
   * @schema AppGateway#spec
   */
  readonly spec: AppGatewaySpec;

}

/**
 * Converts an object of type 'AppGatewayProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppGatewayProps(obj: AppGatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppGatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppGatewaySpec defines the desired state of AppGateway
 *
 * @schema AppGatewaySpec
 */
export interface AppGatewaySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppGatewaySpec#deletionPolicy
   */
  readonly deletionPolicy?: AppGatewaySpecDeletionPolicy;

  /**
   * @schema AppGatewaySpec#forProvider
   */
  readonly forProvider: AppGatewaySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AppGatewaySpec#initProvider
   */
  readonly initProvider?: AppGatewaySpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AppGatewaySpec#managementPolicies
   */
  readonly managementPolicies?: AppGatewaySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppGatewaySpec#providerConfigRef
   */
  readonly providerConfigRef?: AppGatewaySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppGatewaySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppGatewaySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppGatewaySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppGatewaySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppGatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppGatewaySpec(obj: AppGatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppGatewaySpecForProvider(obj.forProvider),
    'initProvider': toJson_AppGatewaySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AppGatewaySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AppGatewaySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppGatewaySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppGatewaySpecDeletionPolicy
 */
export enum AppGatewaySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppGatewaySpecForProvider
 */
export interface AppGatewaySpecForProvider {
  /**
   * An arbitrary user-provided name for the AppGateway.
   *
   * @schema AppGatewaySpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The type of hosting used by the AppGateway. Default value is HOST_TYPE_UNSPECIFIED. Possible values are: HOST_TYPE_UNSPECIFIED, GCP_REGIONAL_MIG.
   *
   * @schema AppGatewaySpecForProvider#hostType
   */
  readonly hostType?: string;

  /**
   * Resource labels to represent user provided metadata.
   *
   * @schema AppGatewaySpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AppGatewaySpecForProvider#project
   */
  readonly project?: string;

  /**
   * The region of the AppGateway.
   *
   * @schema AppGatewaySpecForProvider#region
   */
  readonly region: string;

  /**
   * The type of network connectivity used by the AppGateway. Default value is TYPE_UNSPECIFIED. Possible values are: TYPE_UNSPECIFIED, TCP_PROXY.
   *
   * @schema AppGatewaySpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppGatewaySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppGatewaySpecForProvider(obj: AppGatewaySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'hostType': obj.hostType,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
    'region': obj.region,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AppGatewaySpecInitProvider
 */
export interface AppGatewaySpecInitProvider {
  /**
   * An arbitrary user-provided name for the AppGateway.
   *
   * @schema AppGatewaySpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The type of hosting used by the AppGateway. Default value is HOST_TYPE_UNSPECIFIED. Possible values are: HOST_TYPE_UNSPECIFIED, GCP_REGIONAL_MIG.
   *
   * @schema AppGatewaySpecInitProvider#hostType
   */
  readonly hostType?: string;

  /**
   * Resource labels to represent user provided metadata.
   *
   * @schema AppGatewaySpecInitProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AppGatewaySpecInitProvider#project
   */
  readonly project?: string;

  /**
   * The type of network connectivity used by the AppGateway. Default value is TYPE_UNSPECIFIED. Possible values are: TYPE_UNSPECIFIED, TCP_PROXY.
   *
   * @schema AppGatewaySpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppGatewaySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppGatewaySpecInitProvider(obj: AppGatewaySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'hostType': obj.hostType,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AppGatewaySpecManagementPolicies
 */
export enum AppGatewaySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppGatewaySpecProviderConfigRef
 */
export interface AppGatewaySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppGatewaySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppGatewaySpecProviderConfigRef#policy
   */
  readonly policy?: AppGatewaySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppGatewaySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppGatewaySpecProviderConfigRef(obj: AppGatewaySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppGatewaySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppGatewaySpecPublishConnectionDetailsTo
 */
export interface AppGatewaySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppGatewaySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppGatewaySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppGatewaySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppGatewaySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppGatewaySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppGatewaySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppGatewaySpecPublishConnectionDetailsTo(obj: AppGatewaySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppGatewaySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppGatewaySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppGatewaySpecWriteConnectionSecretToRef
 */
export interface AppGatewaySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppGatewaySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppGatewaySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppGatewaySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppGatewaySpecWriteConnectionSecretToRef(obj: AppGatewaySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppGatewaySpecProviderConfigRefPolicy
 */
export interface AppGatewaySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppGatewaySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppGatewaySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppGatewaySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppGatewaySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppGatewaySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppGatewaySpecProviderConfigRefPolicy(obj: AppGatewaySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppGatewaySpecPublishConnectionDetailsToConfigRef
 */
export interface AppGatewaySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppGatewaySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppGatewaySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppGatewaySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppGatewaySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppGatewaySpecPublishConnectionDetailsToConfigRef(obj: AppGatewaySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppGatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppGatewaySpecPublishConnectionDetailsToMetadata
 */
export interface AppGatewaySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppGatewaySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppGatewaySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppGatewaySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppGatewaySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppGatewaySpecPublishConnectionDetailsToMetadata(obj: AppGatewaySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppGatewaySpecProviderConfigRefPolicyResolution
 */
export enum AppGatewaySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppGatewaySpecProviderConfigRefPolicyResolve
 */
export enum AppGatewaySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppGatewaySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppGatewaySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppGatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppGatewaySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppGatewaySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppGatewaySpecPublishConnectionDetailsToConfigRefPolicy(obj: AppGatewaySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppGatewaySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

